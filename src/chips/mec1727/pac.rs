#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![doc = "Peripheral access API (generated using chiptool v0.1.0 (d771c7b 2025-03-27))"]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Interrupt {
    #[doc = "0 - GIRQ08"]
    GIRQ08 = 0,
    #[doc = "1 - GIRQ09"]
    GIRQ09 = 1,
    #[doc = "2 - GIRQ10"]
    GIRQ10 = 2,
    #[doc = "3 - GIRQ11"]
    GIRQ11 = 3,
    #[doc = "4 - GIRQ12"]
    GIRQ12 = 4,
    #[doc = "5 - GIRQ13"]
    GIRQ13 = 5,
    #[doc = "6 - GIRQ14"]
    GIRQ14 = 6,
    #[doc = "7 - GIRQ15"]
    GIRQ15 = 7,
    #[doc = "9 - GIRQ17"]
    GIRQ17 = 9,
    #[doc = "10 - GIRQ18"]
    GIRQ18 = 10,
    #[doc = "11 - GIRQ19"]
    GIRQ19 = 11,
    #[doc = "12 - GIRQ20"]
    GIRQ20 = 12,
    #[doc = "13 - GIRQ21"]
    GIRQ21 = 13,
    #[doc = "14 - GIRQ23"]
    GIRQ23 = 14,
    #[doc = "15 - GIRQ24"]
    GIRQ24 = 15,
    #[doc = "16 - GIRQ25"]
    GIRQ25 = 16,
    #[doc = "17 - GIRQ26"]
    GIRQ26 = 17,
    #[doc = "20 - I2CSMB0"]
    I2CSMB0 = 20,
    #[doc = "21 - I2CSMB1"]
    I2CSMB1 = 21,
    #[doc = "22 - I2CSMB2"]
    I2CSMB2 = 22,
    #[doc = "23 - I2CSMB3"]
    I2CSMB3 = 23,
    #[doc = "24 - DMA_CH00"]
    DMA_CH00 = 24,
    #[doc = "25 - DMA_CH01"]
    DMA_CH01 = 25,
    #[doc = "26 - DMA_CH02"]
    DMA_CH02 = 26,
    #[doc = "27 - DMA_CH03"]
    DMA_CH03 = 27,
    #[doc = "28 - DMA_CH04"]
    DMA_CH04 = 28,
    #[doc = "29 - DMA_CH05"]
    DMA_CH05 = 29,
    #[doc = "30 - DMA_CH06"]
    DMA_CH06 = 30,
    #[doc = "31 - DMA_CH07"]
    DMA_CH07 = 31,
    #[doc = "32 - DMA_CH08"]
    DMA_CH08 = 32,
    #[doc = "33 - DMA_CH09"]
    DMA_CH09 = 33,
    #[doc = "34 - DMA_CH10"]
    DMA_CH10 = 34,
    #[doc = "35 - DMA_CH11"]
    DMA_CH11 = 35,
    #[doc = "36 - DMA_CH12"]
    DMA_CH12 = 36,
    #[doc = "37 - DMA_CH13"]
    DMA_CH13 = 37,
    #[doc = "38 - DMA_CH14"]
    DMA_CH14 = 38,
    #[doc = "39 - DMA_CH15"]
    DMA_CH15 = 39,
    #[doc = "40 - UART0"]
    UART0 = 40,
    #[doc = "41 - UART1"]
    UART1 = 41,
    #[doc = "42 - EMI0"]
    EMI0 = 42,
    #[doc = "43 - EMI1"]
    EMI1 = 43,
    #[doc = "44 - EMI2"]
    EMI2 = 44,
    #[doc = "45 - AEC0_IBF"]
    AEC0_IBF = 45,
    #[doc = "46 - AEC0_OBE"]
    AEC0_OBE = 46,
    #[doc = "47 - AEC1_IBF"]
    AEC1_IBF = 47,
    #[doc = "48 - AEC1_OBE"]
    AEC1_OBE = 48,
    #[doc = "49 - AEC2_IBF"]
    AEC2_IBF = 49,
    #[doc = "50 - AEC2_OBE"]
    AEC2_OBE = 50,
    #[doc = "51 - AEC3_IBF"]
    AEC3_IBF = 51,
    #[doc = "52 - AEC3_OBE"]
    AEC3_OBE = 52,
    #[doc = "53 - AEC4_IBF"]
    AEC4_IBF = 53,
    #[doc = "54 - AEC4_OBE"]
    AEC4_OBE = 54,
    #[doc = "55 - APM1_CTL"]
    APM1_CTL = 55,
    #[doc = "56 - APM1_EN"]
    APM1_EN = 56,
    #[doc = "57 - APM1_STS"]
    APM1_STS = 57,
    #[doc = "58 - KBC_OBE"]
    KBC_OBE = 58,
    #[doc = "59 - KBC_IBF"]
    KBC_IBF = 59,
    #[doc = "60 - MBOX"]
    MBOX = 60,
    #[doc = "62 - P80CAP0"]
    P80CAP0 = 62,
    #[doc = "64 - ASIF"]
    ASIF = 64,
    #[doc = "70 - PECI"]
    PECI = 70,
    #[doc = "71 - TACH0"]
    TACH0 = 71,
    #[doc = "72 - TACH1"]
    TACH1 = 72,
    #[doc = "73 - TACH2"]
    TACH2 = 73,
    #[doc = "74 - RPM2PWM_0_STALL"]
    RPM2PWM_0_STALL = 74,
    #[doc = "75 - RPM2PWM_0_SPIN"]
    RPM2PWM_0_SPIN = 75,
    #[doc = "76 - RPM2PWM_1_STALL"]
    RPM2PWM_1_STALL = 76,
    #[doc = "77 - RPM2PWM_1_SPIN"]
    RPM2PWM_1_SPIN = 77,
    #[doc = "78 - ADC_SNGL"]
    ADC_SNGL = 78,
    #[doc = "79 - ADC_RPT"]
    ADC_RPT = 79,
    #[doc = "80 - RC_ID0"]
    RC_ID0 = 80,
    #[doc = "81 - RC_ID1"]
    RC_ID1 = 81,
    #[doc = "82 - RC_ID2"]
    RC_ID2 = 82,
    #[doc = "83 - LED0"]
    LED0 = 83,
    #[doc = "84 - LED1"]
    LED1 = 84,
    #[doc = "85 - LED2"]
    LED2 = 85,
    #[doc = "86 - LED3"]
    LED3 = 86,
    #[doc = "87 - PHOT"]
    PHOT = 87,
    #[doc = "88 - POWERGUARD_0"]
    POWERGUARD_0 = 88,
    #[doc = "89 - POWERGUARD_1"]
    POWERGUARD_1 = 89,
    #[doc = "90 - SPISLV"]
    SPISLV = 90,
    #[doc = "91 - QMSPI"]
    QMSPI = 91,
    #[doc = "92 - TX0"]
    TX0 = 92,
    #[doc = "93 - RX0"]
    RX0 = 93,
    #[doc = "94 - TX1"]
    TX1 = 94,
    #[doc = "95 - RX1"]
    RX1 = 95,
    #[doc = "96 - BCM_ERR_0"]
    BCM_ERR_0 = 96,
    #[doc = "97 - BCM_BUSY_CLR_0"]
    BCM_BUSY_CLR_0 = 97,
    #[doc = "100 - PS2_0_ACT"]
    PS2_0_ACT = 100,
    #[doc = "103 - INTR_PC"]
    INTR_PC = 103,
    #[doc = "104 - INTR_BM1"]
    INTR_BM1 = 104,
    #[doc = "105 - INTR_BM2"]
    INTR_BM2 = 105,
    #[doc = "106 - INTR_LTR"]
    INTR_LTR = 106,
    #[doc = "107 - INTR_OOB_UP"]
    INTR_OOB_UP = 107,
    #[doc = "108 - INTR_OOB_DOWN"]
    INTR_OOB_DOWN = 108,
    #[doc = "109 - INTR_FLASH"]
    INTR_FLASH = 109,
    #[doc = "110 - ESPI_RESET"]
    ESPI_RESET = 110,
    #[doc = "111 - RTMR"]
    RTMR = 111,
    #[doc = "112 - HTMR0"]
    HTMR0 = 112,
    #[doc = "113 - HTMR1"]
    HTMR1 = 113,
    #[doc = "114 - WK"]
    WK = 114,
    #[doc = "115 - WKSUB"]
    WKSUB = 115,
    #[doc = "116 - WKSEC"]
    WKSEC = 116,
    #[doc = "117 - WKSUBSEC"]
    WKSUBSEC = 117,
    #[doc = "118 - SYSPWR"]
    SYSPWR = 118,
    #[doc = "119 - RTC"]
    RTC = 119,
    #[doc = "120 - RTC_ALARM"]
    RTC_ALARM = 120,
    #[doc = "121 - VCI_OVRD_IN"]
    VCI_OVRD_IN = 121,
    #[doc = "122 - VCI_IN0"]
    VCI_IN0 = 122,
    #[doc = "123 - VCI_IN1"]
    VCI_IN1 = 123,
    #[doc = "124 - VCI_IN2"]
    VCI_IN2 = 124,
    #[doc = "125 - VCI_IN3"]
    VCI_IN3 = 125,
    #[doc = "129 - PS2_0A_WAKE"]
    PS2_0A_WAKE = 129,
    #[doc = "130 - PS2_0B_WAKE"]
    PS2_0B_WAKE = 130,
    #[doc = "135 - KEYSCAN"]
    KEYSCAN = 135,
    #[doc = "136 - TIMER16_0"]
    TIMER16_0 = 136,
    #[doc = "137 - TIMER16_1"]
    TIMER16_1 = 137,
    #[doc = "138 - TIMER16_2"]
    TIMER16_2 = 138,
    #[doc = "139 - TIMER16_3"]
    TIMER16_3 = 139,
    #[doc = "140 - TIMER32_0"]
    TIMER32_0 = 140,
    #[doc = "141 - TIMER32_1"]
    TIMER32_1 = 141,
    #[doc = "142 - CNTR_TMR0"]
    CNTR_TMR0 = 142,
    #[doc = "143 - CNTR_TMR1"]
    CNTR_TMR1 = 143,
    #[doc = "144 - CNTR_TMR2"]
    CNTR_TMR2 = 144,
    #[doc = "145 - CNTR_TMR3"]
    CNTR_TMR3 = 145,
    #[doc = "146 - CCT"]
    CCT = 146,
    #[doc = "147 - CCT_CAP0"]
    CCT_CAP0 = 147,
    #[doc = "148 - CCT_CAP1"]
    CCT_CAP1 = 148,
    #[doc = "149 - CCT_CAP2"]
    CCT_CAP2 = 149,
    #[doc = "150 - CCT_CAP3"]
    CCT_CAP3 = 150,
    #[doc = "151 - CCT_CAP4"]
    CCT_CAP4 = 151,
    #[doc = "152 - CCT_CAP5"]
    CCT_CAP5 = 152,
    #[doc = "153 - CCT_CMP0"]
    CCT_CMP0 = 153,
    #[doc = "154 - CCT_CMP1"]
    CCT_CMP1 = 154,
    #[doc = "156 - ESPI_VWIRE"]
    ESPI_VWIRE = 156,
    #[doc = "158 - I2CSMB4"]
    I2CSMB4 = 158,
    #[doc = "159 - TACH3"]
    TACH3 = 159,
    #[doc = "166 - SAF_DONE"]
    SAF_DONE = 166,
    #[doc = "167 - SAF_ERR"]
    SAF_ERR = 167,
    #[doc = "171 - WDT"]
    WDT = 171,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[cfg(feature = "rt")]
mod _vectors {
    extern "C" {
        fn GIRQ08();
        fn GIRQ09();
        fn GIRQ10();
        fn GIRQ11();
        fn GIRQ12();
        fn GIRQ13();
        fn GIRQ14();
        fn GIRQ15();
        fn GIRQ17();
        fn GIRQ18();
        fn GIRQ19();
        fn GIRQ20();
        fn GIRQ21();
        fn GIRQ23();
        fn GIRQ24();
        fn GIRQ25();
        fn GIRQ26();
        fn I2CSMB0();
        fn I2CSMB1();
        fn I2CSMB2();
        fn I2CSMB3();
        fn DMA_CH00();
        fn DMA_CH01();
        fn DMA_CH02();
        fn DMA_CH03();
        fn DMA_CH04();
        fn DMA_CH05();
        fn DMA_CH06();
        fn DMA_CH07();
        fn DMA_CH08();
        fn DMA_CH09();
        fn DMA_CH10();
        fn DMA_CH11();
        fn DMA_CH12();
        fn DMA_CH13();
        fn DMA_CH14();
        fn DMA_CH15();
        fn UART0();
        fn UART1();
        fn EMI0();
        fn EMI1();
        fn EMI2();
        fn AEC0_IBF();
        fn AEC0_OBE();
        fn AEC1_IBF();
        fn AEC1_OBE();
        fn AEC2_IBF();
        fn AEC2_OBE();
        fn AEC3_IBF();
        fn AEC3_OBE();
        fn AEC4_IBF();
        fn AEC4_OBE();
        fn APM1_CTL();
        fn APM1_EN();
        fn APM1_STS();
        fn KBC_OBE();
        fn KBC_IBF();
        fn MBOX();
        fn P80CAP0();
        fn ASIF();
        fn PECI();
        fn TACH0();
        fn TACH1();
        fn TACH2();
        fn RPM2PWM_0_STALL();
        fn RPM2PWM_0_SPIN();
        fn RPM2PWM_1_STALL();
        fn RPM2PWM_1_SPIN();
        fn ADC_SNGL();
        fn ADC_RPT();
        fn RC_ID0();
        fn RC_ID1();
        fn RC_ID2();
        fn LED0();
        fn LED1();
        fn LED2();
        fn LED3();
        fn PHOT();
        fn POWERGUARD_0();
        fn POWERGUARD_1();
        fn SPISLV();
        fn QMSPI();
        fn TX0();
        fn RX0();
        fn TX1();
        fn RX1();
        fn BCM_ERR_0();
        fn BCM_BUSY_CLR_0();
        fn PS2_0_ACT();
        fn INTR_PC();
        fn INTR_BM1();
        fn INTR_BM2();
        fn INTR_LTR();
        fn INTR_OOB_UP();
        fn INTR_OOB_DOWN();
        fn INTR_FLASH();
        fn ESPI_RESET();
        fn RTMR();
        fn HTMR0();
        fn HTMR1();
        fn WK();
        fn WKSUB();
        fn WKSEC();
        fn WKSUBSEC();
        fn SYSPWR();
        fn RTC();
        fn RTC_ALARM();
        fn VCI_OVRD_IN();
        fn VCI_IN0();
        fn VCI_IN1();
        fn VCI_IN2();
        fn VCI_IN3();
        fn PS2_0A_WAKE();
        fn PS2_0B_WAKE();
        fn KEYSCAN();
        fn TIMER16_0();
        fn TIMER16_1();
        fn TIMER16_2();
        fn TIMER16_3();
        fn TIMER32_0();
        fn TIMER32_1();
        fn CNTR_TMR0();
        fn CNTR_TMR1();
        fn CNTR_TMR2();
        fn CNTR_TMR3();
        fn CCT();
        fn CCT_CAP0();
        fn CCT_CAP1();
        fn CCT_CAP2();
        fn CCT_CAP3();
        fn CCT_CAP4();
        fn CCT_CAP5();
        fn CCT_CMP0();
        fn CCT_CMP1();
        fn ESPI_VWIRE();
        fn I2CSMB4();
        fn TACH3();
        fn SAF_DONE();
        fn SAF_ERR();
        fn WDT();
    }
    pub union Vector {
        _handler: unsafe extern "C" fn(),
        _reserved: u32,
    }
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    pub static __INTERRUPTS: [Vector; 172] = [
        Vector { _handler: GIRQ08 },
        Vector { _handler: GIRQ09 },
        Vector { _handler: GIRQ10 },
        Vector { _handler: GIRQ11 },
        Vector { _handler: GIRQ12 },
        Vector { _handler: GIRQ13 },
        Vector { _handler: GIRQ14 },
        Vector { _handler: GIRQ15 },
        Vector { _reserved: 0 },
        Vector { _handler: GIRQ17 },
        Vector { _handler: GIRQ18 },
        Vector { _handler: GIRQ19 },
        Vector { _handler: GIRQ20 },
        Vector { _handler: GIRQ21 },
        Vector { _handler: GIRQ23 },
        Vector { _handler: GIRQ24 },
        Vector { _handler: GIRQ25 },
        Vector { _handler: GIRQ26 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: I2CSMB0 },
        Vector { _handler: I2CSMB1 },
        Vector { _handler: I2CSMB2 },
        Vector { _handler: I2CSMB3 },
        Vector { _handler: DMA_CH00 },
        Vector { _handler: DMA_CH01 },
        Vector { _handler: DMA_CH02 },
        Vector { _handler: DMA_CH03 },
        Vector { _handler: DMA_CH04 },
        Vector { _handler: DMA_CH05 },
        Vector { _handler: DMA_CH06 },
        Vector { _handler: DMA_CH07 },
        Vector { _handler: DMA_CH08 },
        Vector { _handler: DMA_CH09 },
        Vector { _handler: DMA_CH10 },
        Vector { _handler: DMA_CH11 },
        Vector { _handler: DMA_CH12 },
        Vector { _handler: DMA_CH13 },
        Vector { _handler: DMA_CH14 },
        Vector { _handler: DMA_CH15 },
        Vector { _handler: UART0 },
        Vector { _handler: UART1 },
        Vector { _handler: EMI0 },
        Vector { _handler: EMI1 },
        Vector { _handler: EMI2 },
        Vector { _handler: AEC0_IBF },
        Vector { _handler: AEC0_OBE },
        Vector { _handler: AEC1_IBF },
        Vector { _handler: AEC1_OBE },
        Vector { _handler: AEC2_IBF },
        Vector { _handler: AEC2_OBE },
        Vector { _handler: AEC3_IBF },
        Vector { _handler: AEC3_OBE },
        Vector { _handler: AEC4_IBF },
        Vector { _handler: AEC4_OBE },
        Vector { _handler: APM1_CTL },
        Vector { _handler: APM1_EN },
        Vector { _handler: APM1_STS },
        Vector { _handler: KBC_OBE },
        Vector { _handler: KBC_IBF },
        Vector { _handler: MBOX },
        Vector { _reserved: 0 },
        Vector { _handler: P80CAP0 },
        Vector { _reserved: 0 },
        Vector { _handler: ASIF },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: PECI },
        Vector { _handler: TACH0 },
        Vector { _handler: TACH1 },
        Vector { _handler: TACH2 },
        Vector {
            _handler: RPM2PWM_0_STALL,
        },
        Vector {
            _handler: RPM2PWM_0_SPIN,
        },
        Vector {
            _handler: RPM2PWM_1_STALL,
        },
        Vector {
            _handler: RPM2PWM_1_SPIN,
        },
        Vector { _handler: ADC_SNGL },
        Vector { _handler: ADC_RPT },
        Vector { _handler: RC_ID0 },
        Vector { _handler: RC_ID1 },
        Vector { _handler: RC_ID2 },
        Vector { _handler: LED0 },
        Vector { _handler: LED1 },
        Vector { _handler: LED2 },
        Vector { _handler: LED3 },
        Vector { _handler: PHOT },
        Vector { _handler: POWERGUARD_0 },
        Vector { _handler: POWERGUARD_1 },
        Vector { _handler: SPISLV },
        Vector { _handler: QMSPI },
        Vector { _handler: TX0 },
        Vector { _handler: RX0 },
        Vector { _handler: TX1 },
        Vector { _handler: RX1 },
        Vector { _handler: BCM_ERR_0 },
        Vector {
            _handler: BCM_BUSY_CLR_0,
        },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: PS2_0_ACT },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: INTR_PC },
        Vector { _handler: INTR_BM1 },
        Vector { _handler: INTR_BM2 },
        Vector { _handler: INTR_LTR },
        Vector { _handler: INTR_OOB_UP },
        Vector {
            _handler: INTR_OOB_DOWN,
        },
        Vector { _handler: INTR_FLASH },
        Vector { _handler: ESPI_RESET },
        Vector { _handler: RTMR },
        Vector { _handler: HTMR0 },
        Vector { _handler: HTMR1 },
        Vector { _handler: WK },
        Vector { _handler: WKSUB },
        Vector { _handler: WKSEC },
        Vector { _handler: WKSUBSEC },
        Vector { _handler: SYSPWR },
        Vector { _handler: RTC },
        Vector { _handler: RTC_ALARM },
        Vector { _handler: VCI_OVRD_IN },
        Vector { _handler: VCI_IN0 },
        Vector { _handler: VCI_IN1 },
        Vector { _handler: VCI_IN2 },
        Vector { _handler: VCI_IN3 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: PS2_0A_WAKE },
        Vector { _handler: PS2_0B_WAKE },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: KEYSCAN },
        Vector { _handler: TIMER16_0 },
        Vector { _handler: TIMER16_1 },
        Vector { _handler: TIMER16_2 },
        Vector { _handler: TIMER16_3 },
        Vector { _handler: TIMER32_0 },
        Vector { _handler: TIMER32_1 },
        Vector { _handler: CNTR_TMR0 },
        Vector { _handler: CNTR_TMR1 },
        Vector { _handler: CNTR_TMR2 },
        Vector { _handler: CNTR_TMR3 },
        Vector { _handler: CCT },
        Vector { _handler: CCT_CAP0 },
        Vector { _handler: CCT_CAP1 },
        Vector { _handler: CCT_CAP2 },
        Vector { _handler: CCT_CAP3 },
        Vector { _handler: CCT_CAP4 },
        Vector { _handler: CCT_CAP5 },
        Vector { _handler: CCT_CMP0 },
        Vector { _handler: CCT_CMP1 },
        Vector { _reserved: 0 },
        Vector { _handler: ESPI_VWIRE },
        Vector { _reserved: 0 },
        Vector { _handler: I2CSMB4 },
        Vector { _handler: TACH3 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SAF_DONE },
        Vector { _handler: SAF_ERR },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: WDT },
    ];
}
#[doc = "The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed."]
pub const WDT: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x4000_0400usize as _) };
#[doc = "This 16-bit timer block offers a simple mechanism for firmware to maintain a time base."]
pub const TIMER16_0: timer16_0::Timer160 = unsafe { timer16_0::Timer160::from_ptr(0x4000_0c00usize as _) };
pub const TIMER16_1: timer16_0::Timer160 = unsafe { timer16_0::Timer160::from_ptr(0x4000_0c20usize as _) };
pub const TIMER16_2: timer16_0::Timer160 = unsafe { timer16_0::Timer160::from_ptr(0x4000_0c40usize as _) };
pub const TIMER16_3: timer16_0::Timer160 = unsafe { timer16_0::Timer160::from_ptr(0x4000_0c60usize as _) };
#[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base."]
pub const TIMER32_0: timer32_0::Timer320 = unsafe { timer32_0::Timer320::from_ptr(0x4000_0c80usize as _) };
pub const TIMER32_1: timer32_0::Timer320 = unsafe { timer32_0::Timer320::from_ptr(0x4000_0ca0usize as _) };
#[doc = "This interface is a 16-bit auto-reloading timer/counter."]
pub const CNTR_TMR0: cntr_tmr0::CntrTmr0 = unsafe { cntr_tmr0::CntrTmr0::from_ptr(0x4000_0d00usize as _) };
pub const CNTR_TMR1: cntr_tmr0::CntrTmr0 = unsafe { cntr_tmr0::CntrTmr0::from_ptr(0x4000_0d20usize as _) };
pub const CNTR_TMR2: cntr_tmr0::CntrTmr0 = unsafe { cntr_tmr0::CntrTmr0::from_ptr(0x4000_0d40usize as _) };
pub const CNTR_TMR3: cntr_tmr0::CntrTmr0 = unsafe { cntr_tmr0::CntrTmr0::from_ptr(0x4000_0d60usize as _) };
#[doc = "This is a 16-bit auto-reloading timer/counter."]
pub const CCT: cct::Cct = unsafe { cct::Cct::from_ptr(0x4000_1000usize as _) };
#[doc = "This interface provides a single pin interface which can discriminate a number of quantized RC constants."]
pub const RC_ID0: rc_id0::RcId0 = unsafe { rc_id0::RcId0::from_ptr(0x4000_1400usize as _) };
pub const RC_ID1: rc_id0::RcId0 = unsafe { rc_id0::RcId0::from_ptr(0x4000_1480usize as _) };
pub const RC_ID2: rc_id0::RcId0 = unsafe { rc_id0::RcId0::from_ptr(0x4000_1500usize as _) };
#[doc = "DMA Main Registers"]
pub const DMA_MAIN: dma_main::DmaMain = unsafe { dma_main::DmaMain::from_ptr(0x4000_2400usize as _) };
#[doc = "DMA Channel 00 Registers"]
pub const DMA_CHAN00: dma_chan00::DmaChan00 = unsafe { dma_chan00::DmaChan00::from_ptr(0x4000_2440usize as _) };
#[doc = "DMA Channel 01 Registers"]
pub const DMA_CHAN01: dma_chan01::DmaChan01 = unsafe { dma_chan01::DmaChan01::from_ptr(0x4000_2480usize as _) };
#[doc = "DMA Channel 02 Registers"]
pub const DMA_CHAN02: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_24c0usize as _) };
pub const DMA_CHAN03: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2500usize as _) };
pub const DMA_CHAN04: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2540usize as _) };
pub const DMA_CHAN05: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2580usize as _) };
pub const DMA_CHAN06: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_25c0usize as _) };
pub const DMA_CHAN07: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2600usize as _) };
pub const DMA_CHAN08: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2640usize as _) };
pub const DMA_CHAN09: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2680usize as _) };
pub const DMA_CHAN10: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_26c0usize as _) };
pub const DMA_CHAN11: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2700usize as _) };
pub const DMA_CHAN12: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2740usize as _) };
pub const DMA_CHAN13: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2780usize as _) };
pub const DMA_CHAN14: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_27c0usize as _) };
pub const DMA_CHAN15: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2800usize as _) };
#[doc = "This block monitors PowerGuard output signals (or locked rotor signals) from various types of fans, and determines their speed."]
pub const POWERGUARD_0: powerguard_0::Powerguard0 =
    unsafe { powerguard_0::Powerguard0::from_ptr(0x4000_3000usize as _) };
pub const POWERGUARD_1: powerguard_0::Powerguard0 =
    unsafe { powerguard_0::Powerguard0::from_ptr(0x4000_3080usize as _) };
#[doc = "This block monitors the PROCHOT# signal and designed to detect single assertions and monitor cumulative PROCHOT active time."]
pub const PHOT: phot::Phot = unsafe { phot::Phot::from_ptr(0x4000_3400usize as _) };
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub const SMB0: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4000usize as _) };
pub const SMB1: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4400usize as _) };
pub const SMB2: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4800usize as _) };
pub const SMB3: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4c00usize as _) };
pub const SMB4: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_5000usize as _) };
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz."]
pub const PWM0: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5800usize as _) };
pub const PWM1: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5810usize as _) };
pub const PWM2: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5820usize as _) };
pub const PWM3: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5830usize as _) };
pub const PWM4: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5840usize as _) };
pub const PWM5: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5850usize as _) };
pub const PWM6: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5860usize as _) };
pub const PWM7: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5870usize as _) };
pub const PWM8: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5880usize as _) };
pub const PWM9: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5890usize as _) };
pub const PWM10: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_58a0usize as _) };
pub const PWM11: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_58b0usize as _) };
#[doc = "This block monitors TACH output signals from various types of fans, and determines their speed"]
pub const TACH0: tach0::Tach0 = unsafe { tach0::Tach0::from_ptr(0x4000_6000usize as _) };
pub const TACH1: tach0::Tach0 = unsafe { tach0::Tach0::from_ptr(0x4000_6010usize as _) };
pub const TACH2: tach0::Tach0 = unsafe { tach0::Tach0::from_ptr(0x4000_6020usize as _) };
pub const TACH3: tach0::Tach0 = unsafe { tach0::Tach0::from_ptr(0x4000_6030usize as _) };
#[doc = "The PECI Interface allows the EC to retrieve temperature readings from PECI-compliant devices."]
pub const PECI: peci::Peci = unsafe { peci::Peci::from_ptr(0x4000_6400usize as _) };
#[doc = "SPI Slave Register."]
pub const SPI_SLAVE: spi_slave::SpiSlave = unsafe { spi_slave::SpiSlave::from_ptr(0x4000_7000usize as _) };
#[doc = "RTOS is a 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states."]
pub const RTOS: rtos::Rtos = unsafe { rtos::Rtos::from_ptr(0x4000_7400usize as _) };
#[doc = "This block is designed to convert external analog voltage readings into digital values."]
pub const ADC: adc::Adc = unsafe { adc::Adc::from_ptr(0x4000_7c00usize as _) };
#[doc = "SAF BRIDGE COMPONENT"]
pub const SAFBC_EC: safbc_ec::SafbcEc = unsafe { safbc_ec::SafbcEc::from_ptr(0x4000_8000usize as _) };
#[doc = "The TFDP serially transmits EC-originated diagnostic vectors to an external debug trace system."]
pub const TFDP: tfdp::Tfdp = unsafe { tfdp::Tfdp::from_ptr(0x4000_8c00usize as _) };
#[doc = "The four PS/2 Ports implementation eliminates the need to bit bang I/O ports to generate PS/2 traffic."]
pub const PS2_0: ps2_0::Ps20 = unsafe { ps2_0::Ps20::from_ptr(0x4000_9000usize as _) };
#[doc = "The General Purpose Serial Peripheral Interface (GP-SPI) may be used to communicate with various peripheral devices, e.g., EEPROMS, DACs, ADCs, that use a standard Serial Peripheral Interface."]
pub const GP_SPI0: gp_spi0::GpSpi0 = unsafe { gp_spi0::GpSpi0::from_ptr(0x4000_9400usize as _) };
pub const GP_SPI1: gp_spi0::GpSpi0 = unsafe { gp_spi0::GpSpi0::from_ptr(0x4000_9480usize as _) };
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode."]
pub const HTM0: htm0::Htm0 = unsafe { htm0::Htm0::from_ptr(0x4000_9800usize as _) };
pub const HTM1: htm0::Htm0 = unsafe { htm0::Htm0::from_ptr(0x4000_9820usize as _) };
#[doc = "The Keyboard Scan Interface block provides a register interface to directly scan an external keyboard matrix of size up to 18x8."]
pub const KMS: kms::Kms = unsafe { kms::Kms::from_ptr(0x4000_9c00usize as _) };
#[doc = "The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors the fan's speed and automatically adjusts the drive to maintain the desired fan speed. This RPM based Fan Control Algorithm controls a PWM output based on a tachometer input."]
pub const FAN0: fan0::Fan0 = unsafe { fan0::Fan0::from_ptr(0x4000_a000usize as _) };
pub const FAN1: fan0::Fan0 = unsafe { fan0::Fan0::from_ptr(0x4000_a080usize as _) };
#[doc = "The VBAT Register Bank block is a block implemented for miscellaneous battery-backed registers."]
pub const VBAT: vbat::Vbat = unsafe { vbat::Vbat::from_ptr(0x4000_a400usize as _) };
#[doc = "The VBAT RAM is operational while the main power rail is operational, and will retain its values powered by battery power while the main rail is unpowered."]
pub const VBAT_RAM: vbat_ram::VbatRam = unsafe { vbat_ram::VbatRam::from_ptr(0x4000_a800usize as _) };
#[doc = "The Week Timer and the Sub-Week Timer assert the Power-Up Event Output which automatically powers-up the system from the G3 state"]
pub const WEEK: week::Week = unsafe { week::Week::from_ptr(0x4000_ac80usize as _) };
#[doc = "The VBAT-Powered Control Interfaces with the RTC With Date and DST Adjustment as well as the Week Alarm."]
pub const VCI: vci::Vci = unsafe { vci::Vci::from_ptr(0x4000_ae00usize as _) };
#[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
pub const LED0: led0::Led0 = unsafe { led0::Led0::from_ptr(0x4000_b800usize as _) };
pub const LED1: led0::Led0 = unsafe { led0::Led0::from_ptr(0x4000_b900usize as _) };
pub const LED2: led0::Led0 = unsafe { led0::Led0::from_ptr(0x4000_ba00usize as _) };
pub const LED3: led0::Led0 = unsafe { led0::Led0::from_ptr(0x4000_bb00usize as _) };
#[doc = "This block provides BC-Link connectivity to a slave device. The BC-Link protocol includes a start bit to signal the beginning of a message and a turnaround (TAR) period for bus transfer between the Master and Companion devices."]
pub const BC_LINK0: bc_link0::BcLink0 = unsafe { bc_link0::BcLink0::from_ptr(0x4000_cd00usize as _) };
#[doc = "The ECIA works in conjunction with the processor interrupt interface to handle hardware interrupts andd exceptions."]
pub const ECIA: ecia::Ecia = unsafe { ecia::Ecia::from_ptr(0x4000_e000usize as _) };
#[doc = "SAF BRIDGE CACHE INTERFACE"]
pub const SAFBC_CACHE: safbc_cache::SafbcCache = unsafe { safbc_cache::SafbcCache::from_ptr(0x4000_f000usize as _) };
#[doc = "This block is designed to be accessed internally by the EC via the register interface."]
pub const EC_REG_BANK: ec_reg_bank::EcRegBank = unsafe { ec_reg_bank::EcRegBank::from_ptr(0x4000_fc00usize as _) };
#[doc = "This is the CACHE Controller"]
pub const CACHE: cache::Cache = unsafe { cache::Cache::from_ptr(0x4001_0000usize as _) };
#[doc = "The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface."]
pub const QMSPI: qmspi::Qmspi = unsafe { qmspi::Qmspi::from_ptr(0x4007_0000usize as _) };
#[doc = "This register contains one bit PREFETCH_EN that should be set to '1' during initialization, to enable Prefetch Mode operation in SAFS Mode. Prefetch Mode allows overlapped anticipatory reading of information from Flash during the eSPI delivery of previously-read data to the Host Chipset. If enabled, Prefetching is invoked during consecutive Reads that are 64 bytes in length and from consecutive 64-byte aligned Flash addresses. With roughly equal clock rates on eSPI and SPI, these features together can approximately double the effective bandwidth of consecutive Flash reads performed over eSPI. In SAFS operation (SAF_MODE_ENABLE bit = 1) attempted accesses by EC firmware to this register are blocked."]
pub const SAFCOMM: safcomm::Safcomm = unsafe { safcomm::Safcomm::from_ptr(0x4007_1000usize as _) };
#[doc = "The Power, Clocks, and Resets (PCR) Section identifies clock sources, and reset inputs to the chip."]
pub const PCR: pcr::Pcr = unsafe { pcr::Pcr::from_ptr(0x4008_0100usize as _) };
#[doc = "GPIO Pin Control Registers"]
pub const GPIO: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x4008_1000usize as _) };
#[doc = "OTP Programming registers."]
pub const OTP: otp::Otp = unsafe { otp::Otp::from_ptr(0x4008_2000usize as _) };
#[doc = "The Mailbox provides a standard run-time mechanism for the host to communicate with the Embedded Controller (EC)."]
pub const MBX: mbx::Mbx = unsafe { mbx::Mbx::from_ptr(0x400f_0000usize as _) };
#[doc = "The Keyboard Controller is a Host/EC Message Interface with hardware assists to emulate 8042 behavior."]
pub const KBC: kbc::Kbc = unsafe { kbc::Kbc::from_ptr(0x400f_0400usize as _) };
#[doc = "The ACPI-ECI provides a four byte full duplex data interface."]
pub const ACPI_EC0: acpi_ec0::AcpiEc0 = unsafe { acpi_ec0::AcpiEc0::from_ptr(0x400f_0800usize as _) };
pub const ACPI_EC1: acpi_ec0::AcpiEc0 = unsafe { acpi_ec0::AcpiEc0::from_ptr(0x400f_0c00usize as _) };
pub const ACPI_EC2: acpi_ec0::AcpiEc0 = unsafe { acpi_ec0::AcpiEc0::from_ptr(0x400f_1000usize as _) };
pub const ACPI_EC3: acpi_ec0::AcpiEc0 = unsafe { acpi_ec0::AcpiEc0::from_ptr(0x400f_1400usize as _) };
pub const ACPI_EC4: acpi_ec0::AcpiEc0 = unsafe { acpi_ec0::AcpiEc0::from_ptr(0x400f_1800usize as _) };
#[doc = "These features comply with the ACPI Specification through a combination of hardware and EC software."]
pub const PM1: pm1::Pm1 = unsafe { pm1::Pm1::from_ptr(0x400f_1c00usize as _) };
#[doc = "The registers listed in the Configuration Register Summary table are for a single instance of the Legacy Port92/GATEA20 logic."]
pub const PORT92: port92::Port92 = unsafe { port92::Port92::from_ptr(0x400f_2000usize as _) };
#[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub const UART0: uart0::Uart0 = unsafe { uart0::Uart0::from_ptr(0x400f_2400usize as _) };
pub const UART1: uart0::Uart0 = unsafe { uart0::Uart0::from_ptr(0x400f_2800usize as _) };
#[doc = "The ESPI is used by the system host to configure the chip and communicate with the logical devices implemented in the design."]
pub const ESPI_IO: espi_io::EspiIo = unsafe { espi_io::EspiIo::from_ptr(0x400f_3400usize as _) };
#[doc = "The eSPI Memory Component is one of two Logical Devices (along with the I/O Component) that provide access to all the registers in the device."]
pub const ESPI_MEMORY: espi_memory::EspiMemory = unsafe { espi_memory::EspiMemory::from_ptr(0x400f_3800usize as _) };
#[doc = "The EMI provides a communication between system host and Embedded Controller."]
pub const EMI0: emi0::Emi0 = unsafe { emi0::Emi0::from_ptr(0x400f_4000usize as _) };
pub const EMI1: emi0::Emi0 = unsafe { emi0::Emi0::from_ptr(0x400f_4400usize as _) };
pub const EMI2: emi0::Emi0 = unsafe { emi0::Emi0::from_ptr(0x400f_4800usize as _) };
#[doc = "This is the set of registers that are automatically counted by hardware every 1 second while the block is enabled."]
pub const RTC: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x400f_5000usize as _) };
#[doc = "Diagnostic data is written by the Host Interface to the Port 80 BIOS Debug Port."]
pub const PORT_80_DEBUG: port_80_debug::Port80debug =
    unsafe { port_80_debug::Port80debug::from_ptr(0x400f_8000usize as _) };
#[doc = "The Virtual Wire Channel permits the System to emulate a set of wires that interconnect the system Core Logic with the EC."]
pub const ESPI_MSVW00_06: espi_msvw00_06::EspiMsvw0006 =
    unsafe { espi_msvw00_06::EspiMsvw0006::from_ptr(0x400f_9c00usize as _) };
#[doc = "The ESPI VW Channel permits the System to emulate a set of wires that interconnect the system Core Logic with the EC."]
pub const ESPI_MSVW07_10: espi_msvw07_10::EspiMsvw0710 =
    unsafe { espi_msvw07_10::EspiMsvw0710::from_ptr(0x400f_9c54usize as _) };
#[doc = "The ESPI VW Channel permits the System to emulate a set of wires that interconnect the system Core Logic with the EC."]
pub const ESPI_SMVW00_10: espi_smvw00_10::EspiSmvw0010 =
    unsafe { espi_smvw00_10::EspiSmvw0010::from_ptr(0x400f_9e00usize as _) };
#[doc = "32 Byte ESPI Test Register"]
pub const ESPI_SCRATCH: espi_scratch::EspiScratch =
    unsafe { espi_scratch::EspiScratch::from_ptr(0x400f_bc00usize as _) };
#[doc = "The ASIF allows the Host and EC to use index addressing to access registers residing in an external IC."]
pub const ASIF: asif::Asif = unsafe { asif::Asif::from_ptr(0x400f_c000usize as _) };
#[doc = "The Logical Device Configuration registers support motherboard designs in which the resources required by their components are known and assigned by the BIOS at POST."]
pub const GCR: gcr::Gcr = unsafe { gcr::Gcr::from_ptr(0x400f_ff00usize as _) };
#[doc = "Internal Master SPI."]
pub const IMSPI: imspi::Imspi = unsafe { imspi::Imspi::from_ptr(0x4022_0000usize as _) };
#[doc = "Floating Point Unit"]
pub const FPU: fpu::Fpu = unsafe { fpu::Fpu::from_ptr(0xe000_ef30usize as _) };
#[doc = r" Number available in the NVIC for configuring priority"]
#[cfg(feature = "rt")]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
pub use Interrupt as interrupt;
#[doc = "Pin buffer drive type."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum BufferType {
    #[doc = "Output buffer type is Open-drain."]
    PUSH_PULL = 0x0,
    #[doc = "Output buffer type is Push-pull."]
    OPEN_DRAIN = 0x01,
}
impl BufferType {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> BufferType {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for BufferType {
    #[inline(always)]
    fn from(val: u8) -> BufferType {
        BufferType::from_bits(val)
    }
}
impl From<BufferType> for u8 {
    #[inline(always)]
    fn from(val: BufferType) -> u8 {
        BufferType::to_bits(val)
    }
}
#[doc = "Pin direction."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Dir {
    #[doc = "Input GPIO."]
    INPUT = 0x0,
    #[doc = "Output GPIO."]
    OUTPUT = 0x01,
}
impl Dir {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Dir {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Dir {
    #[inline(always)]
    fn from(val: u8) -> Dir {
        Dir::from_bits(val)
    }
}
impl From<Dir> for u8 {
    #[inline(always)]
    fn from(val: Dir) -> u8 {
        Dir::to_bits(val)
    }
}
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Function {
    #[doc = "GPIO function selected."]
    GPIO = 0x0,
    #[doc = "Function 1 selected."]
    F1 = 0x01,
    #[doc = "Function 2 selected."]
    F2 = 0x02,
    #[doc = "Function 3 selected."]
    F3 = 0x03,
    #[doc = "Function 4 selected."]
    F4 = 0x04,
    #[doc = "Function 5 selected."]
    F5 = 0x05,
    _RESERVED_6 = 0x06,
    _RESERVED_7 = 0x07,
}
impl Function {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Function {
        unsafe { core::mem::transmute(val & 0x07) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Function {
    #[inline(always)]
    fn from(val: u8) -> Function {
        Function::from_bits(val)
    }
}
impl From<Function> for u8 {
    #[inline(always)]
    fn from(val: Function) -> u8 {
        Function::to_bits(val)
    }
}
#[doc = "Power Gating Signals provide the chip Power Emulation options."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Pgs {
    #[doc = "The output buffer is tristated when VTR_PWRGD=0."]
    VTR = 0x0,
    #[doc = "The output buffer is tristated when VCC_PWRGD=0."]
    VCC = 0x01,
    #[doc = "The always unpowered setting on a GPIO will force the pin to tristate. The input and output are disabled, and the pad is in the lowest power state."]
    UNPOWERED = 0x02,
    _RESERVED_3 = 0x03,
}
impl Pgs {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Pgs {
        unsafe { core::mem::transmute(val & 0x03) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Pgs {
    #[inline(always)]
    fn from(val: u8) -> Pgs {
        Pgs::from_bits(val)
    }
}
impl From<Pgs> for u8 {
    #[inline(always)]
    fn from(val: Pgs) -> u8 {
        Pgs::to_bits(val)
    }
}
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Pol {
    #[doc = "Non-inverted polarity."]
    NON_INVERTED = 0x0,
    #[doc = "Inverted polarity."]
    INVERTED = 0x01,
}
impl Pol {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Pol {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Pol {
    #[inline(always)]
    fn from(val: u8) -> Pol {
        Pol::from_bits(val)
    }
}
impl From<Pol> for u8 {
    #[inline(always)]
    fn from(val: Pol) -> u8 {
        Pol::to_bits(val)
    }
}
#[doc = "Configure internal pull-up and pull-down resistors."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Pull {
    #[doc = "Pin tristates when no active driver is present on the pin."]
    NONE = 0x0,
    #[doc = "Pull up enabled."]
    UP = 0x01,
    #[doc = "Pull down enabled."]
    DOWN = 0x02,
    #[doc = "Pin is kept at previous voltage level when no active driver is present on the pin."]
    REPEATER = 0x03,
}
impl Pull {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Pull {
        unsafe { core::mem::transmute(val & 0x03) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Pull {
    #[inline(always)]
    fn from(val: u8) -> Pull {
        Pull::from_bits(val)
    }
}
impl From<Pull> for u8 {
    #[inline(always)]
    fn from(val: Pull) -> u8 {
        Pull::to_bits(val)
    }
}
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Sel {
    #[doc = "Single GPIO output data bit is enabled."]
    PIN = 0x0,
    #[doc = "Grouped Output GPIO is enabled."]
    GROUP = 0x01,
}
impl Sel {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Sel {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Sel {
    #[inline(always)]
    fn from(val: u8) -> Sel {
        Sel::from_bits(val)
    }
}
impl From<Sel> for u8 {
    #[inline(always)]
    fn from(val: Sel) -> u8 {
        Sel::to_bits(val)
    }
}
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum SlewCtrl {
    SLOW = 0x0,
    FAST = 0x01,
}
impl SlewCtrl {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> SlewCtrl {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for SlewCtrl {
    #[inline(always)]
    fn from(val: u8) -> SlewCtrl {
        SlewCtrl::from_bits(val)
    }
}
impl From<SlewCtrl> for u8 {
    #[inline(always)]
    fn from(val: SlewCtrl) -> u8 {
        SlewCtrl::to_bits(val)
    }
}
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Strength {
    #[doc = "2mA for PIO-12 pins, 4mA for PIO-24 pins."]
    LOWEST = 0x0,
    #[doc = "4mA for PIO-12 pins, 8mA for PIO-24 pins."]
    LOW = 0x01,
    #[doc = "8mA for PIO-12 pins, 16mA for PIO-24 pins."]
    MEDIUM = 0x02,
    #[doc = "12mA for PIO-12 pins, 24mA for PIO-24 pins."]
    FULL = 0x03,
}
impl Strength {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Strength {
        unsafe { core::mem::transmute(val & 0x03) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Strength {
    #[inline(always)]
    fn from(val: u8) -> Strength {
        Strength::from_bits(val)
    }
}
impl From<Strength> for u8 {
    #[inline(always)]
    fn from(val: Strength) -> u8 {
        Strength::to_bits(val)
    }
}
pub mod acpi_ec0 {
    #[doc = "The ACPI-ECI provides a four byte full duplex data interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct AcpiEc0 {
        ptr: *mut u8,
    }
    unsafe impl Send for AcpiEc0 {}
    unsafe impl Sync for AcpiEc0 {}
    impl AcpiEc0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This is byte n of the 32-bit ACPI-OS DATA BYTES\\[3:0\\]. Writes by the ACPI_OS to the ACPI-OS DATA BYTES\\[n\\] are aliased to the OS2EC DATA BYTES\\[n\\]. Reads by the ACPI_OS from the ACPI-OS DATA BYTES\\[n\\] are aliased to the EC2OS DATA BYTES\\[n\\]."]
        #[inline(always)]
        pub const fn os_data(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Writes to the this register are aliased in the OS2EC Data EC Byte 0 Register. Writes to this register also set the CMD and IBF bits in the OS STATUS OS Register"]
        #[inline(always)]
        pub const fn os_cmd(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "OS STATUS"]
        #[inline(always)]
        pub const fn os_sts(self) -> crate::common::Reg<regs::OsSts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "OS Byte Control Register"]
        #[inline(always)]
        pub const fn os_byte_ctrl(self) -> crate::common::Reg<regs::OsByteCtrl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "This is byte n of the 32-bit EC2OS DATA BYTES\\[3:0\\]. Writes by the ACPI_EC to the EC2OS DATA BYTES\\[3:0\\] are aliased to the ACPI-OS DATA BYTES\\[3:0\\]."]
        #[inline(always)]
        pub const fn ec2os_data(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "EC STATUS"]
        #[inline(always)]
        pub const fn ec_status(self) -> crate::common::Reg<regs::EcStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Byte Control EC-Register"]
        #[inline(always)]
        pub const fn ec_byte_ctrl(self) -> crate::common::Reg<regs::EcByteCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0105usize) as _) }
        }
        #[doc = "OS_TO_EC_DATA_BYTE_n. This is byte n of the 32-bit OS2EC DATA BYTES\\[3:0\\]. When the CMD bit in the OS STATUS OS Register is cleared to '0', reads by the ACPI_EC from the OS2EC DATA BYTES\\[3:0\\] are aliased to the ACPI-OS DATA BYTES\\[3:0\\]."]
        #[inline(always)]
        pub const fn os2ec_data(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Byte Control EC-Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcByteCtrl(pub u8);
        impl EcByteCtrl {
            #[doc = "When this bit is set to '1', the ACPI Embedded Controller Interface (ACPI-ECI) accesses four bytes through the ACPI-OS DATA BYTES\\[3:0\\]. When this bit is cleared to '0', the ACPI Embedded Controller Interface (ACPI-ECI) accesses one byte through the ACPI OS Data Register Byte 0 Register. This corresponds to Legacy Mode. This bit effects the behaviour of the IBF and OBF bits in the OS STATUS OS Register."]
            #[inline(always)]
            pub const fn four_byte_access(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is set to '1', the ACPI Embedded Controller Interface (ACPI-ECI) accesses four bytes through the ACPI-OS DATA BYTES\\[3:0\\]. When this bit is cleared to '0', the ACPI Embedded Controller Interface (ACPI-ECI) accesses one byte through the ACPI OS Data Register Byte 0 Register. This corresponds to Legacy Mode. This bit effects the behaviour of the IBF and OBF bits in the OS STATUS OS Register."]
            #[inline(always)]
            pub fn set_four_byte_access(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for EcByteCtrl {
            #[inline(always)]
            fn default() -> EcByteCtrl {
                EcByteCtrl(0)
            }
        }
        impl core::fmt::Debug for EcByteCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcByteCtrl")
                    .field("four_byte_access", &self.four_byte_access())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcByteCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcByteCtrl {{ four_byte_access: {=bool:?} }}",
                    self.four_byte_access()
                )
            }
        }
        #[doc = "EC STATUS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcStatus(pub u8);
        impl EcStatus {
            #[doc = "The Output Buffer Full bit is set to indicate that a the ACPI_EC has written a data to the ACPI_OS and that data is ready."]
            #[inline(always)]
            pub const fn obf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The Output Buffer Full bit is set to indicate that a the ACPI_EC has written a data to the ACPI_OS and that data is ready."]
            #[inline(always)]
            pub fn set_obf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "The Input Buffer Full bit is set to indicate that a the ACPI_OS has written a command or data to the ACPI_EC and that data is ready."]
            #[inline(always)]
            pub const fn ibf(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The Input Buffer Full bit is set to indicate that a the ACPI_OS has written a command or data to the ACPI_EC and that data is ready."]
            #[inline(always)]
            pub fn set_ibf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "UD1A User Defined"]
            #[inline(always)]
            pub const fn ud1a(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "UD1A User Defined"]
            #[inline(always)]
            pub fn set_ud1a(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is set when the OS2EC Data EC Byte 0 Register contains a command byte written into ACPI OS COMMAND Register"]
            #[inline(always)]
            pub const fn cmd(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the OS2EC Data EC Byte 0 Register contains a command byte written into ACPI OS COMMAND Register"]
            #[inline(always)]
            pub fn set_cmd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "The BURST bit is set when the ACPI_EC is in Burst Mode"]
            #[inline(always)]
            pub const fn burst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "The BURST bit is set when the ACPI_EC is in Burst Mode"]
            #[inline(always)]
            pub fn set_burst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is set by software when an SCI event is pending"]
            #[inline(always)]
            pub const fn sci_evt(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set by software when an SCI event is pending"]
            #[inline(always)]
            pub fn set_sci_evt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "This bit is set when an SMI event is pending"]
            #[inline(always)]
            pub const fn smi_evt(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when an SMI event is pending"]
            #[inline(always)]
            pub fn set_smi_evt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "User Defined"]
            #[inline(always)]
            pub const fn ud0a(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "User Defined"]
            #[inline(always)]
            pub fn set_ud0a(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for EcStatus {
            #[inline(always)]
            fn default() -> EcStatus {
                EcStatus(0)
            }
        }
        impl core::fmt::Debug for EcStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcStatus")
                    .field("obf", &self.obf())
                    .field("ibf", &self.ibf())
                    .field("ud1a", &self.ud1a())
                    .field("cmd", &self.cmd())
                    .field("burst", &self.burst())
                    .field("sci_evt", &self.sci_evt())
                    .field("smi_evt", &self.smi_evt())
                    .field("ud0a", &self.ud0a())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcStatus {{ obf: {=bool:?}, ibf: {=bool:?}, ud1a: {=bool:?}, cmd: {=bool:?}, burst: {=bool:?}, sci_evt: {=bool:?}, smi_evt: {=bool:?}, ud0a: {=bool:?} }}" , self . obf () , self . ibf () , self . ud1a () , self . cmd () , self . burst () , self . sci_evt () , self . smi_evt () , self . ud0a ())
            }
        }
        #[doc = "OS Byte Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OsByteCtrl(pub u8);
        impl OsByteCtrl {
            #[doc = "When this bit is set to '1', the ACPI Embedded Controller Interface (ACPI-ECI) accesses four bytes through the ACPI-OS DATA BYTES\\[3:0\\]. When this bit is cleared to '0', the ACPI Embedded Controller Interface (ACPI-ECI) accesses one byte through the ACPI OS Data Register Byte 0 Register. This corresponds to Legacy Mode. This bit effects the behaviour of the IBF and OBF bits in the OS STATUS OS Register."]
            #[inline(always)]
            pub const fn four_byte_access(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is set to '1', the ACPI Embedded Controller Interface (ACPI-ECI) accesses four bytes through the ACPI-OS DATA BYTES\\[3:0\\]. When this bit is cleared to '0', the ACPI Embedded Controller Interface (ACPI-ECI) accesses one byte through the ACPI OS Data Register Byte 0 Register. This corresponds to Legacy Mode. This bit effects the behaviour of the IBF and OBF bits in the OS STATUS OS Register."]
            #[inline(always)]
            pub fn set_four_byte_access(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for OsByteCtrl {
            #[inline(always)]
            fn default() -> OsByteCtrl {
                OsByteCtrl(0)
            }
        }
        impl core::fmt::Debug for OsByteCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OsByteCtrl")
                    .field("four_byte_access", &self.four_byte_access())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OsByteCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "OsByteCtrl {{ four_byte_access: {=bool:?} }}",
                    self.four_byte_access()
                )
            }
        }
        #[doc = "OS STATUS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OsSts(pub u8);
        impl OsSts {
            #[doc = "The Output Buffer Full bit is set to indicate that a the ACPI_EC has written a data to the ACPI_OS and that data is ready. This bit is automatically cleared when all the data has been read by the ACPI_OS. Note: The setting and clearing of this OBF varies depending on the setting FOUR_BYTE_ACCESS bit in the OS Byte Control Register."]
            #[inline(always)]
            pub const fn obf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The Output Buffer Full bit is set to indicate that a the ACPI_EC has written a data to the ACPI_OS and that data is ready. This bit is automatically cleared when all the data has been read by the ACPI_OS. Note: The setting and clearing of this OBF varies depending on the setting FOUR_BYTE_ACCESS bit in the OS Byte Control Register."]
            #[inline(always)]
            pub fn set_obf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "The Input Buffer Full bit is set to indicate that a the ACPI_OS has written a command or data to the ACPI_EC and that data is ready. This bit is automatically cleared when data has been read by the ACPI_EC. Note: The setting and clearing of this IBF varies depending on the setting of the following bits: CMD bit in this register and FOUR_BYTE_ACCESS bit in the OS Byte Control Register."]
            #[inline(always)]
            pub const fn ibf(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The Input Buffer Full bit is set to indicate that a the ACPI_OS has written a command or data to the ACPI_EC and that data is ready. This bit is automatically cleared when data has been read by the ACPI_EC. Note: The setting and clearing of this IBF varies depending on the setting of the following bits: CMD bit in this register and FOUR_BYTE_ACCESS bit in the OS Byte Control Register."]
            #[inline(always)]
            pub fn set_ibf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "User Defined"]
            #[inline(always)]
            pub const fn ud1b(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "User Defined"]
            #[inline(always)]
            pub fn set_ud1b(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit is set when the OS2EC Data EC Byte 0 Register contains a command byte written into ACPI OS COMMAND Register; this bit is cleared when the OS2EC DATA BYTES\\[3:0\\] contains a data byte written into the ACPI-OS DATA BYTES\\[3:0\\]. This bit is hardware controlled: ACPI_OS writes to any of the four ACPI-OS DATA BYTES\\[3:0\\] bytes clears this bit ACPI_OS writes to the ACPI OS COMMAND Register sets this bit. Note: This bit allows the embedded controller to differentiate the start of a command sequence from a data byte write operation."]
            #[inline(always)]
            pub const fn cmd(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the OS2EC Data EC Byte 0 Register contains a command byte written into ACPI OS COMMAND Register; this bit is cleared when the OS2EC DATA BYTES\\[3:0\\] contains a data byte written into the ACPI-OS DATA BYTES\\[3:0\\]. This bit is hardware controlled: ACPI_OS writes to any of the four ACPI-OS DATA BYTES\\[3:0\\] bytes clears this bit ACPI_OS writes to the ACPI OS COMMAND Register sets this bit. Note: This bit allows the embedded controller to differentiate the start of a command sequence from a data byte write operation."]
            #[inline(always)]
            pub fn set_cmd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "The BURST bit is set when the ACPI_EC is in Burst Mode for polled command processing; the BURST bit is cleared when the ACPI_EC is in Normal mode for interrupt-driven command processing. The BURST bit is is an ACPI_EC-maintained software flag that indicates the embedded controller has received the Burst Enable command from the host, has halted normal processing, and is waiting for a series of commands to be sent from the host."]
            #[inline(always)]
            pub const fn burst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "The BURST bit is set when the ACPI_EC is in Burst Mode for polled command processing; the BURST bit is cleared when the ACPI_EC is in Normal mode for interrupt-driven command processing. The BURST bit is is an ACPI_EC-maintained software flag that indicates the embedded controller has received the Burst Enable command from the host, has halted normal processing, and is waiting for a series of commands to be sent from the host."]
            #[inline(always)]
            pub fn set_burst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is set by software when an SCI event is pending; i.e., the ACPI_EC is requesting an SCI query; SCI Event flag is clear when no SCI events are pending. This bit is an ACPI_EC-maintained software flag that is set when the embedded controller has detected an internal event that requires operating system attention. The ACPI_EC sets this bit before generating an SCI to the OS."]
            #[inline(always)]
            pub const fn sci_evt(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set by software when an SCI event is pending; i.e., the ACPI_EC is requesting an SCI query; SCI Event flag is clear when no SCI events are pending. This bit is an ACPI_EC-maintained software flag that is set when the embedded controller has detected an internal event that requires operating system attention. The ACPI_EC sets this bit before generating an SCI to the OS."]
            #[inline(always)]
            pub fn set_sci_evt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "This bit is set when an SMI event is pending; i.e., the ACPI_EC is requesting an SMI query; This bit is cleared when no SMI events are pending. This bit is an ACPI_EC-maintained software flag that is set when the ACPI_EC has detected an internal event that requires system management interrupt handler attention. The ACPI_EC sets this bit before generating an SMI."]
            #[inline(always)]
            pub const fn smi_evt(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when an SMI event is pending; i.e., the ACPI_EC is requesting an SMI query; This bit is cleared when no SMI events are pending. This bit is an ACPI_EC-maintained software flag that is set when the ACPI_EC has detected an internal event that requires system management interrupt handler attention. The ACPI_EC sets this bit before generating an SMI."]
            #[inline(always)]
            pub fn set_smi_evt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "User Defined"]
            #[inline(always)]
            pub const fn ud0b(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "User Defined"]
            #[inline(always)]
            pub fn set_ud0b(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for OsSts {
            #[inline(always)]
            fn default() -> OsSts {
                OsSts(0)
            }
        }
        impl core::fmt::Debug for OsSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OsSts")
                    .field("obf", &self.obf())
                    .field("ibf", &self.ibf())
                    .field("ud1b", &self.ud1b())
                    .field("cmd", &self.cmd())
                    .field("burst", &self.burst())
                    .field("sci_evt", &self.sci_evt())
                    .field("smi_evt", &self.smi_evt())
                    .field("ud0b", &self.ud0b())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OsSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "OsSts {{ obf: {=bool:?}, ibf: {=bool:?}, ud1b: {=bool:?}, cmd: {=bool:?}, burst: {=bool:?}, sci_evt: {=bool:?}, smi_evt: {=bool:?}, ud0b: {=bool:?} }}" , self . obf () , self . ibf () , self . ud1b () , self . cmd () , self . burst () , self . sci_evt () , self . smi_evt () , self . ud0b ())
            }
        }
    }
}
pub mod adc {
    #[doc = "This block is designed to convert external analog voltage readings into digital values."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Adc {
        ptr: *mut u8,
    }
    unsafe impl Send for Adc {}
    unsafe impl Sync for Adc {}
    impl Adc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The ADC Control Register is used to control the behavior of the Analog to Digital Converter."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "The ADC Delay register determines the delay from setting Start_Repeat in the ADC Control Register and the start of a conversion cycle. This register also controls the interval between conversion cycles in repeat mode."]
        #[inline(always)]
        pub const fn delay(self) -> crate::common::Reg<regs::Delay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The ADC Status Register indicates whether the ADC has completed a conversion cycle. All bits are cleared by being written with a 1. 0: conversion of the corresponding ADC channel is not complete 1: conversion of the corresponding ADC channel is complete"]
        #[inline(always)]
        pub const fn chan_sts(self) -> crate::common::Reg<regs::ChanSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "The ADC Single Register is used to control which ADC channel is captured during a Single-Sample conversion cycle initiated by the Start_Single bit in the ADC Control Register. APPLICATION NOTE: Do not change the bits in this register in the middle of a conversion cycle to insure proper operation. 0: single cycle conversions for this channel are disabled 1: single cycle conversions for this channel are enabled"]
        #[inline(always)]
        pub const fn sng_en(self) -> crate::common::Reg<regs::SngEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "The ADC Repeat Register is used to control which ADC channels are captured during a repeat conversion cycle initiated by the Start_Repeat bit in the ADC Control Register."]
        #[inline(always)]
        pub const fn rept_en(self) -> crate::common::Reg<regs::ReptEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "All 16 ADC channels return their results into a 32-bit reading register. In each case the low 10 bits of the reading register return the result of the Analog to Digital conversion and the upper 22 bits return 0."]
        #[inline(always)]
        pub const fn chan_rd(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize + n * 4usize) as _) }
        }
        #[doc = "The ADC Configuration Register is used to configure the ADC clock timing."]
        #[inline(always)]
        pub const fn cfg(self) -> crate::common::Reg<regs::Cfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "The ADC Channel Register is used to configure the reference voltage to the clock timing."]
        #[inline(always)]
        pub const fn vref_chan(self) -> crate::common::Reg<regs::VrefChan, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "This is the VREF Control Register"]
        #[inline(always)]
        pub const fn vref_ctrl(self) -> crate::common::Reg<regs::VrefCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "This is the SAR ADC Control Register."]
        #[inline(always)]
        pub const fn sar_ctrl(self) -> crate::common::Reg<regs::SarCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "This is the SAR ADC Configuration Register."]
        #[inline(always)]
        pub const fn sar_cfg(self) -> crate::common::Reg<regs::SarCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "The ADC Configuration Register is used to configure the ADC clock timing."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfg(pub u32);
        impl Cfg {
            #[doc = "These bits define the low time count of the ADC clock. 0= not used. 1= 1 System Clock. 2= 2 System Clock."]
            #[inline(always)]
            pub const fn clklw_tim(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These bits define the low time count of the ADC clock. 0= not used. 1= 1 System Clock. 2= 2 System Clock."]
            #[inline(always)]
            pub fn set_clklw_tim(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These bits define the high time count of the ADC clock. 0= not used. 1= 1 System Clock. 2= 2 System Clock."]
            #[inline(always)]
            pub const fn clkhigh_tim(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "These bits define the high time count of the ADC clock. 0= not used. 1= 1 System Clock. 2= 2 System Clock."]
            #[inline(always)]
            pub fn set_clkhigh_tim(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "These bits define the dummy cycles of the ADC clock. Valid Values are from 0x0 to 0xF."]
            #[inline(always)]
            pub const fn clkdumy_tim(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits define the dummy cycles of the ADC clock. Valid Values are from 0x0 to 0xF."]
            #[inline(always)]
            pub fn set_clkdumy_tim(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "These bits define the power up delay in number of micro-seconds. Valid Values are from 0x0 to 0xF."]
            #[inline(always)]
            pub const fn pwrup_dly(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits define the power up delay in number of micro-seconds. Valid Values are from 0x0 to 0xF."]
            #[inline(always)]
            pub fn set_pwrup_dly(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "These bits define the number of micro-seconds between consective Starts."]
            #[inline(always)]
            pub const fn dumycyc_gap(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "These bits define the number of micro-seconds between consective Starts."]
            #[inline(always)]
            pub fn set_dumycyc_gap(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cfg {
            #[inline(always)]
            fn default() -> Cfg {
                Cfg(0)
            }
        }
        impl core::fmt::Debug for Cfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfg")
                    .field("clklw_tim", &self.clklw_tim())
                    .field("clkhigh_tim", &self.clkhigh_tim())
                    .field("clkdumy_tim", &self.clkdumy_tim())
                    .field("pwrup_dly", &self.pwrup_dly())
                    .field("dumycyc_gap", &self.dumycyc_gap())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cfg {{ clklw_tim: {=u8:?}, clkhigh_tim: {=u8:?}, clkdumy_tim: {=u8:?}, pwrup_dly: {=u8:?}, dumycyc_gap: {=u8:?} }}" , self . clklw_tim () , self . clkhigh_tim () , self . clkdumy_tim () , self . pwrup_dly () , self . dumycyc_gap ())
            }
        }
        #[doc = "The ADC Status Register indicates whether the ADC has completed a conversion cycle. All bits are cleared by being written with a 1. 0: conversion of the corresponding ADC channel is not complete 1: conversion of the corresponding ADC channel is complete"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ChanSts(pub u32);
        impl ChanSts {
            #[doc = "All bits are cleared by being written with a '1'. 1=conversion of the corresponding ADC channel is complete; 0=conversion of the corresponding ADC channel is not complete. For enabled single cycles, the SINGLE_DONE_STATUS bit in the ADC Control Register is also set after all enabled channel conversion are done; for enabled repeat cycles, the REPEAT_DONE_STATUS in the ADC Control Register is also set after all enabled channel conversion are done."]
            #[inline(always)]
            pub const fn sts(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "All bits are cleared by being written with a '1'. 1=conversion of the corresponding ADC channel is complete; 0=conversion of the corresponding ADC channel is not complete. For enabled single cycles, the SINGLE_DONE_STATUS bit in the ADC Control Register is also set after all enabled channel conversion are done; for enabled repeat cycles, the REPEAT_DONE_STATUS in the ADC Control Register is also set after all enabled channel conversion are done."]
            #[inline(always)]
            pub fn set_sts(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for ChanSts {
            #[inline(always)]
            fn default() -> ChanSts {
                ChanSts(0)
            }
        }
        impl core::fmt::Debug for ChanSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ChanSts").field("sts", &self.sts()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ChanSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ChanSts {{ sts: {=u16:?} }}", self.sts())
            }
        }
        #[doc = "The ADC Control Register is used to control the behavior of the Analog to Digital Converter."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "0: The ADC is disabled and placed in its lowest power state. 1: ADC block is enabled for operation."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "0: The ADC is disabled and placed in its lowest power state. 1: ADC block is enabled for operation."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "(START_SINGLE) 0: The ADC Single Mode is disabled. 1: The ADC Single Mode is enabled. Note: This bit is self-clearing"]
            #[inline(always)]
            pub const fn strt_sin(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "(START_SINGLE) 0: The ADC Single Mode is disabled. 1: The ADC Single Mode is enabled. Note: This bit is self-clearing"]
            #[inline(always)]
            pub fn set_strt_sin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "0: The ADC Repeat Mode is disabled. 1: The ADC Repeat Mode is enabled."]
            #[inline(always)]
            pub const fn strt_rpt(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "0: The ADC Repeat Mode is disabled. 1: The ADC Repeat Mode is enabled."]
            #[inline(always)]
            pub fn set_strt_rpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "0: Power saving feature is enabled. 1: Power saving feature is disabled."]
            #[inline(always)]
            pub const fn pwr_sav_dis(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "0: Power saving feature is enabled. 1: Power saving feature is disabled."]
            #[inline(always)]
            pub fn set_pwr_sav_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "(SOFT_RESET) 1: writing one causes a reset of the ADC block hardware (not the registers) 0: writing zero takes the ADC block out of reset"]
            #[inline(always)]
            pub const fn sft_rst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "(SOFT_RESET) 1: writing one causes a reset of the ADC block hardware (not the registers) 0: writing zero takes the ADC block out of reset"]
            #[inline(always)]
            pub fn set_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "0: ADC repeat-sample conversion is not complete. 1: ADC repeat-sample conversion is completed. (R/WC)"]
            #[inline(always)]
            pub const fn rpt_done_sts(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "0: ADC repeat-sample conversion is not complete. 1: ADC repeat-sample conversion is completed. (R/WC)"]
            #[inline(always)]
            pub fn set_rpt_done_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "0: ADC single-sample conversion is not complete. 1: ADC single-sample conversion is completed. (R/WC)"]
            #[inline(always)]
            pub const fn sin_done_sts(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "0: ADC single-sample conversion is not complete. 1: ADC single-sample conversion is completed. (R/WC)"]
            #[inline(always)]
            pub fn set_sin_done_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("act", &self.act())
                    .field("strt_sin", &self.strt_sin())
                    .field("strt_rpt", &self.strt_rpt())
                    .field("pwr_sav_dis", &self.pwr_sav_dis())
                    .field("sft_rst", &self.sft_rst())
                    .field("rpt_done_sts", &self.rpt_done_sts())
                    .field("sin_done_sts", &self.sin_done_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ act: {=bool:?}, strt_sin: {=bool:?}, strt_rpt: {=bool:?}, pwr_sav_dis: {=bool:?}, sft_rst: {=bool:?}, rpt_done_sts: {=bool:?}, sin_done_sts: {=bool:?} }}" , self . act () , self . strt_sin () , self . strt_rpt () , self . pwr_sav_dis () , self . sft_rst () , self . rpt_done_sts () , self . sin_done_sts ())
            }
        }
        #[doc = "The ADC Delay register determines the delay from setting Start_Repeat in the ADC Control Register and the start of a conversion cycle. This register also controls the interval between conversion cycles in repeat mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Delay(pub u32);
        impl Delay {
            #[doc = "This field determines the starting delay before a conversion cycle is begun when Start_Repeat is written with a 1."]
            #[inline(always)]
            pub const fn strt_dly(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This field determines the starting delay before a conversion cycle is begun when Start_Repeat is written with a 1."]
            #[inline(always)]
            pub fn set_strt_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "This field determines the interval between conversion cycles when Start_Repeat is 1."]
            #[inline(always)]
            pub const fn rpt_dly(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This field determines the interval between conversion cycles when Start_Repeat is 1."]
            #[inline(always)]
            pub fn set_rpt_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Delay {
            #[inline(always)]
            fn default() -> Delay {
                Delay(0)
            }
        }
        impl core::fmt::Debug for Delay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Delay")
                    .field("strt_dly", &self.strt_dly())
                    .field("rpt_dly", &self.rpt_dly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Delay {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Delay {{ strt_dly: {=u16:?}, rpt_dly: {=u16:?} }}",
                    self.strt_dly(),
                    self.rpt_dly()
                )
            }
        }
        #[doc = "The ADC Repeat Register is used to control which ADC channels are captured during a repeat conversion cycle initiated by the Start_Repeat bit in the ADC Control Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ReptEn(pub u32);
        impl ReptEn {
            #[doc = "Each bit in this field enables the corresponding ADC channel for each pass of the Repeated ADC Conversion that is controlled by bit START_REPEAT in the ADC Control Register. 1=repeat conversions for this channel are enabled; 0=repeat conversions for this channel are disabled"]
            #[inline(always)]
            pub const fn r_en(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Each bit in this field enables the corresponding ADC channel for each pass of the Repeated ADC Conversion that is controlled by bit START_REPEAT in the ADC Control Register. 1=repeat conversions for this channel are enabled; 0=repeat conversions for this channel are disabled"]
            #[inline(always)]
            pub fn set_r_en(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for ReptEn {
            #[inline(always)]
            fn default() -> ReptEn {
                ReptEn(0)
            }
        }
        impl core::fmt::Debug for ReptEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ReptEn").field("r_en", &self.r_en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ReptEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ReptEn {{ r_en: {=u16:?} }}", self.r_en())
            }
        }
        #[doc = "This is the SAR ADC Configuration Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SarCfg(pub u32);
        impl SarCfg {
            #[doc = "Enable Common Mode Buffer Amplifier. 0= Common Mode Buffer Amplifier is high all the time. 1= Controls Common Mode Buffer Amplifier during power cycling."]
            #[inline(always)]
            pub const fn en_cmbf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Common Mode Buffer Amplifier. 0= Common Mode Buffer Amplifier is high all the time. 1= Controls Common Mode Buffer Amplifier during power cycling."]
            #[inline(always)]
            pub fn set_en_cmbf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Disable Parallel Output. 0= Enable Parallel Output. 1= Disable Parallel Output."]
            #[inline(always)]
            pub const fn dis_dout(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Disable Parallel Output. 0= Enable Parallel Output. 1= Disable Parallel Output."]
            #[inline(always)]
            pub fn set_dis_dout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable Dithering. 0= Disable Dither. 1= Enable Dither."]
            #[inline(always)]
            pub const fn en_dither(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Dithering. 0= Disable Dither. 1= Enable Dither."]
            #[inline(always)]
            pub fn set_en_dither(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable F_AZ AUTOZEROING. 1= Disable f_az autozeroing. 0= Enable f_az autozeroing."]
            #[inline(always)]
            pub const fn faz_au_zero(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable F_AZ AUTOZEROING. 1= Disable f_az autozeroing. 0= Enable f_az autozeroing."]
            #[inline(always)]
            pub fn set_faz_au_zero(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable S_AZ AUTOZEROING. 1= Disable S_AZ autozeroing. 0= Enable S_AZ autozeroing."]
            #[inline(always)]
            pub const fn saz_au_zero(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable S_AZ AUTOZEROING. 1= Disable S_AZ autozeroing. 0= Enable S_AZ autozeroing."]
            #[inline(always)]
            pub fn set_saz_au_zero(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable L_AZ AUTOZEROING. 1= Disable L_AZ autozeroing. 0= Enable L_AZ autozeroing."]
            #[inline(always)]
            pub const fn laz_au_zero(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable L_AZ AUTOZEROING. 1= Disable L_AZ autozeroing. 0= Enable L_AZ autozeroing."]
            #[inline(always)]
            pub fn set_laz_au_zero(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable RADC. 1 = RDAC remains high during power cycling. 0 = Controls RDAC during power cycling."]
            #[inline(always)]
            pub const fn en_radc(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RADC. 1 = RDAC remains high during power cycling. 0 = Controls RDAC during power cycling."]
            #[inline(always)]
            pub fn set_en_radc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This register defines the delay between regen and latch."]
            #[inline(always)]
            pub const fn regen_dly(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x03;
                val as u8
            }
            #[doc = "This register defines the delay between regen and latch."]
            #[inline(always)]
            pub fn set_regen_dly(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 9usize)) | (((val as u32) & 0x03) << 9usize);
            }
            #[doc = "This register defines the programmable ADC Clock divider value. Divider ratios of 256,128,64,32,16 are supported."]
            #[inline(always)]
            pub const fn clk_div(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x1f;
                val as u8
            }
            #[doc = "This register defines the programmable ADC Clock divider value. Divider ratios of 256,128,64,32,16 are supported."]
            #[inline(always)]
            pub fn set_clk_div(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 11usize)) | (((val as u32) & 0x1f) << 11usize);
            }
            #[doc = "This register controls the current consumption for the whole ADC."]
            #[inline(always)]
            pub const fn iadc_range2(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x03;
                val as u8
            }
            #[doc = "This register controls the current consumption for the whole ADC."]
            #[inline(always)]
            pub fn set_iadc_range2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 20usize)) | (((val as u32) & 0x03) << 20usize);
            }
            #[doc = "This register controls the current consumption for the whole ADC."]
            #[inline(always)]
            pub const fn iadc_range1(&self) -> u8 {
                let val = (self.0 >> 22usize) & 0x03;
                val as u8
            }
            #[doc = "This register controls the current consumption for the whole ADC."]
            #[inline(always)]
            pub fn set_iadc_range1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 22usize)) | (((val as u32) & 0x03) << 22usize);
            }
            #[doc = "This register controls the bias current for the 1st stage of the comparator."]
            #[inline(always)]
            pub const fn icmbf_stg1(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x03;
                val as u8
            }
            #[doc = "This register controls the bias current for the 1st stage of the comparator."]
            #[inline(always)]
            pub fn set_icmbf_stg1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize);
            }
            #[doc = "This register controls the bias current for the 2nd stage of the comparator."]
            #[inline(always)]
            pub const fn icmbf_stg2(&self) -> u8 {
                let val = (self.0 >> 26usize) & 0x03;
                val as u8
            }
            #[doc = "This register controls the bias current for the 2nd stage of the comparator."]
            #[inline(always)]
            pub fn set_icmbf_stg2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 26usize)) | (((val as u32) & 0x03) << 26usize);
            }
            #[doc = "This register controls the bias current for common mode buffer amplifier."]
            #[inline(always)]
            pub const fn icmbf(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x03;
                val as u8
            }
            #[doc = "This register controls the bias current for common mode buffer amplifier."]
            #[inline(always)]
            pub fn set_icmbf(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 28usize)) | (((val as u32) & 0x03) << 28usize);
            }
            #[doc = "EN external bias. 1 = Disables internal switched cap bias circuit. 0 = Enables internal switched cap bias circuit."]
            #[inline(always)]
            pub const fn en_ext_bias(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "EN external bias. 1 = Disables internal switched cap bias circuit. 0 = Enables internal switched cap bias circuit."]
            #[inline(always)]
            pub fn set_en_ext_bias(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for SarCfg {
            #[inline(always)]
            fn default() -> SarCfg {
                SarCfg(0)
            }
        }
        impl core::fmt::Debug for SarCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SarCfg")
                    .field("en_cmbf", &self.en_cmbf())
                    .field("dis_dout", &self.dis_dout())
                    .field("en_dither", &self.en_dither())
                    .field("faz_au_zero", &self.faz_au_zero())
                    .field("saz_au_zero", &self.saz_au_zero())
                    .field("laz_au_zero", &self.laz_au_zero())
                    .field("en_radc", &self.en_radc())
                    .field("regen_dly", &self.regen_dly())
                    .field("clk_div", &self.clk_div())
                    .field("iadc_range2", &self.iadc_range2())
                    .field("iadc_range1", &self.iadc_range1())
                    .field("icmbf_stg1", &self.icmbf_stg1())
                    .field("icmbf_stg2", &self.icmbf_stg2())
                    .field("icmbf", &self.icmbf())
                    .field("en_ext_bias", &self.en_ext_bias())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SarCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SarCfg {{ en_cmbf: {=bool:?}, dis_dout: {=bool:?}, en_dither: {=bool:?}, faz_au_zero: {=bool:?}, saz_au_zero: {=bool:?}, laz_au_zero: {=bool:?}, en_radc: {=bool:?}, regen_dly: {=u8:?}, clk_div: {=u8:?}, iadc_range2: {=u8:?}, iadc_range1: {=u8:?}, icmbf_stg1: {=u8:?}, icmbf_stg2: {=u8:?}, icmbf: {=u8:?}, en_ext_bias: {=bool:?} }}" , self . en_cmbf () , self . dis_dout () , self . en_dither () , self . faz_au_zero () , self . saz_au_zero () , self . laz_au_zero () , self . en_radc () , self . regen_dly () , self . clk_div () , self . iadc_range2 () , self . iadc_range1 () , self . icmbf_stg1 () , self . icmbf_stg2 () , self . icmbf () , self . en_ext_bias ())
            }
        }
        #[doc = "This is the SAR ADC Control Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SarCtrl(pub u32);
        impl SarCtrl {
            #[doc = "This field select between Single ended / Differential input. 0= ADC core is enabled for single ended input operation. 1= ADC core is enabled for differential input operation."]
            #[inline(always)]
            pub const fn sel_diff(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This field select between Single ended / Differential input. 0= ADC core is enabled for single ended input operation. 1= ADC core is enabled for differential input operation."]
            #[inline(always)]
            pub fn set_sel_diff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This field select the ADC Resolution (10/12 bits). 0x0= Reserved. 0x1= Reserved. 0x2= 10 bit ADC resolution. 0x3= 12 bit ADC resolution."]
            #[inline(always)]
            pub const fn sel_res(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x03;
                val as u8
            }
            #[doc = "This field select the ADC Resolution (10/12 bits). 0x0= Reserved. 0x1= Reserved. 0x2= 10 bit ADC resolution. 0x3= 12 bit ADC resolution."]
            #[inline(always)]
            pub fn set_sel_res(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val as u32) & 0x03) << 1usize);
            }
            #[doc = "This field defined if the ADC output is Right or Left Justified. 1= adc_dout is not shifted and lower bits are set to 0. 0= adc_dout is shifted right following resolution selected."]
            #[inline(always)]
            pub const fn shift_dat(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This field defined if the ADC output is Right or Left Justified. 1= adc_dout is not shifted and lower bits are set to 0. 0= adc_dout is shifted right following resolution selected."]
            #[inline(always)]
            pub fn set_shift_dat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This field enables asynchronous sampling. 0= Async Sampling Disabled. 1= Async Sampling Enabled."]
            #[inline(always)]
            pub const fn en_asyn_smpl(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This field enables asynchronous sampling. 0= Async Sampling Disabled. 1= Async Sampling Enabled."]
            #[inline(always)]
            pub fn set_en_asyn_smpl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This field enables serial output (dout) from ADC. 0= Parallel dout. 1= Serial dout."]
            #[inline(always)]
            pub const fn en_serial(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This field enables serial output (dout) from ADC. 0= Parallel dout. 1= Serial dout."]
            #[inline(always)]
            pub fn set_en_serial(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This field represents the warmup delay number in microseconds."]
            #[inline(always)]
            pub const fn warm_up_dly(&self) -> u16 {
                let val = (self.0 >> 7usize) & 0x01ff;
                val as u16
            }
            #[doc = "This field represents the warmup delay number in microseconds."]
            #[inline(always)]
            pub fn set_warm_up_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 7usize)) | (((val as u32) & 0x01ff) << 7usize);
            }
        }
        impl Default for SarCtrl {
            #[inline(always)]
            fn default() -> SarCtrl {
                SarCtrl(0)
            }
        }
        impl core::fmt::Debug for SarCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SarCtrl")
                    .field("sel_diff", &self.sel_diff())
                    .field("sel_res", &self.sel_res())
                    .field("shift_dat", &self.shift_dat())
                    .field("en_asyn_smpl", &self.en_asyn_smpl())
                    .field("en_serial", &self.en_serial())
                    .field("warm_up_dly", &self.warm_up_dly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SarCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SarCtrl {{ sel_diff: {=bool:?}, sel_res: {=u8:?}, shift_dat: {=bool:?}, en_asyn_smpl: {=bool:?}, en_serial: {=bool:?}, warm_up_dly: {=u16:?} }}" , self . sel_diff () , self . sel_res () , self . shift_dat () , self . en_asyn_smpl () , self . en_serial () , self . warm_up_dly ())
            }
        }
        #[doc = "The ADC Single Register is used to control which ADC channel is captured during a Single-Sample conversion cycle initiated by the Start_Single bit in the ADC Control Register. APPLICATION NOTE: Do not change the bits in this register in the middle of a conversion cycle to insure proper operation. 0: single cycle conversions for this channel are disabled 1: single cycle conversions for this channel are enabled"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SngEn(pub u32);
        impl SngEn {
            #[doc = "Each bit in this field enables the corresponding ADC channel when a single cycle of conversions is started when the START_SINGLE bit in the ADC Control Register is written with a 1. 1=single cycle conversions for this channel are enabled 0=single cycle conversions for this channel are disabled. Note: If this register is changed while a conversion."]
            #[inline(always)]
            pub const fn s_en(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Each bit in this field enables the corresponding ADC channel when a single cycle of conversions is started when the START_SINGLE bit in the ADC Control Register is written with a 1. 1=single cycle conversions for this channel are enabled 0=single cycle conversions for this channel are disabled. Note: If this register is changed while a conversion."]
            #[inline(always)]
            pub fn set_s_en(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for SngEn {
            #[inline(always)]
            fn default() -> SngEn {
                SngEn(0)
            }
        }
        impl core::fmt::Debug for SngEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SngEn").field("s_en", &self.s_en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SngEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SngEn {{ s_en: {=u16:?} }}", self.s_en())
            }
        }
        #[doc = "The ADC Channel Register is used to configure the reference voltage to the clock timing."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VrefChan(pub u32);
        impl VrefChan {
            #[doc = "These bits define the reference voltage for Channel 0. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 0. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "These bits define the reference voltage for Channel 1. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel1(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 1. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "These bits define the reference voltage for Channel 2. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel2(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 2. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "These bits define the reference voltage for Channel 3. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel3(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 3. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u32) & 0x03) << 6usize);
            }
            #[doc = "These bits define the reference voltage for Channel 4. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel4(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 4. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "These bits define the reference voltage for Channel 5. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel5(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 5. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize);
            }
            #[doc = "These bits define the reference voltage for Channel 6. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel6(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 6. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize);
            }
            #[doc = "These bits define the reference voltage for Channel 7. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel7(&self) -> u8 {
                let val = (self.0 >> 14usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 7. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 14usize)) | (((val as u32) & 0x03) << 14usize);
            }
            #[doc = "These bits define the reference voltage for Channel 8. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel8(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 8. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel8(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 16usize)) | (((val as u32) & 0x03) << 16usize);
            }
            #[doc = "These bits define the reference voltage for Channel 9. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel9(&self) -> u8 {
                let val = (self.0 >> 18usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 9. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel9(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 18usize)) | (((val as u32) & 0x03) << 18usize);
            }
            #[doc = "These bits define the reference voltage for Channel 10. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel10(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 10. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 20usize)) | (((val as u32) & 0x03) << 20usize);
            }
            #[doc = "These bits define the reference voltage for Channel 11. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel11(&self) -> u8 {
                let val = (self.0 >> 22usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 11. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel11(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 22usize)) | (((val as u32) & 0x03) << 22usize);
            }
            #[doc = "These bits define the reference voltage for Channel 12. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel12(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 12. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel12(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize);
            }
            #[doc = "These bits define the reference voltage for Channel 13. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel13(&self) -> u8 {
                let val = (self.0 >> 26usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 13. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel13(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 26usize)) | (((val as u32) & 0x03) << 26usize);
            }
            #[doc = "These bits define the reference voltage for Channel 14. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel14(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 14. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel14(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 28usize)) | (((val as u32) & 0x03) << 28usize);
            }
            #[doc = "These bits define the reference voltage for Channel 15. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub const fn sel15(&self) -> u8 {
                let val = (self.0 >> 30usize) & 0x03;
                val as u8
            }
            #[doc = "These bits define the reference voltage for Channel 15. 0h= VREF0 1h= VREF1 2h= Reserved 3h= Reserved"]
            #[inline(always)]
            pub fn set_sel15(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 30usize)) | (((val as u32) & 0x03) << 30usize);
            }
        }
        impl Default for VrefChan {
            #[inline(always)]
            fn default() -> VrefChan {
                VrefChan(0)
            }
        }
        impl core::fmt::Debug for VrefChan {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VrefChan")
                    .field("sel0", &self.sel0())
                    .field("sel1", &self.sel1())
                    .field("sel2", &self.sel2())
                    .field("sel3", &self.sel3())
                    .field("sel4", &self.sel4())
                    .field("sel5", &self.sel5())
                    .field("sel6", &self.sel6())
                    .field("sel7", &self.sel7())
                    .field("sel8", &self.sel8())
                    .field("sel9", &self.sel9())
                    .field("sel10", &self.sel10())
                    .field("sel11", &self.sel11())
                    .field("sel12", &self.sel12())
                    .field("sel13", &self.sel13())
                    .field("sel14", &self.sel14())
                    .field("sel15", &self.sel15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VrefChan {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "VrefChan {{ sel0: {=u8:?}, sel1: {=u8:?}, sel2: {=u8:?}, sel3: {=u8:?}, sel4: {=u8:?}, sel5: {=u8:?}, sel6: {=u8:?}, sel7: {=u8:?}, sel8: {=u8:?}, sel9: {=u8:?}, sel10: {=u8:?}, sel11: {=u8:?}, sel12: {=u8:?}, sel13: {=u8:?}, sel14: {=u8:?}, sel15: {=u8:?} }}" , self . sel0 () , self . sel1 () , self . sel2 () , self . sel3 () , self . sel4 () , self . sel5 () , self . sel6 () , self . sel7 () , self . sel8 () , self . sel9 () , self . sel10 () , self . sel11 () , self . sel12 () , self . sel13 () , self . sel14 () , self . sel15 ())
            }
        }
        #[doc = "This is the VREF Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VrefCtrl(pub u32);
        impl VrefCtrl {
            #[doc = "This field represnts the delay time to charge up the external VREF capacitor."]
            #[inline(always)]
            pub const fn chrg_dly(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This field represnts the delay time to charge up the external VREF capacitor."]
            #[inline(always)]
            pub fn set_chrg_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "This field represnts the delay time interval between switching VREF Selects."]
            #[inline(always)]
            pub const fn switch_dly(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x1fff;
                val as u16
            }
            #[doc = "This field represnts the delay time interval between switching VREF Selects."]
            #[inline(always)]
            pub fn set_switch_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 16usize)) | (((val as u32) & 0x1fff) << 16usize);
            }
            #[doc = "This fields give the choice to the application whether to float the unused PAD's or to Drive them to 0. 1= Drive unused PAD's Low 0b 0= Leave unused PAD's Floating."]
            #[inline(always)]
            pub const fn padctrl(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "This fields give the choice to the application whether to float the unused PAD's or to Drive them to 0. 1= Drive unused PAD's Low 0b 0= Leave unused PAD's Floating."]
            #[inline(always)]
            pub fn set_padctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "This fields gives information about the current VREF selected. 0x0= VREF0 0x1= VREF1 0x2= Reserved 0x3= Reserved"]
            #[inline(always)]
            pub const fn selstat(&self) -> u8 {
                let val = (self.0 >> 30usize) & 0x03;
                val as u8
            }
            #[doc = "This fields gives information about the current VREF selected. 0x0= VREF0 0x1= VREF1 0x2= Reserved 0x3= Reserved"]
            #[inline(always)]
            pub fn set_selstat(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 30usize)) | (((val as u32) & 0x03) << 30usize);
            }
        }
        impl Default for VrefCtrl {
            #[inline(always)]
            fn default() -> VrefCtrl {
                VrefCtrl(0)
            }
        }
        impl core::fmt::Debug for VrefCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VrefCtrl")
                    .field("chrg_dly", &self.chrg_dly())
                    .field("switch_dly", &self.switch_dly())
                    .field("padctrl", &self.padctrl())
                    .field("selstat", &self.selstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VrefCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "VrefCtrl {{ chrg_dly: {=u16:?}, switch_dly: {=u16:?}, padctrl: {=bool:?}, selstat: {=u8:?} }}",
                    self.chrg_dly(),
                    self.switch_dly(),
                    self.padctrl(),
                    self.selstat()
                )
            }
        }
    }
}
pub mod asif {
    #[doc = "The ASIF allows the Host and EC to use index addressing to access registers residing in an external IC."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Asif {
        ptr: *mut u8,
    }
    unsafe impl Send for Asif {}
    unsafe impl Sync for Asif {}
    impl Asif {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "LPC BAL Register"]
        #[inline(always)]
        pub const fn host_bal(self) -> crate::common::Reg<regs::HostBal, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "LPC BAH Register."]
        #[inline(always)]
        pub const fn host_bah(self) -> crate::common::Reg<regs::HostBah, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Scratch 0 Register"]
        #[inline(always)]
        pub const fn scratch(self, n: usize) -> crate::common::Reg<regs::Scratch, crate::common::RW> {
            assert!(n < 10usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize + n * 1usize) as _) }
        }
        #[doc = "LPC AIXL Register"]
        #[inline(always)]
        pub const fn host_aixl(self) -> crate::common::Reg<regs::HostAixl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "LPC AIXH Register"]
        #[inline(always)]
        pub const fn host_aixh(self) -> crate::common::Reg<regs::HostAixh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "LPC Data In Register"]
        #[inline(always)]
        pub const fn host_data_in(self) -> crate::common::Reg<regs::HostDataIn, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "LPC Data Out Register"]
        #[inline(always)]
        pub const fn host_data_out(self) -> crate::common::Reg<regs::HostDataOut, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "LPC Status Register"]
        #[inline(always)]
        pub const fn host_sts(self) -> crate::common::Reg<regs::HostSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fusize) as _) }
        }
        #[doc = "EC AIXL Register"]
        #[inline(always)]
        pub const fn ec_aixl(self) -> crate::common::Reg<regs::EcAixl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "EC AIXH Register"]
        #[inline(always)]
        pub const fn ec_aixh(self) -> crate::common::Reg<regs::EcAixh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0101usize) as _) }
        }
        #[doc = "EC Data In Register"]
        #[inline(always)]
        pub const fn ec_data_in(self) -> crate::common::Reg<regs::EcDataIn, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0102usize) as _) }
        }
        #[doc = "EC Data Out Register"]
        #[inline(always)]
        pub const fn ec_data_out(self) -> crate::common::Reg<regs::EcDataOut, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0102usize) as _) }
        }
        #[doc = "EC Status Register"]
        #[inline(always)]
        pub const fn ec_sts(self) -> crate::common::Reg<regs::EcSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0103usize) as _) }
        }
        #[doc = "EC BAL Register"]
        #[inline(always)]
        pub const fn ec_bal(self) -> crate::common::Reg<regs::EcBal, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "EC BAH Register."]
        #[inline(always)]
        pub const fn ec_bah(self) -> crate::common::Reg<regs::EcBah, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0105usize) as _) }
        }
        #[doc = "EC Interrupt Enable Register"]
        #[inline(always)]
        pub const fn ec_ien(self) -> crate::common::Reg<regs::EcIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "EC Interrupt Status Register"]
        #[inline(always)]
        pub const fn ec_ists(self) -> crate::common::Reg<regs::EcIsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Timeout Counter Register."]
        #[inline(always)]
        pub const fn ec_tmout_cntr(self) -> crate::common::Reg<regs::EcTmoutCntr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Block Configuration Register"]
        #[inline(always)]
        pub const fn ec_blk_cfg(self) -> crate::common::Reg<regs::EcBlkCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "SPI Clock Generator Register."]
        #[inline(always)]
        pub const fn ec_spi_clk_gen(self) -> crate::common::Reg<regs::EcSpiClkGen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "SPI Control Register"]
        #[inline(always)]
        pub const fn ec_spi_ctrl(self) -> crate::common::Reg<regs::EcSpiCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
        #[doc = "SPI Clock Control Register"]
        #[inline(always)]
        pub const fn ec_spi_clk_ctrl(self) -> crate::common::Reg<regs::EcSpiClkCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "SPI Enable Register"]
        #[inline(always)]
        pub const fn ec_spi_en(self) -> crate::common::Reg<regs::EcSpiEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "EC AIXH Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcAixh(pub u8);
        impl EcAixh {
            #[doc = "Most significant two bits of the 10-bit index from the EC interface."]
            #[inline(always)]
            pub const fn ec_ind_hi(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "Most significant two bits of the 10-bit index from the EC interface."]
            #[inline(always)]
            pub fn set_ec_ind_hi(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "0: Atomic access mode. EC cycles to Data register will be blocked until current LPC request is serviced 1: Synchronous mode: EC polls the EC Status Register after issuing a command. When EC-IF Busy bit is cleared, write data has been latched by the external IC or read data has been fetched into the EC Data In Register."]
            #[inline(always)]
            pub const fn ec_access_mode(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "0: Atomic access mode. EC cycles to Data register will be blocked until current LPC request is serviced 1: Synchronous mode: EC polls the EC Status Register after issuing a command. When EC-IF Busy bit is cleared, write data has been latched by the external IC or read data has been fetched into the EC Data In Register."]
            #[inline(always)]
            pub fn set_ec_access_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for EcAixh {
            #[inline(always)]
            fn default() -> EcAixh {
                EcAixh(0)
            }
        }
        impl core::fmt::Debug for EcAixh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcAixh")
                    .field("ec_ind_hi", &self.ec_ind_hi())
                    .field("ec_access_mode", &self.ec_access_mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcAixh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcAixh {{ ec_ind_hi: {=u8:?}, ec_access_mode: {=bool:?} }}",
                    self.ec_ind_hi(),
                    self.ec_access_mode()
                )
            }
        }
        #[doc = "EC AIXL Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcAixl(pub u8);
        impl EcAixl {
            #[doc = "Low-byte of the 10-bit index from the EC interface."]
            #[inline(always)]
            pub const fn ind_low(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Low-byte of the 10-bit index from the EC interface."]
            #[inline(always)]
            pub fn set_ind_low(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for EcAixl {
            #[inline(always)]
            fn default() -> EcAixl {
                EcAixl(0)
            }
        }
        impl core::fmt::Debug for EcAixl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcAixl").field("ind_low", &self.ind_low()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcAixl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcAixl {{ ind_low: {=u8:?} }}", self.ind_low())
            }
        }
        #[doc = "EC BAH Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcBah(pub u8);
        impl EcBah {
            #[doc = "Nominally, the high-byte of the block's LPC base address. This register is a writable alias of the LPC BAH Register. This register has no function. It is provided for legacy reasons."]
            #[inline(always)]
            pub const fn lpc_bah(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Nominally, the high-byte of the block's LPC base address. This register is a writable alias of the LPC BAH Register. This register has no function. It is provided for legacy reasons."]
            #[inline(always)]
            pub fn set_lpc_bah(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for EcBah {
            #[inline(always)]
            fn default() -> EcBah {
                EcBah(0)
            }
        }
        impl core::fmt::Debug for EcBah {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcBah").field("lpc_bah", &self.lpc_bah()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcBah {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcBah {{ lpc_bah: {=u8:?} }}", self.lpc_bah())
            }
        }
        #[doc = "EC BAL Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcBal(pub u8);
        impl EcBal {
            #[doc = "Nominally, the low-byte of the block's LPC base address. This register is a writable alias of the LPC BAL Register. This register has no function. It is provided for legacy reasons."]
            #[inline(always)]
            pub const fn lpc_bal(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Nominally, the low-byte of the block's LPC base address. This register is a writable alias of the LPC BAL Register. This register has no function. It is provided for legacy reasons."]
            #[inline(always)]
            pub fn set_lpc_bal(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for EcBal {
            #[inline(always)]
            fn default() -> EcBal {
                EcBal(0)
            }
        }
        impl core::fmt::Debug for EcBal {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcBal").field("lpc_bal", &self.lpc_bal()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcBal {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcBal {{ lpc_bal: {=u8:?} }}", self.lpc_bal())
            }
        }
        #[doc = "Block Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcBlkCfg(pub u32);
        impl EcBlkCfg {
            #[doc = "1=Block is operational 0=Block is disabled. Clocks are gated to conserve power and output signals are set to their inactive state. The block must finish all outstanding transactions on both SPI and LPC/EC logical interfaces before it can gate off internal clocks."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Block is operational 0=Block is disabled. Clocks are gated to conserve power and output signals are set to their inactive state. The block must finish all outstanding transactions on both SPI and LPC/EC logical interfaces before it can gate off internal clocks."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Set to 1 to issue a soft reset to the block. Soft reset has similar effect as a hardware power-on reset except that register settings other than status bits remain unchanged. This bit is self-clearing. The interface bus signals after a soft reset are as follows: SPI_CS# is de-asserted high; SPI clock is low; SPI_MOSI is high after POR and retains its bus value when Soft Reset is asserted; SPI_MISO is input."]
            #[inline(always)]
            pub const fn soft_rst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Set to 1 to issue a soft reset to the block. Soft reset has similar effect as a hardware power-on reset except that register settings other than status bits remain unchanged. This bit is self-clearing. The interface bus signals after a soft reset are as follows: SPI_CS# is de-asserted high; SPI clock is low; SPI_MOSI is high after POR and retains its bus value when Soft Reset is asserted; SPI_MISO is input."]
            #[inline(always)]
            pub fn set_soft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for EcBlkCfg {
            #[inline(always)]
            fn default() -> EcBlkCfg {
                EcBlkCfg(0)
            }
        }
        impl core::fmt::Debug for EcBlkCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcBlkCfg")
                    .field("act", &self.act())
                    .field("soft_rst", &self.soft_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcBlkCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcBlkCfg {{ act: {=bool:?}, soft_rst: {=bool:?} }}",
                    self.act(),
                    self.soft_rst()
                )
            }
        }
        #[doc = "EC Data In Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcDataIn(pub u8);
        impl EcDataIn {
            #[doc = "This register contains data read from the external ASIC. This register shares an offset with EC Data Out Register. After a read command is issued, software reads from this register when EC_IF_BUSY='0' and EC_OBF= 1."]
            #[inline(always)]
            pub const fn data(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This register contains data read from the external ASIC. This register shares an offset with EC Data Out Register. After a read command is issued, software reads from this register when EC_IF_BUSY='0' and EC_OBF= 1."]
            #[inline(always)]
            pub fn set_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for EcDataIn {
            #[inline(always)]
            fn default() -> EcDataIn {
                EcDataIn(0)
            }
        }
        impl core::fmt::Debug for EcDataIn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcDataIn").field("data", &self.data()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcDataIn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcDataIn {{ data: {=u8:?} }}", self.data())
            }
        }
        #[doc = "EC Data Out Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcDataOut(pub u8);
        impl EcDataOut {
            #[doc = "This register contains write data targeting the external ASIC. This register shares an offset with EC Data In Register. Writes to this register are ignored while EC_IF_BUSY is 1, i.e., until write data has been transferred to the external IC over SPI."]
            #[inline(always)]
            pub const fn ec_data_out(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This register contains write data targeting the external ASIC. This register shares an offset with EC Data In Register. Writes to this register are ignored while EC_IF_BUSY is 1, i.e., until write data has been transferred to the external IC over SPI."]
            #[inline(always)]
            pub fn set_ec_data_out(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for EcDataOut {
            #[inline(always)]
            fn default() -> EcDataOut {
                EcDataOut(0)
            }
        }
        impl core::fmt::Debug for EcDataOut {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcDataOut")
                    .field("ec_data_out", &self.ec_data_out())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcDataOut {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcDataOut {{ ec_data_out: {=u8:?} }}", self.ec_data_out())
            }
        }
        #[doc = "EC Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcIen(pub u32);
        impl EcIen {
            #[doc = "EC Command Done Interrupt Enable. 1=Enable interrupt when the transaction to the external IC is complete (when the status bit EC_CMD_DONE is 1) 0=Command Done interrupts disabled."]
            #[inline(always)]
            pub const fn ec_cmddone_ie(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "EC Command Done Interrupt Enable. 1=Enable interrupt when the transaction to the external IC is complete (when the status bit EC_CMD_DONE is 1) 0=Command Done interrupts disabled."]
            #[inline(always)]
            pub fn set_ec_cmddone_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Read Done Interrupt Enable. 1=Enable interrupt when read data from the external IC is available for the EC (when the status bit EC_RD_DONE is 1) 0=Read Done interrupts disabled"]
            #[inline(always)]
            pub const fn rd_done_ie(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Read Done Interrupt Enable. 1=Enable interrupt when read data from the external IC is available for the EC (when the status bit EC_RD_DONE is 1) 0=Read Done interrupts disabled"]
            #[inline(always)]
            pub fn set_rd_done_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Write Done Interrupt Enable. 1=Enable interrupt when transfer of write data to the external IC is complete (when the status bit EC_WR_DONE is 1) 0=Write Done interrupts disabled."]
            #[inline(always)]
            pub const fn wr_done_ie(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Write Done Interrupt Enable. 1=Enable interrupt when transfer of write data to the external IC is complete (when the status bit EC_WR_DONE is 1) 0=Write Done interrupts disabled."]
            #[inline(always)]
            pub fn set_wr_done_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Timeout Interrupt Enable. 1=Enable interrupt when Timeout Counter expires 0=Timeout interrupts disabled."]
            #[inline(always)]
            pub const fn timeout_ie(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Interrupt Enable. 1=Enable interrupt when Timeout Counter expires 0=Timeout interrupts disabled."]
            #[inline(always)]
            pub fn set_timeout_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for EcIen {
            #[inline(always)]
            fn default() -> EcIen {
                EcIen(0)
            }
        }
        impl core::fmt::Debug for EcIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcIen")
                    .field("ec_cmddone_ie", &self.ec_cmddone_ie())
                    .field("rd_done_ie", &self.rd_done_ie())
                    .field("wr_done_ie", &self.wr_done_ie())
                    .field("timeout_ie", &self.timeout_ie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcIen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcIen {{ ec_cmddone_ie: {=bool:?}, rd_done_ie: {=bool:?}, wr_done_ie: {=bool:?}, timeout_ie: {=bool:?} }}" , self . ec_cmddone_ie () , self . rd_done_ie () , self . wr_done_ie () , self . timeout_ie ())
            }
        }
        #[doc = "EC Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcIsts(pub u32);
        impl EcIsts {
            #[doc = "EC Command Done Status. This bit is set to 1 when the SPI transfer to service an EC command to the external IC, either read or write, has completed. This bit is cleared when written with a 1. Writes of a 0 have no effect."]
            #[inline(always)]
            pub const fn cmd_done(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "EC Command Done Status. This bit is set to 1 when the SPI transfer to service an EC command to the external IC, either read or write, has completed. This bit is cleared when written with a 1. Writes of a 0 have no effect."]
            #[inline(always)]
            pub fn set_cmd_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Read Done Status.This bit is set to 1 when the external IC returns data to the EC as a result of an EC read command. This bit is cleared when written with a 1. Writes of a 0 have no effect."]
            #[inline(always)]
            pub const fn rd_done(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Read Done Status.This bit is set to 1 when the external IC returns data to the EC as a result of an EC read command. This bit is cleared when written with a 1. Writes of a 0 have no effect."]
            #[inline(always)]
            pub fn set_rd_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Write Done Status.This bit is set to 1 when EC write data has been transfered to the external IC (when EC_IF_BUSY is cleared). This bit is cleared when written with a 1. Writes of a 0 have no effect."]
            #[inline(always)]
            pub const fn wr_done(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Write Done Status.This bit is set to 1 when EC write data has been transfered to the external IC (when EC_IF_BUSY is cleared). This bit is cleared when written with a 1. Writes of a 0 have no effect."]
            #[inline(always)]
            pub fn set_wr_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Locked Timeout. This bit is set to 1 when the Timeout Counter Register counts down to 0, indicating the Auxiliary Serial Interface is reset due to a time-out event. Although this bit is cleared to 0 on a Soft Reset that is generated by a write to the SOFT_RESET bit, it is not cleared if the Soft Reset is generated by a time-out event. This bit is cleared when written with a 1. Writes of a 0 have no effect."]
            #[inline(always)]
            pub const fn locked_to(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Locked Timeout. This bit is set to 1 when the Timeout Counter Register counts down to 0, indicating the Auxiliary Serial Interface is reset due to a time-out event. Although this bit is cleared to 0 on a Soft Reset that is generated by a write to the SOFT_RESET bit, it is not cleared if the Soft Reset is generated by a time-out event. This bit is cleared when written with a 1. Writes of a 0 have no effect."]
            #[inline(always)]
            pub fn set_locked_to(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for EcIsts {
            #[inline(always)]
            fn default() -> EcIsts {
                EcIsts(0)
            }
        }
        impl core::fmt::Debug for EcIsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcIsts")
                    .field("cmd_done", &self.cmd_done())
                    .field("rd_done", &self.rd_done())
                    .field("wr_done", &self.wr_done())
                    .field("locked_to", &self.locked_to())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcIsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcIsts {{ cmd_done: {=bool:?}, rd_done: {=bool:?}, wr_done: {=bool:?}, locked_to: {=bool:?} }}",
                    self.cmd_done(),
                    self.rd_done(),
                    self.wr_done(),
                    self.locked_to()
                )
            }
        }
        #[doc = "SPI Clock Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcSpiClkCtrl(pub u32);
        impl EcSpiClkCtrl {
            #[doc = "Transmit Clock Phase, the SPCLK edge on which the master will clock data out. The transmit clock phase is not affected by the SPI Clock Polarity. 1=Valid data is clocked out on the first SPI_CLK edge on SPDOUT signal. The slave device should sample this data on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is clocked out on the SPDOUT signal prior to the first SPI_CLK edge. The slave device should sample this data on the first and following odd SPI_CLK edges (i.e., sample data on rising edge)."]
            #[inline(always)]
            pub const fn tclkph(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit Clock Phase, the SPCLK edge on which the master will clock data out. The transmit clock phase is not affected by the SPI Clock Polarity. 1=Valid data is clocked out on the first SPI_CLK edge on SPDOUT signal. The slave device should sample this data on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is clocked out on the SPDOUT signal prior to the first SPI_CLK edge. The slave device should sample this data on the first and following odd SPI_CLK edges (i.e., sample data on rising edge)."]
            #[inline(always)]
            pub fn set_tclkph(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Receive Clock Phase, the SPI_CLK edge on which the master will sample data. The receive clock phase is not affected by the SPI Clock Polarity. 1=Valid data on SPDIN signal is expected after the first SPI_CLK edge. This data is sampled on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is expected on the SPDIN signal on the first SPI_CLK edge. This data is sampled on the first and following odd SPI_CLK edges (i.e., sample data on rising edge)"]
            #[inline(always)]
            pub const fn rclkph(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Receive Clock Phase, the SPI_CLK edge on which the master will sample data. The receive clock phase is not affected by the SPI Clock Polarity. 1=Valid data on SPDIN signal is expected after the first SPI_CLK edge. This data is sampled on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is expected on the SPDIN signal on the first SPI_CLK edge. This data is sampled on the first and following odd SPI_CLK edges (i.e., sample data on rising edge)"]
            #[inline(always)]
            pub fn set_rclkph(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "SPI Clock Polarity. 1=The SPI_CLK signal is high when the interface is idle and the first clock edge is a falling edge 0=The SPI_CLK is low when the interface is idle and the first clock edge is a rising edge."]
            #[inline(always)]
            pub const fn clkpol(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Clock Polarity. 1=The SPI_CLK signal is high when the interface is idle and the first clock edge is a falling edge 0=The SPI_CLK is low when the interface is idle and the first clock edge is a rising edge."]
            #[inline(always)]
            pub fn set_clkpol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Clock Source for the SPI Clock Generator. This bit should not be changed during a SPI transaction. When the field PRELOAD in the SPI Clock Generator Register is 0, this bit is ignored and the Clock Source is always the main system clock (the equivalent of setting this bit to 0). 1=2MHz; 0=48MHz."]
            #[inline(always)]
            pub const fn clksrc(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Clock Source for the SPI Clock Generator. This bit should not be changed during a SPI transaction. When the field PRELOAD in the SPI Clock Generator Register is 0, this bit is ignored and the Clock Source is always the main system clock (the equivalent of setting this bit to 0). 1=2MHz; 0=48MHz."]
            #[inline(always)]
            pub fn set_clksrc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit must remain at 1, its reset default, for correct operation."]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit must remain at 1, its reset default, for correct operation."]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for EcSpiClkCtrl {
            #[inline(always)]
            fn default() -> EcSpiClkCtrl {
                EcSpiClkCtrl(0)
            }
        }
        impl core::fmt::Debug for EcSpiClkCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcSpiClkCtrl")
                    .field("tclkph", &self.tclkph())
                    .field("rclkph", &self.rclkph())
                    .field("clkpol", &self.clkpol())
                    .field("clksrc", &self.clksrc())
                    .field("test", &self.test())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcSpiClkCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcSpiClkCtrl {{ tclkph: {=bool:?}, rclkph: {=bool:?}, clkpol: {=bool:?}, clksrc: {=bool:?}, test: {=bool:?} }}" , self . tclkph () , self . rclkph () , self . clkpol () , self . clksrc () , self . test ())
            }
        }
        #[doc = "SPI Clock Generator Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcSpiClkGen(pub u32);
        impl EcSpiClkGen {
            #[doc = "SPI Clock Generator Preload value."]
            #[inline(always)]
            pub const fn preld(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "SPI Clock Generator Preload value."]
            #[inline(always)]
            pub fn set_preld(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for EcSpiClkGen {
            #[inline(always)]
            fn default() -> EcSpiClkGen {
                EcSpiClkGen(0)
            }
        }
        impl core::fmt::Debug for EcSpiClkGen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcSpiClkGen").field("preld", &self.preld()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcSpiClkGen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcSpiClkGen {{ preld: {=u8:?} }}", self.preld())
            }
        }
        #[doc = "SPI Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcSpiCtrl(pub u32);
        impl EcSpiCtrl {
            #[doc = "Least Significant Bit First. 1= The data is transferred in LSB-first order. 0= The data is transferred in MSB-first order. (default)."]
            #[inline(always)]
            pub const fn lsbf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Least Significant Bit First. 1= The data is transferred in LSB-first order. 0= The data is transferred in MSB-first order. (default)."]
            #[inline(always)]
            pub fn set_lsbf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Bidirectional Output Enable control. When the SPI is configured for Half Duplex mode or Dual Mode the SPDOUT pin operates as a bidirectional signal. The BIOEN bit is used by the internal DIRECTION bit to control the direction of the SPDOUT buffers. The direction of the buffer is never changed while a byte is being transmitted. 1=The SPDOUT_Direction signal configures the SPDOUT signal as an output. 0=The SPDOUT_Direction signal configures the SPDOUT signal as an input. If the SPIMODE bit is configured for Full Duplex mode the BIOEN bit must be set to 1 to configure the SPI_MOSI signal as an output. Although the design supports back-to-back transmissions even when the direction of the buffer is changed, it is the software's responsibility to avoid collisions on the SPI_MOSI signal. The design has been implemented to support a 0 second (max) turnaround (TAR) time. If TAR greater than zero is required, the software must wait for the transmission in one direction to complete before writing the TX_DATA register to start sending/receiving in the opposite direction."]
            #[inline(always)]
            pub const fn bioen(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Bidirectional Output Enable control. When the SPI is configured for Half Duplex mode or Dual Mode the SPDOUT pin operates as a bidirectional signal. The BIOEN bit is used by the internal DIRECTION bit to control the direction of the SPDOUT buffers. The direction of the buffer is never changed while a byte is being transmitted. 1=The SPDOUT_Direction signal configures the SPDOUT signal as an output. 0=The SPDOUT_Direction signal configures the SPDOUT signal as an input. If the SPIMODE bit is configured for Full Duplex mode the BIOEN bit must be set to 1 to configure the SPI_MOSI signal as an output. Although the design supports back-to-back transmissions even when the direction of the buffer is changed, it is the software's responsibility to avoid collisions on the SPI_MOSI signal. The design has been implemented to support a 0 second (max) turnaround (TAR) time. If TAR greater than zero is required, the software must wait for the transmission in one direction to complete before writing the TX_DATA register to start sending/receiving in the opposite direction."]
            #[inline(always)]
            pub fn set_bioen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The SPDIN Select which SPI input signals are enabled when the BIOEN bit is configured as an input. 1xb=SPDIN1 and SPDIN2. Select this option for Dual Mode 01b=SPDIN2 only. Select this option for Half Duplex 00b=SPDIN1 only. Select this option for Full Duplex."]
            #[inline(always)]
            pub const fn spdin_sel(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "The SPDIN Select which SPI input signals are enabled when the BIOEN bit is configured as an input. 1xb=SPDIN1 and SPDIN2. Select this option for Dual Mode 01b=SPDIN2 only. Select this option for Half Duplex 00b=SPDIN1 only. Select this option for Full Duplex."]
            #[inline(always)]
            pub fn set_spdin_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
        }
        impl Default for EcSpiCtrl {
            #[inline(always)]
            fn default() -> EcSpiCtrl {
                EcSpiCtrl(0)
            }
        }
        impl core::fmt::Debug for EcSpiCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcSpiCtrl")
                    .field("lsbf", &self.lsbf())
                    .field("bioen", &self.bioen())
                    .field("spdin_sel", &self.spdin_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcSpiCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcSpiCtrl {{ lsbf: {=bool:?}, bioen: {=bool:?}, spdin_sel: {=u8:?} }}",
                    self.lsbf(),
                    self.bioen(),
                    self.spdin_sel()
                )
            }
        }
        #[doc = "SPI Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcSpiEn(pub u32);
        impl EcSpiEn {
            #[doc = "SPI Receive transfer enable. 1=SPI read transfer is enabled 0=SPI read transfer is disabled. Read commands received at the LPC and EC interfaces will not result in SPI transfers to IC, i.e., address is not shifted out and read data not shifted in."]
            #[inline(always)]
            pub const fn rxen(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Receive transfer enable. 1=SPI read transfer is enabled 0=SPI read transfer is disabled. Read commands received at the LPC and EC interfaces will not result in SPI transfers to IC, i.e., address is not shifted out and read data not shifted in."]
            #[inline(always)]
            pub fn set_rxen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SPI Transmit transfer enable. 1=SPI write transfer is enabled 0=SPI write transfer is disabled. Write commands received at the LPC and EC interfaces will not result in SPI transfers to IC, i.e., address and write data are not shifted out."]
            #[inline(always)]
            pub const fn txen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Transmit transfer enable. 1=SPI write transfer is enabled 0=SPI write transfer is disabled. Write commands received at the LPC and EC interfaces will not result in SPI transfers to IC, i.e., address and write data are not shifted out."]
            #[inline(always)]
            pub fn set_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Receive Busy. 1=Set when a SPI read transfer to external IC is started. Cleared when the transfer is completed 0=Receive channel idle."]
            #[inline(always)]
            pub const fn rxbusy(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Receive Busy. 1=Set when a SPI read transfer to external IC is started. Cleared when the transfer is completed 0=Receive channel idle."]
            #[inline(always)]
            pub fn set_rxbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit Busy. 1=Set when a SPI write transfer to external IC is started. Cleared when the transfer is completed 0=Transmit channel idle."]
            #[inline(always)]
            pub const fn txbusy(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit Busy. 1=Set when a SPI write transfer to external IC is started. Cleared when the transfer is completed 0=Transmit channel idle."]
            #[inline(always)]
            pub fn set_txbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for EcSpiEn {
            #[inline(always)]
            fn default() -> EcSpiEn {
                EcSpiEn(0)
            }
        }
        impl core::fmt::Debug for EcSpiEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcSpiEn")
                    .field("rxen", &self.rxen())
                    .field("txen", &self.txen())
                    .field("rxbusy", &self.rxbusy())
                    .field("txbusy", &self.txbusy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcSpiEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcSpiEn {{ rxen: {=bool:?}, txen: {=bool:?}, rxbusy: {=bool:?}, txbusy: {=bool:?} }}",
                    self.rxen(),
                    self.txen(),
                    self.rxbusy(),
                    self.txbusy()
                )
            }
        }
        #[doc = "EC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcSts(pub u8);
        impl EcSts {
            #[doc = "This bit is set to 1 when the Host issues a command to the Auxiliary SPI Interface. This bit is cleared to 0 when the corresponding SPI transfer to the external IC is completed. This bit is the same as the LPC_IF_BUSY bit in the LPC Status Register."]
            #[inline(always)]
            pub const fn lpc_if_busy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 when the Host issues a command to the Auxiliary SPI Interface. This bit is cleared to 0 when the corresponding SPI transfer to the external IC is completed. This bit is the same as the LPC_IF_BUSY bit in the LPC Status Register."]
            #[inline(always)]
            pub fn set_lpc_if_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to 1 when the EC issues a command to the Auxiliary SPI Interface. This bit is cleared to 0 when the corresponding SPI transfer to the external IC is completed. This bit is the same as EC_IF_BUSY in the LPC Status Register."]
            #[inline(always)]
            pub const fn ec_if_busy(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 when the EC issues a command to the Auxiliary SPI Interface. This bit is cleared to 0 when the corresponding SPI transfer to the external IC is completed. This bit is the same as EC_IF_BUSY in the LPC Status Register."]
            #[inline(always)]
            pub fn set_ec_if_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "EC Output Buffer Full. This bit is set to 1 after read data from the external IC has been latched into the EC Data In Register. This bit is cleared to 0 after the register has been read."]
            #[inline(always)]
            pub const fn ec_obf(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "EC Output Buffer Full. This bit is set to 1 after read data from the external IC has been latched into the EC Data In Register. This bit is cleared to 0 after the register has been read."]
            #[inline(always)]
            pub fn set_ec_obf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "EC Input Buffer Full. This bit is set to 1 when the EC issues a write command to the Auxiliary SPI Interface. This bit is cleared to 0 after transfer to the external IC has completed."]
            #[inline(always)]
            pub const fn ec_ibf(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "EC Input Buffer Full. This bit is set to 1 when the EC issues a write command to the Auxiliary SPI Interface. This bit is cleared to 0 after transfer to the external IC has completed."]
            #[inline(always)]
            pub fn set_ec_ibf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "EC Transmission Done. This bit is set to 1 when a write transfer to the external IC is completed. It is cleared when it is written with a 0."]
            #[inline(always)]
            pub const fn ec_tx_done(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "EC Transmission Done. This bit is set to 1 when a write transfer to the external IC is completed. It is cleared when it is written with a 0."]
            #[inline(always)]
            pub fn set_ec_tx_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for EcSts {
            #[inline(always)]
            fn default() -> EcSts {
                EcSts(0)
            }
        }
        impl core::fmt::Debug for EcSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcSts")
                    .field("lpc_if_busy", &self.lpc_if_busy())
                    .field("ec_if_busy", &self.ec_if_busy())
                    .field("ec_obf", &self.ec_obf())
                    .field("ec_ibf", &self.ec_ibf())
                    .field("ec_tx_done", &self.ec_tx_done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcSts {{ lpc_if_busy: {=bool:?}, ec_if_busy: {=bool:?}, ec_obf: {=bool:?}, ec_ibf: {=bool:?}, ec_tx_done: {=bool:?} }}" , self . lpc_if_busy () , self . ec_if_busy () , self . ec_obf () , self . ec_ibf () , self . ec_tx_done ())
            }
        }
        #[doc = "Timeout Counter Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcTmoutCntr(pub u32);
        impl EcTmoutCntr {
            #[doc = "Timeout period in number of 100KHz cycles -1. Reads return the current count value."]
            #[inline(always)]
            pub const fn timeout_cnt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Timeout period in number of 100KHz cycles -1. Reads return the current count value."]
            #[inline(always)]
            pub fn set_timeout_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for EcTmoutCntr {
            #[inline(always)]
            fn default() -> EcTmoutCntr {
                EcTmoutCntr(0)
            }
        }
        impl core::fmt::Debug for EcTmoutCntr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcTmoutCntr")
                    .field("timeout_cnt", &self.timeout_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcTmoutCntr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcTmoutCntr {{ timeout_cnt: {=u8:?} }}", self.timeout_cnt())
            }
        }
        #[doc = "LPC AIXH Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostAixh(pub u8);
        impl HostAixh {
            #[doc = "Most significant two bits of the 10-bit index from the LPC interface."]
            #[inline(always)]
            pub const fn lpc_ind_hi(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "Most significant two bits of the 10-bit index from the LPC interface."]
            #[inline(always)]
            pub fn set_lpc_ind_hi(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "1=Synchronous mode: the host would poll the LPC Status Register after issuing a command. When the LPC_IF_BUSY bit is cleared, write data has been latched by the external IC or read data has been fetched into the LPC Data In Register. 0=Atomic access mode. LPC cycles to Data register will be blocked until current LPC request is serviced."]
            #[inline(always)]
            pub const fn lpc_access_mode(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "1=Synchronous mode: the host would poll the LPC Status Register after issuing a command. When the LPC_IF_BUSY bit is cleared, write data has been latched by the external IC or read data has been fetched into the LPC Data In Register. 0=Atomic access mode. LPC cycles to Data register will be blocked until current LPC request is serviced."]
            #[inline(always)]
            pub fn set_lpc_access_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for HostAixh {
            #[inline(always)]
            fn default() -> HostAixh {
                HostAixh(0)
            }
        }
        impl core::fmt::Debug for HostAixh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostAixh")
                    .field("lpc_ind_hi", &self.lpc_ind_hi())
                    .field("lpc_access_mode", &self.lpc_access_mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostAixh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "HostAixh {{ lpc_ind_hi: {=u8:?}, lpc_access_mode: {=bool:?} }}",
                    self.lpc_ind_hi(),
                    self.lpc_access_mode()
                )
            }
        }
        #[doc = "LPC AIXL Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostAixl(pub u8);
        impl HostAixl {
            #[doc = "Low-byte of the 10-bit index from the LPC interface."]
            #[inline(always)]
            pub const fn lpc_ind_low(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Low-byte of the 10-bit index from the LPC interface."]
            #[inline(always)]
            pub fn set_lpc_ind_low(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for HostAixl {
            #[inline(always)]
            fn default() -> HostAixl {
                HostAixl(0)
            }
        }
        impl core::fmt::Debug for HostAixl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostAixl")
                    .field("lpc_ind_low", &self.lpc_ind_low())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostAixl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HostAixl {{ lpc_ind_low: {=u8:?} }}", self.lpc_ind_low())
            }
        }
        #[doc = "LPC BAH Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostBah(pub u8);
        impl HostBah {
            #[doc = "Nominally, the high-byte of the block's LPC base address. This register has no function. It is provided for legacy reasons."]
            #[inline(always)]
            pub const fn lpc_bah(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Nominally, the high-byte of the block's LPC base address. This register has no function. It is provided for legacy reasons."]
            #[inline(always)]
            pub fn set_lpc_bah(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for HostBah {
            #[inline(always)]
            fn default() -> HostBah {
                HostBah(0)
            }
        }
        impl core::fmt::Debug for HostBah {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostBah").field("lpc_bah", &self.lpc_bah()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostBah {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HostBah {{ lpc_bah: {=u8:?} }}", self.lpc_bah())
            }
        }
        #[doc = "LPC BAL Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostBal(pub u8);
        impl HostBal {
            #[doc = "Nominally, the low-byte of the block's LPC base address. This register has no function. It is provided for legacy reasons."]
            #[inline(always)]
            pub const fn lpc_bal(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Nominally, the low-byte of the block's LPC base address. This register has no function. It is provided for legacy reasons."]
            #[inline(always)]
            pub fn set_lpc_bal(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for HostBal {
            #[inline(always)]
            fn default() -> HostBal {
                HostBal(0)
            }
        }
        impl core::fmt::Debug for HostBal {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostBal").field("lpc_bal", &self.lpc_bal()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostBal {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HostBal {{ lpc_bal: {=u8:?} }}", self.lpc_bal())
            }
        }
        #[doc = "LPC Data In Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostDataIn(pub u8);
        impl HostDataIn {
            #[doc = "This register contains data read from the external ASIC. This register shares an offset with LPC Data Out Register. After a read command is issued, software reads from this register when LPC_IF_BUSY='0' and LPC_OBF= 1."]
            #[inline(always)]
            pub const fn lpc_data_in(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This register contains data read from the external ASIC. This register shares an offset with LPC Data Out Register. After a read command is issued, software reads from this register when LPC_IF_BUSY='0' and LPC_OBF= 1."]
            #[inline(always)]
            pub fn set_lpc_data_in(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for HostDataIn {
            #[inline(always)]
            fn default() -> HostDataIn {
                HostDataIn(0)
            }
        }
        impl core::fmt::Debug for HostDataIn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostDataIn")
                    .field("lpc_data_in", &self.lpc_data_in())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostDataIn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HostDataIn {{ lpc_data_in: {=u8:?} }}", self.lpc_data_in())
            }
        }
        #[doc = "LPC Data Out Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostDataOut(pub u8);
        impl HostDataOut {
            #[doc = "This register contains write data targeting the external ASIC. This register shares an offset with LPC Data In Register. Writes to this register are ignored while LPC_IF_BUSY is 1, i.e., until write data has been transferred to the external IC over SPI."]
            #[inline(always)]
            pub const fn lpc_data_out(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This register contains write data targeting the external ASIC. This register shares an offset with LPC Data In Register. Writes to this register are ignored while LPC_IF_BUSY is 1, i.e., until write data has been transferred to the external IC over SPI."]
            #[inline(always)]
            pub fn set_lpc_data_out(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for HostDataOut {
            #[inline(always)]
            fn default() -> HostDataOut {
                HostDataOut(0)
            }
        }
        impl core::fmt::Debug for HostDataOut {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostDataOut")
                    .field("lpc_data_out", &self.lpc_data_out())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostDataOut {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HostDataOut {{ lpc_data_out: {=u8:?} }}", self.lpc_data_out())
            }
        }
        #[doc = "LPC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostSts(pub u8);
        impl HostSts {
            #[doc = "EC Interface Busy. Set to 1 when the EC issues a read or write to the EC_DAT Register. Set to 0 when the SPI transfer to the external ASIC that is triggered by the EC register access is completed. This is the same bit as EC_IF_BUSY in the EC Status Register."]
            #[inline(always)]
            pub const fn ec_if_busy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "EC Interface Busy. Set to 1 when the EC issues a read or write to the EC_DAT Register. Set to 0 when the SPI transfer to the external ASIC that is triggered by the EC register access is completed. This is the same bit as EC_IF_BUSY in the EC Status Register."]
            #[inline(always)]
            pub fn set_ec_if_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "LPC Interface Busy, also known as Host Command in Progress. The bit is set to 1 when the Host issues a command to the LPC interface, by either reading from the LPC Data In Register or writing to the LPC Data Out Register. The bit is cleared to 0 when the corresponding SPI transfer to the external IC is completed. This is the same bit as LPC_IF_BUSY in the EC Status Register."]
            #[inline(always)]
            pub const fn lpc_if_busy(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "LPC Interface Busy, also known as Host Command in Progress. The bit is set to 1 when the Host issues a command to the LPC interface, by either reading from the LPC Data In Register or writing to the LPC Data Out Register. The bit is cleared to 0 when the corresponding SPI transfer to the external IC is completed. This is the same bit as LPC_IF_BUSY in the EC Status Register."]
            #[inline(always)]
            pub fn set_lpc_if_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "LPC Output Buffer Full. This bit is set to 1 after read data from the external IC has been latched into the LPC Data In Register. Cleared after the ASIF returns read data to the host. This register is aliased to EC-Only Register."]
            #[inline(always)]
            pub const fn lpc_obf(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "LPC Output Buffer Full. This bit is set to 1 after read data from the external IC has been latched into the LPC Data In Register. Cleared after the ASIF returns read data to the host. This register is aliased to EC-Only Register."]
            #[inline(always)]
            pub fn set_lpc_obf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "LPC Input Buffer Full. This bit is set to 1 after the host issues a write command. The bit is reset to 0 when the SPI write transfer to the external IC has completed."]
            #[inline(always)]
            pub const fn lpc_ibf(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "LPC Input Buffer Full. This bit is set to 1 after the host issues a write command. The bit is reset to 0 when the SPI write transfer to the external IC has completed."]
            #[inline(always)]
            pub fn set_lpc_ibf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
        }
        impl Default for HostSts {
            #[inline(always)]
            fn default() -> HostSts {
                HostSts(0)
            }
        }
        impl core::fmt::Debug for HostSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostSts")
                    .field("ec_if_busy", &self.ec_if_busy())
                    .field("lpc_if_busy", &self.lpc_if_busy())
                    .field("lpc_obf", &self.lpc_obf())
                    .field("lpc_ibf", &self.lpc_ibf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "HostSts {{ ec_if_busy: {=bool:?}, lpc_if_busy: {=bool:?}, lpc_obf: {=bool:?}, lpc_ibf: {=bool:?} }}" , self . ec_if_busy () , self . lpc_if_busy () , self . lpc_obf () , self . lpc_ibf ())
            }
        }
        #[doc = "Scratch 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scratch(pub u8);
        impl Scratch {
            #[doc = "This field has no functionality other than storage. This register is aliased to EC-Only Register."]
            #[inline(always)]
            pub const fn scr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to EC-Only Register."]
            #[inline(always)]
            pub fn set_scr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Scratch {
            #[inline(always)]
            fn default() -> Scratch {
                Scratch(0)
            }
        }
        impl core::fmt::Debug for Scratch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scratch").field("scr", &self.scr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scratch {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Scratch {{ scr: {=u8:?} }}", self.scr())
            }
        }
    }
}
pub mod bc_link0 {
    #[doc = "This block provides BC-Link connectivity to a slave device. The BC-Link protocol includes a start bit to signal the beginning of a message and a turnaround (TAR) period for bus transfer between the Master and Companion devices."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct BcLink0 {
        ptr: *mut u8,
    }
    unsafe impl Send for BcLink0 {}
    unsafe impl Sync for BcLink0 {}
    impl BcLink0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "BC-Link Status"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "BC-Link Address Register \\[7:0\\] Address in the Companion for the BC-Link transaction."]
        #[inline(always)]
        pub const fn addr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "BC-Link Data Register \\[7:0\\] this register hold data used in a BC-Link transaction."]
        #[inline(always)]
        pub const fn data(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "BC-Link Clock Select Register \\[7:0\\] DIVIDER The BC Clock is set to the Master Clock divided by this field, or 48MHz/ (Divider +1). The clock divider bits can only can be changed when the BC Bus is in soft RESET (when either the Reset bit is set by software or when the BUSY bit is set by the interface)."]
        #[inline(always)]
        pub const fn clk_sel(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "BC-Link Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "This bit is asserted to '1' when the BC interface is transferring data and on reset."]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is asserted to '1' when the BC interface is transferring data and on reset."]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is an enable for generating an interrupt when the BUSY bit in this register is cleared by hardware. When this bit is set to '1', the interrupt signal is enabled. When the this bit is cleared to '0', the interrupt is disabled. When enabled, the interrupt occurs after a BC Bus read or write."]
            #[inline(always)]
            pub const fn busy_clr_int_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is an enable for generating an interrupt when the BUSY bit in this register is cleared by hardware. When this bit is set to '1', the interrupt signal is enabled. When the this bit is cleared to '0', the interrupt is disabled. When enabled, the interrupt occurs after a BC Bus read or write."]
            #[inline(always)]
            pub fn set_busy_clr_int_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit is an enable for generating an interrupt when the BC_ERR bit is set by hardware. When this bit is '1', the interrupt signal is enabled. When this bit is '0', the interrupt is disabled."]
            #[inline(always)]
            pub const fn err_int_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is an enable for generating an interrupt when the BC_ERR bit is set by hardware. When this bit is '1', the interrupt signal is enabled. When this bit is '0', the interrupt is disabled."]
            #[inline(always)]
            pub fn set_err_int_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit indicates that a BC Bus Error has occurred. (R/WC)"]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a BC Bus Error has occurred. (R/WC)"]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "When this bit is '1'the BC_Link Master Interface will be placed in reset and be held in reset until this bit is cleared to '0'. Setting RESET to '1' causes the BUSY bit to be set to '1'. The BUSY remains set to '1' until the reset operation of the BC Interface is completed, which takes approximately 48 BC clocks."]
            #[inline(always)]
            pub const fn reset(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1'the BC_Link Master Interface will be placed in reset and be held in reset until this bit is cleared to '0'. Setting RESET to '1' causes the BUSY bit to be set to '1'. The BUSY remains set to '1' until the reset operation of the BC Interface is completed, which takes approximately 48 BC clocks."]
            #[inline(always)]
            pub fn set_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("busy", &self.busy())
                    .field("busy_clr_int_en", &self.busy_clr_int_en())
                    .field("err_int_en", &self.err_int_en())
                    .field("error", &self.error())
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sts {{ busy: {=bool:?}, busy_clr_int_en: {=bool:?}, err_int_en: {=bool:?}, error: {=bool:?}, reset: {=bool:?} }}" , self . busy () , self . busy_clr_int_en () , self . err_int_en () , self . error () , self . reset ())
            }
        }
    }
}
pub mod cache {
    #[doc = "This is the CACHE Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cache {
        ptr: *mut u8,
    }
    unsafe impl Send for Cache {}
    unsafe impl Sync for Cache {}
    impl Cache {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "CACHE MODE register."]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "CSPI Bank. This is ORed into the access address from the processor to create the address sent over to the SPI Flash."]
        #[inline(always)]
        pub const fn spi_bank(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "CACHE TAG VALIDATE register."]
        #[inline(always)]
        pub const fn tag_vldt(self) -> crate::common::Reg<regs::TagVldt, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Tag Force Address. This is the address that will be stored in the Tag Line and accessed over SPI if a Tag Force is issued. This address is still used in conjunction with the Cache SPI Bank.This is meant to be an address from the processors perspective. 4 Byte Boundary aligned"]
        #[inline(always)]
        pub const fn tag_vldt_addr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "CACHE STATUS register"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Hit count Hi. Stores the Hit Count \\[63:32\\] of the Cache"]
        #[inline(always)]
        pub const fn hit_hi(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Hit count low. Stores the Hit Count \\[31:0\\] of the Cache"]
        #[inline(always)]
        pub const fn hit_low(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "Miss count Hi. Stores the Miss Count \\[63:32\\] of the Cache"]
        #[inline(always)]
        pub const fn miss_hi(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "Miss count low. Stores the Miss Count \\[31:0\\] of the Cache"]
        #[inline(always)]
        pub const fn miss_low(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "Fill count Hi. Stores the Fill Count \\[63:32\\] of the Cache"]
        #[inline(always)]
        pub const fn fill_hi(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Fill count low. Stores the Fill Count \\[31:0\\] of the Cache"]
        #[inline(always)]
        pub const fn fill_low(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "Rx Buffer0."]
        #[inline(always)]
        pub const fn rx_buffer(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize + n * 4usize) as _) }
        }
        #[doc = "Tag Lock0. 0: Tag is not Locked. 1: Tag is Locked."]
        #[inline(always)]
        pub const fn tag_lock0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0800usize) as _) }
        }
        #[doc = "Tag Lock1. 0: Tag is not Locked. 1: Tag is Locked."]
        #[inline(always)]
        pub const fn tag_lock1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0804usize) as _) }
        }
        #[doc = "Tag Valid0. Tells Line has valid data in the cache. 0: Line is empty. 1: Line is full."]
        #[inline(always)]
        pub const fn tag_valid0(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c00usize) as _) }
        }
        #[doc = "Tag Valid1. Tells Line has valid data in the cache. 0: Line is empty. 1: Line is full."]
        #[inline(always)]
        pub const fn tag_valid1(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c04usize) as _) }
        }
        #[doc = "Tag Address0."]
        #[inline(always)]
        pub const fn tag_addr(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 64usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1000usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CACHE MODE register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "ACTIVATE 0: Disable block. 1: Enable block."]
            #[inline(always)]
            pub const fn activate(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "ACTIVATE 0: Disable block. 1: Enable block."]
            #[inline(always)]
            pub fn set_activate(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Soft reset the Cache Controller module. This is self clearing bit. Write Only bit"]
            #[inline(always)]
            pub const fn soft_reset(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Soft reset the Cache Controller module. This is self clearing bit. Write Only bit"]
            #[inline(always)]
            pub fn set_soft_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "CACHE SPI Enable. 0: Standard register access. 1: Cache takes over the register interface of eSPI SAF EC"]
            #[inline(always)]
            pub const fn spi_enable(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "CACHE SPI Enable. 0: Standard register access. 1: Cache takes over the register interface of eSPI SAF EC"]
            #[inline(always)]
            pub fn set_spi_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CACHE connection mode. 0: eSPI SAF EC."]
            #[inline(always)]
            pub const fn connect_mode(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "CACHE connection mode. 0: eSPI SAF EC."]
            #[inline(always)]
            pub fn set_connect_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Full line read enable. 0: Critical section, first and early termination enabled. 1: Critical section, first and early termination disabled."]
            #[inline(always)]
            pub const fn full_line_rd_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Full line read enable. 0: Critical section, first and early termination enabled. 1: Critical section, first and early termination disabled."]
            #[inline(always)]
            pub fn set_full_line_rd_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "INVALIDATE all CACHE lines."]
            #[inline(always)]
            pub const fn invalidate_all(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "INVALIDATE all CACHE lines."]
            #[inline(always)]
            pub fn set_invalidate_all(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("activate", &self.activate())
                    .field("soft_reset", &self.soft_reset())
                    .field("spi_enable", &self.spi_enable())
                    .field("connect_mode", &self.connect_mode())
                    .field("full_line_rd_en", &self.full_line_rd_en())
                    .field("invalidate_all", &self.invalidate_all())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mode {{ activate: {=bool:?}, soft_reset: {=bool:?}, spi_enable: {=bool:?}, connect_mode: {=bool:?}, full_line_rd_en: {=bool:?}, invalidate_all: {=bool:?} }}" , self . activate () , self . soft_reset () , self . spi_enable () , self . connect_mode () , self . full_line_rd_en () , self . invalidate_all ())
            }
        }
        #[doc = "CACHE STATUS register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "Validate Done. This bit is set when Validate command has completed."]
            #[inline(always)]
            pub const fn validate_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Validate Done. This bit is set when Validate command has completed."]
            #[inline(always)]
            pub fn set_validate_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Invalidate Done. This bit is set when invalidate command has completed."]
            #[inline(always)]
            pub const fn invalidate_done(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Invalidate Done. This bit is set when invalidate command has completed."]
            #[inline(always)]
            pub fn set_invalidate_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates CACHE Line Fill error from Flash memory"]
            #[inline(always)]
            pub const fn spi_err(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates CACHE Line Fill error from Flash memory"]
            #[inline(always)]
            pub fn set_spi_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("validate_done", &self.validate_done())
                    .field("invalidate_done", &self.invalidate_done())
                    .field("spi_err", &self.spi_err())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sts {{ validate_done: {=bool:?}, invalidate_done: {=bool:?}, spi_err: {=bool:?} }}",
                    self.validate_done(),
                    self.invalidate_done(),
                    self.spi_err()
                )
            }
        }
        #[doc = "CACHE TAG VALIDATE register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TagVldt(pub u32);
        impl TagVldt {
            #[doc = "Tag Force. This bit will allow the cache select a Tag line and allocate the Cache Tag Validate Address to it. 0: No action. 1: A tag line will be allocated"]
            #[inline(always)]
            pub const fn tag_force(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Tag Force. This bit will allow the cache select a Tag line and allocate the Cache Tag Validate Address to it. 0: No action. 1: A tag line will be allocated"]
            #[inline(always)]
            pub fn set_tag_force(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Tag Force Lock. Will lock the cache line. 0: Line will not be locked. 1: Line will be locked."]
            #[inline(always)]
            pub const fn tag_force_lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Tag Force Lock. Will lock the cache line. 0: Line will not be locked. 1: Line will be locked."]
            #[inline(always)]
            pub fn set_tag_force_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Tag Force Fill. Will cause the cache to immediately fill this cache line. 0: Line will not be filled until it is Miss/Fill. 1: Line will auto fill immediately"]
            #[inline(always)]
            pub const fn tag_force_fill(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Tag Force Fill. Will cause the cache to immediately fill this cache line. 0: Line will not be filled until it is Miss/Fill. 1: Line will auto fill immediately"]
            #[inline(always)]
            pub fn set_tag_force_fill(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Tag Force Invalid. Will invalidate the address pointed by Tag Validate Address register. 0: No action. 1: Invalidate address."]
            #[inline(always)]
            pub const fn tag_force_invaliid(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Tag Force Invalid. Will invalidate the address pointed by Tag Validate Address register. 0: No action. 1: Invalidate address."]
            #[inline(always)]
            pub fn set_tag_force_invaliid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for TagVldt {
            #[inline(always)]
            fn default() -> TagVldt {
                TagVldt(0)
            }
        }
        impl core::fmt::Debug for TagVldt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TagVldt")
                    .field("tag_force", &self.tag_force())
                    .field("tag_force_lock", &self.tag_force_lock())
                    .field("tag_force_fill", &self.tag_force_fill())
                    .field("tag_force_invaliid", &self.tag_force_invaliid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TagVldt {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "TagVldt {{ tag_force: {=bool:?}, tag_force_lock: {=bool:?}, tag_force_fill: {=bool:?}, tag_force_invaliid: {=bool:?} }}" , self . tag_force () , self . tag_force_lock () , self . tag_force_fill () , self . tag_force_invaliid ())
            }
        }
    }
}
pub mod cct {
    #[doc = "This is a 16-bit auto-reloading timer/counter."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cct {
        ptr: *mut u8,
    }
    unsafe impl Send for Cct {}
    unsafe impl Sync for Cct {}
    impl Cct {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This register controls the capture and compare timer."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This register is used to configure capture and compare timers 0-3."]
        #[inline(always)]
        pub const fn cap0_ctrl(self) -> crate::common::Reg<regs::Cap0ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This register is used to configure capture and compare timers 4-5."]
        #[inline(always)]
        pub const fn cap1_ctrl(self) -> crate::common::Reg<regs::Cap1ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This register contains the current value of the Free Running Timer."]
        #[inline(always)]
        pub const fn free_run(self) -> crate::common::Reg<regs::FreeRun, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[inline(always)]
        pub const fn cap0(self) -> crate::common::Reg<regs::Cap0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
        #[inline(always)]
        pub const fn cap1(self) -> crate::common::Reg<regs::Cap1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[inline(always)]
        pub const fn cap2(self) -> crate::common::Reg<regs::Cap2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[inline(always)]
        pub const fn cap3(self) -> crate::common::Reg<regs::Cap3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
        #[inline(always)]
        pub const fn cap4(self) -> crate::common::Reg<regs::Cap4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
        #[inline(always)]
        pub const fn cap5(self) -> crate::common::Reg<regs::Cap5, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[inline(always)]
        pub const fn comp0(self) -> crate::common::Reg<regs::Comp0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[inline(always)]
        pub const fn comp1(self) -> crate::common::Reg<regs::Comp1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "This register selects the pin mapping to the capture register."]
        #[inline(always)]
        pub const fn mux_sel(self) -> crate::common::Reg<regs::MuxSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap0(pub u32);
        impl Cap0 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
            #[inline(always)]
            pub const fn cap_0(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
            #[inline(always)]
            pub fn set_cap_0(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap0 {
            #[inline(always)]
            fn default() -> Cap0 {
                Cap0(0)
            }
        }
        impl core::fmt::Debug for Cap0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap0").field("cap_0", &self.cap_0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap0 {{ cap_0: {=u32:?} }}", self.cap_0())
            }
        }
        #[doc = "This register is used to configure capture and compare timers 0-3."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap0ctrl(pub u32);
        impl Cap0ctrl {
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 0."]
            #[inline(always)]
            pub const fn cap_edge0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 0."]
            #[inline(always)]
            pub fn set_cap_edge0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 0, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp0(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 0, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 0."]
            #[inline(always)]
            pub const fn fclk_sel0(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 0."]
            #[inline(always)]
            pub fn set_fclk_sel0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u32) & 0x07) << 5usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 1."]
            #[inline(always)]
            pub const fn cap_edge1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 1."]
            #[inline(always)]
            pub fn set_cap_edge1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 1, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp1(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 1, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 1."]
            #[inline(always)]
            pub const fn fclk_sel1(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 1."]
            #[inline(always)]
            pub fn set_fclk_sel1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val as u32) & 0x07) << 13usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 2."]
            #[inline(always)]
            pub const fn cap_edge2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 2."]
            #[inline(always)]
            pub fn set_cap_edge2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 16usize)) | (((val as u32) & 0x03) << 16usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 2, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 2, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 2."]
            #[inline(always)]
            pub const fn fclk_sel2(&self) -> u8 {
                let val = (self.0 >> 21usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 2."]
            #[inline(always)]
            pub fn set_fclk_sel2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 21usize)) | (((val as u32) & 0x07) << 21usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 3."]
            #[inline(always)]
            pub const fn cap_edge3(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 3."]
            #[inline(always)]
            pub fn set_cap_edge3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 3, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp3(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 3, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 3."]
            #[inline(always)]
            pub const fn fclk_sel3(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 3."]
            #[inline(always)]
            pub fn set_fclk_sel3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
            }
        }
        impl Default for Cap0ctrl {
            #[inline(always)]
            fn default() -> Cap0ctrl {
                Cap0ctrl(0)
            }
        }
        impl core::fmt::Debug for Cap0ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap0ctrl")
                    .field("cap_edge0", &self.cap_edge0())
                    .field("filter_byp0", &self.filter_byp0())
                    .field("fclk_sel0", &self.fclk_sel0())
                    .field("cap_edge1", &self.cap_edge1())
                    .field("filter_byp1", &self.filter_byp1())
                    .field("fclk_sel1", &self.fclk_sel1())
                    .field("cap_edge2", &self.cap_edge2())
                    .field("filter_byp2", &self.filter_byp2())
                    .field("fclk_sel2", &self.fclk_sel2())
                    .field("cap_edge3", &self.cap_edge3())
                    .field("filter_byp3", &self.filter_byp3())
                    .field("fclk_sel3", &self.fclk_sel3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap0ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cap0ctrl {{ cap_edge0: {=u8:?}, filter_byp0: {=bool:?}, fclk_sel0: {=u8:?}, cap_edge1: {=u8:?}, filter_byp1: {=bool:?}, fclk_sel1: {=u8:?}, cap_edge2: {=u8:?}, filter_byp2: {=bool:?}, fclk_sel2: {=u8:?}, cap_edge3: {=u8:?}, filter_byp3: {=bool:?}, fclk_sel3: {=u8:?} }}" , self . cap_edge0 () , self . filter_byp0 () , self . fclk_sel0 () , self . cap_edge1 () , self . filter_byp1 () , self . fclk_sel1 () , self . cap_edge2 () , self . filter_byp2 () , self . fclk_sel2 () , self . cap_edge3 () , self . filter_byp3 () , self . fclk_sel3 ())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap1(pub u32);
        impl Cap1 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
            #[inline(always)]
            pub const fn cap_1(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
            #[inline(always)]
            pub fn set_cap_1(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap1 {
            #[inline(always)]
            fn default() -> Cap1 {
                Cap1(0)
            }
        }
        impl core::fmt::Debug for Cap1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap1").field("cap_1", &self.cap_1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap1 {{ cap_1: {=u32:?} }}", self.cap_1())
            }
        }
        #[doc = "This register is used to configure capture and compare timers 4-5."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap1ctrl(pub u32);
        impl Cap1ctrl {
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 4."]
            #[inline(always)]
            pub const fn cap_edge4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 4."]
            #[inline(always)]
            pub fn set_cap_edge4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 4, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp4(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 4, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 4."]
            #[inline(always)]
            pub const fn fclk_sel4(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 4."]
            #[inline(always)]
            pub fn set_fclk_sel4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u32) & 0x07) << 5usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 5."]
            #[inline(always)]
            pub const fn cap_edge5(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 5."]
            #[inline(always)]
            pub fn set_cap_edge5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 5, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp5(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 5, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 5."]
            #[inline(always)]
            pub const fn fclk_sel5(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 5."]
            #[inline(always)]
            pub fn set_fclk_sel5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val as u32) & 0x07) << 13usize);
            }
        }
        impl Default for Cap1ctrl {
            #[inline(always)]
            fn default() -> Cap1ctrl {
                Cap1ctrl(0)
            }
        }
        impl core::fmt::Debug for Cap1ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap1ctrl")
                    .field("cap_edge4", &self.cap_edge4())
                    .field("filter_byp4", &self.filter_byp4())
                    .field("fclk_sel4", &self.fclk_sel4())
                    .field("cap_edge5", &self.cap_edge5())
                    .field("filter_byp5", &self.filter_byp5())
                    .field("fclk_sel5", &self.fclk_sel5())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap1ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cap1ctrl {{ cap_edge4: {=u8:?}, filter_byp4: {=bool:?}, fclk_sel4: {=u8:?}, cap_edge5: {=u8:?}, filter_byp5: {=bool:?}, fclk_sel5: {=u8:?} }}" , self . cap_edge4 () , self . filter_byp4 () , self . fclk_sel4 () , self . cap_edge5 () , self . filter_byp5 () , self . fclk_sel5 ())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap2(pub u32);
        impl Cap2 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT2."]
            #[inline(always)]
            pub const fn cap_2(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT2."]
            #[inline(always)]
            pub fn set_cap_2(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap2 {
            #[inline(always)]
            fn default() -> Cap2 {
                Cap2(0)
            }
        }
        impl core::fmt::Debug for Cap2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap2").field("cap_2", &self.cap_2()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap2 {{ cap_2: {=u32:?} }}", self.cap_2())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap3(pub u32);
        impl Cap3 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT3."]
            #[inline(always)]
            pub const fn cap_3(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT3."]
            #[inline(always)]
            pub fn set_cap_3(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap3 {
            #[inline(always)]
            fn default() -> Cap3 {
                Cap3(0)
            }
        }
        impl core::fmt::Debug for Cap3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap3").field("cap_3", &self.cap_3()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap3 {{ cap_3: {=u32:?} }}", self.cap_3())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap4(pub u32);
        impl Cap4 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
            #[inline(always)]
            pub const fn cap_4(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
            #[inline(always)]
            pub fn set_cap_4(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap4 {
            #[inline(always)]
            fn default() -> Cap4 {
                Cap4(0)
            }
        }
        impl core::fmt::Debug for Cap4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap4").field("cap_4", &self.cap_4()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap4 {{ cap_4: {=u32:?} }}", self.cap_4())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap5(pub u32);
        impl Cap5 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
            #[inline(always)]
            pub const fn cap_5(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
            #[inline(always)]
            pub fn set_cap_5(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap5 {
            #[inline(always)]
            fn default() -> Cap5 {
                Cap5(0)
            }
        }
        impl core::fmt::Debug for Cap5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap5").field("cap_5", &self.cap_5()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap5 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap5 {{ cap_5: {=u32:?} }}", self.cap_5())
            }
        }
        #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Comp0(pub u32);
        impl Comp0 {
            #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub const fn comp_0(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub fn set_comp_0(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Comp0 {
            #[inline(always)]
            fn default() -> Comp0 {
                Comp0(0)
            }
        }
        impl core::fmt::Debug for Comp0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Comp0").field("comp_0", &self.comp_0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Comp0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Comp0 {{ comp_0: {=u32:?} }}", self.comp_0())
            }
        }
        #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Comp1(pub u32);
        impl Comp1 {
            #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub const fn comp_1(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub fn set_comp_1(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Comp1 {
            #[inline(always)]
            fn default() -> Comp1 {
                Comp1(0)
            }
        }
        impl core::fmt::Debug for Comp1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Comp1").field("comp_1", &self.comp_1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Comp1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Comp1 {{ comp_1: {=u32:?} }}", self.comp_1())
            }
        }
        #[doc = "This register controls the capture and compare timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This bit is used to start the capture and compare timer running and power it down."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to start the capture and compare timer running and power it down."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Free-Running Timer Enable. This bit is used to start and stop the free running timer."]
            #[inline(always)]
            pub const fn free_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Free-Running Timer Enable. This bit is used to start and stop the free running timer."]
            #[inline(always)]
            pub fn set_free_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Free Running Timer Reset. This bit stops the timer and resets the internal counter to 0000_0000h."]
            #[inline(always)]
            pub const fn free_rst(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Free Running Timer Reset. This bit stops the timer and resets the internal counter to 0000_0000h."]
            #[inline(always)]
            pub fn set_free_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This 3-bit field sets the clock source for the Free-Running Counter."]
            #[inline(always)]
            pub const fn tclk(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the Free-Running Counter."]
            #[inline(always)]
            pub fn set_tclk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
            }
            #[doc = "Compare Enable for Compare 0 Register."]
            #[inline(always)]
            pub const fn cmp_en0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Compare Enable for Compare 0 Register."]
            #[inline(always)]
            pub fn set_cmp_en0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Compare Enable for Compare 1 Register."]
            #[inline(always)]
            pub const fn cmp_en1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Compare Enable for Compare 1 Register."]
            #[inline(always)]
            pub fn set_cmp_en1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub const fn cmp_set1(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub fn set_cmp_set1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub const fn cmp_set0(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub fn set_cmp_set0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub const fn cmp_clr1(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub fn set_cmp_clr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub const fn cmp_clr0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub fn set_cmp_clr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("act", &self.act())
                    .field("free_en", &self.free_en())
                    .field("free_rst", &self.free_rst())
                    .field("tclk", &self.tclk())
                    .field("cmp_en0", &self.cmp_en0())
                    .field("cmp_en1", &self.cmp_en1())
                    .field("cmp_set1", &self.cmp_set1())
                    .field("cmp_set0", &self.cmp_set0())
                    .field("cmp_clr1", &self.cmp_clr1())
                    .field("cmp_clr0", &self.cmp_clr0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ act: {=bool:?}, free_en: {=bool:?}, free_rst: {=bool:?}, tclk: {=u8:?}, cmp_en0: {=bool:?}, cmp_en1: {=bool:?}, cmp_set1: {=bool:?}, cmp_set0: {=bool:?}, cmp_clr1: {=bool:?}, cmp_clr0: {=bool:?} }}" , self . act () , self . free_en () , self . free_rst () , self . tclk () , self . cmp_en0 () , self . cmp_en1 () , self . cmp_set1 () , self . cmp_set0 () , self . cmp_clr1 () , self . cmp_clr0 ())
            }
        }
        #[doc = "This register contains the current value of the Free Running Timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FreeRun(pub u32);
        impl FreeRun {
            #[doc = "This register contains the current value of the Free Running Timer."]
            #[inline(always)]
            pub const fn tmr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register contains the current value of the Free Running Timer."]
            #[inline(always)]
            pub fn set_tmr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FreeRun {
            #[inline(always)]
            fn default() -> FreeRun {
                FreeRun(0)
            }
        }
        impl core::fmt::Debug for FreeRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FreeRun").field("tmr", &self.tmr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FreeRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FreeRun {{ tmr: {=u32:?} }}", self.tmr())
            }
        }
        #[doc = "This register selects the pin mapping to the capture register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MuxSel(pub u32);
        impl MuxSel {
            #[doc = "Mux Select for Capture 0 register."]
            #[inline(always)]
            pub const fn cap0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 0 register."]
            #[inline(always)]
            pub fn set_cap0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Mux Select for Capture 1 register."]
            #[inline(always)]
            pub const fn cap1(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 1 register."]
            #[inline(always)]
            pub fn set_cap1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Mux Select for Capture 2 register."]
            #[inline(always)]
            pub const fn cap2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 2 register."]
            #[inline(always)]
            pub fn set_cap2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Mux Select for Capture 3 register."]
            #[inline(always)]
            pub const fn cap3(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 3 register."]
            #[inline(always)]
            pub fn set_cap3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "Mux Select for Capture 4 register."]
            #[inline(always)]
            pub const fn cap4(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 4 register."]
            #[inline(always)]
            pub fn set_cap4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Mux Select for Capture 5 register."]
            #[inline(always)]
            pub const fn cap5(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 5 register."]
            #[inline(always)]
            pub fn set_cap5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
        }
        impl Default for MuxSel {
            #[inline(always)]
            fn default() -> MuxSel {
                MuxSel(0)
            }
        }
        impl core::fmt::Debug for MuxSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MuxSel")
                    .field("cap0", &self.cap0())
                    .field("cap1", &self.cap1())
                    .field("cap2", &self.cap2())
                    .field("cap3", &self.cap3())
                    .field("cap4", &self.cap4())
                    .field("cap5", &self.cap5())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MuxSel {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MuxSel {{ cap0: {=u8:?}, cap1: {=u8:?}, cap2: {=u8:?}, cap3: {=u8:?}, cap4: {=u8:?}, cap5: {=u8:?} }}" , self . cap0 () , self . cap1 () , self . cap2 () , self . cap3 () , self . cap4 () , self . cap5 ())
            }
        }
    }
}
pub mod cntr_tmr0 {
    #[doc = "This interface is a 16-bit auto-reloading timer/counter."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CntrTmr0 {
        ptr: *mut u8,
    }
    unsafe impl Send for CntrTmr0 {}
    unsafe impl Sync for CntrTmr0 {}
    impl CntrTmr0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This bit reflects the current state of the timer's Clock_Required output signal."]
        #[inline(always)]
        pub const fn timerx_control(self) -> crate::common::Reg<regs::TimerxControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the Timer Clock and Event Control Register."]
        #[inline(always)]
        pub const fn clk_evnt_ctrl(self) -> crate::common::Reg<regs::ClkEvntCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This register is used in Timer and One-Shot modes to set the lower limit of the timer."]
        #[inline(always)]
        pub const fn timerx_reload(self) -> crate::common::Reg<regs::TimerxReload, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This register returns the current value of the timer in all modes."]
        #[inline(always)]
        pub const fn timerx_count(self) -> crate::common::Reg<regs::TimerxCount, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This is the Timer Clock and Event Control Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkEvntCtrl(pub u32);
        impl ClkEvntCtrl {
            #[doc = "Timer Clock Select. This field determines the clock source for the 16-bit counter in the timer."]
            #[inline(always)]
            pub const fn tclk(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Timer Clock Select. This field determines the clock source for the 16-bit counter in the timer."]
            #[inline(always)]
            pub fn set_tclk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "This field selects which edge of the TINx input signal affects the timer in Event Mode, One-Shot Mode and Measurement Mode. Event Mode: 11b=No event selected; 10b=Counts rising and falling edges; 01b=Counts rising edges; 00b=Counts falling edges. One-Shot Mode: 11b=Start counting when the Enable bit is set; 10b=Starts counting on a rising or falling edge; 01b=Starts counting on a rising edge; 00b=Starts counting on a falling edge. Measurement Mode: 11b=No event selected; 10b=Measures the time between rising edges and falling edges and the time between falling edges and rising edges; 01b=Measures the time between rising edges; 00b=Measures the time between falling edges."]
            #[inline(always)]
            pub const fn edge(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects which edge of the TINx input signal affects the timer in Event Mode, One-Shot Mode and Measurement Mode. Event Mode: 11b=No event selected; 10b=Counts rising and falling edges; 01b=Counts rising edges; 00b=Counts falling edges. One-Shot Mode: 11b=Start counting when the Enable bit is set; 10b=Starts counting on a rising or falling edge; 01b=Starts counting on a rising edge; 00b=Starts counting on a falling edge. Measurement Mode: 11b=No event selected; 10b=Measures the time between rising edges and falling edges and the time between falling edges and rising edges; 01b=Measures the time between rising edges; 00b=Measures the time between falling edges."]
            #[inline(always)]
            pub fn set_edge(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize);
            }
            #[doc = "Event Select. This bit is used to select the count source when the timer is operating in Event Mode. 1=TINx is count source; 0=Timer x-1 overflow is count source."]
            #[inline(always)]
            pub const fn event(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Event Select. This bit is used to select the count source when the timer is operating in Event Mode. 1=TINx is count source; 0=Timer x-1 overflow is count source."]
            #[inline(always)]
            pub fn set_event(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Timer Clock Select. This field determines the clock source for the TINx noise filter. The available frequencies are the same as for TCLK."]
            #[inline(always)]
            pub const fn fclk(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Timer Clock Select. This field determines the clock source for the TINx noise filter. The available frequencies are the same as for TCLK."]
            #[inline(always)]
            pub fn set_fclk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for ClkEvntCtrl {
            #[inline(always)]
            fn default() -> ClkEvntCtrl {
                ClkEvntCtrl(0)
            }
        }
        impl core::fmt::Debug for ClkEvntCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkEvntCtrl")
                    .field("tclk", &self.tclk())
                    .field("edge", &self.edge())
                    .field("event", &self.event())
                    .field("fclk", &self.fclk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkEvntCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "ClkEvntCtrl {{ tclk: {=u8:?}, edge: {=u8:?}, event: {=bool:?}, fclk: {=u8:?} }}",
                    self.tclk(),
                    self.edge(),
                    self.event(),
                    self.fclk()
                )
            }
        }
        #[doc = "This bit reflects the current state of the timer's Clock_Required output signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TimerxControl(pub u32);
        impl TimerxControl {
            #[doc = "This bit is used to start and stop the timer. This bit does not reset the timer count but does reset the timer pulse output. This bit will be cleared when the timer stops counting in One-Shot mode. The ENABLE bit is cleared after a RESET cycle has completed. Firmware must poll the RESET bit in order to determine when the timer is active after reset. 1=Timer is enabled; 0=Timer is disabled."]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to start and stop the timer. This bit does not reset the timer count but does reset the timer pulse output. This bit will be cleared when the timer stops counting in One-Shot mode. The ENABLE bit is cleared after a RESET cycle has completed. Firmware must poll the RESET bit in order to determine when the timer is active after reset. 1=Timer is enabled; 0=Timer is disabled."]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit stops the timer and resets the internal counter to the value in the Timer Reload Register. This bit also clears the ENABLE bit if it is set. This bit is self-clearing after the timer is reset. Firmware must poll the RESET bit in order to determine when the timer is active after reset. Interrupts are blocked only when RESET takes effect and the ENABLE bit is cleared. If interrupts are not desired, firmware must mask the interrupt in the interrupt block. 1=Timer reset; 0=Normal timer operation."]
            #[inline(always)]
            pub const fn reset(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit stops the timer and resets the internal counter to the value in the Timer Reload Register. This bit also clears the ENABLE bit if it is set. This bit is self-clearing after the timer is reset. Firmware must poll the RESET bit in order to determine when the timer is active after reset. Interrupts are blocked only when RESET takes effect and the ENABLE bit is cleared. If interrupts are not desired, firmware must mask the interrupt in the interrupt block. 1=Timer reset; 0=Normal timer operation."]
            #[inline(always)]
            pub fn set_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Timer Mode. 3=Measurement Mode; 2=One Shot Mode; 1=Event Mode; 0=Timer Mode."]
            #[inline(always)]
            pub const fn mode(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "Timer Mode. 3=Measurement Mode; 2=One Shot Mode; 1=Event Mode; 0=Timer Mode."]
            #[inline(always)]
            pub fn set_mode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "This bit selects the polarity of the TINx input. 1=TINx is active low; 0=TINx is active high."]
            #[inline(always)]
            pub const fn inpol(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects the polarity of the TINx input. 1=TINx is active low; 0=TINx is active high."]
            #[inline(always)]
            pub fn set_inpol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "In Event Mode, this bit selects the timer count direction. In Timer Mode enables timer control by the TINx input pin. Event Mode: 1=The timer counts up; 0=The timer counts down. Timer Mode:; 1=TINx pin pauses the timer when de-asserted; 0=TINx pin has no effect on the timer."]
            #[inline(always)]
            pub const fn updn(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "In Event Mode, this bit selects the timer count direction. In Timer Mode enables timer control by the TINx input pin. Event Mode: 1=The timer counts up; 0=The timer counts down. Timer Mode:; 1=TINx pin pauses the timer when de-asserted; 0=TINx pin has no effect on the timer."]
            #[inline(always)]
            pub fn set_updn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit enables the TOUTx pin. 1=TOUTx pin function is enabled; 0=TOUTx pin is inactive."]
            #[inline(always)]
            pub const fn tout_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the TOUTx pin. 1=TOUTx pin function is enabled; 0=TOUTx pin is inactive."]
            #[inline(always)]
            pub fn set_tout_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Reload Control. This bit controls how the timer is reloaded on overflow or underflow in Event and Timer modes. It has no effect in One shot mode. 1=Reload timer from Timer Reload Register and continue counting; 0=Roll timer over to FFFFh and continue counting when counting down and rolls over to 0000h and continues counting when counting up."]
            #[inline(always)]
            pub const fn rload(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Reload Control. This bit controls how the timer is reloaded on overflow or underflow in Event and Timer modes. It has no effect in One shot mode. 1=Reload timer from Timer Reload Register and continue counting; 0=Roll timer over to FFFFh and continue counting when counting down and rolls over to 0000h and continues counting when counting up."]
            #[inline(always)]
            pub fn set_rload(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This bit is used to enable or disable the noise filter on the TINx input signal. 1=Bypass Mode: input filter disabled. The TINx input directly affects the timer; 0=Filter Mode: input filter enabled. The TINx input is filtered by the input filter."]
            #[inline(always)]
            pub const fn filter_bypass(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to enable or disable the noise filter on the TINx input signal. 1=Bypass Mode: input filter disabled. The TINx input directly affects the timer; 0=Filter Mode: input filter enabled. The TINx input is filtered by the input filter."]
            #[inline(always)]
            pub fn set_filter_bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Power Down. 1=The timer is powered down and all clocks are gated; 0=The timer is in a running state."]
            #[inline(always)]
            pub const fn pd(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Power Down. 1=The timer is powered down and all clocks are gated; 0=The timer is in a running state."]
            #[inline(always)]
            pub fn set_pd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This bit determines the polarity of the TOUTx output signal. In timer modes that toggle the TOUTx signal, this polarity bit will not have a perceivable difference, except to determine the inactive state. In One-Shot mode this determines if the pulsed output is active high or active low. 1=Active low; 0=Active high."]
            #[inline(always)]
            pub const fn tout_polarity(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit determines the polarity of the TOUTx output signal. In timer modes that toggle the TOUTx signal, this polarity bit will not have a perceivable difference, except to determine the inactive state. In One-Shot mode this determines if the pulsed output is active high or active low. 1=Active low; 0=Active high."]
            #[inline(always)]
            pub fn set_tout_polarity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This bit reflects the current state of the timer's Sleep_Enable input signal. 1=Normal operation; 0=Sleep Mode is requested."]
            #[inline(always)]
            pub const fn sleep_enable(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reflects the current state of the timer's Sleep_Enable input signal. 1=Normal operation; 0=Sleep Mode is requested."]
            #[inline(always)]
            pub fn set_sleep_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "This bit reflects the current state of the timer's Clock_Required output signal. 1=The main clock is required by this block; 0=The main clock is not required by this block."]
            #[inline(always)]
            pub const fn timerx_clk_req(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reflects the current state of the timer's Clock_Required output signal. 1=The main clock is required by this block; 0=The main clock is not required by this block."]
            #[inline(always)]
            pub fn set_timerx_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for TimerxControl {
            #[inline(always)]
            fn default() -> TimerxControl {
                TimerxControl(0)
            }
        }
        impl core::fmt::Debug for TimerxControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TimerxControl")
                    .field("enable", &self.enable())
                    .field("reset", &self.reset())
                    .field("mode", &self.mode())
                    .field("inpol", &self.inpol())
                    .field("updn", &self.updn())
                    .field("tout_en", &self.tout_en())
                    .field("rload", &self.rload())
                    .field("filter_bypass", &self.filter_bypass())
                    .field("pd", &self.pd())
                    .field("tout_polarity", &self.tout_polarity())
                    .field("sleep_enable", &self.sleep_enable())
                    .field("timerx_clk_req", &self.timerx_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TimerxControl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "TimerxControl {{ enable: {=bool:?}, reset: {=bool:?}, mode: {=u8:?}, inpol: {=bool:?}, updn: {=bool:?}, tout_en: {=bool:?}, rload: {=bool:?}, filter_bypass: {=bool:?}, pd: {=bool:?}, tout_polarity: {=bool:?}, sleep_enable: {=bool:?}, timerx_clk_req: {=bool:?} }}" , self . enable () , self . reset () , self . mode () , self . inpol () , self . updn () , self . tout_en () , self . rload () , self . filter_bypass () , self . pd () , self . tout_polarity () , self . sleep_enable () , self . timerx_clk_req ())
            }
        }
        #[doc = "This register returns the current value of the timer in all modes."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TimerxCount(pub u32);
        impl TimerxCount {
            #[doc = "This is the current value of the timer in all modes."]
            #[inline(always)]
            pub const fn timer_count(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is the current value of the timer in all modes."]
            #[inline(always)]
            pub fn set_timer_count(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TimerxCount {
            #[inline(always)]
            fn default() -> TimerxCount {
                TimerxCount(0)
            }
        }
        impl core::fmt::Debug for TimerxCount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TimerxCount")
                    .field("timer_count", &self.timer_count())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TimerxCount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TimerxCount {{ timer_count: {=u16:?} }}", self.timer_count())
            }
        }
        #[doc = "This register is used in Timer and One-Shot modes to set the lower limit of the timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TimerxReload(pub u32);
        impl TimerxReload {
            #[doc = "The Timer Reload register is used in Timer and One-Shot modes to set the lower limit of the timer. In Event mode the Timer Reload register sets either the upper or lower limit of the timer depending on if the timer is counting up or down. Valid Timer Reload values are 0001h - FFFFh. If the timer is running, the reload value will not be updated until the timer overflows or underflows. Programming a 0000h as a preload value is not a valid count value. Using a value of 0000h will cause unpredictable behavior."]
            #[inline(always)]
            pub const fn timer_reload(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "The Timer Reload register is used in Timer and One-Shot modes to set the lower limit of the timer. In Event mode the Timer Reload register sets either the upper or lower limit of the timer depending on if the timer is counting up or down. Valid Timer Reload values are 0001h - FFFFh. If the timer is running, the reload value will not be updated until the timer overflows or underflows. Programming a 0000h as a preload value is not a valid count value. Using a value of 0000h will cause unpredictable behavior."]
            #[inline(always)]
            pub fn set_timer_reload(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TimerxReload {
            #[inline(always)]
            fn default() -> TimerxReload {
                TimerxReload(0)
            }
        }
        impl core::fmt::Debug for TimerxReload {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TimerxReload")
                    .field("timer_reload", &self.timer_reload())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TimerxReload {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TimerxReload {{ timer_reload: {=u16:?} }}", self.timer_reload())
            }
        }
    }
}
pub mod common {
    use core::marker::PhantomData;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct RW;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct R;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct W;
    mod sealed {
        use super::*;
        pub trait Access {}
        impl Access for R {}
        impl Access for W {}
        impl Access for RW {}
    }
    pub trait Access: sealed::Access + Copy {}
    impl Access for R {}
    impl Access for W {}
    impl Access for RW {}
    pub trait Read: Access {}
    impl Read for RW {}
    impl Read for R {}
    pub trait Write: Access {}
    impl Write for RW {}
    impl Write for W {}
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct Reg<T: Copy, A: Access> {
        ptr: *mut u8,
        phantom: PhantomData<*mut (T, A)>,
    }
    unsafe impl<T: Copy, A: Access> Send for Reg<T, A> {}
    unsafe impl<T: Copy, A: Access> Sync for Reg<T, A> {}
    impl<T: Copy, A: Access> Reg<T, A> {
        #[allow(clippy::missing_safety_doc)]
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut T) -> Self {
            Self {
                ptr: ptr as _,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut T {
            self.ptr as _
        }
    }
    impl<T: Copy, A: Read> Reg<T, A> {
        #[inline(always)]
        pub fn read(&self) -> T {
            unsafe { (self.ptr as *mut T).read_volatile() }
        }
    }
    impl<T: Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write_value(&self, val: T) {
            unsafe { (self.ptr as *mut T).write_volatile(val) }
        }
    }
    impl<T: Default + Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = Default::default();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
    impl<T: Copy, A: Read + Write> Reg<T, A> {
        #[inline(always)]
        pub fn modify<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = self.read();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
}
pub mod dma_chan00 {
    #[doc = "DMA Channel 00 Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaChan00 {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaChan00 {}
    unsafe impl Sync for DmaChan00 {}
    impl DmaChan00 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<regs::Activate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the starting address for the Memory device."]
        #[inline(always)]
        pub const fn mstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the ending address for the Memory device."]
        #[inline(always)]
        pub const fn mend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the Master Device address."]
        #[inline(always)]
        pub const fn dstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DMA Channel N Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[inline(always)]
        pub const fn ists(self) -> crate::common::Reg<regs::Ists, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "DMA CHANNEL N CRC ENABLE"]
        #[inline(always)]
        pub const fn crc_en(self) -> crate::common::Reg<regs::CrcEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "DMA CHANNEL N CRC DATA"]
        #[inline(always)]
        pub const fn crc_data(self) -> crate::common::Reg<regs::CrcData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "DMA CHANNEL N CRC POST STATUS"]
        #[inline(always)]
        pub const fn crc_post_sts(self) -> crate::common::Reg<regs::CrcPostSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate(pub u8);
        impl Activate {
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate {
            #[inline(always)]
            fn default() -> Activate {
                Activate(0)
            }
        }
        impl core::fmt::Debug for Activate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate {{ chn: {=bool:?} }}", self.chn())
            }
        }
        #[doc = "DMA CHANNEL N CRC DATA"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcData(pub u32);
        impl CrcData {
            #[doc = "Writes to this register initialize the CRC generator. Reads from this register return the output of the CRC that is calculated from the data transferred by DMA Channel N. The output of the CRC generator is bit-reversed and inverted on reads, as required by the CRC-32-IEEE definition. A CRC can be accumulated across multiple DMA transactions on Channel N. If it is necessary to save the intermediate CRC value, the result of the read of this register must be bit-reversed and inverted before being written back to this register."]
            #[inline(always)]
            pub const fn crc(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Writes to this register initialize the CRC generator. Reads from this register return the output of the CRC that is calculated from the data transferred by DMA Channel N. The output of the CRC generator is bit-reversed and inverted on reads, as required by the CRC-32-IEEE definition. A CRC can be accumulated across multiple DMA transactions on Channel N. If it is necessary to save the intermediate CRC value, the result of the read of this register must be bit-reversed and inverted before being written back to this register."]
            #[inline(always)]
            pub fn set_crc(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for CrcData {
            #[inline(always)]
            fn default() -> CrcData {
                CrcData(0)
            }
        }
        impl core::fmt::Debug for CrcData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcData").field("crc", &self.crc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CrcData {{ crc: {=u32:?} }}", self.crc())
            }
        }
        #[doc = "DMA CHANNEL N CRC ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcEn(pub u32);
        impl CrcEn {
            #[doc = "1=Enable the calculation of CRC-32 for DMA Channel N 0=Disable the calculation of CRC-32 for DMA Channel N"]
            #[inline(always)]
            pub const fn mode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable the calculation of CRC-32 for DMA Channel N 0=Disable the calculation of CRC-32 for DMA Channel N"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The bit enables the transfer of the calculated CRC-32 after the completion of the DMA transaction. If the DMA transaction is aborted by either firmware or an internal bus error, the transfer will not occur. If the target of the DMA transfer is a device and the device signaled the termination of the DMA transaction, the CRC post transfer will not occur. 1=Enable the transfer of CRC-32 for DMA Channel N after the DMA transaction completes 0=Disable the automatic transfer of the CRC"]
            #[inline(always)]
            pub const fn post_trans(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The bit enables the transfer of the calculated CRC-32 after the completion of the DMA transaction. If the DMA transaction is aborted by either firmware or an internal bus error, the transfer will not occur. If the target of the DMA transfer is a device and the device signaled the termination of the DMA transaction, the CRC post transfer will not occur. 1=Enable the transfer of CRC-32 for DMA Channel N after the DMA transaction completes 0=Disable the automatic transfer of the CRC"]
            #[inline(always)]
            pub fn set_post_trans(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for CrcEn {
            #[inline(always)]
            fn default() -> CrcEn {
                CrcEn(0)
            }
        }
        impl core::fmt::Debug for CrcEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcEn")
                    .field("mode", &self.mode())
                    .field("post_trans", &self.post_trans())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "CrcEn {{ mode: {=bool:?}, post_trans: {=bool:?} }}",
                    self.mode(),
                    self.post_trans()
                )
            }
        }
        #[doc = "DMA CHANNEL N CRC POST STATUS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcPostSts(pub u32);
        impl CrcPostSts {
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub const fn crc_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub fn set_crc_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub const fn crc_running(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub fn set_crc_running(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller has completed the post-transfer of the CRC data. This bit is cleared to '0b' when the a new DMA transfer starts."]
            #[inline(always)]
            pub const fn crc_data_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller has completed the post-transfer of the CRC data. This bit is cleared to '0b' when the a new DMA transfer starts."]
            #[inline(always)]
            pub fn set_crc_data_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller is processing the post-transfer of the CRC data. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub const fn crc_data_ready(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller is processing the post-transfer of the CRC data. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub fn set_crc_data_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for CrcPostSts {
            #[inline(always)]
            fn default() -> CrcPostSts {
                CrcPostSts(0)
            }
        }
        impl core::fmt::Debug for CrcPostSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcPostSts")
                    .field("crc_done", &self.crc_done())
                    .field("crc_running", &self.crc_running())
                    .field("crc_data_done", &self.crc_data_done())
                    .field("crc_data_ready", &self.crc_data_ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcPostSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CrcPostSts {{ crc_done: {=bool:?}, crc_running: {=bool:?}, crc_data_done: {=bool:?}, crc_data_ready: {=bool:?} }}" , self . crc_done () , self . crc_running () , self . crc_data_done () , self . crc_data_ready ())
            }
        }
        #[doc = "DMA Channel N Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub const fn run(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub fn set_run(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub const fn req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub fn set_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Sts {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Sts::from_bits(val as u8)
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Sts) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u32) & 0x03) << 3usize);
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub const fn tx_dir(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub fn set_tx_dir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub const fn hw_flow_ctrl_dev(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub fn set_hw_flow_ctrl_dev(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u32) & 0x7f) << 9usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub const fn inc_mem_addr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub fn set_inc_mem_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub const fn inc_dev_addr(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub fn set_inc_dev_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub const fn dis_hw_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub fn set_dis_hw_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub const fn trans_size(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub fn set_trans_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub const fn trans_go(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub fn set_trans_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub const fn trans_abort(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub fn set_trans_abort(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("run", &self.run())
                    .field("req", &self.req())
                    .field("done", &self.done())
                    .field("sts", &self.sts())
                    .field("busy", &self.busy())
                    .field("tx_dir", &self.tx_dir())
                    .field("hw_flow_ctrl_dev", &self.hw_flow_ctrl_dev())
                    .field("inc_mem_addr", &self.inc_mem_addr())
                    .field("inc_dev_addr", &self.inc_dev_addr())
                    .field("lock", &self.lock())
                    .field("dis_hw_flow_ctrl", &self.dis_hw_flow_ctrl())
                    .field("trans_size", &self.trans_size())
                    .field("trans_go", &self.trans_go())
                    .field("trans_abort", &self.trans_abort())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ run: {=bool:?}, req: {=bool:?}, done: {=bool:?}, sts: {:?}, busy: {=bool:?}, tx_dir: {=bool:?}, hw_flow_ctrl_dev: {=u8:?}, inc_mem_addr: {=bool:?}, inc_dev_addr: {=bool:?}, lock: {=bool:?}, dis_hw_flow_ctrl: {=bool:?}, trans_size: {=u8:?}, trans_go: {=bool:?}, trans_abort: {=bool:?} }}" , self . run () , self . req () , self . done () , self . sts () , self . busy () , self . tx_dir () , self . hw_flow_ctrl_dev () , self . inc_mem_addr () , self . inc_dev_addr () , self . lock () , self . dis_hw_flow_ctrl () , self . trans_size () , self . trans_go () , self . trans_abort ())
            }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("sts_en_bus_err", &self.sts_en_bus_err())
                    .field("sts_en_flow_ctrl", &self.sts_en_flow_ctrl())
                    .field("sts_en_done", &self.sts_en_done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ sts_en_bus_err: {=bool:?}, sts_en_flow_ctrl: {=bool:?}, sts_en_done: {=bool:?} }}",
                    self.sts_en_bus_err(),
                    self.sts_en_flow_ctrl(),
                    self.sts_en_done()
                )
            }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ists(pub u8);
        impl Ists {
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub const fn bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub fn set_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub const fn flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub fn set_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ists {
            #[inline(always)]
            fn default() -> Ists {
                Ists(0)
            }
        }
        impl core::fmt::Debug for Ists {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ists")
                    .field("bus_err", &self.bus_err())
                    .field("flow_ctrl", &self.flow_ctrl())
                    .field("done", &self.done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ists {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ists {{ bus_err: {=bool:?}, flow_ctrl: {=bool:?}, done: {=bool:?} }}",
                    self.bus_err(),
                    self.flow_ctrl(),
                    self.done()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sts {
            #[doc = "0: DMA Channel Control:Run is Disabled (0x0)"]
            DIS = 0x0,
            #[doc = "1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address"]
            LOC_DONE = 0x01,
            #[doc = "2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term"]
            EXT_DONE = 0x02,
            #[doc = "3: Error detected by the DMA"]
            ERROR = 0x03,
        }
        impl Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sts {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sts {
            #[inline(always)]
            fn from(val: u8) -> Sts {
                Sts::from_bits(val)
            }
        }
        impl From<Sts> for u8 {
            #[inline(always)]
            fn from(val: Sts) -> u8 {
                Sts::to_bits(val)
            }
        }
    }
}
pub mod dma_chan01 {
    #[doc = "DMA Channel 01 Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaChan01 {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaChan01 {}
    unsafe impl Sync for DmaChan01 {}
    impl DmaChan01 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<regs::Activate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the starting address for the Memory device."]
        #[inline(always)]
        pub const fn mstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the ending address for the Memory device."]
        #[inline(always)]
        pub const fn mend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the Master Device address."]
        #[inline(always)]
        pub const fn dstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DMA Channel N Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[inline(always)]
        pub const fn ists(self) -> crate::common::Reg<regs::Ists, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "DMA CHANNEL N FILL ENABLE"]
        #[inline(always)]
        pub const fn fill_en(self) -> crate::common::Reg<regs::FillEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "DMA CHANNEL N FILL DATA"]
        #[inline(always)]
        pub const fn fill_data(self) -> crate::common::Reg<regs::FillData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "DMA CHANNEL N FILL STATUS"]
        #[inline(always)]
        pub const fn fill_sts(self) -> crate::common::Reg<regs::FillSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate(pub u8);
        impl Activate {
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate {
            #[inline(always)]
            fn default() -> Activate {
                Activate(0)
            }
        }
        impl core::fmt::Debug for Activate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate {{ chn: {=bool:?} }}", self.chn())
            }
        }
        #[doc = "DMA Channel N Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub const fn run(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub fn set_run(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub const fn req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub fn set_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Sts {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Sts::from_bits(val as u8)
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Sts) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u32) & 0x03) << 3usize);
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub const fn tx_dir(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub fn set_tx_dir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub const fn hw_flow_ctrl_dev(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub fn set_hw_flow_ctrl_dev(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u32) & 0x7f) << 9usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub const fn inc_mem_addr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub fn set_inc_mem_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub const fn inc_dev_addr(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub fn set_inc_dev_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub const fn dis_hw_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub fn set_dis_hw_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub const fn trans_size(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub fn set_trans_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub const fn trans_go(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub fn set_trans_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub const fn trans_abort(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub fn set_trans_abort(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("run", &self.run())
                    .field("req", &self.req())
                    .field("done", &self.done())
                    .field("sts", &self.sts())
                    .field("busy", &self.busy())
                    .field("tx_dir", &self.tx_dir())
                    .field("hw_flow_ctrl_dev", &self.hw_flow_ctrl_dev())
                    .field("inc_mem_addr", &self.inc_mem_addr())
                    .field("inc_dev_addr", &self.inc_dev_addr())
                    .field("lock", &self.lock())
                    .field("dis_hw_flow_ctrl", &self.dis_hw_flow_ctrl())
                    .field("trans_size", &self.trans_size())
                    .field("trans_go", &self.trans_go())
                    .field("trans_abort", &self.trans_abort())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ run: {=bool:?}, req: {=bool:?}, done: {=bool:?}, sts: {:?}, busy: {=bool:?}, tx_dir: {=bool:?}, hw_flow_ctrl_dev: {=u8:?}, inc_mem_addr: {=bool:?}, inc_dev_addr: {=bool:?}, lock: {=bool:?}, dis_hw_flow_ctrl: {=bool:?}, trans_size: {=u8:?}, trans_go: {=bool:?}, trans_abort: {=bool:?} }}" , self . run () , self . req () , self . done () , self . sts () , self . busy () , self . tx_dir () , self . hw_flow_ctrl_dev () , self . inc_mem_addr () , self . inc_dev_addr () , self . lock () , self . dis_hw_flow_ctrl () , self . trans_size () , self . trans_go () , self . trans_abort ())
            }
        }
        #[doc = "DMA CHANNEL N FILL DATA"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FillData(pub u32);
        impl FillData {
            #[doc = "This is the data pattern used to fill memory."]
            #[inline(always)]
            pub const fn data(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the data pattern used to fill memory."]
            #[inline(always)]
            pub fn set_data(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FillData {
            #[inline(always)]
            fn default() -> FillData {
                FillData(0)
            }
        }
        impl core::fmt::Debug for FillData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FillData").field("data", &self.data()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FillData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FillData {{ data: {=u32:?} }}", self.data())
            }
        }
        #[doc = "DMA CHANNEL N FILL ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FillEn(pub u32);
        impl FillEn {
            #[doc = "1=Enable the DMA Channel Fill Engine N 0=Disable the DMA Channel Fill Engine"]
            #[inline(always)]
            pub const fn mode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable the DMA Channel Fill Engine N 0=Disable the DMA Channel Fill Engine"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for FillEn {
            #[inline(always)]
            fn default() -> FillEn {
                FillEn(0)
            }
        }
        impl core::fmt::Debug for FillEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FillEn").field("mode", &self.mode()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FillEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FillEn {{ mode: {=bool:?} }}", self.mode())
            }
        }
        #[doc = "DMA CHANNEL N FILL STATUS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FillSts(pub u32);
        impl FillSts {
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub const fn running(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub fn set_running(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for FillSts {
            #[inline(always)]
            fn default() -> FillSts {
                FillSts(0)
            }
        }
        impl core::fmt::Debug for FillSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FillSts")
                    .field("done", &self.done())
                    .field("running", &self.running())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FillSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FillSts {{ done: {=bool:?}, running: {=bool:?} }}",
                    self.done(),
                    self.running()
                )
            }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("sts_en_bus_err", &self.sts_en_bus_err())
                    .field("sts_en_flow_ctrl", &self.sts_en_flow_ctrl())
                    .field("sts_en_done", &self.sts_en_done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ sts_en_bus_err: {=bool:?}, sts_en_flow_ctrl: {=bool:?}, sts_en_done: {=bool:?} }}",
                    self.sts_en_bus_err(),
                    self.sts_en_flow_ctrl(),
                    self.sts_en_done()
                )
            }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ists(pub u8);
        impl Ists {
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub const fn bus_error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub fn set_bus_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub const fn flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub fn set_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ists {
            #[inline(always)]
            fn default() -> Ists {
                Ists(0)
            }
        }
        impl core::fmt::Debug for Ists {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ists")
                    .field("bus_error", &self.bus_error())
                    .field("flow_ctrl", &self.flow_ctrl())
                    .field("done", &self.done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ists {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ists {{ bus_error: {=bool:?}, flow_ctrl: {=bool:?}, done: {=bool:?} }}",
                    self.bus_error(),
                    self.flow_ctrl(),
                    self.done()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sts {
            #[doc = "0: DMA Channel Control:Run is Disabled (0x0)"]
            DIS = 0x0,
            #[doc = "1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address"]
            LOC_DONE = 0x01,
            #[doc = "2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term"]
            EXT_DONE = 0x02,
            #[doc = "3: Error detected by the DMA"]
            ERROR = 0x03,
        }
        impl Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sts {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sts {
            #[inline(always)]
            fn from(val: u8) -> Sts {
                Sts::from_bits(val)
            }
        }
        impl From<Sts> for u8 {
            #[inline(always)]
            fn from(val: Sts) -> u8 {
                Sts::to_bits(val)
            }
        }
    }
}
pub mod dma_chan02 {
    #[doc = "DMA Channel 02 Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaChan02 {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaChan02 {}
    unsafe impl Sync for DmaChan02 {}
    impl DmaChan02 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<regs::Activate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the starting address for the Memory device."]
        #[inline(always)]
        pub const fn mstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the ending address for the Memory device."]
        #[inline(always)]
        pub const fn mend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the Master Device address."]
        #[inline(always)]
        pub const fn dstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DMA Channel N Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[inline(always)]
        pub const fn ists(self) -> crate::common::Reg<regs::Ists, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate(pub u8);
        impl Activate {
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate {
            #[inline(always)]
            fn default() -> Activate {
                Activate(0)
            }
        }
        impl core::fmt::Debug for Activate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate {{ chn: {=bool:?} }}", self.chn())
            }
        }
        #[doc = "DMA Channel N Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub const fn run(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub fn set_run(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub const fn req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub fn set_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Sts {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Sts::from_bits(val as u8)
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Sts) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u32) & 0x03) << 3usize);
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub const fn tx_dir(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub fn set_tx_dir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub const fn hw_flow_ctrl_dev(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub fn set_hw_flow_ctrl_dev(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u32) & 0x7f) << 9usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub const fn inc_mem_addr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub fn set_inc_mem_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub const fn inc_dev_addr(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub fn set_inc_dev_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub const fn dis_hw_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub fn set_dis_hw_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub const fn trans_size(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub fn set_trans_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub const fn trans_go(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub fn set_trans_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub const fn trans_abort(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub fn set_trans_abort(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("run", &self.run())
                    .field("req", &self.req())
                    .field("done", &self.done())
                    .field("sts", &self.sts())
                    .field("busy", &self.busy())
                    .field("tx_dir", &self.tx_dir())
                    .field("hw_flow_ctrl_dev", &self.hw_flow_ctrl_dev())
                    .field("inc_mem_addr", &self.inc_mem_addr())
                    .field("inc_dev_addr", &self.inc_dev_addr())
                    .field("lock", &self.lock())
                    .field("dis_hw_flow_ctrl", &self.dis_hw_flow_ctrl())
                    .field("trans_size", &self.trans_size())
                    .field("trans_go", &self.trans_go())
                    .field("trans_abort", &self.trans_abort())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ run: {=bool:?}, req: {=bool:?}, done: {=bool:?}, sts: {:?}, busy: {=bool:?}, tx_dir: {=bool:?}, hw_flow_ctrl_dev: {=u8:?}, inc_mem_addr: {=bool:?}, inc_dev_addr: {=bool:?}, lock: {=bool:?}, dis_hw_flow_ctrl: {=bool:?}, trans_size: {=u8:?}, trans_go: {=bool:?}, trans_abort: {=bool:?} }}" , self . run () , self . req () , self . done () , self . sts () , self . busy () , self . tx_dir () , self . hw_flow_ctrl_dev () , self . inc_mem_addr () , self . inc_dev_addr () , self . lock () , self . dis_hw_flow_ctrl () , self . trans_size () , self . trans_go () , self . trans_abort ())
            }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("sts_en_bus_err", &self.sts_en_bus_err())
                    .field("sts_en_flow_ctrl", &self.sts_en_flow_ctrl())
                    .field("sts_en_done", &self.sts_en_done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ sts_en_bus_err: {=bool:?}, sts_en_flow_ctrl: {=bool:?}, sts_en_done: {=bool:?} }}",
                    self.sts_en_bus_err(),
                    self.sts_en_flow_ctrl(),
                    self.sts_en_done()
                )
            }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ists(pub u8);
        impl Ists {
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub const fn bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub fn set_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub const fn flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub fn set_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ists {
            #[inline(always)]
            fn default() -> Ists {
                Ists(0)
            }
        }
        impl core::fmt::Debug for Ists {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ists")
                    .field("bus_err", &self.bus_err())
                    .field("flow_ctrl", &self.flow_ctrl())
                    .field("done", &self.done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ists {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ists {{ bus_err: {=bool:?}, flow_ctrl: {=bool:?}, done: {=bool:?} }}",
                    self.bus_err(),
                    self.flow_ctrl(),
                    self.done()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sts {
            #[doc = "0: DMA Channel Control:Run is Disabled (0x0)"]
            DIS = 0x0,
            #[doc = "1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address"]
            LOC_DONE = 0x01,
            #[doc = "2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term"]
            EXT_DONE = 0x02,
            #[doc = "3: Error detected by the DMA"]
            ERROR = 0x03,
        }
        impl Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sts {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sts {
            #[inline(always)]
            fn from(val: u8) -> Sts {
                Sts::from_bits(val)
            }
        }
        impl From<Sts> for u8 {
            #[inline(always)]
            fn from(val: Sts) -> u8 {
                Sts::to_bits(val)
            }
        }
    }
}
pub mod dma_main {
    #[doc = "DMA Main Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaMain {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaMain {}
    unsafe impl Sync for DmaMain {}
    impl DmaMain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Soft reset the entire module. Enable the blocks operation."]
        #[inline(always)]
        pub const fn actrst(self) -> crate::common::Reg<regs::Actrst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Debug register that has the data that is stored in the Data Packet. This data is read data from the currently active transfer source."]
        #[inline(always)]
        pub const fn data_pkt(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Soft reset the entire module. Enable the blocks operation."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Actrst(pub u8);
        impl Actrst {
            #[doc = "Enable the blocks operation. (R/WS) 1=Enable block. Each individual channel must be enabled separately. 0=Disable all channels."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the blocks operation. (R/WS) 1=Enable block. Each individual channel must be enabled separately. 0=Disable all channels."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Soft reset the entire module. This bit is self-clearing."]
            #[inline(always)]
            pub const fn soft_rst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Soft reset the entire module. This bit is self-clearing."]
            #[inline(always)]
            pub fn set_soft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Actrst {
            #[inline(always)]
            fn default() -> Actrst {
                Actrst(0)
            }
        }
        impl core::fmt::Debug for Actrst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Actrst")
                    .field("act", &self.act())
                    .field("soft_rst", &self.soft_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Actrst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Actrst {{ act: {=bool:?}, soft_rst: {=bool:?} }}",
                    self.act(),
                    self.soft_rst()
                )
            }
        }
    }
}
pub mod ec_reg_bank {
    #[doc = "This block is designed to be accessed internally by the EC via the register interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EcRegBank {
        ptr: *mut u8,
    }
    unsafe impl Send for EcRegBank {}
    unsafe impl Sync for EcRegBank {}
    impl EcRegBank {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SRAM Configuration Register"]
        #[inline(always)]
        pub const fn sram_cnfg(self) -> crate::common::Reg<regs::SramCnfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "AHB Error Address \\[0:0\\]"]
        #[inline(always)]
        pub const fn ahb_err_addr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "AHB Error Control \\[0:0\\] AHB_ERROR_DISABLE, 0: EC memory exceptions are enabled. 1: EC memory exceptions are disabled."]
        #[inline(always)]
        pub const fn ahb_err_ctrl(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Interrupt Control \\[0:0\\] NVIC_EN (NVIC_EN) This bit enables Alternate NVIC IRQ's Vectors. The Alternate NVIC Vectors provides each interrupt event with a dedicated (direct) NVIC vector. 0 = Alternate NVIC vectors disabled, 1= Alternate NVIC vectors enabled"]
        #[inline(always)]
        pub const fn intr_ctrl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "ETM TRACE Enable \\[0:0\\] TRACE_EN (TRACE_EN) This bit enables the ARM TRACE debug port (ETM/ITM). The Trace Debug Interface pins are forced to the TRACE functions. 0 = ARM TRACE port disabled, 1= ARM TRACE port enabled"]
        #[inline(always)]
        pub const fn etm_ctrl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Debug Enable Register"]
        #[inline(always)]
        pub const fn debug_ctrl(self) -> crate::common::Reg<regs::DebugCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Lock Register"]
        #[inline(always)]
        pub const fn otp_lock(self) -> crate::common::Reg<regs::OtpLock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "WDT Event Count \\[3:0\\] WDT_COUNT (WDT_COUNT) These EC R/W bits are cleared to 0 on VCC1 POR, but not on a WDT. Note: This field is written by Boot ROM firmware to indicate the number of times a WDT fired before loading a good EC code image."]
        #[inline(always)]
        pub const fn wdt_cnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "AES HASH Byte Swap Control Register."]
        #[inline(always)]
        pub const fn aesh_bswap_ctrl(self) -> crate::common::Reg<regs::AeshBswapCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "PECI Disable"]
        #[inline(always)]
        pub const fn peci_dis(self) -> crate::common::Reg<regs::PeciDis, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "GPIO Bank Power Register"]
        #[inline(always)]
        pub const fn gpio_bank_pwr(self) -> crate::common::Reg<regs::GpioBankPwr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "JTAG Master Configuration Register"]
        #[inline(always)]
        pub const fn jtag_mcfg(self) -> crate::common::Reg<regs::JtagMcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "JTAG Master Status Register"]
        #[inline(always)]
        pub const fn jtag_msts(self) -> crate::common::Reg<regs::JtagMsts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "JTAG Master TDO Register"]
        #[inline(always)]
        pub const fn jtag_mtdo(self) -> crate::common::Reg<regs::JtagMtdo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "JTAG Master TDI Register"]
        #[inline(always)]
        pub const fn jtag_mtdi(self) -> crate::common::Reg<regs::JtagMtdi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "JTAG Master TMS Register"]
        #[inline(always)]
        pub const fn jtag_mtms(self) -> crate::common::Reg<regs::JtagMtms, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "JTAG Master Command Register"]
        #[inline(always)]
        pub const fn jtag_mcmd(self) -> crate::common::Reg<regs::JtagMcmd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Virtual Wire Source Configuration Register"]
        #[inline(always)]
        pub const fn vw_src_cngf(self) -> crate::common::Reg<regs::VwSrcCngf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Comparator Enable"]
        #[inline(always)]
        pub const fn acomp_ctrl(self) -> crate::common::Reg<regs::AcompCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "Analog Comparator Sleep Control Register"]
        #[inline(always)]
        pub const fn acomp_slp_ctrl(self) -> crate::common::Reg<regs::AcompSlpCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "Embedded Reset Enable Register"]
        #[inline(always)]
        pub const fn emdrst_en(self) -> crate::common::Reg<regs::EmdrstEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb0usize) as _) }
        }
        #[doc = "Embedded Reset Timeout Register"]
        #[inline(always)]
        pub const fn emdrst_tout(self) -> crate::common::Reg<regs::EmdrstTout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb4usize) as _) }
        }
        #[doc = "Embedded Reset Status Register"]
        #[inline(always)]
        pub const fn emdrst_sts(self) -> crate::common::Reg<regs::EmdrstSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb8usize) as _) }
        }
        #[doc = "Embedded Reset Count Register"]
        #[inline(always)]
        pub const fn emdrst_cnt(self) -> crate::common::Reg<regs::EmdrstCnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xbcusize) as _) }
        }
        #[doc = "BOOT ROM Scratch 0 Register"]
        #[inline(always)]
        pub const fn fw_scr0(self) -> crate::common::Reg<regs::FwScr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "BOOT ROM Scratch 1 Register"]
        #[inline(always)]
        pub const fn fw_scr1(self) -> crate::common::Reg<regs::FwScr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "BOOT ROM Scratch 2 Register"]
        #[inline(always)]
        pub const fn fw_scr2(self) -> crate::common::Reg<regs::FwScr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "BOOT ROM Scratch 3 Register"]
        #[inline(always)]
        pub const fn fw_scr3(self) -> crate::common::Reg<regs::FwScr3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Comparator Enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcompCtrl(pub u8);
        impl AcompCtrl {
            #[doc = "Comparator 0 Enable 0: Disable Comparator for operation 1: Enable Comparator operation."]
            #[inline(always)]
            pub const fn cmp0en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Comparator 0 Enable 0: Disable Comparator for operation 1: Enable Comparator operation."]
            #[inline(always)]
            pub fn set_cmp0en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Comparator 0 Configuration Locked 0: Configuration Not Locked. Bits\\[2,0\\] are Read-Write 1: Configuration Locked. Bits\\[2,0\\] are Read-Only Note: If the CMP_STRAP0 Pin = 1 the Boot ROM writes this bit. Once it is written this bit becomes a read-only bit."]
            #[inline(always)]
            pub const fn conf0lck(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Comparator 0 Configuration Locked 0: Configuration Not Locked. Bits\\[2,0\\] are Read-Write 1: Configuration Locked. Bits\\[2,0\\] are Read-Only Note: If the CMP_STRAP0 Pin = 1 the Boot ROM writes this bit. Once it is written this bit becomes a read-only bit."]
            #[inline(always)]
            pub fn set_conf0lck(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Comparator 1 Enable 0: Disable Comparator for operation 1: Enable Comparator operation."]
            #[inline(always)]
            pub const fn cmp1en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Comparator 1 Enable 0: Disable Comparator for operation 1: Enable Comparator operation."]
            #[inline(always)]
            pub fn set_cmp1en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for AcompCtrl {
            #[inline(always)]
            fn default() -> AcompCtrl {
                AcompCtrl(0)
            }
        }
        impl core::fmt::Debug for AcompCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcompCtrl")
                    .field("cmp0en", &self.cmp0en())
                    .field("conf0lck", &self.conf0lck())
                    .field("cmp1en", &self.cmp1en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcompCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcompCtrl {{ cmp0en: {=bool:?}, conf0lck: {=bool:?}, cmp1en: {=bool:?} }}",
                    self.cmp0en(),
                    self.conf0lck(),
                    self.cmp1en()
                )
            }
        }
        #[doc = "Analog Comparator Sleep Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcompSlpCtrl(pub u8);
        impl AcompSlpCtrl {
            #[doc = "Comparator 0 Deep Sleep Enable. 0 = Comparator Deep Sleep Disable. 1 = Comparator Deep Sleep Enable. Note: If the CMP_STRAP0 Pin = 1 the Boot ROM writes this bit. Once it is written this bit becomes a read-only bit."]
            #[inline(always)]
            pub const fn cmp0slp_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Comparator 0 Deep Sleep Enable. 0 = Comparator Deep Sleep Disable. 1 = Comparator Deep Sleep Enable. Note: If the CMP_STRAP0 Pin = 1 the Boot ROM writes this bit. Once it is written this bit becomes a read-only bit."]
            #[inline(always)]
            pub fn set_cmp0slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Comparator 1 Deep Sleep Enable. 0 = Comparator Deep Sleep Disable. 1 = Comparator Deep Sleep Enable."]
            #[inline(always)]
            pub const fn cmp1slp_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Comparator 1 Deep Sleep Enable. 0 = Comparator Deep Sleep Disable. 1 = Comparator Deep Sleep Enable."]
            #[inline(always)]
            pub fn set_cmp1slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
        }
        impl Default for AcompSlpCtrl {
            #[inline(always)]
            fn default() -> AcompSlpCtrl {
                AcompSlpCtrl(0)
            }
        }
        impl core::fmt::Debug for AcompSlpCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcompSlpCtrl")
                    .field("cmp0slp_en", &self.cmp0slp_en())
                    .field("cmp1slp_en", &self.cmp1slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcompSlpCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcompSlpCtrl {{ cmp0slp_en: {=bool:?}, cmp1slp_en: {=bool:?} }}",
                    self.cmp0slp_en(),
                    self.cmp1slp_en()
                )
            }
        }
        #[doc = "AES HASH Byte Swap Control Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AeshBswapCtrl(pub u32);
        impl AeshBswapCtrl {
            #[doc = "Used to enable byte swap on a DWORD during AHB read from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub const fn ip_byte_swap_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Used to enable byte swap on a DWORD during AHB read from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub fn set_ip_byte_swap_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Used to enable byte swap on a DWORD during AHB write from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub const fn op_byte_swap_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Used to enable byte swap on a DWORD during AHB write from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub fn set_op_byte_swap_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Used to enable word swap on a DWORD during AHB read from AES / HASH block 0=Disable."]
            #[inline(always)]
            pub const fn ip_blk_swap_en(&self) -> super::vals::IpBlkSwapEn {
                let val = (self.0 >> 2usize) & 0x07;
                super::vals::IpBlkSwapEn::from_bits(val as u8)
            }
            #[doc = "Used to enable word swap on a DWORD during AHB read from AES / HASH block 0=Disable."]
            #[inline(always)]
            pub fn set_ip_blk_swap_en(&mut self, val: super::vals::IpBlkSwapEn) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val.to_bits() as u32) & 0x07) << 2usize);
            }
            #[doc = "Used to enable word swap on a DWORD during AHB write from AES / HASH block 0=Disable."]
            #[inline(always)]
            pub const fn op_blk_swap_en(&self) -> super::vals::OpBlkSwapEn {
                let val = (self.0 >> 5usize) & 0x07;
                super::vals::OpBlkSwapEn::from_bits(val as u8)
            }
            #[doc = "Used to enable word swap on a DWORD during AHB write from AES / HASH block 0=Disable."]
            #[inline(always)]
            pub fn set_op_blk_swap_en(&mut self, val: super::vals::OpBlkSwapEn) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val.to_bits() as u32) & 0x07) << 5usize);
            }
        }
        impl Default for AeshBswapCtrl {
            #[inline(always)]
            fn default() -> AeshBswapCtrl {
                AeshBswapCtrl(0)
            }
        }
        impl core::fmt::Debug for AeshBswapCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AeshBswapCtrl")
                    .field("ip_byte_swap_en", &self.ip_byte_swap_en())
                    .field("op_byte_swap_en", &self.op_byte_swap_en())
                    .field("ip_blk_swap_en", &self.ip_blk_swap_en())
                    .field("op_blk_swap_en", &self.op_blk_swap_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AeshBswapCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "AeshBswapCtrl {{ ip_byte_swap_en: {=bool:?}, op_byte_swap_en: {=bool:?}, ip_blk_swap_en: {:?}, op_blk_swap_en: {:?} }}" , self . ip_byte_swap_en () , self . op_byte_swap_en () , self . ip_blk_swap_en () , self . op_blk_swap_en ())
            }
        }
        #[doc = "Debug Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DebugCtrl(pub u32);
        impl DebugCtrl {
            #[doc = "DEBUG_EN (JTAG_EN) This bit enables the JTAG/SWD debug port. 0= JTAG/SWD port disabled. JTAG/SWD cannot be enabled (i.e., the TRST# pin is ignored and the JTAG signals remain in their non-JTAG state) 1= JTAG/SWD port enabled. A high on TRST# enables JTAG or SWD, as determined by SWD_EN."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DEBUG_EN (JTAG_EN) This bit enables the JTAG/SWD debug port. 0= JTAG/SWD port disabled. JTAG/SWD cannot be enabled (i.e., the TRST# pin is ignored and the JTAG signals remain in their non-JTAG state) 1= JTAG/SWD port enabled. A high on TRST# enables JTAG or SWD, as determined by SWD_EN."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This field determines which pins are affected by the TRST# debug enable pin. 3=Reserved 2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required 1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) and Serial Wire Viewer (SWV) are both required for debugging 0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high. This setting should be used when the JTAG TAP controller is required for debugging."]
            #[inline(always)]
            pub const fn pin_cfg(&self) -> super::vals::PinCfg {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::PinCfg::from_bits(val as u8)
            }
            #[doc = "This field determines which pins are affected by the TRST# debug enable pin. 3=Reserved 2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required 1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) and Serial Wire Viewer (SWV) are both required for debugging 0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high. This setting should be used when the JTAG TAP controller is required for debugging."]
            #[inline(always)]
            pub fn set_pin_cfg(&mut self, val: super::vals::PinCfg) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u32) & 0x03) << 1usize);
            }
            #[doc = "If this bit is set to '1b' internal pull-up resistors are automatically enabled on the appropriate debugging port wires whenever the debug port is enabled (the DEBUG_EN bit in this register is '1b' and the JTAG_RST# pin is high). The setting of DEBUG_PIN_CFG determines which pins have pull-ups enabled when the debug port is enabled."]
            #[inline(always)]
            pub const fn pu_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is set to '1b' internal pull-up resistors are automatically enabled on the appropriate debugging port wires whenever the debug port is enabled (the DEBUG_EN bit in this register is '1b' and the JTAG_RST# pin is high). The setting of DEBUG_PIN_CFG determines which pins have pull-ups enabled when the debug port is enabled."]
            #[inline(always)]
            pub fn set_pu_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit sets the boundary scan tap controller accessibility from JTAG port. 1= Boundary scan tap controller accessibile through JTAG Port. 0= Boundary scan tap controller not accessibile through JTAG Port."]
            #[inline(always)]
            pub const fn bsp_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit sets the boundary scan tap controller accessibility from JTAG port. 1= Boundary scan tap controller accessibile through JTAG Port. 0= Boundary scan tap controller not accessibile through JTAG Port."]
            #[inline(always)]
            pub fn set_bsp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for DebugCtrl {
            #[inline(always)]
            fn default() -> DebugCtrl {
                DebugCtrl(0)
            }
        }
        impl core::fmt::Debug for DebugCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DebugCtrl")
                    .field("en", &self.en())
                    .field("pin_cfg", &self.pin_cfg())
                    .field("pu_en", &self.pu_en())
                    .field("bsp_en", &self.bsp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DebugCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DebugCtrl {{ en: {=bool:?}, pin_cfg: {:?}, pu_en: {=bool:?}, bsp_en: {=bool:?} }}",
                    self.en(),
                    self.pin_cfg(),
                    self.pu_en(),
                    self.bsp_en()
                )
            }
        }
        #[doc = "Embedded Reset Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EmdrstCnt(pub u32);
        impl EmdrstCnt {
            #[doc = "Embedded Reset CNT Register."]
            #[inline(always)]
            pub const fn cnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Embedded Reset CNT Register."]
            #[inline(always)]
            pub fn set_cnt(&mut self, val: u32) {
                self.0 = (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
        }
        impl Default for EmdrstCnt {
            #[inline(always)]
            fn default() -> EmdrstCnt {
                EmdrstCnt(0)
            }
        }
        impl core::fmt::Debug for EmdrstCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EmdrstCnt").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EmdrstCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EmdrstCnt {{ cnt: {=u32:?} }}", self.cnt())
            }
        }
        #[doc = "Embedded Reset Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EmdrstEn(pub u32);
        impl EmdrstEn {
            #[doc = "Embedded Reset Enable Register. 0 = Disable, 1 = Enable."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Embedded Reset Enable Register. 0 = Disable, 1 = Enable."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EmdrstEn {
            #[inline(always)]
            fn default() -> EmdrstEn {
                EmdrstEn(0)
            }
        }
        impl core::fmt::Debug for EmdrstEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EmdrstEn").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EmdrstEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EmdrstEn {{ en: {=bool:?} }}", self.en())
            }
        }
        #[doc = "Embedded Reset Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EmdrstSts(pub u32);
        impl EmdrstSts {
            #[doc = "Embedded Reset Status Register."]
            #[inline(always)]
            pub const fn sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Embedded Reset Status Register."]
            #[inline(always)]
            pub fn set_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EmdrstSts {
            #[inline(always)]
            fn default() -> EmdrstSts {
                EmdrstSts(0)
            }
        }
        impl core::fmt::Debug for EmdrstSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EmdrstSts").field("sts", &self.sts()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EmdrstSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EmdrstSts {{ sts: {=bool:?} }}", self.sts())
            }
        }
        #[doc = "Embedded Reset Timeout Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EmdrstTout(pub u32);
        impl EmdrstTout {
            #[doc = "Embedded Reset Timeout Register."]
            #[inline(always)]
            pub const fn tout(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Embedded Reset Timeout Register."]
            #[inline(always)]
            pub fn set_tout(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for EmdrstTout {
            #[inline(always)]
            fn default() -> EmdrstTout {
                EmdrstTout(0)
            }
        }
        impl core::fmt::Debug for EmdrstTout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EmdrstTout").field("tout", &self.tout()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EmdrstTout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EmdrstTout {{ tout: {=u8:?} }}", self.tout())
            }
        }
        #[doc = "BOOT ROM Scratch 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FwScr0(pub u32);
        impl FwScr0 {
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr0(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr0(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FwScr0 {
            #[inline(always)]
            fn default() -> FwScr0 {
                FwScr0(0)
            }
        }
        impl core::fmt::Debug for FwScr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FwScr0").field("scr0", &self.scr0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FwScr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FwScr0 {{ scr0: {=u32:?} }}", self.scr0())
            }
        }
        #[doc = "BOOT ROM Scratch 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FwScr1(pub u32);
        impl FwScr1 {
            #[doc = "UDS CRC status. 0 = UDS CRC checking disabled. Hardware POR state 1 = UDS CRC check passed, 2 = UDS CRC check failed, 3 = invalid. Can only get this result if UDS CRC feature not enabled and bits are set by application code."]
            #[inline(always)]
            pub const fn uds_crc_sts(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "UDS CRC status. 0 = UDS CRC checking disabled. Hardware POR state 1 = UDS CRC check passed, 2 = UDS CRC check failed, 3 = invalid. Can only get this result if UDS CRC feature not enabled and bits are set by application code."]
            #[inline(always)]
            pub fn set_uds_crc_sts(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr1(&self) -> u32 {
                let val = (self.0 >> 2usize) & 0x3fff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr1(&mut self, val: u32) {
                self.0 = (self.0 & !(0x3fff_ffff << 2usize)) | (((val as u32) & 0x3fff_ffff) << 2usize);
            }
        }
        impl Default for FwScr1 {
            #[inline(always)]
            fn default() -> FwScr1 {
                FwScr1(0)
            }
        }
        impl core::fmt::Debug for FwScr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FwScr1")
                    .field("uds_crc_sts", &self.uds_crc_sts())
                    .field("scr1", &self.scr1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FwScr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FwScr1 {{ uds_crc_sts: {=u8:?}, scr1: {=u32:?} }}",
                    self.uds_crc_sts(),
                    self.scr1()
                )
            }
        }
        #[doc = "BOOT ROM Scratch 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FwScr2(pub u32);
        impl FwScr2 {
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr2(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr2(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FwScr2 {
            #[inline(always)]
            fn default() -> FwScr2 {
                FwScr2(0)
            }
        }
        impl core::fmt::Debug for FwScr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FwScr2").field("scr2", &self.scr2()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FwScr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FwScr2 {{ scr2: {=u32:?} }}", self.scr2())
            }
        }
        #[doc = "BOOT ROM Scratch 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FwScr3(pub u32);
        impl FwScr3 {
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr3(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr3(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FwScr3 {
            #[inline(always)]
            fn default() -> FwScr3 {
                FwScr3(0)
            }
        }
        impl core::fmt::Debug for FwScr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FwScr3").field("scr3", &self.scr3()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FwScr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FwScr3 {{ scr3: {=u32:?} }}", self.scr3())
            }
        }
        #[doc = "GPIO Bank Power Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GpioBankPwr(pub u32);
        impl GpioBankPwr {
            #[doc = "This bit must be programmed to 0h for proper operation of the device."]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit must be programmed to 0h for proper operation of the device."]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Voltage value on VTR2. This bit is set by Firmware after a VTR Power On Reset. It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7. 1=VTR2 is powered by 1.8V 0=VTR2 is powered by 3.3V."]
            #[inline(always)]
            pub const fn vtr_lvl2(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Voltage value on VTR2. This bit is set by Firmware after a VTR Power On Reset. It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7. 1=VTR2 is powered by 1.8V 0=VTR2 is powered by 3.3V."]
            #[inline(always)]
            pub fn set_vtr_lvl2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "GPIO Bank Power Lock. 0: VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are R/W 1 = VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are Read Only."]
            #[inline(always)]
            pub const fn gpio_bank_pwr_lock(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO Bank Power Lock. 0: VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are R/W 1 = VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are Read Only."]
            #[inline(always)]
            pub fn set_gpio_bank_pwr_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for GpioBankPwr {
            #[inline(always)]
            fn default() -> GpioBankPwr {
                GpioBankPwr(0)
            }
        }
        impl core::fmt::Debug for GpioBankPwr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GpioBankPwr")
                    .field("test", &self.test())
                    .field("vtr_lvl2", &self.vtr_lvl2())
                    .field("gpio_bank_pwr_lock", &self.gpio_bank_pwr_lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GpioBankPwr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GpioBankPwr {{ test: {=bool:?}, vtr_lvl2: {=bool:?}, gpio_bank_pwr_lock: {=bool:?} }}",
                    self.test(),
                    self.vtr_lvl2(),
                    self.gpio_bank_pwr_lock()
                )
            }
        }
        #[doc = "JTAG Master Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMcfg(pub u32);
        impl JtagMcfg {
            #[doc = "This field determines the JTAG Master clock rate, derived from the 48MHz master clock. 7=375KHz; 6=750KHz; 5=1.5Mhz; 4=3Mhz; 3=6Mhz; 2=12Mhz; 1=24MHz; 0=Reserved."]
            #[inline(always)]
            pub const fn jtm_clk(&self) -> super::vals::JtmClk {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::JtmClk::from_bits(val as u8)
            }
            #[doc = "This field determines the JTAG Master clock rate, derived from the 48MHz master clock. 7=375KHz; 6=750KHz; 5=1.5Mhz; 4=3Mhz; 3=6Mhz; 2=12Mhz; 1=24MHz; 0=Reserved."]
            #[inline(always)]
            pub fn set_jtm_clk(&mut self, val: super::vals::JtmClk) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "This bit controls the direction of the JTAG port. 1=The JTAG Port is configured as a Master 0=The JTAG Port is configures as a Slave."]
            #[inline(always)]
            pub const fn mas_slv(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls the direction of the JTAG port. 1=The JTAG Port is configured as a Master 0=The JTAG Port is configures as a Slave."]
            #[inline(always)]
            pub fn set_mas_slv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for JtagMcfg {
            #[inline(always)]
            fn default() -> JtagMcfg {
                JtagMcfg(0)
            }
        }
        impl core::fmt::Debug for JtagMcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMcfg")
                    .field("jtm_clk", &self.jtm_clk())
                    .field("mas_slv", &self.mas_slv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "JtagMcfg {{ jtm_clk: {:?}, mas_slv: {=bool:?} }}",
                    self.jtm_clk(),
                    self.mas_slv()
                )
            }
        }
        #[doc = "JTAG Master Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMcmd(pub u32);
        impl JtagMcmd {
            #[doc = "If the JTAG Port is configured as a Master, writing this register starts clocking and shifting on the JTAG port. The JTAG Master port will shift JTM_COUNT+1 times, so writing a '0h' will shift 1 bit, and writing '31h' will shift 32 bits. The signal JTAG_CLK will cycle JTM_COUNT+1 times. The contents of the JTAG Master TMS Register and the JTAG Master TDI Register will be shifted out on the falling edge of JTAG_CLK and the.JTAG Master TDO Register will get shifted in on the rising edge of JTAG_CLK. If the JTAG Port is configured as a Slave, writing this register has no effect."]
            #[inline(always)]
            pub const fn jtm_count(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "If the JTAG Port is configured as a Master, writing this register starts clocking and shifting on the JTAG port. The JTAG Master port will shift JTM_COUNT+1 times, so writing a '0h' will shift 1 bit, and writing '31h' will shift 32 bits. The signal JTAG_CLK will cycle JTM_COUNT+1 times. The contents of the JTAG Master TMS Register and the JTAG Master TDI Register will be shifted out on the falling edge of JTAG_CLK and the.JTAG Master TDO Register will get shifted in on the rising edge of JTAG_CLK. If the JTAG Port is configured as a Slave, writing this register has no effect."]
            #[inline(always)]
            pub fn set_jtm_count(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for JtagMcmd {
            #[inline(always)]
            fn default() -> JtagMcmd {
                JtagMcmd(0)
            }
        }
        impl core::fmt::Debug for JtagMcmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMcmd")
                    .field("jtm_count", &self.jtm_count())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMcmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "JtagMcmd {{ jtm_count: {=u8:?} }}", self.jtm_count())
            }
        }
        #[doc = "JTAG Master Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMsts(pub u32);
        impl JtagMsts {
            #[doc = "This bit is set to '1b' when the JTAG Master Command Register is written. It becomes '0b' when shifting has completed. Software can poll this bit to determine when a command has completed and it is therefore safe to remove the data in the JTAG Master TDO Register and load new data into the JTAG Master TMS Register and the JTAG Master TDI Register."]
            #[inline(always)]
            pub const fn jtm_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the JTAG Master Command Register is written. It becomes '0b' when shifting has completed. Software can poll this bit to determine when a command has completed and it is therefore safe to remove the data in the JTAG Master TDO Register and load new data into the JTAG Master TMS Register and the JTAG Master TDI Register."]
            #[inline(always)]
            pub fn set_jtm_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for JtagMsts {
            #[inline(always)]
            fn default() -> JtagMsts {
                JtagMsts(0)
            }
        }
        impl core::fmt::Debug for JtagMsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMsts").field("jtm_done", &self.jtm_done()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "JtagMsts {{ jtm_done: {=bool:?} }}", self.jtm_done())
            }
        }
        #[doc = "JTAG Master TDI Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMtdi(pub u32);
        impl JtagMtdi {
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0, onto the JTAG_TDI pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub const fn jtm_tdi(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0, onto the JTAG_TDI pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub fn set_jtm_tdi(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for JtagMtdi {
            #[inline(always)]
            fn default() -> JtagMtdi {
                JtagMtdi(0)
            }
        }
        impl core::fmt::Debug for JtagMtdi {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMtdi").field("jtm_tdi", &self.jtm_tdi()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMtdi {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "JtagMtdi {{ jtm_tdi: {=u32:?} }}", self.jtm_tdi())
            }
        }
        #[doc = "JTAG Master TDO Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMtdo(pub u32);
        impl JtagMtdo {
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted into this register, starting with bit 0, from the JTAG_TDO pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub const fn jtm_tdo(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted into this register, starting with bit 0, from the JTAG_TDO pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub fn set_jtm_tdo(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for JtagMtdo {
            #[inline(always)]
            fn default() -> JtagMtdo {
                JtagMtdo(0)
            }
        }
        impl core::fmt::Debug for JtagMtdo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMtdo").field("jtm_tdo", &self.jtm_tdo()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMtdo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "JtagMtdo {{ jtm_tdo: {=u32:?} }}", self.jtm_tdo())
            }
        }
        #[doc = "JTAG Master TMS Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMtms(pub u32);
        impl JtagMtms {
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0, onto the JTAG_TMS pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub const fn jtm_tms(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0, onto the JTAG_TMS pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub fn set_jtm_tms(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for JtagMtms {
            #[inline(always)]
            fn default() -> JtagMtms {
                JtagMtms(0)
            }
        }
        impl core::fmt::Debug for JtagMtms {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMtms").field("jtm_tms", &self.jtm_tms()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMtms {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "JtagMtms {{ jtm_tms: {=u32:?} }}", self.jtm_tms())
            }
        }
        #[doc = "Lock Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OtpLock(pub u32);
        impl OtpLock {
            #[doc = "Test"]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Test"]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "VBAT RAM LOCK bit. 0 = Not Locked. 1 = Locked."]
            #[inline(always)]
            pub const fn vbat_ram_lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "VBAT RAM LOCK bit. 0 = Not Locked. 1 = Locked."]
            #[inline(always)]
            pub fn set_vbat_ram_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "VBAT REG LOCK. 0 = Not Locked. 1 = Locked."]
            #[inline(always)]
            pub const fn vbat_reg_lock(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "VBAT REG LOCK. 0 = Not Locked. 1 = Locked."]
            #[inline(always)]
            pub fn set_vbat_reg_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for OtpLock {
            #[inline(always)]
            fn default() -> OtpLock {
                OtpLock(0)
            }
        }
        impl core::fmt::Debug for OtpLock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OtpLock")
                    .field("test", &self.test())
                    .field("vbat_ram_lock", &self.vbat_ram_lock())
                    .field("vbat_reg_lock", &self.vbat_reg_lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OtpLock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "OtpLock {{ test: {=bool:?}, vbat_ram_lock: {=bool:?}, vbat_reg_lock: {=bool:?} }}",
                    self.test(),
                    self.vbat_ram_lock(),
                    self.vbat_reg_lock()
                )
            }
        }
        #[doc = "PECI Disable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PeciDis(pub u32);
        impl PeciDis {
            #[doc = "When this bit is asserted ('1'), it disables the PECI pads to reduce leakage."]
            #[inline(always)]
            pub const fn p_dis(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is asserted ('1'), it disables the PECI pads to reduce leakage."]
            #[inline(always)]
            pub fn set_p_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for PeciDis {
            #[inline(always)]
            fn default() -> PeciDis {
                PeciDis(0)
            }
        }
        impl core::fmt::Debug for PeciDis {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PeciDis").field("p_dis", &self.p_dis()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PeciDis {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PeciDis {{ p_dis: {=bool:?} }}", self.p_dis())
            }
        }
        #[doc = "SRAM Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SramCnfg(pub u8);
        impl SramCnfg {
            #[doc = "SRAM Configuration Register: 0: 384KB (352k Code, 32k Data) 1: 320kB (288k Code, 32k Data) 2: 256kB (224k Code, 32k Data) 3: Illegal 256kB (224k Code, 32k Data)"]
            #[inline(always)]
            pub const fn sram_size(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "SRAM Configuration Register: 0: 384KB (352k Code, 32k Data) 1: 320kB (288k Code, 32k Data) 2: 256kB (224k Code, 32k Data) 3: Illegal 256kB (224k Code, 32k Data)"]
            #[inline(always)]
            pub fn set_sram_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
        }
        impl Default for SramCnfg {
            #[inline(always)]
            fn default() -> SramCnfg {
                SramCnfg(0)
            }
        }
        impl core::fmt::Debug for SramCnfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SramCnfg")
                    .field("sram_size", &self.sram_size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SramCnfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SramCnfg {{ sram_size: {=u8:?} }}", self.sram_size())
            }
        }
        #[doc = "Virtual Wire Source Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VwSrcCngf(pub u32);
        impl VwSrcCngf {
            #[doc = "VWIRE_SOURCE \\[2\\], VWIRE_SOURCE \\[1\\], VWIRE_SOURCE \\[0\\]"]
            #[inline(always)]
            pub const fn vw_src(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "VWIRE_SOURCE \\[2\\], VWIRE_SOURCE \\[1\\], VWIRE_SOURCE \\[0\\]"]
            #[inline(always)]
            pub fn set_vw_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for VwSrcCngf {
            #[inline(always)]
            fn default() -> VwSrcCngf {
                VwSrcCngf(0)
            }
        }
        impl core::fmt::Debug for VwSrcCngf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VwSrcCngf").field("vw_src", &self.vw_src()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VwSrcCngf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VwSrcCngf {{ vw_src: {=u8:?} }}", self.vw_src())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IpBlkSwapEn {
            #[doc = "0=Disable."]
            DIS = 0x0,
            #[doc = "1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4, 0x0, 0xC, 0x8, ..."]
            SWAP_8_BYTE_BLOCK = 0x01,
            #[doc = "2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,..."]
            SWAP_16_BYTE_BLOCK = 0x02,
            #[doc = "3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C, 0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,..."]
            SWAP_64_BYTE_BLOCK = 0x03,
            #[doc = "4=Swap 32-bit doublewords in 128-byte blocks"]
            SWAP_128_BYTE_BLOCK = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl IpBlkSwapEn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IpBlkSwapEn {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IpBlkSwapEn {
            #[inline(always)]
            fn from(val: u8) -> IpBlkSwapEn {
                IpBlkSwapEn::from_bits(val)
            }
        }
        impl From<IpBlkSwapEn> for u8 {
            #[inline(always)]
            fn from(val: IpBlkSwapEn) -> u8 {
                IpBlkSwapEn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum JtmClk {
            _RESERVED_0 = 0x0,
            #[doc = "1=24MHz"]
            JTM_CLK_24MHZ = 0x01,
            #[doc = "2=12Mhz"]
            JTM_CLK_12MHZ = 0x02,
            #[doc = "3=6Mhz"]
            JTM_CLK_6MHZ = 0x03,
            #[doc = "4=3Mhz"]
            JTM_CLK_3MHZ = 0x04,
            #[doc = "5=1.5Mhz"]
            JTM_CLK_1MHZ = 0x05,
            #[doc = "6=750KHz"]
            JTM_CLK_750KHZ = 0x06,
            #[doc = "7=375KHz"]
            JTM_CLK_375KHZ = 0x07,
        }
        impl JtmClk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> JtmClk {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for JtmClk {
            #[inline(always)]
            fn from(val: u8) -> JtmClk {
                JtmClk::from_bits(val)
            }
        }
        impl From<JtmClk> for u8 {
            #[inline(always)]
            fn from(val: JtmClk) -> u8 {
                JtmClk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum OpBlkSwapEn {
            #[doc = "0=Disable."]
            DIS = 0x0,
            #[doc = "1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4, 0x0, 0xC, 0x8, ..."]
            SWAP_8_BYTE_BLOCK = 0x01,
            #[doc = "2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,..."]
            SWAP_16_BYTE_BLOCK = 0x02,
            #[doc = "3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C, 0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,..."]
            SWAP_64_BYTE_BLOCK = 0x03,
            #[doc = "4=Swap 32-bit doublewords in 128-byte blocks"]
            SWAP_128_BYTE_BLOCK = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl OpBlkSwapEn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> OpBlkSwapEn {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for OpBlkSwapEn {
            #[inline(always)]
            fn from(val: u8) -> OpBlkSwapEn {
                OpBlkSwapEn::from_bits(val)
            }
        }
        impl From<OpBlkSwapEn> for u8 {
            #[inline(always)]
            fn from(val: OpBlkSwapEn) -> u8 {
                OpBlkSwapEn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PinCfg {
            #[doc = "0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high. This setting should be used when the JTAG TAP controller is required for debugging."]
            JTAG_TCK_TMS_TDO_TDI = 0x0,
            #[doc = "1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) and Serial Wire Viewer (SWV) are both required for debugging"]
            JTAG_TCK_TMS_TDO = 0x01,
            #[doc = "2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required"]
            JTAG_TCK_TMS = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PinCfg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PinCfg {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PinCfg {
            #[inline(always)]
            fn from(val: u8) -> PinCfg {
                PinCfg::from_bits(val)
            }
        }
        impl From<PinCfg> for u8 {
            #[inline(always)]
            fn from(val: PinCfg) -> u8 {
                PinCfg::to_bits(val)
            }
        }
    }
}
pub mod ecia {
    #[doc = "The ECIA works in conjunction with the processor interrupt interface to handle hardware interrupts andd exceptions."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ecia {
        ptr: *mut u8,
    }
    unsafe impl Send for Ecia {}
    unsafe impl Sync for Ecia {}
    impl Ecia {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "GIRQ8 SOURCE"]
        #[inline(always)]
        pub const fn src8(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "GIRQ8 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set8(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "GIRQ8 RESULT"]
        #[inline(always)]
        pub const fn result8(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "GIRQ8 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr8(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "GIRQ9 SOURCE"]
        #[inline(always)]
        pub const fn src9(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "GIRQ9 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set9(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "GIRQ9 RESULT"]
        #[inline(always)]
        pub const fn result9(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "GIRQ9 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr9(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "GIRQ10 SOURCE"]
        #[inline(always)]
        pub const fn src10(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "GIRQ10 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set10(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "GIRQ10 RESULT"]
        #[inline(always)]
        pub const fn result10(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "GIRQ10 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr10(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "GIRQ11 SOURCE"]
        #[inline(always)]
        pub const fn src11(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "GIRQ11 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set11(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "GIRQ11 RESULT"]
        #[inline(always)]
        pub const fn result11(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "GIRQ11 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr11(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "GIRQ12 SOURCE"]
        #[inline(always)]
        pub const fn src12(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "GIRQ12 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set12(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "GIRQ12 RESULT"]
        #[inline(always)]
        pub const fn result12(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "GIRQ12 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr12(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "GIRQ13 SOURCE"]
        #[inline(always)]
        pub const fn src13(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "GIRQ13 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set13(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize) as _) }
        }
        #[doc = "GIRQ13 RESULT"]
        #[inline(always)]
        pub const fn result13(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6cusize) as _) }
        }
        #[doc = "GIRQ13 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr13(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "GIRQ14 SOURCE"]
        #[inline(always)]
        pub const fn src14(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "GIRQ14 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set14(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "GIRQ14 RESULT"]
        #[inline(always)]
        pub const fn result14(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "GIRQ14 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr14(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "GIRQ15 SOURCE"]
        #[inline(always)]
        pub const fn src15(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "GIRQ15 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set15(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "GIRQ15 RESULT"]
        #[inline(always)]
        pub const fn result15(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "GIRQ15 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr15(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "GIRQ16 SOURCE"]
        #[inline(always)]
        pub const fn src16(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "GIRQ16 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set16(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "GIRQ16 RESULT"]
        #[inline(always)]
        pub const fn result16(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "GIRQ16 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr16(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xacusize) as _) }
        }
        #[doc = "GIRQ17 SOURCE"]
        #[inline(always)]
        pub const fn src17(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb4usize) as _) }
        }
        #[doc = "GIRQ17 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set17(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb8usize) as _) }
        }
        #[doc = "GIRQ17 RESULT"]
        #[inline(always)]
        pub const fn result17(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xbcusize) as _) }
        }
        #[doc = "GIRQ17 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr17(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "GIRQ18 SOURCE"]
        #[inline(always)]
        pub const fn src18(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc8usize) as _) }
        }
        #[doc = "GIRQ18 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set18(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xccusize) as _) }
        }
        #[doc = "GIRQ18 RESULT"]
        #[inline(always)]
        pub const fn result18(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd0usize) as _) }
        }
        #[doc = "GIRQ18 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr18(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd4usize) as _) }
        }
        #[doc = "GIRQ19 SOURCE"]
        #[inline(always)]
        pub const fn src19(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdcusize) as _) }
        }
        #[doc = "GIRQ19 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set19(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize) as _) }
        }
        #[doc = "GIRQ19 RESULT"]
        #[inline(always)]
        pub const fn result19(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe4usize) as _) }
        }
        #[doc = "GIRQ19 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr19(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe8usize) as _) }
        }
        #[doc = "GIRQ20 SOURCE"]
        #[inline(always)]
        pub const fn src20(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf0usize) as _) }
        }
        #[doc = "GIRQ20 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set20(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf4usize) as _) }
        }
        #[doc = "GIRQ20 RESULT"]
        #[inline(always)]
        pub const fn result20(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf8usize) as _) }
        }
        #[doc = "GIRQ20 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr20(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xfcusize) as _) }
        }
        #[doc = "GIRQ21 SOURCE"]
        #[inline(always)]
        pub const fn src21(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "GIRQ21 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set21(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "GIRQ21 RESULT"]
        #[inline(always)]
        pub const fn result21(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "GIRQ21 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr21(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "GIRQ22 SOURCE"]
        #[inline(always)]
        pub const fn src22(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "GIRQ22 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set22(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "GIRQ22 RESULT"]
        #[inline(always)]
        pub const fn result22(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "GIRQ22 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr22(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "GIRQ23 SOURCE"]
        #[inline(always)]
        pub const fn src23(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
        }
        #[doc = "GIRQ23 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set23(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "GIRQ23 RESULT"]
        #[inline(always)]
        pub const fn result23(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
        #[doc = "GIRQ23 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr23(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "GIRQ24 SOURCE"]
        #[inline(always)]
        pub const fn src24(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[doc = "GIRQ24 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set24(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0144usize) as _) }
        }
        #[doc = "GIRQ24 RESULT"]
        #[inline(always)]
        pub const fn result24(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0148usize) as _) }
        }
        #[doc = "GIRQ24 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr24(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "GIRQ25 SOURCE"]
        #[inline(always)]
        pub const fn src25(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0154usize) as _) }
        }
        #[doc = "GIRQ25 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set25(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0158usize) as _) }
        }
        #[doc = "GIRQ25 RESULT"]
        #[inline(always)]
        pub const fn result25(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x015cusize) as _) }
        }
        #[doc = "GIRQ25 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr25(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0160usize) as _) }
        }
        #[doc = "GIRQ26 SOURCE"]
        #[inline(always)]
        pub const fn src26(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0168usize) as _) }
        }
        #[doc = "GIRQ26 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set26(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x016cusize) as _) }
        }
        #[doc = "GIRQ26 RESULT"]
        #[inline(always)]
        pub const fn result26(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0170usize) as _) }
        }
        #[doc = "GIRQ26 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr26(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0174usize) as _) }
        }
        #[doc = "Block Enable Set Register"]
        #[inline(always)]
        pub const fn blk_en_set(self) -> crate::common::Reg<regs::BlkEnSet, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Block Enable Clear Register."]
        #[inline(always)]
        pub const fn blk_en_clr(self) -> crate::common::Reg<regs::BlkEnClr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize) as _) }
        }
        #[doc = "Block IRQ Vector Register"]
        #[inline(always)]
        pub const fn blk_irq_vtor(self) -> crate::common::Reg<regs::BlkIrqVtor, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Block Enable Clear Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BlkEnClr(pub u32);
        impl BlkEnClr {
            #[doc = "Each GIRQx bit can be individually disabled to inhibit an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WC) 1=All interrupts in the GIRQx Source Register are disabled 0=No effect."]
            #[inline(always)]
            pub const fn vtor_en_clr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "Each GIRQx bit can be individually disabled to inhibit an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WC) 1=All interrupts in the GIRQx Source Register are disabled 0=No effect."]
            #[inline(always)]
            pub fn set_vtor_en_clr(&mut self, val: u32) {
                self.0 = (self.0 & !(0x7fff_ffff << 0usize)) | (((val as u32) & 0x7fff_ffff) << 0usize);
            }
        }
        impl Default for BlkEnClr {
            #[inline(always)]
            fn default() -> BlkEnClr {
                BlkEnClr(0)
            }
        }
        impl core::fmt::Debug for BlkEnClr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BlkEnClr")
                    .field("vtor_en_clr", &self.vtor_en_clr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BlkEnClr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BlkEnClr {{ vtor_en_clr: {=u32:?} }}", self.vtor_en_clr())
            }
        }
        #[doc = "Block Enable Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BlkEnSet(pub u32);
        impl BlkEnSet {
            #[doc = "Each GIRQx bit can be individually enabled to assert an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WS) 1=Interrupts in the GIRQx Source Register may be enabled 0=No effect."]
            #[inline(always)]
            pub const fn vtor_en_set(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "Each GIRQx bit can be individually enabled to assert an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WS) 1=Interrupts in the GIRQx Source Register may be enabled 0=No effect."]
            #[inline(always)]
            pub fn set_vtor_en_set(&mut self, val: u32) {
                self.0 = (self.0 & !(0x7fff_ffff << 0usize)) | (((val as u32) & 0x7fff_ffff) << 0usize);
            }
        }
        impl Default for BlkEnSet {
            #[inline(always)]
            fn default() -> BlkEnSet {
                BlkEnSet(0)
            }
        }
        impl core::fmt::Debug for BlkEnSet {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BlkEnSet")
                    .field("vtor_en_set", &self.vtor_en_set())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BlkEnSet {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BlkEnSet {{ vtor_en_set: {=u32:?} }}", self.vtor_en_set())
            }
        }
        #[doc = "Block IRQ Vector Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BlkIrqVtor(pub u32);
        impl BlkIrqVtor {
            #[doc = "Each bit in this field reports the status of the group GIRQ interrupt assertion to the NVIC. If the GIRQx interrupt is disabled as a group, by the Block Enable Clear Register, then the corresponding bit will be '0'b and no interrupt will be asserted."]
            #[inline(always)]
            pub const fn vtor(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x01ff_ffff;
                val as u32
            }
            #[doc = "Each bit in this field reports the status of the group GIRQ interrupt assertion to the NVIC. If the GIRQx interrupt is disabled as a group, by the Block Enable Clear Register, then the corresponding bit will be '0'b and no interrupt will be asserted."]
            #[inline(always)]
            pub fn set_vtor(&mut self, val: u32) {
                self.0 = (self.0 & !(0x01ff_ffff << 0usize)) | (((val as u32) & 0x01ff_ffff) << 0usize);
            }
        }
        impl Default for BlkIrqVtor {
            #[inline(always)]
            fn default() -> BlkIrqVtor {
                BlkIrqVtor(0)
            }
        }
        impl core::fmt::Debug for BlkIrqVtor {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BlkIrqVtor").field("vtor", &self.vtor()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BlkIrqVtor {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BlkIrqVtor {{ vtor: {=u32:?} }}", self.vtor())
            }
        }
    }
}
pub mod emi0 {
    #[doc = "The EMI provides a communication between system host and Embedded Controller."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Emi0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Emi0 {}
    unsafe impl Sync for Emi0 {}
    impl Emi0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Host-to-EC Mailbox Register"]
        #[inline(always)]
        pub const fn rt_host2ec(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "EC-to-Host Mailbox Register"]
        #[inline(always)]
        pub const fn rt_ec2host(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "EC Address Access Control Register"]
        #[inline(always)]
        pub const fn rt_ec_addr_lsb(self) -> crate::common::Reg<regs::RtEcAddrLsb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "EC Address Access Control Register"]
        #[inline(always)]
        pub const fn rt_ec_addr_msb(self) -> crate::common::Reg<regs::RtEcAddrMsb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "EC Data Byte Register"]
        #[inline(always)]
        pub const fn rt_data(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Interrupt Source LSB Register"]
        #[inline(always)]
        pub const fn rt_intr_src_lsb(self) -> crate::common::Reg<regs::RtIntrSrcLsb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Interrupt Source MSB Register"]
        #[inline(always)]
        pub const fn rt_intr_src_msb(self) -> crate::common::Reg<regs::RtIntrSrcMsb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "Interrupt Mask LSB Register"]
        #[inline(always)]
        pub const fn rt_intr_mask_lsb(self) -> crate::common::Reg<regs::RtIntrMaskLsb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Interrupt Mask MSB Register"]
        #[inline(always)]
        pub const fn rt_intr_mask_msb(self) -> crate::common::Reg<regs::RtIntrMaskMsb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "Application ID Register, APPLICATION_ID When this field is 00h it can be written with any value. When set to a non-zero value, writing that value will clear this register to 00h. When set to a non-zero value, writing any value other than the current contents will have no effect."]
        #[inline(always)]
        pub const fn rt_app_id(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Application ID Assignment Register."]
        #[inline(always)]
        pub const fn app_id_asgn(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Host-to-EC Mailbox Register, 8-bit mailbox used communicate information from the system host to the embedded controller. Writing this register generates an event to notify the embedded controller. (R/WC)"]
        #[inline(always)]
        pub const fn host2ec(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "EC-to-Host Mailbox Register, 8-bit mailbox used communicate information from the embedded controller to the system host. Writing this register generates an event to notify the system host."]
        #[inline(always)]
        pub const fn ec2host(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0101usize) as _) }
        }
        #[doc = "Memory Base Address 0 Register \\[31:2\\] This memory base address defines the beginning of region 0 in the Embedded Controller's 32-bit internal address space. Memory allocated to region 0 is intended to be shared between the Host and the EC. The region defined by this base register is used when bit 15 of the EC Address Register is 0. The access will be to a memory location at an offset defined by the EC_Address relative to the beginning of the region defined by this register. Therefore, a read or write to the memory that is triggered by the EC Data Register will occur at Memory_Base_Address_0 + EC_Address."]
        #[inline(always)]
        pub const fn mem0_base(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Memory Read Limit 0 Register \\[14:2\\] Whenever a read of any byte in the EC Data Register is attempted, and bit 15 of EC_Address is 0, the field EC_Address\\[14:2\\] in the EC_Address_Register is compared to this field. As long as EC_Address\\[14:2\\] is less than this field the EC_Data_Register will be loaded from the 24-bit internal address space."]
        #[inline(always)]
        pub const fn mem0_rd_limits(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Memory Write Limit 0 Register \\[14:2\\] Whenever a write of any byte in EC DATA Register is attempted and bit 15 of EC_Address is 0, the field EC_ADDRESS_MSB in the EC_Address Register is compared to this field. As long as EC_Address\\[14:2\\] is less than Memory_Write_Limit_0\\[14:2\\] the addressed bytes in the EC DATA Register will be written into the internal 24-bit address space. If EC_Address\\[14:2\\] is greater than or equal to the Memory_Write_Limit_0\\[14:2\\] no writes will take place."]
        #[inline(always)]
        pub const fn mem0_wr_limits(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010ausize) as _) }
        }
        #[doc = "Memory Base Address 1 Register. \\[31:2\\] This memory base address defines the beginning of region 1 in the Embedded Controller's 32-bit internal address space. Memory allocated to region 1 is intended to be shared between the Host and the EC. The region defined by this base register is used when bit 15 of the EC Address Register is 1. The access will be to a memory location at an offset defined by the EC_Address relative to the beginning of the region defined by this register. Therefore, a read or write to the memory that is triggered by the EC Data Register will occur at Memory_Base_Address_1 + EC_Address."]
        #[inline(always)]
        pub const fn mem1_base(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Memory Read Limit 1 Register, \\[14:2\\]: Whenever a read of any byte in the EC Data Register is attempted, and bit 15 of EC_ADDRESS is 1, the field EC_ADDRESS in the EC_Address_Register is compared to this field. As long as EC_ADDRESS is less than this value, the EC_Data_Register will be loaded from the 24-bit internal address space."]
        #[inline(always)]
        pub const fn mem1_rd_limits(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Memory Write Limit 1 Register, \\[14:2\\]: Whenever a write of any byte in EC DATA Register is attempted and bit 15 of EC_Address is 1, the field EC_Address\\[14:2\\] in the EC_Address Register is compared to this field. As long as EC_Address\\[14:2\\] is less than Memory_Write_Limit_1\\[14:2\\] the addressed bytes in the EC DATA Register will be written into the internal 24-bit address space. If EC_Address\\[14:2\\] is greater than or equal to the Memory_Write_Limit_1\\[14:2\\] no writes will take place."]
        #[inline(always)]
        pub const fn mem1_wr_limits(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0112usize) as _) }
        }
        #[doc = "15:1\\] Interrupt Set Register, Writing a bit in this field with a '1b' sets the corresponding bit in the Interrupt Source Register to '1b'. Writing a bit in this field with a '0b' has no effect. Reading this field returns the current contents of the Interrupt Source Register."]
        #[inline(always)]
        pub const fn intr_set(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "15:1\\] Host Clear Enable Register, When a bit in this field is '0b', the corresponding bit in the Interrupt Source Register cannot be cleared by writes to the Interrupt Source Register. When a bit in this field is '1b', the corresponding bit in the Interrupt Source Register can be cleared when that register bit is written with a '1b'."]
        #[inline(always)]
        pub const fn host_clr_en(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0116usize) as _) }
        }
        #[doc = "Application ID Status register \\[31:0\\]"]
        #[inline(always)]
        pub const fn app_id_sts0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Application ID Status register \\[63:32\\]"]
        #[inline(always)]
        pub const fn app_id_sts1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Application ID Status register \\[95:64\\]"]
        #[inline(always)]
        pub const fn app_id_sts2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize) as _) }
        }
        #[doc = "Application ID Status register \\[127:96\\]"]
        #[inline(always)]
        pub const fn app_id_sts3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
        }
        #[doc = "Application ID Status register \\[159:128\\]"]
        #[inline(always)]
        pub const fn app_id_sts4(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Application ID Status register \\[191:160\\]"]
        #[inline(always)]
        pub const fn app_id_sts5(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
        #[doc = "Application ID Status register \\[223:192\\]"]
        #[inline(always)]
        pub const fn app_id_sts6(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "Application ID Status register \\[255:224\\]"]
        #[inline(always)]
        pub const fn app_id_sts7(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "EC Address Access Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtEcAddrLsb(pub u8);
        impl RtEcAddrLsb {
            #[doc = "This field defines the type of access that occurs when the EC Data Register is read or written. 11b=Auto-increment 32-bit access. 10b=32-bit access. 01b=16-bit access. 00b=8-bit access."]
            #[inline(always)]
            pub const fn access_type(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This field defines the type of access that occurs when the EC Data Register is read or written. 11b=Auto-increment 32-bit access. 10b=32-bit access. 01b=16-bit access. 00b=8-bit access."]
            #[inline(always)]
            pub fn set_access_type(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "This field defines bits\\[7:2\\] of EC_Address \\[15:0\\]. Bits\\[1:0\\] of the EC_Address are always forced to 00b. The EC_Address is aligned on a DWord boundary. It is the address of the memory being accessed by EC Data Byte 0 Register, which is an offset from the programmed base address of the selected REGION."]
            #[inline(always)]
            pub const fn addr(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x3f;
                val as u8
            }
            #[doc = "This field defines bits\\[7:2\\] of EC_Address \\[15:0\\]. Bits\\[1:0\\] of the EC_Address are always forced to 00b. The EC_Address is aligned on a DWord boundary. It is the address of the memory being accessed by EC Data Byte 0 Register, which is an offset from the programmed base address of the selected REGION."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u8) & 0x3f) << 2usize);
            }
        }
        impl Default for RtEcAddrLsb {
            #[inline(always)]
            fn default() -> RtEcAddrLsb {
                RtEcAddrLsb(0)
            }
        }
        impl core::fmt::Debug for RtEcAddrLsb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtEcAddrLsb")
                    .field("access_type", &self.access_type())
                    .field("addr", &self.addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtEcAddrLsb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RtEcAddrLsb {{ access_type: {=u8:?}, addr: {=u8:?} }}",
                    self.access_type(),
                    self.addr()
                )
            }
        }
        #[doc = "EC Address Access Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtEcAddrMsb(pub u8);
        impl RtEcAddrMsb {
            #[doc = "This field defines bits\\[14:8\\] of EC_Address. Bits\\[1:0\\] of the EC_Address are always forced to 00b. The EC_Address is aligned on a DWord boundary. It is the address of the memory being accessed by EC Data Byte 0 Register, which is an offset from the programmed base address of the selected REGION."]
            #[inline(always)]
            pub const fn addr(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x1f;
                val as u8
            }
            #[doc = "This field defines bits\\[14:8\\] of EC_Address. Bits\\[1:0\\] of the EC_Address are always forced to 00b. The EC_Address is aligned on a DWord boundary. It is the address of the memory being accessed by EC Data Byte 0 Register, which is an offset from the programmed base address of the selected REGION."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 2usize)) | (((val as u8) & 0x1f) << 2usize);
            }
            #[doc = "The field specifies which of two segments in the 32-bit internal address space is to be accessed by the EC_Address\\[14:2\\] to generate accesses to the memory. 1=The address defined by EC_Address\\[14:2\\] is relative to the base address specified by the Memory Base Address 1 Register. 0=The address defined by EC_Address\\[14:2\\] is relative to the base address specified by the Memory Base Address 0 Register."]
            #[inline(always)]
            pub const fn region(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The field specifies which of two segments in the 32-bit internal address space is to be accessed by the EC_Address\\[14:2\\] to generate accesses to the memory. 1=The address defined by EC_Address\\[14:2\\] is relative to the base address specified by the Memory Base Address 1 Register. 0=The address defined by EC_Address\\[14:2\\] is relative to the base address specified by the Memory Base Address 0 Register."]
            #[inline(always)]
            pub fn set_region(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for RtEcAddrMsb {
            #[inline(always)]
            fn default() -> RtEcAddrMsb {
                RtEcAddrMsb(0)
            }
        }
        impl core::fmt::Debug for RtEcAddrMsb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtEcAddrMsb")
                    .field("addr", &self.addr())
                    .field("region", &self.region())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtEcAddrMsb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RtEcAddrMsb {{ addr: {=u8:?}, region: {=bool:?} }}",
                    self.addr(),
                    self.region()
                )
            }
        }
        #[doc = "Interrupt Mask LSB Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtIntrMaskLsb(pub u8);
        impl RtIntrMaskLsb {
            #[doc = "Test Bit."]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Test Bit."]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "EC Software Interrupt Enable Least Significant Bits. Each bit that is set to '1b' in this field enables the generation of a Host Event interrupt by the corresponding bit in the EC_SWI field in the Interrupt Source LSB Register."]
            #[inline(always)]
            pub const fn ec_swi_en_lsb(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "EC Software Interrupt Enable Least Significant Bits. Each bit that is set to '1b' in this field enables the generation of a Host Event interrupt by the corresponding bit in the EC_SWI field in the Interrupt Source LSB Register."]
            #[inline(always)]
            pub fn set_ec_swi_en_lsb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for RtIntrMaskLsb {
            #[inline(always)]
            fn default() -> RtIntrMaskLsb {
                RtIntrMaskLsb(0)
            }
        }
        impl core::fmt::Debug for RtIntrMaskLsb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtIntrMaskLsb")
                    .field("test", &self.test())
                    .field("ec_swi_en_lsb", &self.ec_swi_en_lsb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtIntrMaskLsb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RtIntrMaskLsb {{ test: {=bool:?}, ec_swi_en_lsb: {=u8:?} }}",
                    self.test(),
                    self.ec_swi_en_lsb()
                )
            }
        }
        #[doc = "Interrupt Mask MSB Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtIntrMaskMsb(pub u8);
        impl RtIntrMaskMsb {
            #[doc = "EC Software Interrupt Enable Most Significant Bits. Each bit that is set to '1b' in this field enables the generation of a Host Event interrupt by the corresponding bit in the EC_SWI field in the Interrupt Source MSB Register."]
            #[inline(always)]
            pub const fn ec_swi_en_msb(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "EC Software Interrupt Enable Most Significant Bits. Each bit that is set to '1b' in this field enables the generation of a Host Event interrupt by the corresponding bit in the EC_SWI field in the Interrupt Source MSB Register."]
            #[inline(always)]
            pub fn set_ec_swi_en_msb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for RtIntrMaskMsb {
            #[inline(always)]
            fn default() -> RtIntrMaskMsb {
                RtIntrMaskMsb(0)
            }
        }
        impl core::fmt::Debug for RtIntrMaskMsb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtIntrMaskMsb")
                    .field("ec_swi_en_msb", &self.ec_swi_en_msb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtIntrMaskMsb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RtIntrMaskMsb {{ ec_swi_en_msb: {=u8:?} }}", self.ec_swi_en_msb())
            }
        }
        #[doc = "Interrupt Source LSB Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtIntrSrcLsb(pub u8);
        impl RtIntrSrcLsb {
            #[doc = "EC Mailbox Write. This bit is set when the EC-to-HOST Mailbox Register has been written by the EC at offset 01h of the EC-Only registers. Note: there is no corresponding mask bit in the Interrupt Mask LSB Register."]
            #[inline(always)]
            pub const fn ec_wr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "EC Mailbox Write. This bit is set when the EC-to-HOST Mailbox Register has been written by the EC at offset 01h of the EC-Only registers. Note: there is no corresponding mask bit in the Interrupt Mask LSB Register."]
            #[inline(always)]
            pub fn set_ec_wr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "EC Software Interrupt Least Significant Bits. These bits are software interrupt bits that may be set by the EC to notify the host of an event. The meaning of these bits is dependent on the firmware implementation. Each bit in this field is cleared when written with a '1b'. The ability to clear the bit can be disabled by the EC if the corresponding bit in the Host Clear Enable Register is set to '0b'. This may be used by firmware for events that cannot be cleared while the event is still active."]
            #[inline(always)]
            pub const fn ec_swi_lsb(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "EC Software Interrupt Least Significant Bits. These bits are software interrupt bits that may be set by the EC to notify the host of an event. The meaning of these bits is dependent on the firmware implementation. Each bit in this field is cleared when written with a '1b'. The ability to clear the bit can be disabled by the EC if the corresponding bit in the Host Clear Enable Register is set to '0b'. This may be used by firmware for events that cannot be cleared while the event is still active."]
            #[inline(always)]
            pub fn set_ec_swi_lsb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for RtIntrSrcLsb {
            #[inline(always)]
            fn default() -> RtIntrSrcLsb {
                RtIntrSrcLsb(0)
            }
        }
        impl core::fmt::Debug for RtIntrSrcLsb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtIntrSrcLsb")
                    .field("ec_wr", &self.ec_wr())
                    .field("ec_swi_lsb", &self.ec_swi_lsb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtIntrSrcLsb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RtIntrSrcLsb {{ ec_wr: {=bool:?}, ec_swi_lsb: {=u8:?} }}",
                    self.ec_wr(),
                    self.ec_swi_lsb()
                )
            }
        }
        #[doc = "Interrupt Source MSB Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtIntrSrcMsb(pub u8);
        impl RtIntrSrcMsb {
            #[doc = "EC Software Interrupt Most Significant Bits. These bits are software interrupt bits that may be set by the EC to notify the host of an event. The meaning of these bits is dependent on the firmware implementation. Each bit in this field is cleared when written with a '1b'. The ability to clear the bit can be disabled by the EC if the corresponding bit in the Host Clear Enable Register is set to '0b'. This may be used by firmware for events that cannot be cleared while the event is still active."]
            #[inline(always)]
            pub const fn ec_swi_msb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "EC Software Interrupt Most Significant Bits. These bits are software interrupt bits that may be set by the EC to notify the host of an event. The meaning of these bits is dependent on the firmware implementation. Each bit in this field is cleared when written with a '1b'. The ability to clear the bit can be disabled by the EC if the corresponding bit in the Host Clear Enable Register is set to '0b'. This may be used by firmware for events that cannot be cleared while the event is still active."]
            #[inline(always)]
            pub fn set_ec_swi_msb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for RtIntrSrcMsb {
            #[inline(always)]
            fn default() -> RtIntrSrcMsb {
                RtIntrSrcMsb(0)
            }
        }
        impl core::fmt::Debug for RtIntrSrcMsb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtIntrSrcMsb")
                    .field("ec_swi_msb", &self.ec_swi_msb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtIntrSrcMsb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RtIntrSrcMsb {{ ec_swi_msb: {=u8:?} }}", self.ec_swi_msb())
            }
        }
    }
}
pub mod espi_io {
    #[doc = "The ESPI is used by the system host to configure the chip and communicate with the logical devices implemented in the design."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EspiIo {
        ptr: *mut u8,
    }
    unsafe impl Send for EspiIo {}
    unsafe impl Sync for EspiIo {}
    impl EspiIo {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The INDEX register, which is part of the Configuration Port, is used as a pointer to a Configuration Register Address."]
        #[inline(always)]
        pub const fn ind(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "The DATA register, which is part of the Configuration Port, is used to read or write data to the register currently being selected by the INDEX Register."]
        #[inline(always)]
        pub const fn dat_reg(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Peripheral Channel Last Cycle Register (DWord 0)"]
        #[inline(always)]
        pub const fn pc_lc_addr_lsw(self) -> crate::common::Reg<regs::PcLcAddrLsw, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Peripheral Channel Last Cycle Register (DWord 1)"]
        #[inline(always)]
        pub const fn pc_lc_addr_msw(self) -> crate::common::Reg<regs::PcLcAddrMsw, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Peripheral Channel Last Cycle Register (DWord 2)"]
        #[inline(always)]
        pub const fn pc_lc_len_type_tag(self) -> crate::common::Reg<regs::PcLcLenTypeTag, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Peripheral Channel Error Address Register (DWord 0)"]
        #[inline(always)]
        pub const fn pc_err_addr_lsw(self) -> crate::common::Reg<regs::PcErrAddrLsw, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Peripheral Channel Error Address Register (DWord 1)"]
        #[inline(always)]
        pub const fn pc_err_addr_msw(self) -> crate::common::Reg<regs::PcErrAddrMsw, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Peripheral Channel Status Register"]
        #[inline(always)]
        pub const fn pc_status(self) -> crate::common::Reg<regs::PcStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Peripheral Channel Interrupt Enable Register"]
        #[inline(always)]
        pub const fn pc_ien(self) -> crate::common::Reg<regs::PcIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "BAR Inhibit Register (DWord 0)"]
        #[inline(always)]
        pub const fn iobar_inh_lsw(self) -> crate::common::Reg<regs::IobarInhLsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "BAR Inhibit Register (DWord 1)"]
        #[inline(always)]
        pub const fn iobar_inh_msw(self) -> crate::common::Reg<regs::IobarInhMsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "eSPI BAR Init Register"]
        #[inline(always)]
        pub const fn iobar_init(self) -> crate::common::Reg<regs::IobarInit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize) as _) }
        }
        #[doc = "EC IRQ Register"]
        #[inline(always)]
        pub const fn ec_ctrl_irq(self) -> crate::common::Reg<regs::EcCtrlIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
        }
        #[doc = "eSPI I/O Base Address Register"]
        #[inline(always)]
        pub const fn base_addr(self) -> crate::common::Reg<regs::BaseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
        #[doc = "eSPI Memory Base Address Register"]
        #[inline(always)]
        pub const fn espi_mem_base_addr(self) -> crate::common::Reg<regs::EspiMemBaseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "Mailbox BAR Register"]
        #[inline(always)]
        pub const fn mbx_base_addr(self) -> crate::common::Reg<regs::MbxBaseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013cusize) as _) }
        }
        #[doc = "8042 Emulated Keyboard Controller BAR Register"]
        #[inline(always)]
        pub const fn em8042_base_addr(self) -> crate::common::Reg<regs::Em8042baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[doc = "ACPI EC Channel 0 Register"]
        #[inline(always)]
        pub const fn acpi_ec_0_base_addr(self) -> crate::common::Reg<regs::AcpiEc0baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0144usize) as _) }
        }
        #[doc = "ACPI EC Channel 1 BAR Register"]
        #[inline(always)]
        pub const fn acpi_ec_1_base_addr(self) -> crate::common::Reg<regs::AcpiEc1baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0148usize) as _) }
        }
        #[doc = "ACPI EC Channel 2 BAR Register"]
        #[inline(always)]
        pub const fn acpi_ec_2_base_addr(self) -> crate::common::Reg<regs::AcpiEc2baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "ACPI EC Channel 3 BAR Register"]
        #[inline(always)]
        pub const fn acpi_ec_3_base_addr(self) -> crate::common::Reg<regs::AcpiEc3baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0150usize) as _) }
        }
        #[doc = "ACPI EC Channel 4 BAR Register"]
        #[inline(always)]
        pub const fn acpi_ec_4_base_addr(self) -> crate::common::Reg<regs::AcpiEc4baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0154usize) as _) }
        }
        #[doc = "I/O Base Address Register"]
        #[inline(always)]
        pub const fn acpi_pm1_base_addr(self) -> crate::common::Reg<regs::AcpiPm1baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0158usize) as _) }
        }
        #[doc = "Legacy (Fast Keyboard) BAR Register"]
        #[inline(always)]
        pub const fn fast_kdb_base_addr(self) -> crate::common::Reg<regs::FastKdbBaseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x015cusize) as _) }
        }
        #[doc = "UART 0 BAR Register"]
        #[inline(always)]
        pub const fn uart_0_base_addr(self) -> crate::common::Reg<regs::Uart0baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0160usize) as _) }
        }
        #[doc = "UART 1 BAR Register"]
        #[inline(always)]
        pub const fn uart_1_base_addr(self) -> crate::common::Reg<regs::Uart1baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0164usize) as _) }
        }
        #[doc = "Embedded Memory Interface (EMI) 0 BAR Register"]
        #[inline(always)]
        pub const fn emi_0_base_addr(self) -> crate::common::Reg<regs::Emi0baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0168usize) as _) }
        }
        #[doc = "Embedded Memory Interface (EMI) 1 BAR Register"]
        #[inline(always)]
        pub const fn emi_1_base_addr(self) -> crate::common::Reg<regs::Emi1baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x016cusize) as _) }
        }
        #[doc = "Embedded Memory Interface (EMI) 2 BAR Register"]
        #[inline(always)]
        pub const fn emi_2_base_addr(self) -> crate::common::Reg<regs::Emi2baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0170usize) as _) }
        }
        #[doc = "BIOS Debug Port (Port 80) 0 BAR Register"]
        #[inline(always)]
        pub const fn port80_0_base_addr(self) -> crate::common::Reg<regs::Port800baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0174usize) as _) }
        }
        #[doc = "BIOS Debug Port (Port 80) 1 BAR Register"]
        #[inline(always)]
        pub const fn port80_1_base_addr(self) -> crate::common::Reg<regs::Port801baseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0178usize) as _) }
        }
        #[doc = "RTC Base Address Register"]
        #[inline(always)]
        pub const fn rtc_base_addr(self) -> crate::common::Reg<regs::RtcBaseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x017cusize) as _) }
        }
        #[doc = "GLUE Base Address Register"]
        #[inline(always)]
        pub const fn glue_base_addr(self) -> crate::common::Reg<regs::GlueBaseAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "LTR Peripheral Status Register"]
        #[inline(always)]
        pub const fn ltr_sts(self) -> crate::common::Reg<regs::LtrSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0220usize) as _) }
        }
        #[doc = "LTR Peripheral Enable Register"]
        #[inline(always)]
        pub const fn ltr_en(self) -> crate::common::Reg<regs::LtrEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0224usize) as _) }
        }
        #[doc = "LTR Peripheral Control Register"]
        #[inline(always)]
        pub const fn ltr_ctrl(self) -> crate::common::Reg<regs::LtrCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0228usize) as _) }
        }
        #[doc = "LTR Peripheral Message Register"]
        #[inline(always)]
        pub const fn ltr_mesg(self) -> crate::common::Reg<regs::LtrMesg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x022cusize) as _) }
        }
        #[doc = "OOB Channel Receive Address Register"]
        #[inline(always)]
        pub const fn oob_rx_addr_lsw(self) -> crate::common::Reg<regs::OobRxAddrLsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0240usize) as _) }
        }
        #[doc = "OOB Channel Transmit Address Register"]
        #[inline(always)]
        pub const fn oob_tx_addr_lsw(self) -> crate::common::Reg<regs::OobTxAddrLsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0248usize) as _) }
        }
        #[doc = "OOB Channel Receive Length Register"]
        #[inline(always)]
        pub const fn oob_rx_len(self) -> crate::common::Reg<regs::OobRxLen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0250usize) as _) }
        }
        #[doc = "OOB Channel Transmit Length Register"]
        #[inline(always)]
        pub const fn oob_tx_len(self) -> crate::common::Reg<regs::OobTxLen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0254usize) as _) }
        }
        #[doc = "OOB Channel Receive Control Register"]
        #[inline(always)]
        pub const fn oob_rx_ctrl(self) -> crate::common::Reg<regs::OobRxCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0258usize) as _) }
        }
        #[doc = "OOB Channel Receive Interrupt Enable Register"]
        #[inline(always)]
        pub const fn oob_rx_ien(self) -> crate::common::Reg<regs::OobRxIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x025cusize) as _) }
        }
        #[doc = "OOB Channel Receive Status Register"]
        #[inline(always)]
        pub const fn oob_rx_sts(self) -> crate::common::Reg<regs::OobRxSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0260usize) as _) }
        }
        #[doc = "OOB Channel Transmit Control Register"]
        #[inline(always)]
        pub const fn oob_tx_ctrl(self) -> crate::common::Reg<regs::OobTxCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0264usize) as _) }
        }
        #[doc = "OOB Channel Transmit Interrupt Enable Register"]
        #[inline(always)]
        pub const fn oob_tx_ien(self) -> crate::common::Reg<regs::OobTxIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0268usize) as _) }
        }
        #[doc = "OOB Channel Transmit Status Register"]
        #[inline(always)]
        pub const fn oob_tx_sts(self) -> crate::common::Reg<regs::OobTxSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x026cusize) as _) }
        }
        #[doc = "Flash Access Channel Flash Address Register"]
        #[inline(always)]
        pub const fn fc_flash_addr_lsw(self) -> crate::common::Reg<regs::FcFlashAddrLsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0280usize) as _) }
        }
        #[doc = "Flash Access Channel Buffer Address Register"]
        #[inline(always)]
        pub const fn fc_buf_addr_lsw(self) -> crate::common::Reg<regs::FcBufAddrLsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0288usize) as _) }
        }
        #[doc = "Flash Access Channel Transfer Length Register"]
        #[inline(always)]
        pub const fn fc_xfr_len(self) -> crate::common::Reg<regs::FcXfrLen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0290usize) as _) }
        }
        #[doc = "Flash Access Channel Control Register"]
        #[inline(always)]
        pub const fn fc_ctrl(self) -> crate::common::Reg<regs::FcCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0294usize) as _) }
        }
        #[doc = "Flash Access Channel Interrupt Enable Register"]
        #[inline(always)]
        pub const fn fc_ien(self) -> crate::common::Reg<regs::FcIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0298usize) as _) }
        }
        #[doc = "Flash Access Channel Configuration Register"]
        #[inline(always)]
        pub const fn fc_cfg(self) -> crate::common::Reg<regs::FcCfg, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x029cusize) as _) }
        }
        #[doc = "Flash Access Channel Status Register"]
        #[inline(always)]
        pub const fn fc_sts(self) -> crate::common::Reg<regs::FcSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02a0usize) as _) }
        }
        #[doc = "Virtual Wire Status Register"]
        #[inline(always)]
        pub const fn vw_en_sts(self) -> crate::common::Reg<regs::VwEnSts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02b0usize) as _) }
        }
        #[doc = "eSPI Capabilities ID Register"]
        #[inline(always)]
        pub const fn cap_id(self) -> crate::common::Reg<regs::CapId, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02e0usize) as _) }
        }
        #[doc = "eSPI Capabilities Global Capabilities 0 Register"]
        #[inline(always)]
        pub const fn glb_cap0(self) -> crate::common::Reg<regs::GlbCap0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02e1usize) as _) }
        }
        #[doc = "eSPI Capabilities Global Capabilities 1 Register"]
        #[inline(always)]
        pub const fn glb_cap1(self) -> crate::common::Reg<regs::GlbCap1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02e2usize) as _) }
        }
        #[doc = "eSPI Peripheral Channel Capabilities Register"]
        #[inline(always)]
        pub const fn pc_cap(self) -> crate::common::Reg<regs::PcCap, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02e3usize) as _) }
        }
        #[doc = "eSPI Virtual Wire Channel Capabilities Register"]
        #[inline(always)]
        pub const fn vw_cap(self) -> crate::common::Reg<regs::VwCap, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02e4usize) as _) }
        }
        #[doc = "eSPI OOB Channel Capabilities Register"]
        #[inline(always)]
        pub const fn oob_cap(self) -> crate::common::Reg<regs::OobCap, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02e5usize) as _) }
        }
        #[doc = "eSPI Flash Channel Capabilities Register"]
        #[inline(always)]
        pub const fn fc_cap(self) -> crate::common::Reg<regs::FcCap, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02e6usize) as _) }
        }
        #[doc = "eSPI Peripheral Channel Ready Register"]
        #[inline(always)]
        pub const fn pc_ready(self) -> crate::common::Reg<regs::PcReady, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02e7usize) as _) }
        }
        #[doc = "eSPI OOB Channel Ready Register"]
        #[inline(always)]
        pub const fn oob_ready(self) -> crate::common::Reg<regs::OobReady, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02e8usize) as _) }
        }
        #[doc = "eSPI Flash Channel Ready Register"]
        #[inline(always)]
        pub const fn fc_ready(self) -> crate::common::Reg<regs::FcReady, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02e9usize) as _) }
        }
        #[doc = "eSPI Reset Interrupt Status Register"]
        #[inline(always)]
        pub const fn reset_sts(self) -> crate::common::Reg<regs::ResetSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02eausize) as _) }
        }
        #[doc = "eSPI Reset Interrupt Enable Register"]
        #[inline(always)]
        pub const fn reset_ien(self) -> crate::common::Reg<regs::ResetIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02ebusize) as _) }
        }
        #[doc = "PLTRST Source Register"]
        #[inline(always)]
        pub const fn pltrst_src(self) -> crate::common::Reg<regs::PltrstSrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02ecusize) as _) }
        }
        #[doc = "eSPI Virtual Wire Channel Ready Register"]
        #[inline(always)]
        pub const fn vw_ready(self) -> crate::common::Reg<regs::VwReady, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02edusize) as _) }
        }
        #[doc = "RPMC OP1 Opcode Display Configuration Register"]
        #[inline(always)]
        pub const fn rpmc_op_disp_rw(self) -> crate::common::Reg<regs::RpmcOpDispRw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "RPMC OP1 Opcode Num Counter Register"]
        #[inline(always)]
        pub const fn rpmc_num_disp_rw(self) -> crate::common::Reg<regs::RpmcNumDispRw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "eSPI Activate Register"]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<regs::Activate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "eSPI I/O Base Address Configuration Register"]
        #[inline(always)]
        pub const fn addr(self) -> crate::common::Reg<regs::Addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0334usize) as _) }
        }
        #[doc = "eSPI Memory Base Address Configuration Register"]
        #[inline(always)]
        pub const fn espi_mem_addr(self) -> crate::common::Reg<regs::EspiMemAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0338usize) as _) }
        }
        #[doc = "Mailbox Base Address Configuration Register"]
        #[inline(always)]
        pub const fn mbx_addr(self) -> crate::common::Reg<regs::MbxAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x033cusize) as _) }
        }
        #[doc = "8042 Emulated Keyboard Controller Base Address Configuration Register"]
        #[inline(always)]
        pub const fn em8042_addr(self) -> crate::common::Reg<regs::Em8042addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0340usize) as _) }
        }
        #[doc = "ACPI EC 0 Base Address Configuration Register"]
        #[inline(always)]
        pub const fn acpi_ec0_addr(self) -> crate::common::Reg<regs::AcpiEc0addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0344usize) as _) }
        }
        #[doc = "ACPI EC 1 Base Address Configuration Register"]
        #[inline(always)]
        pub const fn acpi_ec1_addr(self) -> crate::common::Reg<regs::AcpiEc1addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0348usize) as _) }
        }
        #[doc = "ACPI EC 2 Base Address Configuration Register"]
        #[inline(always)]
        pub const fn acpi_ec2_addr(self) -> crate::common::Reg<regs::AcpiEc2addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x034cusize) as _) }
        }
        #[doc = "ACPI EC 3 Base Address Configuration Register"]
        #[inline(always)]
        pub const fn acpi_ec3_addr(self) -> crate::common::Reg<regs::AcpiEc3addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0350usize) as _) }
        }
        #[doc = "ACPI EC 4 Base Address Configuration Register"]
        #[inline(always)]
        pub const fn acpi_ec4_addr(self) -> crate::common::Reg<regs::AcpiEc4addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0354usize) as _) }
        }
        #[doc = "ACPI PM1 Base Address Configuration Register"]
        #[inline(always)]
        pub const fn acpi_pm1_addr(self) -> crate::common::Reg<regs::AcpiPm1addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0358usize) as _) }
        }
        #[doc = "I/O Base Address Configuration Register"]
        #[inline(always)]
        pub const fn fast_kbd_addr(self) -> crate::common::Reg<regs::FastKbdAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x035cusize) as _) }
        }
        #[doc = "UART 0 Base Address Configuration Register"]
        #[inline(always)]
        pub const fn uart0_addr(self) -> crate::common::Reg<regs::Uart0addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0360usize) as _) }
        }
        #[doc = "UART 1 Base Address Configuration Register"]
        #[inline(always)]
        pub const fn uart1_addr(self) -> crate::common::Reg<regs::Uart1addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0364usize) as _) }
        }
        #[doc = "Embedded Memory Interface (EMI) 0 BAR Config Register"]
        #[inline(always)]
        pub const fn emi0_addr(self) -> crate::common::Reg<regs::Emi0addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0368usize) as _) }
        }
        #[doc = "Embedded Memory Interface (EMI) 1 BAR Config Register"]
        #[inline(always)]
        pub const fn emi1_addr(self) -> crate::common::Reg<regs::Emi1addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x036cusize) as _) }
        }
        #[doc = "Embedded Memory Interface (EMI) 2 BAR Config Register"]
        #[inline(always)]
        pub const fn emi2_addr(self) -> crate::common::Reg<regs::Emi2addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0370usize) as _) }
        }
        #[doc = "BIOS Debug Port (Port 80) 0 BAR Config Register"]
        #[inline(always)]
        pub const fn port80_0_addr(self) -> crate::common::Reg<regs::Port800addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0374usize) as _) }
        }
        #[doc = "BIOS Debug Port (Port 80) 1 BAR Config Register"]
        #[inline(always)]
        pub const fn port80_1_addr(self) -> crate::common::Reg<regs::Port801addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0378usize) as _) }
        }
        #[doc = "RTC BAR Config Register"]
        #[inline(always)]
        pub const fn rtc_addr(self) -> crate::common::Reg<regs::RtcAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x037cusize) as _) }
        }
        #[doc = "GLUE Base Address Configuration Register"]
        #[inline(always)]
        pub const fn glue_addr(self) -> crate::common::Reg<regs::GlueAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x038cusize) as _) }
        }
        #[doc = "Mailbox (MBX_Host_SIRQ Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn mbx_host_sirq_irq(self) -> crate::common::Reg<regs::MbxHostSirqIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03acusize) as _) }
        }
        #[doc = "Mailbox (MBX_Host_SMI Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn mbx_host_smi_irq(self) -> crate::common::Reg<regs::MbxHostSmiIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03adusize) as _) }
        }
        #[doc = "8042 (KIRQ Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn kirq_8042_irq(self) -> crate::common::Reg<regs::Kirq8042irq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03aeusize) as _) }
        }
        #[doc = "8042 (MIRQ Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn mirq_8042_irq(self) -> crate::common::Reg<regs::Mirq8042irq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03afusize) as _) }
        }
        #[doc = "ACPI EC 0 (EC_OBF Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn acpi_ec0_obf_irq(self) -> crate::common::Reg<regs::AcpiEc0obfIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b0usize) as _) }
        }
        #[doc = "ACPI EC 1 (EC_OBF Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn acpi_ec1_obf_irq(self) -> crate::common::Reg<regs::AcpiEc1obfIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b1usize) as _) }
        }
        #[doc = "ACPI EC 2 (EC_OBF Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn acpi_ec2_obf_irq(self) -> crate::common::Reg<regs::AcpiEc2obfIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b2usize) as _) }
        }
        #[doc = "ACPI EC 3 (EC_OBF Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn acpi_ec3_obf_irq(self) -> crate::common::Reg<regs::AcpiEc3obfIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b3usize) as _) }
        }
        #[doc = "ACPI EC 4 (EC_OBF Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn acpi_ec4_obf_irq(self) -> crate::common::Reg<regs::AcpiEc4obfIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b4usize) as _) }
        }
        #[doc = "UART 0 (UART Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn uart0_irq(self) -> crate::common::Reg<regs::Uart0irq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b5usize) as _) }
        }
        #[doc = "UART 1 (UART Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn uart1_irq(self) -> crate::common::Reg<regs::Uart1irq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b6usize) as _) }
        }
        #[doc = "EMI 0 (Host Event Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn emi0_host_irq(self) -> crate::common::Reg<regs::Emi0hostIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b7usize) as _) }
        }
        #[doc = "EMI 0 (EC-to-Host Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn emi0_ec_host_irq(self) -> crate::common::Reg<regs::Emi0ecHostIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b8usize) as _) }
        }
        #[doc = "EMI 1 (Host Event Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn emi1_host_irq(self) -> crate::common::Reg<regs::Emi1hostIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b9usize) as _) }
        }
        #[doc = "EMI 1 (EC-to-Host Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn emi1_ec_host_irq(self) -> crate::common::Reg<regs::Emi1ecHostIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03bausize) as _) }
        }
        #[doc = "EMI 2 (Host Event Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn emi2_host_irq(self) -> crate::common::Reg<regs::Emi2hostIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03bbusize) as _) }
        }
        #[doc = "EMI 2 (EC-to-Host Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn emi2_ec_host_irq(self) -> crate::common::Reg<regs::Emi2ecHostIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03bcusize) as _) }
        }
        #[doc = "RTC (RTC Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn rtc_irq(self) -> crate::common::Reg<regs::RtcIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03bdusize) as _) }
        }
        #[doc = "EC (EC_IRQ Interrupt) Selection Register"]
        #[inline(always)]
        pub const fn ec_irq(self) -> crate::common::Reg<regs::EcIrq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03beusize) as _) }
        }
        #[doc = "RPMC OP1 Opcode Num Counter Register"]
        #[inline(always)]
        pub const fn rpmc_num_disp_r(self) -> crate::common::Reg<regs::RpmcNumDispR, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03e4usize) as _) }
        }
        #[doc = "eSPI Virtual Wire Errors Register"]
        #[inline(always)]
        pub const fn espi_vw_err(self) -> crate::common::Reg<regs::EspiVwErr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03f0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "ACPI EC 0 Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc0addr(pub u32);
        impl AcpiEc0addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for AcpiEc0addr {
            #[inline(always)]
            fn default() -> AcpiEc0addr {
                AcpiEc0addr(0)
            }
        }
        impl core::fmt::Debug for AcpiEc0addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc0addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc0addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiEc0addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "ACPI EC Channel 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc0baseAddr(pub u32);
        impl AcpiEc0baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for AcpiEc0baseAddr {
            #[inline(always)]
            fn default() -> AcpiEc0baseAddr {
                AcpiEc0baseAddr(0)
            }
        }
        impl core::fmt::Debug for AcpiEc0baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc0baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc0baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiEc0baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "ACPI EC 0 (EC_OBF Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc0obfIrq(pub u8);
        impl AcpiEc0obfIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AcpiEc0obfIrq {
            #[inline(always)]
            fn default() -> AcpiEc0obfIrq {
                AcpiEc0obfIrq(0)
            }
        }
        impl core::fmt::Debug for AcpiEc0obfIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc0obfIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc0obfIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AcpiEc0obfIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "ACPI EC 1 Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc1addr(pub u32);
        impl AcpiEc1addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for AcpiEc1addr {
            #[inline(always)]
            fn default() -> AcpiEc1addr {
                AcpiEc1addr(0)
            }
        }
        impl core::fmt::Debug for AcpiEc1addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc1addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc1addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiEc1addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "ACPI EC Channel 1 BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc1baseAddr(pub u32);
        impl AcpiEc1baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for AcpiEc1baseAddr {
            #[inline(always)]
            fn default() -> AcpiEc1baseAddr {
                AcpiEc1baseAddr(0)
            }
        }
        impl core::fmt::Debug for AcpiEc1baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc1baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc1baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiEc1baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "ACPI EC 1 (EC_OBF Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc1obfIrq(pub u8);
        impl AcpiEc1obfIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AcpiEc1obfIrq {
            #[inline(always)]
            fn default() -> AcpiEc1obfIrq {
                AcpiEc1obfIrq(0)
            }
        }
        impl core::fmt::Debug for AcpiEc1obfIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc1obfIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc1obfIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AcpiEc1obfIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "ACPI EC 2 Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc2addr(pub u32);
        impl AcpiEc2addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for AcpiEc2addr {
            #[inline(always)]
            fn default() -> AcpiEc2addr {
                AcpiEc2addr(0)
            }
        }
        impl core::fmt::Debug for AcpiEc2addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc2addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc2addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiEc2addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "ACPI EC Channel 2 BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc2baseAddr(pub u32);
        impl AcpiEc2baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for AcpiEc2baseAddr {
            #[inline(always)]
            fn default() -> AcpiEc2baseAddr {
                AcpiEc2baseAddr(0)
            }
        }
        impl core::fmt::Debug for AcpiEc2baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc2baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc2baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiEc2baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "ACPI EC 2 (EC_OBF Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc2obfIrq(pub u8);
        impl AcpiEc2obfIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AcpiEc2obfIrq {
            #[inline(always)]
            fn default() -> AcpiEc2obfIrq {
                AcpiEc2obfIrq(0)
            }
        }
        impl core::fmt::Debug for AcpiEc2obfIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc2obfIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc2obfIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AcpiEc2obfIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "ACPI EC 3 Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc3addr(pub u32);
        impl AcpiEc3addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for AcpiEc3addr {
            #[inline(always)]
            fn default() -> AcpiEc3addr {
                AcpiEc3addr(0)
            }
        }
        impl core::fmt::Debug for AcpiEc3addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc3addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc3addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiEc3addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "ACPI EC Channel 3 BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc3baseAddr(pub u32);
        impl AcpiEc3baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for AcpiEc3baseAddr {
            #[inline(always)]
            fn default() -> AcpiEc3baseAddr {
                AcpiEc3baseAddr(0)
            }
        }
        impl core::fmt::Debug for AcpiEc3baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc3baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc3baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiEc3baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "ACPI EC 3 (EC_OBF Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc3obfIrq(pub u8);
        impl AcpiEc3obfIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AcpiEc3obfIrq {
            #[inline(always)]
            fn default() -> AcpiEc3obfIrq {
                AcpiEc3obfIrq(0)
            }
        }
        impl core::fmt::Debug for AcpiEc3obfIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc3obfIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc3obfIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AcpiEc3obfIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "ACPI EC 4 Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc4addr(pub u32);
        impl AcpiEc4addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for AcpiEc4addr {
            #[inline(always)]
            fn default() -> AcpiEc4addr {
                AcpiEc4addr(0)
            }
        }
        impl core::fmt::Debug for AcpiEc4addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc4addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc4addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiEc4addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "ACPI EC Channel 4 BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc4baseAddr(pub u32);
        impl AcpiEc4baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for AcpiEc4baseAddr {
            #[inline(always)]
            fn default() -> AcpiEc4baseAddr {
                AcpiEc4baseAddr(0)
            }
        }
        impl core::fmt::Debug for AcpiEc4baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc4baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc4baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiEc4baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "ACPI EC 4 (EC_OBF Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiEc4obfIrq(pub u8);
        impl AcpiEc4obfIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AcpiEc4obfIrq {
            #[inline(always)]
            fn default() -> AcpiEc4obfIrq {
                AcpiEc4obfIrq(0)
            }
        }
        impl core::fmt::Debug for AcpiEc4obfIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiEc4obfIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiEc4obfIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AcpiEc4obfIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "ACPI PM1 Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiPm1addr(pub u32);
        impl AcpiPm1addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for AcpiPm1addr {
            #[inline(always)]
            fn default() -> AcpiPm1addr {
                AcpiPm1addr(0)
            }
        }
        impl core::fmt::Debug for AcpiPm1addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiPm1addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiPm1addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiPm1addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "I/O Base Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AcpiPm1baseAddr(pub u32);
        impl AcpiPm1baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for AcpiPm1baseAddr {
            #[inline(always)]
            fn default() -> AcpiPm1baseAddr {
                AcpiPm1baseAddr(0)
            }
        }
        impl core::fmt::Debug for AcpiPm1baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AcpiPm1baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AcpiPm1baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AcpiPm1baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "eSPI Activate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate(pub u8);
        impl Activate {
            #[doc = "1=Activate. When this bit is '1', the eSPI Logical Device is powered and functional. 0=Deactivate. When this bit is 0, the logical device is powered down and inactive. Except for the eSPI Activate Register itself, clocks to the block are gated and the eSPI Logical Device will permit the main oscillator to be shut down."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Activate. When this bit is '1', the eSPI Logical Device is powered and functional. 0=Deactivate. When this bit is 0, the logical device is powered down and inactive. Except for the eSPI Activate Register itself, clocks to the block are gated and the eSPI Logical Device will permit the main oscillator to be shut down."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate {
            #[inline(always)]
            fn default() -> Activate {
                Activate(0)
            }
        }
        impl core::fmt::Debug for Activate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate").field("act", &self.act()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate {{ act: {=bool:?} }}", self.act())
            }
        }
        #[doc = "eSPI I/O Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addr(pub u32);
        impl Addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Addr {
            #[inline(always)]
            fn default() -> Addr {
                Addr(0)
            }
        }
        impl core::fmt::Debug for Addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "eSPI I/O Base Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BaseAddr(pub u32);
        impl BaseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for BaseAddr {
            #[inline(always)]
            fn default() -> BaseAddr {
                BaseAddr(0)
            }
        }
        impl core::fmt::Debug for BaseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BaseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BaseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BaseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "eSPI Capabilities ID Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CapId(pub u8);
        impl CapId {
            #[doc = "The default value should not be changed."]
            #[inline(always)]
            pub const fn esp_devid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The default value should not be changed."]
            #[inline(always)]
            pub fn set_esp_devid(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for CapId {
            #[inline(always)]
            fn default() -> CapId {
                CapId(0)
            }
        }
        impl core::fmt::Debug for CapId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CapId").field("esp_devid", &self.esp_devid()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CapId {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CapId {{ esp_devid: {=u8:?} }}", self.esp_devid())
            }
        }
        #[doc = "EC IRQ Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcCtrlIrq(pub u32);
        impl EcCtrlIrq {
            #[doc = "This bit can be used as a firmware-controlled interrupt source for the EC. When the EC entry in the IRQ Assignment Table is set to a valid IRQ number, changes in this bit will be transmitted to the Host over a Virtual Wire IRQ channel."]
            #[inline(always)]
            pub const fn irq(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be used as a firmware-controlled interrupt source for the EC. When the EC entry in the IRQ Assignment Table is set to a valid IRQ number, changes in this bit will be transmitted to the Host over a Virtual Wire IRQ channel."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EcCtrlIrq {
            #[inline(always)]
            fn default() -> EcCtrlIrq {
                EcCtrlIrq(0)
            }
        }
        impl core::fmt::Debug for EcCtrlIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcCtrlIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcCtrlIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcCtrlIrq {{ irq: {=bool:?} }}", self.irq())
            }
        }
        #[doc = "EC (EC_IRQ Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcIrq(pub u8);
        impl EcIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for EcIrq {
            #[inline(always)]
            fn default() -> EcIrq {
                EcIrq(0)
            }
        }
        impl core::fmt::Debug for EcIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "8042 Emulated Keyboard Controller Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Em8042addr(pub u32);
        impl Em8042addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Em8042addr {
            #[inline(always)]
            fn default() -> Em8042addr {
                Em8042addr(0)
            }
        }
        impl core::fmt::Debug for Em8042addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Em8042addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Em8042addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Em8042addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "8042 Emulated Keyboard Controller BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Em8042baseAddr(pub u32);
        impl Em8042baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Em8042baseAddr {
            #[inline(always)]
            fn default() -> Em8042baseAddr {
                Em8042baseAddr(0)
            }
        }
        impl core::fmt::Debug for Em8042baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Em8042baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Em8042baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Em8042baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "Embedded Memory Interface (EMI) 0 BAR Config Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi0addr(pub u32);
        impl Emi0addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Emi0addr {
            #[inline(always)]
            fn default() -> Emi0addr {
                Emi0addr(0)
            }
        }
        impl core::fmt::Debug for Emi0addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi0addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi0addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi0addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "Embedded Memory Interface (EMI) 0 BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi0baseAddr(pub u32);
        impl Emi0baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Emi0baseAddr {
            #[inline(always)]
            fn default() -> Emi0baseAddr {
                Emi0baseAddr(0)
            }
        }
        impl core::fmt::Debug for Emi0baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi0baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi0baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi0baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "EMI 0 (EC-to-Host Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi0ecHostIrq(pub u8);
        impl Emi0ecHostIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Emi0ecHostIrq {
            #[inline(always)]
            fn default() -> Emi0ecHostIrq {
                Emi0ecHostIrq(0)
            }
        }
        impl core::fmt::Debug for Emi0ecHostIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi0ecHostIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi0ecHostIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Emi0ecHostIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "EMI 0 (Host Event Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi0hostIrq(pub u8);
        impl Emi0hostIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Emi0hostIrq {
            #[inline(always)]
            fn default() -> Emi0hostIrq {
                Emi0hostIrq(0)
            }
        }
        impl core::fmt::Debug for Emi0hostIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi0hostIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi0hostIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Emi0hostIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "Embedded Memory Interface (EMI) 1 BAR Config Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi1addr(pub u32);
        impl Emi1addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Emi1addr {
            #[inline(always)]
            fn default() -> Emi1addr {
                Emi1addr(0)
            }
        }
        impl core::fmt::Debug for Emi1addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi1addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi1addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi1addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "Embedded Memory Interface (EMI) 1 BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi1baseAddr(pub u32);
        impl Emi1baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Emi1baseAddr {
            #[inline(always)]
            fn default() -> Emi1baseAddr {
                Emi1baseAddr(0)
            }
        }
        impl core::fmt::Debug for Emi1baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi1baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi1baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi1baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "EMI 1 (EC-to-Host Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi1ecHostIrq(pub u8);
        impl Emi1ecHostIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Emi1ecHostIrq {
            #[inline(always)]
            fn default() -> Emi1ecHostIrq {
                Emi1ecHostIrq(0)
            }
        }
        impl core::fmt::Debug for Emi1ecHostIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi1ecHostIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi1ecHostIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Emi1ecHostIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "EMI 1 (Host Event Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi1hostIrq(pub u8);
        impl Emi1hostIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Emi1hostIrq {
            #[inline(always)]
            fn default() -> Emi1hostIrq {
                Emi1hostIrq(0)
            }
        }
        impl core::fmt::Debug for Emi1hostIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi1hostIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi1hostIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Emi1hostIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "Embedded Memory Interface (EMI) 2 BAR Config Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi2addr(pub u32);
        impl Emi2addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Emi2addr {
            #[inline(always)]
            fn default() -> Emi2addr {
                Emi2addr(0)
            }
        }
        impl core::fmt::Debug for Emi2addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi2addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi2addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi2addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "Embedded Memory Interface (EMI) 2 BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi2baseAddr(pub u32);
        impl Emi2baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Emi2baseAddr {
            #[inline(always)]
            fn default() -> Emi2baseAddr {
                Emi2baseAddr(0)
            }
        }
        impl core::fmt::Debug for Emi2baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi2baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi2baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi2baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "EMI 2 (EC-to-Host Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi2ecHostIrq(pub u8);
        impl Emi2ecHostIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Emi2ecHostIrq {
            #[inline(always)]
            fn default() -> Emi2ecHostIrq {
                Emi2ecHostIrq(0)
            }
        }
        impl core::fmt::Debug for Emi2ecHostIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi2ecHostIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi2ecHostIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Emi2ecHostIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "EMI 2 (Host Event Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi2hostIrq(pub u8);
        impl Emi2hostIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Emi2hostIrq {
            #[inline(always)]
            fn default() -> Emi2hostIrq {
                Emi2hostIrq(0)
            }
        }
        impl core::fmt::Debug for Emi2hostIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi2hostIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi2hostIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Emi2hostIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "eSPI Memory Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EspiMemAddr(pub u32);
        impl EspiMemAddr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for EspiMemAddr {
            #[inline(always)]
            fn default() -> EspiMemAddr {
                EspiMemAddr(0)
            }
        }
        impl core::fmt::Debug for EspiMemAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EspiMemAddr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EspiMemAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EspiMemAddr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "eSPI Memory Base Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EspiMemBaseAddr(pub u32);
        impl EspiMemBaseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for EspiMemBaseAddr {
            #[inline(always)]
            fn default() -> EspiMemBaseAddr {
                EspiMemBaseAddr(0)
            }
        }
        impl core::fmt::Debug for EspiMemBaseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EspiMemBaseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EspiMemBaseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EspiMemBaseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "eSPI Virtual Wire Errors Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EspiVwErr(pub u8);
        impl EspiVwErr {
            #[doc = "This bit is a Master-readable copy of the Virtual Wire ERROR_FATAL (bit 1 in Slave-to-Master Virtual Wire Index 5h)."]
            #[inline(always)]
            pub const fn ftl_sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is a Master-readable copy of the Virtual Wire ERROR_FATAL (bit 1 in Slave-to-Master Virtual Wire Index 5h)."]
            #[inline(always)]
            pub fn set_ftl_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "When this field is written with a 1 the Virtual Wire ERROR_FATAL (bit 1 in Slave-to-Master Virtual Wire Index 5h) is cleared to 0. Because clearing the status bit changes its state, a Virtual Wire packet reporting the new state will be sent to the Master. Writes of 0 to this bit have no effect. Reads of this bit always return '0'."]
            #[inline(always)]
            pub const fn clr_ftl_status(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this field is written with a 1 the Virtual Wire ERROR_FATAL (bit 1 in Slave-to-Master Virtual Wire Index 5h) is cleared to 0. Because clearing the status bit changes its state, a Virtual Wire packet reporting the new state will be sent to the Master. Writes of 0 to this bit have no effect. Reads of this bit always return '0'."]
            #[inline(always)]
            pub fn set_clr_ftl_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This bit is a Master-readable copy of the Virtual Wire ERROR_NON_FATAL (bit 2 in Slave-to-Master Virtual Wire Index 5h)."]
            #[inline(always)]
            pub const fn nftl_sts(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is a Master-readable copy of the Virtual Wire ERROR_NON_FATAL (bit 2 in Slave-to-Master Virtual Wire Index 5h)."]
            #[inline(always)]
            pub fn set_nftl_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "When this field is written with a 1 the Virtual Wire ERROR_NON_- FATAL (bit 2 in Slave-to-Master Virtual Wire Index 5h) is cleared to 0. Because clearing the status bit changes its state, a Virtual Wire packet reporting the new state will be sent to the Master. Writes of 0 to this bit have no effect. Reads of this bit always return '0'."]
            #[inline(always)]
            pub const fn clr_nftl_sts(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When this field is written with a 1 the Virtual Wire ERROR_NON_- FATAL (bit 2 in Slave-to-Master Virtual Wire Index 5h) is cleared to 0. Because clearing the status bit changes its state, a Virtual Wire packet reporting the new state will be sent to the Master. Writes of 0 to this bit have no effect. Reads of this bit always return '0'."]
            #[inline(always)]
            pub fn set_clr_nftl_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
        }
        impl Default for EspiVwErr {
            #[inline(always)]
            fn default() -> EspiVwErr {
                EspiVwErr(0)
            }
        }
        impl core::fmt::Debug for EspiVwErr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EspiVwErr")
                    .field("ftl_sts", &self.ftl_sts())
                    .field("clr_ftl_status", &self.clr_ftl_status())
                    .field("nftl_sts", &self.nftl_sts())
                    .field("clr_nftl_sts", &self.clr_nftl_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EspiVwErr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EspiVwErr {{ ftl_sts: {=bool:?}, clr_ftl_status: {=bool:?}, nftl_sts: {=bool:?}, clr_nftl_sts: {=bool:?} }}" , self . ftl_sts () , self . clr_ftl_status () , self . nftl_sts () , self . clr_nftl_sts ())
            }
        }
        #[doc = "I/O Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FastKbdAddr(pub u32);
        impl FastKbdAddr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for FastKbdAddr {
            #[inline(always)]
            fn default() -> FastKbdAddr {
                FastKbdAddr(0)
            }
        }
        impl core::fmt::Debug for FastKbdAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FastKbdAddr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FastKbdAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FastKbdAddr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "Legacy (Fast Keyboard) BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FastKdbBaseAddr(pub u32);
        impl FastKdbBaseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for FastKdbBaseAddr {
            #[inline(always)]
            fn default() -> FastKdbBaseAddr {
                FastKdbBaseAddr(0)
            }
        }
        impl core::fmt::Debug for FastKdbBaseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FastKdbBaseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FastKdbBaseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FastKdbBaseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "Flash Access Channel Buffer Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcBufAddrLsw(pub u32);
        impl FcBufAddrLsw {
            #[doc = "Before starting a Flash access, this field must be initialized with the address of the data buffer in the EC's memory space."]
            #[inline(always)]
            pub const fn blsw(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Before starting a Flash access, this field must be initialized with the address of the data buffer in the EC's memory space."]
            #[inline(always)]
            pub fn set_blsw(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FcBufAddrLsw {
            #[inline(always)]
            fn default() -> FcBufAddrLsw {
                FcBufAddrLsw(0)
            }
        }
        impl core::fmt::Debug for FcBufAddrLsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcBufAddrLsw").field("blsw", &self.blsw()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcBufAddrLsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FcBufAddrLsw {{ blsw: {=u32:?} }}", self.blsw())
            }
        }
        #[doc = "eSPI Flash Channel Capabilities Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcCap(pub u8);
        impl FcCap {
            #[doc = "This field identifies the maximum payload size supported by the slave. It corresponds to the field Flash Access Channel Maximum Payload Size Supported, bits \\[7:0\\] of the Flash Channel Capabilities and Configurations Register. 111b - 100b=Reserved 011b=256 bytes address aligned max payload size 010b=128 bytes address aligned max payload size 001b=64 bytes address aligned max payload size 000b=Reserved."]
            #[inline(always)]
            pub const fn max_pay_ld(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "This field identifies the maximum payload size supported by the slave. It corresponds to the field Flash Access Channel Maximum Payload Size Supported, bits \\[7:0\\] of the Flash Channel Capabilities and Configurations Register. 111b - 100b=Reserved 011b=256 bytes address aligned max payload size 010b=128 bytes address aligned max payload size 001b=64 bytes address aligned max payload size 000b=Reserved."]
            #[inline(always)]
            pub fn set_max_pay_ld(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u8) & 0x07) << 0usize);
            }
            #[doc = "This field identifies the flash sharing scheme supported by the slave. It corresponds to the field Flash Sharing Mode, bit \\[11\\] of the Flash Channel Capabilities and Configurations Register. 1=Slave attached flash sharing 0=Master attached flash sharing"]
            #[inline(always)]
            pub const fn shar_mode(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This field identifies the flash sharing scheme supported by the slave. It corresponds to the field Flash Sharing Mode, bit \\[11\\] of the Flash Channel Capabilities and Configurations Register. 1=Slave attached flash sharing 0=Master attached flash sharing"]
            #[inline(always)]
            pub fn set_shar_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for FcCap {
            #[inline(always)]
            fn default() -> FcCap {
                FcCap(0)
            }
        }
        impl core::fmt::Debug for FcCap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcCap")
                    .field("max_pay_ld", &self.max_pay_ld())
                    .field("shar_mode", &self.shar_mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcCap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FcCap {{ max_pay_ld: {=u8:?}, shar_mode: {=bool:?} }}",
                    self.max_pay_ld(),
                    self.shar_mode()
                )
            }
        }
        #[doc = "Flash Access Channel Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcCfg(pub u32);
        impl FcCfg {
            #[doc = "This bit is set to '1' when a '1' is written to the FLASH_START bit, and cleared either by hardware completion of the requested operation or by firmware writing '1' to the ABORT_ACCESS bit. 1=The Channel is busy. 0=The Channel is not busy."]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' when a '1' is written to the FLASH_START bit, and cleared either by hardware completion of the requested operation or by firmware writing '1' to the ABORT_ACCESS bit. 1=The Channel is busy. 0=The Channel is not busy."]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This is a read-only image of the equivalent field of the eSPI Configuration register. This field is set by the Master to define what the Erase block size is for the Flash being used, and whether there is a choice available to firmware. 111b = Reserved 110b = Reserved 101b = 256K 100b = 128K 010b = 64K 011b = Both 4K and 64K allowed (see FUNCTION field) 001b = 4K 000b = Reserved."]
            #[inline(always)]
            pub const fn eras_blk_size(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x07;
                val as u8
            }
            #[doc = "This is a read-only image of the equivalent field of the eSPI Configuration register. This field is set by the Master to define what the Erase block size is for the Flash being used, and whether there is a choice available to firmware. 111b = Reserved 110b = Reserved 101b = 256K 100b = 128K 010b = 64K 011b = Both 4K and 64K allowed (see FUNCTION field) 001b = 4K 000b = Reserved."]
            #[inline(always)]
            pub fn set_eras_blk_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val as u32) & 0x07) << 2usize);
            }
            #[doc = "This is a read-only image of the equivalent field of the eSPI Configuration register, set by the Master to declare the maximum number of bytes that can be used in a single Flash payload, in either direction. It will never be set greater than the value provided by the EC in the FLASH_MAXIMUM_PAYLOAD_SIZE_SUPPORTED field in the eSPI Flash Channel Capabilities Register. 100b -- 111b = Reserved 011b = 256 bytes 010b = 128 bytes 001b = 64 bytes 000b = Reserved."]
            #[inline(always)]
            pub const fn max_payld_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "This is a read-only image of the equivalent field of the eSPI Configuration register, set by the Master to declare the maximum number of bytes that can be used in a single Flash payload, in either direction. It will never be set greater than the value provided by the EC in the FLASH_MAXIMUM_PAYLOAD_SIZE_SUPPORTED field in the eSPI Flash Channel Capabilities Register. 100b -- 111b = Reserved 011b = 256 bytes 010b = 128 bytes 001b = 64 bytes 000b = Reserved."]
            #[inline(always)]
            pub fn set_max_payld_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize);
            }
            #[doc = "This comes read-only from the eSPI Configuration register, set by the Master to declare the maximum number of bytes that can be requested by the EC in a single Flash Read request packet. 111b = 4K bytes 110b = 2K bytes 101b = 1K bytes 100b = 512 bytes 011b = 256 bytes 010b = 128 bytes 001b = 64 bytes 000b = Reserved."]
            #[inline(always)]
            pub const fn max_rd_req(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x07;
                val as u8
            }
            #[doc = "This comes read-only from the eSPI Configuration register, set by the Master to declare the maximum number of bytes that can be requested by the EC in a single Flash Read request packet. 111b = 4K bytes 110b = 2K bytes 101b = 1K bytes 100b = 512 bytes 011b = 256 bytes 010b = 128 bytes 001b = 64 bytes 000b = Reserved."]
            #[inline(always)]
            pub fn set_max_rd_req(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 12usize)) | (((val as u32) & 0x07) << 12usize);
            }
        }
        impl Default for FcCfg {
            #[inline(always)]
            fn default() -> FcCfg {
                FcCfg(0)
            }
        }
        impl core::fmt::Debug for FcCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcCfg")
                    .field("busy", &self.busy())
                    .field("eras_blk_size", &self.eras_blk_size())
                    .field("max_payld_sel", &self.max_payld_sel())
                    .field("max_rd_req", &self.max_rd_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FcCfg {{ busy: {=bool:?}, eras_blk_size: {=u8:?}, max_payld_sel: {=u8:?}, max_rd_req: {=u8:?} }}",
                    self.busy(),
                    self.eras_blk_size(),
                    self.max_payld_sel(),
                    self.max_rd_req()
                )
            }
        }
        #[doc = "Flash Access Channel Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcCtrl(pub u32);
        impl FcCtrl {
            #[doc = "A write of '1' to this bit starts the transmission and sets the Busy status bit. A write of '0' has no effect. The transmission will be inhibited if the OOB channel is not Ready, as defined in the eSPI Flash Channel Ready Register."]
            #[inline(always)]
            pub const fn fstrt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "A write of '1' to this bit starts the transmission and sets the Busy status bit. A write of '0' has no effect. The transmission will be inhibited if the OOB channel is not Ready, as defined in the eSPI Flash Channel Ready Register."]
            #[inline(always)]
            pub fn set_fstrt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit selects the requested Flash function as follows: 11=Erase Flash Range=Larger of two ranges, if a choice exists 10=Erase Flash Range=Smaller of two ranges, if a choice exists 01=Write to Flash 00=Read from Flash."]
            #[inline(always)]
            pub const fn func(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "This bit selects the requested Flash function as follows: 11=Erase Flash Range=Larger of two ranges, if a choice exists 10=Erase Flash Range=Smaller of two ranges, if a choice exists 01=Write to Flash 00=Read from Flash."]
            #[inline(always)]
            pub fn set_func(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "This field should always be written to zero, which is the only expected Tag value for Flash Access traffic. It provides the 4-bit TAG value in the eSPI Transaction Header sent by the EC. Completion traffic from the Master is required to match this field also."]
            #[inline(always)]
            pub const fn tag(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "This field should always be written to zero, which is the only expected Tag value for Flash Access traffic. It provides the 4-bit TAG value in the eSPI Transaction Header sent by the EC. Completion traffic from the Master is required to match this field also."]
            #[inline(always)]
            pub fn set_tag(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "By writing '1' to this bit while Busy==1, the transaction sequence last triggered by the Start bit is terminated, and the Busy bit is cleared, at the next protocol-compliant opportunity. The clearing of the Busy bit will set the DONE status bit and the ABORTED_BY_SLAVE status bit is set to '1' to acknowledge this specific action as the cause. The action of writing '1' to this bit is ignored while Busy==0. This bit reads as '0' always."]
            #[inline(always)]
            pub const fn abrt(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "By writing '1' to this bit while Busy==1, the transaction sequence last triggered by the Start bit is terminated, and the Busy bit is cleared, at the next protocol-compliant opportunity. The clearing of the Busy bit will set the DONE status bit and the ABORTED_BY_SLAVE status bit is set to '1' to acknowledge this specific action as the cause. The action of writing '1' to this bit is ignored while Busy==0. This bit reads as '0' always."]
            #[inline(always)]
            pub fn set_abrt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for FcCtrl {
            #[inline(always)]
            fn default() -> FcCtrl {
                FcCtrl(0)
            }
        }
        impl core::fmt::Debug for FcCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcCtrl")
                    .field("fstrt", &self.fstrt())
                    .field("func", &self.func())
                    .field("tag", &self.tag())
                    .field("abrt", &self.abrt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FcCtrl {{ fstrt: {=bool:?}, func: {=u8:?}, tag: {=u8:?}, abrt: {=bool:?} }}",
                    self.fstrt(),
                    self.func(),
                    self.tag(),
                    self.abrt()
                )
            }
        }
        #[doc = "Flash Access Channel Flash Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcFlashAddrLsw(pub u32);
        impl FcFlashAddrLsw {
            #[doc = "Before starting a Flash access, this field must be initialized to contain the value used by eSPI for addressing the Flash contents."]
            #[inline(always)]
            pub const fn flsw(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Before starting a Flash access, this field must be initialized to contain the value used by eSPI for addressing the Flash contents."]
            #[inline(always)]
            pub fn set_flsw(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FcFlashAddrLsw {
            #[inline(always)]
            fn default() -> FcFlashAddrLsw {
                FcFlashAddrLsw(0)
            }
        }
        impl core::fmt::Debug for FcFlashAddrLsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcFlashAddrLsw").field("flsw", &self.flsw()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcFlashAddrLsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FcFlashAddrLsw {{ flsw: {=u32:?} }}", self.flsw())
            }
        }
        #[doc = "Flash Access Channel Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcIen(pub u32);
        impl FcIen {
            #[doc = "When this bit is '1' an interrupt is generated when the bit DONE in the Flash Access Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit DONE in the Flash Access Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit CHANNEL_ENABLE_CHANGE_STATUS in the Flash Access Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn en_sts_chng(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit CHANNEL_ENABLE_CHANGE_STATUS in the Flash Access Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_en_sts_chng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for FcIen {
            #[inline(always)]
            fn default() -> FcIen {
                FcIen(0)
            }
        }
        impl core::fmt::Debug for FcIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcIen")
                    .field("done", &self.done())
                    .field("en_sts_chng", &self.en_sts_chng())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcIen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FcIen {{ done: {=bool:?}, en_sts_chng: {=bool:?} }}",
                    self.done(),
                    self.en_sts_chng()
                )
            }
        }
        #[doc = "eSPI Flash Channel Ready Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcReady(pub u8);
        impl FcReady {
            #[doc = "Firmware sets this bit to '1' to inform the Master that the Flash channel is ready for transactions. It corresponds to the field Flash Channel Ready, bit 1 of Config Offset 40h=Flash Channel Capabilities and Configurations Register. It is forced to '0' while the Flash Channel Enabled bit in the Capabilities and Configurations register is 0. Once set to '1' it cannot be set to '0' by firmware. It is only set to '0'by a reset, or when the Master changes the Enabled bit to '0'. While this bit is '0' all Flash transactions initiated by the Slave are inhibited."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Firmware sets this bit to '1' to inform the Master that the Flash channel is ready for transactions. It corresponds to the field Flash Channel Ready, bit 1 of Config Offset 40h=Flash Channel Capabilities and Configurations Register. It is forced to '0' while the Flash Channel Enabled bit in the Capabilities and Configurations register is 0. Once set to '1' it cannot be set to '0' by firmware. It is only set to '0'by a reset, or when the Master changes the Enabled bit to '0'. While this bit is '0' all Flash transactions initiated by the Slave are inhibited."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for FcReady {
            #[inline(always)]
            fn default() -> FcReady {
                FcReady(0)
            }
        }
        impl core::fmt::Debug for FcReady {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcReady").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcReady {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FcReady {{ chn: {=bool:?} }}", self.chn())
            }
        }
        #[doc = "Flash Access Channel Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcSts(pub u32);
        impl FcSts {
            #[doc = "This bit is a Read-only image of the bit Flash Access Channel Enable in the eSPI Configuration space. Rising or falling edges of this bit will set the CHANNEL_ENABLE_CHANGE_STATUS bit to 1, and may be used to trigger interrupts. A falling edge on this bit, while Busy==1, will also clear the Busy bit and set the DONE bit, with DISABLED_BY_MASTER status. 1=Flash Access Channel Enable bit = 1. 0=Flash Access Channel Enable bit = 0."]
            #[inline(always)]
            pub const fn chn_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is a Read-only image of the bit Flash Access Channel Enable in the eSPI Configuration space. Rising or falling edges of this bit will set the CHANNEL_ENABLE_CHANGE_STATUS bit to 1, and may be used to trigger interrupts. A falling edge on this bit, while Busy==1, will also clear the Busy bit and set the DONE bit, with DISABLED_BY_MASTER status. 1=Flash Access Channel Enable bit = 1. 0=Flash Access Channel Enable bit = 0."]
            #[inline(always)]
            pub fn set_chn_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "0=Flash Access Enable bit in eSPI Configuration space has not been changed since this bit was last cleared. 1=Flash Access Enable bit in eSPI Configuration space has been changed since this bit was last cleared. The current state of the Flash Access Enable bit can be seen as the read-only bit CHANNEL_ENABLE_STATUS in this register. This bit is cleared by writing '1'. (R/WC)"]
            #[inline(always)]
            pub const fn chn_en_chng(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "0=Flash Access Enable bit in eSPI Configuration space has not been changed since this bit was last cleared. 1=Flash Access Enable bit in eSPI Configuration space has been changed since this bit was last cleared. The current state of the Flash Access Enable bit can be seen as the read-only bit CHANNEL_ENABLE_STATUS in this register. This bit is cleared by writing '1'. (R/WC)"]
            #[inline(always)]
            pub fn set_chn_en_chng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1=Channel is done=Busy bit has been cleared since this bit was last cleared. It is cleared by writing '1'. (R/WC) 0=Channel is not done=Busy bit has not been cleared since this bit was last cleared."]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=Channel is done=Busy bit has been cleared since this bit was last cleared. It is cleared by writing '1'. (R/WC) 0=Channel is not done=Busy bit has not been cleared since this bit was last cleared."]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is set to '1' if the Flash Channel is disabled by the Master while the Busy bit is '1'. It is cleared by writing '1'. (R/WC) 1=The command finished because the Enable bit became 0. 0=The command finished without a change in the Enable bit."]
            #[inline(always)]
            pub const fn dis_mast(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' if the Flash Channel is disabled by the Master while the Busy bit is '1'. It is cleared by writing '1'. (R/WC) 1=The command finished because the Enable bit became 0. 0=The command finished without a change in the Enable bit."]
            #[inline(always)]
            pub fn set_dis_mast(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit is set to '1' if the internal bus master associated with the Flash Access Channel encounters a Bus Fault condition. It is cleared by writing '1'. (R/WC) 1=Bus Error detected. 0=The command finished without a Bus Error."]
            #[inline(always)]
            pub const fn int_bus_err(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' if the internal bus master associated with the Flash Access Channel encounters a Bus Fault condition. It is cleared by writing '1'. (R/WC) 1=Bus Error detected. 0=The command finished without a Bus Error."]
            #[inline(always)]
            pub fn set_int_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit is set to '1' if the Abort bit is set to '1' by firmware while the Busy bit is '1', thereby clearing Busy status. It is cleared by writing '1'. (R/WC) 1=The command finished because of the Abort bit. 0=The command finished without an Abort bit activation."]
            #[inline(always)]
            pub const fn abort_slave(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' if the Abort bit is set to '1' by firmware while the Busy bit is '1', thereby clearing Busy status. It is cleared by writing '1'. (R/WC) 1=The command finished because of the Abort bit. 0=The command finished without an Abort bit activation."]
            #[inline(always)]
            pub fn set_abort_slave(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit is set to '1' by a SUCCESSFUL COMPLETION response by the eSPI Master to a Read sequence, but either without indicating Final Completion when the requested byte count is reached or with too many bytes provided while indicating Final Completion. It is cleared by writing '1'. (R/WC) 1=The eSPI Master finished with too much data. 0=The eSPI Master finished without too much data."]
            #[inline(always)]
            pub const fn dat_ovrun(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' by a SUCCESSFUL COMPLETION response by the eSPI Master to a Read sequence, but either without indicating Final Completion when the requested byte count is reached or with too many bytes provided while indicating Final Completion. It is cleared by writing '1'. (R/WC) 1=The eSPI Master finished with too much data. 0=The eSPI Master finished without too much data."]
            #[inline(always)]
            pub fn set_dat_ovrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit is set to '1' by a SUCCESSFUL COMPLETION Read response from the eSPI Master, indicating a Final Completion, but with too few bytes provided for the Transaction step that was issued by the eSPI Slave. It is cleared by writing '1'. This bit is cleared by writing '1'. (R/WC) 1=The eSPI Master finished with too little data. 0=The eSPI Master finished with at least enough data."]
            #[inline(always)]
            pub const fn incmpl(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' by a SUCCESSFUL COMPLETION Read response from the eSPI Master, indicating a Final Completion, but with too few bytes provided for the Transaction step that was issued by the eSPI Slave. It is cleared by writing '1'. This bit is cleared by writing '1'. (R/WC) 1=The eSPI Master finished with too little data. 0=The eSPI Master finished with at least enough data."]
            #[inline(always)]
            pub fn set_incmpl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This bit is set to '1' by an explicit UNSUCCESSFUL COMPLETION response from the eSPI Master, which also terminates the transaction sequence. This may occur if an invalid or illegal section of Flash memory is accessed, and only at Runtime (post-boot). This bit is cleared by writing '1'. (R/WC) 1=The eSPI Master indicated unsuccessful completion. 0=The eSPI Master indicated successful completion."]
            #[inline(always)]
            pub const fn fail(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' by an explicit UNSUCCESSFUL COMPLETION response from the eSPI Master, which also terminates the transaction sequence. This may occur if an invalid or illegal section of Flash memory is accessed, and only at Runtime (post-boot). This bit is cleared by writing '1'. (R/WC) 1=The eSPI Master indicated unsuccessful completion. 0=The eSPI Master indicated successful completion."]
            #[inline(always)]
            pub fn set_fail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This bit is set if a command (initiated by setting the Start bit) has been ignored because the Busy bit was already on. The transfer in progress is also brought to the Done state at the next opportunity allowed by the eSPI protocol, as if the Abort bit had been set by the firmware, so that this bit will be present at a Done interrupt. This bit is cleared by writing '1'. (R/WC) This flag represents a serious mis-communication between the firmware and hardware, and should be handled cautiously as a special case by firmware. 1=Start Overflow. Firmware has attempted to trigger a transaction sequence before allowing the previous sequence to finish and without using the Abort bit to terminate it first 0=No Start Overflow detected."]
            #[inline(always)]
            pub const fn strt_ovrflw(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if a command (initiated by setting the Start bit) has been ignored because the Busy bit was already on. The transfer in progress is also brought to the Done state at the next opportunity allowed by the eSPI protocol, as if the Abort bit had been set by the firmware, so that this bit will be present at a Done interrupt. This bit is cleared by writing '1'. (R/WC) This flag represents a serious mis-communication between the firmware and hardware, and should be handled cautiously as a special case by firmware. 1=Start Overflow. Firmware has attempted to trigger a transaction sequence before allowing the previous sequence to finish and without using the Abort bit to terminate it first 0=No Start Overflow detected."]
            #[inline(always)]
            pub fn set_strt_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This bit is set to '1' when a firmware Flash Access request is invalid. For example, this bit is set for a request to Read or Write 0 bytes. This bit is cleared by writing '1'. (R/WC)"]
            #[inline(always)]
            pub const fn bad_req(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' when a firmware Flash Access request is invalid. For example, this bit is set for a request to Read or Write 0 bytes. This bit is cleared by writing '1'. (R/WC)"]
            #[inline(always)]
            pub fn set_bad_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for FcSts {
            #[inline(always)]
            fn default() -> FcSts {
                FcSts(0)
            }
        }
        impl core::fmt::Debug for FcSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcSts")
                    .field("chn_en", &self.chn_en())
                    .field("chn_en_chng", &self.chn_en_chng())
                    .field("done", &self.done())
                    .field("dis_mast", &self.dis_mast())
                    .field("int_bus_err", &self.int_bus_err())
                    .field("abort_slave", &self.abort_slave())
                    .field("dat_ovrun", &self.dat_ovrun())
                    .field("incmpl", &self.incmpl())
                    .field("fail", &self.fail())
                    .field("strt_ovrflw", &self.strt_ovrflw())
                    .field("bad_req", &self.bad_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "FcSts {{ chn_en: {=bool:?}, chn_en_chng: {=bool:?}, done: {=bool:?}, dis_mast: {=bool:?}, int_bus_err: {=bool:?}, abort_slave: {=bool:?}, dat_ovrun: {=bool:?}, incmpl: {=bool:?}, fail: {=bool:?}, strt_ovrflw: {=bool:?}, bad_req: {=bool:?} }}" , self . chn_en () , self . chn_en_chng () , self . done () , self . dis_mast () , self . int_bus_err () , self . abort_slave () , self . dat_ovrun () , self . incmpl () , self . fail () , self . strt_ovrflw () , self . bad_req ())
            }
        }
        #[doc = "Flash Access Channel Transfer Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcXfrLen(pub u32);
        impl FcXfrLen {
            #[doc = "Before starting a Flash access, this field must be initialized with the total number of bytes to be transferred in the requested transaction sequence. If the Master attempts to transfer more bytes than this in Read Completions, the transfer is faulted and the DATA_OVERRUN bit in the Flash Access Channel Status Register register is asserted."]
            #[inline(always)]
            pub const fn tlen(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Before starting a Flash access, this field must be initialized with the total number of bytes to be transferred in the requested transaction sequence. If the Master attempts to transfer more bytes than this in Read Completions, the transfer is faulted and the DATA_OVERRUN bit in the Flash Access Channel Status Register register is asserted."]
            #[inline(always)]
            pub fn set_tlen(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FcXfrLen {
            #[inline(always)]
            fn default() -> FcXfrLen {
                FcXfrLen(0)
            }
        }
        impl core::fmt::Debug for FcXfrLen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcXfrLen").field("tlen", &self.tlen()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcXfrLen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FcXfrLen {{ tlen: {=u32:?} }}", self.tlen())
            }
        }
        #[doc = "eSPI Capabilities Global Capabilities 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlbCap0(pub u8);
        impl GlbCap0 {
            #[doc = "1=Peripheral Channel is supported by the slave; 0=Peripheral Channel not supported by the slave."]
            #[inline(always)]
            pub const fn phl_chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel is supported by the slave; 0=Peripheral Channel not supported by the slave."]
            #[inline(always)]
            pub fn set_phl_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "1=Virtual Wire Channel is supported by the slave; 0=Virtual Wire Channel Channel not supported by the slave."]
            #[inline(always)]
            pub const fn vw_chn(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=Virtual Wire Channel is supported by the slave; 0=Virtual Wire Channel Channel not supported by the slave."]
            #[inline(always)]
            pub fn set_vw_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "1=OOB Message Channel is supported by the slave; 0=OOB Message Channel not supported by the slave."]
            #[inline(always)]
            pub const fn oob_msg_chn(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=OOB Message Channel is supported by the slave; 0=OOB Message Channel not supported by the slave."]
            #[inline(always)]
            pub fn set_oob_msg_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "1=Flash Access Channel is supported by the slave; 0=Flash Access Channel not supported by the slave."]
            #[inline(always)]
            pub const fn fc_chn(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=Flash Access Channel is supported by the slave; 0=Flash Access Channel not supported by the slave."]
            #[inline(always)]
            pub fn set_fc_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
        }
        impl Default for GlbCap0 {
            #[inline(always)]
            fn default() -> GlbCap0 {
                GlbCap0(0)
            }
        }
        impl core::fmt::Debug for GlbCap0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlbCap0")
                    .field("phl_chn", &self.phl_chn())
                    .field("vw_chn", &self.vw_chn())
                    .field("oob_msg_chn", &self.oob_msg_chn())
                    .field("fc_chn", &self.fc_chn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlbCap0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GlbCap0 {{ phl_chn: {=bool:?}, vw_chn: {=bool:?}, oob_msg_chn: {=bool:?}, fc_chn: {=bool:?} }}",
                    self.phl_chn(),
                    self.vw_chn(),
                    self.oob_msg_chn(),
                    self.fc_chn()
                )
            }
        }
        #[doc = "eSPI Capabilities Global Capabilities 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlbCap1(pub u8);
        impl GlbCap1 {
            #[doc = "This field identifies the maximum frequency of operation supported by the slave. It corresponds to the field Maximum Frequency Supported, bits \\[18:16\\] of the eSPI General Capabilities and Configurations register. 111b - 101b=Reserved 100b=66 MHz 011b=50 MHz 010b=33 MHz 001b=25 MHz 000b=20 MHz (default)."]
            #[inline(always)]
            pub const fn max_freq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "This field identifies the maximum frequency of operation supported by the slave. It corresponds to the field Maximum Frequency Supported, bits \\[18:16\\] of the eSPI General Capabilities and Configurations register. 111b - 101b=Reserved 100b=66 MHz 011b=50 MHz 010b=33 MHz 001b=25 MHz 000b=20 MHz (default)."]
            #[inline(always)]
            pub fn set_max_freq(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u8) & 0x07) << 0usize);
            }
            #[doc = "This field is a read-only copy of the ALERT Mode field, bit 28 of the Config Offset 8h=General Capabilities and Configurations Register."]
            #[inline(always)]
            pub const fn alert(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This field is a read-only copy of the ALERT Mode field, bit 28 of the Config Offset 8h=General Capabilities and Configurations Register."]
            #[inline(always)]
            pub fn set_alert(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "This field identifies the I/O modes supported by the slave. It corresponds to the field I/O Mode Support, bits \\[25:24\\] of the eSPI General Capabilities and Configurations register. 11b=Single, Dual and Quad I/O 10b=Single and Quad I/O 01b=Single and Dual I/O 00b=Single I/O (default)."]
            #[inline(always)]
            pub const fn io_mode(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "This field identifies the I/O modes supported by the slave. It corresponds to the field I/O Mode Support, bits \\[25:24\\] of the eSPI General Capabilities and Configurations register. 11b=Single, Dual and Quad I/O 10b=Single and Quad I/O 01b=Single and Dual I/O 00b=Single I/O (default)."]
            #[inline(always)]
            pub fn set_io_mode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u8) & 0x03) << 4usize);
            }
        }
        impl Default for GlbCap1 {
            #[inline(always)]
            fn default() -> GlbCap1 {
                GlbCap1(0)
            }
        }
        impl core::fmt::Debug for GlbCap1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlbCap1")
                    .field("max_freq", &self.max_freq())
                    .field("alert", &self.alert())
                    .field("io_mode", &self.io_mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlbCap1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GlbCap1 {{ max_freq: {=u8:?}, alert: {=bool:?}, io_mode: {=u8:?} }}",
                    self.max_freq(),
                    self.alert(),
                    self.io_mode()
                )
            }
        }
        #[doc = "GLUE Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlueAddr(pub u32);
        impl GlueAddr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn espi_host_address(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_espi_host_address(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for GlueAddr {
            #[inline(always)]
            fn default() -> GlueAddr {
                GlueAddr(0)
            }
        }
        impl core::fmt::Debug for GlueAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlueAddr")
                    .field("valid", &self.valid())
                    .field("espi_host_address", &self.espi_host_address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlueAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GlueAddr {{ valid: {=bool:?}, espi_host_address: {=u16:?} }}",
                    self.valid(),
                    self.espi_host_address()
                )
            }
        }
        #[doc = "GLUE Base Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlueBaseAddr(pub u32);
        impl GlueBaseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for GlueBaseAddr {
            #[inline(always)]
            fn default() -> GlueBaseAddr {
                GlueBaseAddr(0)
            }
        }
        impl core::fmt::Debug for GlueBaseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlueBaseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlueBaseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GlueBaseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "BAR Inhibit Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IobarInhLsw(pub u32);
        impl IobarInhLsw {
            #[doc = "When bit Di of BAR_Inhibit is 1, the BAR for Logical Device i is disabled and its addresses will not be claimed on the eSPI bus, independent of the value of the Valid bit in the BAR. The BAR Inhibit function applies to both I/O transactions and Memory transactions."]
            #[inline(always)]
            pub const fn lsdw(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "When bit Di of BAR_Inhibit is 1, the BAR for Logical Device i is disabled and its addresses will not be claimed on the eSPI bus, independent of the value of the Valid bit in the BAR. The BAR Inhibit function applies to both I/O transactions and Memory transactions."]
            #[inline(always)]
            pub fn set_lsdw(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for IobarInhLsw {
            #[inline(always)]
            fn default() -> IobarInhLsw {
                IobarInhLsw(0)
            }
        }
        impl core::fmt::Debug for IobarInhLsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IobarInhLsw").field("lsdw", &self.lsdw()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IobarInhLsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IobarInhLsw {{ lsdw: {=u32:?} }}", self.lsdw())
            }
        }
        #[doc = "BAR Inhibit Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IobarInhMsw(pub u32);
        impl IobarInhMsw {
            #[doc = "When bit Di of BAR_Inhibit is 1, the BAR for Logical Device i is disabled and its addresses will not be claimed on the eSPI bus, independent of the value of the Valid bit in the BAR. The BAR Inhibit function applies to both I/O transactions and Memory transactions."]
            #[inline(always)]
            pub const fn msdw(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "When bit Di of BAR_Inhibit is 1, the BAR for Logical Device i is disabled and its addresses will not be claimed on the eSPI bus, independent of the value of the Valid bit in the BAR. The BAR Inhibit function applies to both I/O transactions and Memory transactions."]
            #[inline(always)]
            pub fn set_msdw(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for IobarInhMsw {
            #[inline(always)]
            fn default() -> IobarInhMsw {
                IobarInhMsw(0)
            }
        }
        impl core::fmt::Debug for IobarInhMsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IobarInhMsw").field("msdw", &self.msdw()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IobarInhMsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IobarInhMsw {{ msdw: {=u32:?} }}", self.msdw())
            }
        }
        #[doc = "eSPI BAR Init Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IobarInit(pub u32);
        impl IobarInit {
            #[doc = "This field is loaded into the Base Address Register register for Logical Device Ch (eSPI, I/O Configuration Port) on RESET_SIO."]
            #[inline(always)]
            pub const fn init(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This field is loaded into the Base Address Register register for Logical Device Ch (eSPI, I/O Configuration Port) on RESET_SIO."]
            #[inline(always)]
            pub fn set_init(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for IobarInit {
            #[inline(always)]
            fn default() -> IobarInit {
                IobarInit(0)
            }
        }
        impl core::fmt::Debug for IobarInit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IobarInit").field("init", &self.init()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IobarInit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IobarInit {{ init: {=u16:?} }}", self.init())
            }
        }
        #[doc = "8042 (KIRQ Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Kirq8042irq(pub u8);
        impl Kirq8042irq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Kirq8042irq {
            #[inline(always)]
            fn default() -> Kirq8042irq {
                Kirq8042irq(0)
            }
        }
        impl core::fmt::Debug for Kirq8042irq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Kirq8042irq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Kirq8042irq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Kirq8042irq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "LTR Peripheral Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LtrCtrl(pub u32);
        impl LtrCtrl {
            #[doc = "Writing '1' to this bit triggers the transmission of an LTR packet defined by the LTR Peripheral Message register. Writing '0' to this bit has no effect. The transmission will be inhibited if the Peripheral channel is not Ready, as defined in the eSPI Peripheral Channel Ready Register."]
            #[inline(always)]
            pub const fn strt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing '1' to this bit triggers the transmission of an LTR packet defined by the LTR Peripheral Message register. Writing '0' to this bit has no effect. The transmission will be inhibited if the Peripheral channel is not Ready, as defined in the eSPI Peripheral Channel Ready Register."]
            #[inline(always)]
            pub fn set_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This 4-bit value will be inserted as the TAG number in the next transmitted LTR packet. According to current understanding of Intel specs, this field should be kept zero by firmware."]
            #[inline(always)]
            pub const fn outg_tag(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "This 4-bit value will be inserted as the TAG number in the next transmitted LTR packet. According to current understanding of Intel specs, this field should be kept zero by firmware."]
            #[inline(always)]
            pub fn set_outg_tag(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for LtrCtrl {
            #[inline(always)]
            fn default() -> LtrCtrl {
                LtrCtrl(0)
            }
        }
        impl core::fmt::Debug for LtrCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LtrCtrl")
                    .field("strt", &self.strt())
                    .field("outg_tag", &self.outg_tag())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LtrCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "LtrCtrl {{ strt: {=bool:?}, outg_tag: {=u8:?} }}",
                    self.strt(),
                    self.outg_tag()
                )
            }
        }
        #[doc = "LTR Peripheral Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LtrEn(pub u32);
        impl LtrEn {
            #[doc = "When this bit is '1' an interrupt is generated when the bit TRANSMIT_DONE_STATUS in the LTR Peripheral Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn tx_done_ien(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit TRANSMIT_DONE_STATUS in the LTR Peripheral Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_tx_done_ien(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for LtrEn {
            #[inline(always)]
            fn default() -> LtrEn {
                LtrEn(0)
            }
        }
        impl core::fmt::Debug for LtrEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LtrEn")
                    .field("tx_done_ien", &self.tx_done_ien())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LtrEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LtrEn {{ tx_done_ien: {=bool:?} }}", self.tx_done_ien())
            }
        }
        #[doc = "LTR Peripheral Message Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LtrMesg(pub u32);
        impl LtrMesg {
            #[doc = "This field declares a time, in units expressed by the Scale field. Zero in both this field and the Scale field (zero time) demands best possible effort (minimal latency) by the chipset."]
            #[inline(always)]
            pub const fn val(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "This field declares a time, in units expressed by the Scale field. Zero in both this field and the Scale field (zero time) demands best possible effort (minimal latency) by the chipset."]
            #[inline(always)]
            pub fn set_val(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
            #[doc = "This field declares the time unit expressed by each count of the Value field of this register."]
            #[inline(always)]
            pub const fn scal(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x07;
                val as u8
            }
            #[doc = "This field declares the time unit expressed by each count of the Value field of this register."]
            #[inline(always)]
            pub fn set_scal(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 10usize)) | (((val as u32) & 0x07) << 10usize);
            }
            #[doc = "These bits are Read/Write, but are undefined in the 16-bit LTR message format. These bits are transmitted, but according to current specs they must always be kept as zeros when writing this register."]
            #[inline(always)]
            pub const fn res_tx_bits(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are Read/Write, but are undefined in the 16-bit LTR message format. These bits are transmitted, but according to current specs they must always be kept as zeros when writing this register."]
            #[inline(always)]
            pub fn set_res_tx_bits(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 13usize)) | (((val as u32) & 0x03) << 13usize);
            }
            #[doc = "1 = Maximum latency tolerated is defined by the Scale and Length fields of this register. 0 = No Requirement. Infinite latency tolerated. (Default)."]
            #[inline(always)]
            pub const fn req_bit(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "1 = Maximum latency tolerated is defined by the Scale and Length fields of this register. 0 = No Requirement. Infinite latency tolerated. (Default)."]
            #[inline(always)]
            pub fn set_req_bit(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for LtrMesg {
            #[inline(always)]
            fn default() -> LtrMesg {
                LtrMesg(0)
            }
        }
        impl core::fmt::Debug for LtrMesg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LtrMesg")
                    .field("val", &self.val())
                    .field("scal", &self.scal())
                    .field("res_tx_bits", &self.res_tx_bits())
                    .field("req_bit", &self.req_bit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LtrMesg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "LtrMesg {{ val: {=u16:?}, scal: {=u8:?}, res_tx_bits: {=u8:?}, req_bit: {=bool:?} }}",
                    self.val(),
                    self.scal(),
                    self.res_tx_bits(),
                    self.req_bit()
                )
            }
        }
        #[doc = "LTR Peripheral Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LtrSts(pub u32);
        impl LtrSts {
            #[doc = "This bit is set to '1' whenever a Transmit operation terminates (the TRANSMIT_DONE bit in this register goes from 1 to 0). (R/WC)"]
            #[inline(always)]
            pub const fn tx_don_sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' whenever a Transmit operation terminates (the TRANSMIT_DONE bit in this register goes from 1 to 0). (R/WC)"]
            #[inline(always)]
            pub fn set_tx_don_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "A Start was attempted while the TRANSMIT_BUSY bit in this register was '1'. Any Transmit in progress is immediately terminated. (R/WC)"]
            #[inline(always)]
            pub const fn strt_ovrun_sts(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "A Start was attempted while the TRANSMIT_BUSY bit in this register was '1'. Any Transmit in progress is immediately terminated. (R/WC)"]
            #[inline(always)]
            pub fn set_strt_ovrun_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "A '1' in this bit indicates that the last requested Transmit operation was aborted because Bus Mastering has been disabled by the Host. Bus Mastering is disabled whenever the Peripheral Channel Mastering Enable bit in that register is '0', or the Peripheral Channel Enable bit is '0'."]
            #[inline(always)]
            pub const fn dis_h_sts(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "A '1' in this bit indicates that the last requested Transmit operation was aborted because Bus Mastering has been disabled by the Host. Bus Mastering is disabled whenever the Peripheral Channel Mastering Enable bit in that register is '0', or the Peripheral Channel Enable bit is '0'."]
            #[inline(always)]
            pub fn set_dis_h_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit is set to '1' when firmware writes '1' to the LTR_START (ltr_initiate) bit in the LTR Peripheral Control Register. It is cleared by hardware when the transfer is sufficiently complete so that another packet can be transmitted. If the LTR_START bit is written to '1' while this bit is also '1', then START_OVERRUN_STATUS in this register will be set to '1' and the transfer will terminate immediately."]
            #[inline(always)]
            pub const fn tx_busy(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' when firmware writes '1' to the LTR_START (ltr_initiate) bit in the LTR Peripheral Control Register. It is cleared by hardware when the transfer is sufficiently complete so that another packet can be transmitted. If the LTR_START bit is written to '1' while this bit is also '1', then START_OVERRUN_STATUS in this register will be set to '1' and the transfer will terminate immediately."]
            #[inline(always)]
            pub fn set_tx_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for LtrSts {
            #[inline(always)]
            fn default() -> LtrSts {
                LtrSts(0)
            }
        }
        impl core::fmt::Debug for LtrSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LtrSts")
                    .field("tx_don_sts", &self.tx_don_sts())
                    .field("strt_ovrun_sts", &self.strt_ovrun_sts())
                    .field("dis_h_sts", &self.dis_h_sts())
                    .field("tx_busy", &self.tx_busy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LtrSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "LtrSts {{ tx_don_sts: {=bool:?}, strt_ovrun_sts: {=bool:?}, dis_h_sts: {=bool:?}, tx_busy: {=bool:?} }}" , self . tx_don_sts () , self . strt_ovrun_sts () , self . dis_h_sts () , self . tx_busy ())
            }
        }
        #[doc = "Mailbox Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbxAddr(pub u32);
        impl MbxAddr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for MbxAddr {
            #[inline(always)]
            fn default() -> MbxAddr {
                MbxAddr(0)
            }
        }
        impl core::fmt::Debug for MbxAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbxAddr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbxAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "MbxAddr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "Mailbox BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbxBaseAddr(pub u32);
        impl MbxBaseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for MbxBaseAddr {
            #[inline(always)]
            fn default() -> MbxBaseAddr {
                MbxBaseAddr(0)
            }
        }
        impl core::fmt::Debug for MbxBaseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbxBaseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbxBaseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "MbxBaseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "Mailbox (MBX_Host_SIRQ Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbxHostSirqIrq(pub u8);
        impl MbxHostSirqIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MbxHostSirqIrq {
            #[inline(always)]
            fn default() -> MbxHostSirqIrq {
                MbxHostSirqIrq(0)
            }
        }
        impl core::fmt::Debug for MbxHostSirqIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbxHostSirqIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbxHostSirqIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MbxHostSirqIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "Mailbox (MBX_Host_SMI Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MbxHostSmiIrq(pub u8);
        impl MbxHostSmiIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MbxHostSmiIrq {
            #[inline(always)]
            fn default() -> MbxHostSmiIrq {
                MbxHostSmiIrq(0)
            }
        }
        impl core::fmt::Debug for MbxHostSmiIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MbxHostSmiIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MbxHostSmiIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MbxHostSmiIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "8042 (MIRQ Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mirq8042irq(pub u8);
        impl Mirq8042irq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Mirq8042irq {
            #[inline(always)]
            fn default() -> Mirq8042irq {
                Mirq8042irq(0)
            }
        }
        impl core::fmt::Debug for Mirq8042irq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mirq8042irq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mirq8042irq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mirq8042irq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "eSPI OOB Channel Capabilities Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobCap(pub u8);
        impl OobCap {
            #[doc = "This field identifies the maximum payload size supported by the slave. It corresponds to the field OOB Message Channel Maximum Payload Size Supported, bits \\[6:4\\] of the OOB Channel Capabilities and Configurations Register. 111b - 100b=Reserved 011b=265 bytes address max payload size 010b=137 bytes address max payload size 001b=73 bytes address max payload size 000b=Reserved."]
            #[inline(always)]
            pub const fn max_payld_siz(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "This field identifies the maximum payload size supported by the slave. It corresponds to the field OOB Message Channel Maximum Payload Size Supported, bits \\[6:4\\] of the OOB Channel Capabilities and Configurations Register. 111b - 100b=Reserved 011b=265 bytes address max payload size 010b=137 bytes address max payload size 001b=73 bytes address max payload size 000b=Reserved."]
            #[inline(always)]
            pub fn set_max_payld_siz(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u8) & 0x07) << 0usize);
            }
        }
        impl Default for OobCap {
            #[inline(always)]
            fn default() -> OobCap {
                OobCap(0)
            }
        }
        impl core::fmt::Debug for OobCap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobCap")
                    .field("max_payld_siz", &self.max_payld_siz())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobCap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "OobCap {{ max_payld_siz: {=u8:?} }}", self.max_payld_siz())
            }
        }
        #[doc = "eSPI OOB Channel Ready Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobReady(pub u8);
        impl OobReady {
            #[doc = "Firmware sets this bit to '1' to inform the Master that the OOB channel is ready for transactions. It corresponds to the field OOB Message Channel Ready, bit 1 of Config Offset 30h=OOB ChannelCapabilities and Configurations Register. It is forced to '0' while the OOB Message Channel Enabled bit in the Capabilities and Configurations register is 0. Once set to '1' it cannot be set to '0' by firmware. It is only set to '0' by a reset, or when the Master changes the Enabled bit to '0'. While this bit is '0' all OOB up transactions initiated by the Slave are inhibited."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Firmware sets this bit to '1' to inform the Master that the OOB channel is ready for transactions. It corresponds to the field OOB Message Channel Ready, bit 1 of Config Offset 30h=OOB ChannelCapabilities and Configurations Register. It is forced to '0' while the OOB Message Channel Enabled bit in the Capabilities and Configurations register is 0. Once set to '1' it cannot be set to '0' by firmware. It is only set to '0' by a reset, or when the Master changes the Enabled bit to '0'. While this bit is '0' all OOB up transactions initiated by the Slave are inhibited."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for OobReady {
            #[inline(always)]
            fn default() -> OobReady {
                OobReady(0)
            }
        }
        impl core::fmt::Debug for OobReady {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobReady").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobReady {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "OobReady {{ chn: {=bool:?} }}", self.chn())
            }
        }
        #[doc = "OOB Channel Receive Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobRxAddrLsw(pub u32);
        impl OobRxAddrLsw {
            #[doc = "This field must be initialized to contain the Base Address for accepting the next OOB packet."]
            #[inline(always)]
            pub const fn rx_buf(&self) -> u32 {
                let val = (self.0 >> 2usize) & 0x3fff_ffff;
                val as u32
            }
            #[doc = "This field must be initialized to contain the Base Address for accepting the next OOB packet."]
            #[inline(always)]
            pub fn set_rx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0x3fff_ffff << 2usize)) | (((val as u32) & 0x3fff_ffff) << 2usize);
            }
        }
        impl Default for OobRxAddrLsw {
            #[inline(always)]
            fn default() -> OobRxAddrLsw {
                OobRxAddrLsw(0)
            }
        }
        impl core::fmt::Debug for OobRxAddrLsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobRxAddrLsw").field("rx_buf", &self.rx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobRxAddrLsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "OobRxAddrLsw {{ rx_buf: {=u32:?} }}", self.rx_buf())
            }
        }
        #[doc = "OOB Channel Receive Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobRxCtrl(pub u32);
        impl OobRxCtrl {
            #[doc = "Firmware sets this bit to '1' to indicate that an SRAM buffer is available to receive the next Down OOB packet. This forces the bit RECEIVE_ENABLE bit in the OOB Channel Receive Status Register register to be set to '1'. The OOB Channel Receive Address Register and OOB Channel Receive Length Register must have already been initialized before setting this bit."]
            #[inline(always)]
            pub const fn set_rx_avail(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Firmware sets this bit to '1' to indicate that an SRAM buffer is available to receive the next Down OOB packet. This forces the bit RECEIVE_ENABLE bit in the OOB Channel Receive Status Register register to be set to '1'. The OOB Channel Receive Address Register and OOB Channel Receive Length Register must have already been initialized before setting this bit."]
            #[inline(always)]
            pub fn set_set_rx_avail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This allows firmware to read the OOB Message Channel Enabled field in the eSPI Configuration register. The Master sets the bit to '1' to enable the OOB channel."]
            #[inline(always)]
            pub const fn chn_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This allows firmware to read the OOB Message Channel Enabled field in the eSPI Configuration register. The Master sets the bit to '1' to enable the OOB channel."]
            #[inline(always)]
            pub fn set_chn_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This allows firmware to read the correspondingly-named field in the eSPI Configuration register. The 001b default code selects 64-byte mode, which is actually a 73-byte max payload size for eSPI (64 bytes plus MCTP wrapper bytes)."]
            #[inline(always)]
            pub const fn max_payld_size_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "This allows firmware to read the correspondingly-named field in the eSPI Configuration register. The 001b default code selects 64-byte mode, which is actually a 73-byte max payload size for eSPI (64 bytes plus MCTP wrapper bytes)."]
            #[inline(always)]
            pub fn set_max_payld_size_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
        }
        impl Default for OobRxCtrl {
            #[inline(always)]
            fn default() -> OobRxCtrl {
                OobRxCtrl(0)
            }
        }
        impl core::fmt::Debug for OobRxCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobRxCtrl")
                    .field("set_rx_avail", &self.set_rx_avail())
                    .field("chn_en", &self.chn_en())
                    .field("max_payld_size_sel", &self.max_payld_size_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobRxCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "OobRxCtrl {{ set_rx_avail: {=bool:?}, chn_en: {=bool:?}, max_payld_size_sel: {=u8:?} }}",
                    self.set_rx_avail(),
                    self.chn_en(),
                    self.max_payld_size_sel()
                )
            }
        }
        #[doc = "OOB Channel Receive Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobRxIen(pub u32);
        impl OobRxIen {
            #[doc = "When this bit is '1' an interrupt is generated when the bit RECEIVE_DONE_STATUS in the OOB Channel Receive Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn rx_ien(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit RECEIVE_DONE_STATUS in the OOB Channel Receive Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_rx_ien(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for OobRxIen {
            #[inline(always)]
            fn default() -> OobRxIen {
                OobRxIen(0)
            }
        }
        impl core::fmt::Debug for OobRxIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobRxIen").field("rx_ien", &self.rx_ien()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobRxIen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "OobRxIen {{ rx_ien: {=bool:?} }}", self.rx_ien())
            }
        }
        #[doc = "OOB Channel Receive Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobRxLen(pub u32);
        impl OobRxLen {
            #[doc = "This 13-bit read-only field reports how many bytes were received into SRAM in the last packet. This is necessary, independent of any 'byte count' in the packet itself to distinguish between an SMBus packet with or without a PEC byte."]
            #[inline(always)]
            pub const fn msg(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "This 13-bit read-only field reports how many bytes were received into SRAM in the last packet. This is necessary, independent of any 'byte count' in the packet itself to distinguish between an SMBus packet with or without a PEC byte."]
            #[inline(always)]
            pub fn set_msg(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
            #[doc = "Before setting the Receive Enable bit to allow incoming traffic to the Receive Buffer area, this 13-bit field must be initialized to contain the length in bytes of the receiving buffer in SRAM. This limits the number of bytes that can be received into SRAM. Any additional incoming bytes must be discarded by hardware, posting the Data Overrun error flag. Practically, the maximum value that can be placed in this field is the configured Max Packet Length. This limit, or anything higher, is legal, but will effectively disable the limit check."]
            #[inline(always)]
            pub const fn buf(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x1fff;
                val as u16
            }
            #[doc = "Before setting the Receive Enable bit to allow incoming traffic to the Receive Buffer area, this 13-bit field must be initialized to contain the length in bytes of the receiving buffer in SRAM. This limits the number of bytes that can be received into SRAM. Any additional incoming bytes must be discarded by hardware, posting the Data Overrun error flag. Practically, the maximum value that can be placed in this field is the configured Max Packet Length. This limit, or anything higher, is legal, but will effectively disable the limit check."]
            #[inline(always)]
            pub fn set_buf(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 16usize)) | (((val as u32) & 0x1fff) << 16usize);
            }
        }
        impl Default for OobRxLen {
            #[inline(always)]
            fn default() -> OobRxLen {
                OobRxLen(0)
            }
        }
        impl core::fmt::Debug for OobRxLen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobRxLen")
                    .field("msg", &self.msg())
                    .field("buf", &self.buf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobRxLen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "OobRxLen {{ msg: {=u16:?}, buf: {=u16:?} }}", self.msg(), self.buf())
            }
        }
        #[doc = "OOB Channel Receive Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobRxSts(pub u32);
        impl OobRxSts {
            #[doc = "This bit is set to '1' whenever the RECEIVE_ENABLE bit in this register is cleared to '0' by hardware when an incoming packet is completely transferred to SRAM. This bit is also set whenever either OVERRUN_STATUS or INTERNAL_BUS_ERROR_STATUS in this register are set to '1'. (R/WC)."]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' whenever the RECEIVE_ENABLE bit in this register is cleared to '0' by hardware when an incoming packet is completely transferred to SRAM. This bit is also set whenever either OVERRUN_STATUS or INTERNAL_BUS_ERROR_STATUS in this register are set to '1'. (R/WC)."]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to '1' whenever the channel tries to write an incoming byte into an invalid area of the internal addressing space. This could happen if the OOB Channel Receive Address Register was set to something invalid by firmware. If this error occurs mid-packet(crossing a boundary into an invalid space), then the remaining data is discarded. (R/WC)."]
            #[inline(always)]
            pub const fn int_bus_err_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' whenever the channel tries to write an incoming byte into an invalid area of the internal addressing space. This could happen if the OOB Channel Receive Address Register was set to something invalid by firmware. If this error occurs mid-packet(crossing a boundary into an invalid space), then the remaining data is discarded. (R/WC)."]
            #[inline(always)]
            pub fn set_int_bus_err_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is set to '1' whenever an incoming packet is truncated because it was longer than the RECEIVE_BUFFER_LENGTH field. Incoming extra bytes are discarded when this error is triggered, but the buffer receives the data up to its limit, for debugging purposes. (R/WC)"]
            #[inline(always)]
            pub const fn ovrun_sts(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' whenever an incoming packet is truncated because it was longer than the RECEIVE_BUFFER_LENGTH field. Incoming extra bytes are discarded when this error is triggered, but the buffer receives the data up to its limit, for debugging purposes. (R/WC)"]
            #[inline(always)]
            pub fn set_ovrun_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is set to '1' when firmware sets the bit SET_RECEIVE_AVAILABLE in the OOB Channel Receive Control Register to '1', to indicate that an SRAM buffer is available to receive the next Down OOB packet. The OOB Channel Receive Address Register and OOB Channel Receive Length Register must have already been initialized before setting this bit. This bit is cleared by hardware when the next packet is received. The RECEIVE_DONE_STATUS bit is set to '1' after this bit is cleared. A '0' in this bit does not necessarily present 'Not Free' status to the eSPI Master. As long as FIFO space is available for a complete OOB packet, the packet can be input and held in the FIFO until this bit is again set by firmware."]
            #[inline(always)]
            pub const fn rx_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' when firmware sets the bit SET_RECEIVE_AVAILABLE in the OOB Channel Receive Control Register to '1', to indicate that an SRAM buffer is available to receive the next Down OOB packet. The OOB Channel Receive Address Register and OOB Channel Receive Length Register must have already been initialized before setting this bit. This bit is cleared by hardware when the next packet is received. The RECEIVE_DONE_STATUS bit is set to '1' after this bit is cleared. A '0' in this bit does not necessarily present 'Not Free' status to the eSPI Master. As long as FIFO space is available for a complete OOB packet, the packet can be input and held in the FIFO until this bit is again set by firmware."]
            #[inline(always)]
            pub fn set_rx_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This field holds the 4-bit TAG in the last message received from the Master."]
            #[inline(always)]
            pub const fn in_tag(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "This field holds the 4-bit TAG in the last message received from the Master."]
            #[inline(always)]
            pub fn set_in_tag(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for OobRxSts {
            #[inline(always)]
            fn default() -> OobRxSts {
                OobRxSts(0)
            }
        }
        impl core::fmt::Debug for OobRxSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobRxSts")
                    .field("done", &self.done())
                    .field("int_bus_err_sts", &self.int_bus_err_sts())
                    .field("ovrun_sts", &self.ovrun_sts())
                    .field("rx_en", &self.rx_en())
                    .field("in_tag", &self.in_tag())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobRxSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "OobRxSts {{ done: {=bool:?}, int_bus_err_sts: {=bool:?}, ovrun_sts: {=bool:?}, rx_en: {=bool:?}, in_tag: {=u8:?} }}" , self . done () , self . int_bus_err_sts () , self . ovrun_sts () , self . rx_en () , self . in_tag ())
            }
        }
        #[doc = "OOB Channel Transmit Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobTxAddrLsw(pub u32);
        impl OobTxAddrLsw {
            #[doc = "Before starting an OOB Transmit, this field must be initialized to contain the Base Address of the buffer in SRAM. The contents of the transmit buffer should not be modified while TRANSMIT_BUSY is asserted."]
            #[inline(always)]
            pub const fn tx_buf(&self) -> u32 {
                let val = (self.0 >> 2usize) & 0x3fff_ffff;
                val as u32
            }
            #[doc = "Before starting an OOB Transmit, this field must be initialized to contain the Base Address of the buffer in SRAM. The contents of the transmit buffer should not be modified while TRANSMIT_BUSY is asserted."]
            #[inline(always)]
            pub fn set_tx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0x3fff_ffff << 2usize)) | (((val as u32) & 0x3fff_ffff) << 2usize);
            }
        }
        impl Default for OobTxAddrLsw {
            #[inline(always)]
            fn default() -> OobTxAddrLsw {
                OobTxAddrLsw(0)
            }
        }
        impl core::fmt::Debug for OobTxAddrLsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobTxAddrLsw").field("tx_buf", &self.tx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobTxAddrLsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "OobTxAddrLsw {{ tx_buf: {=u32:?} }}", self.tx_buf())
            }
        }
        #[doc = "OOB Channel Transmit Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobTxCtrl(pub u32);
        impl OobTxCtrl {
            #[doc = "A write of '1' to this bit starts the transmission of an OOB packet defined by the OOB Channel Transmit Address Register and OOB Channel Transmit Length Register registers. A write of '0' has no effect. The transmission will be inhibited if the OOB channel is not Ready, as defined in the eSPI OOB Channel Ready Register."]
            #[inline(always)]
            pub const fn tx_strt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "A write of '1' to this bit starts the transmission of an OOB packet defined by the OOB Channel Transmit Address Register and OOB Channel Transmit Length Register registers. A write of '0' has no effect. The transmission will be inhibited if the OOB channel is not Ready, as defined in the eSPI OOB Channel Ready Register."]
            #[inline(always)]
            pub fn set_tx_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This 4-bit value will be inserted as the TAG number in the next transmitted OOB packet. This field must be 0."]
            #[inline(always)]
            pub const fn outg_tag(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "This 4-bit value will be inserted as the TAG number in the next transmitted OOB packet. This field must be 0."]
            #[inline(always)]
            pub fn set_outg_tag(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for OobTxCtrl {
            #[inline(always)]
            fn default() -> OobTxCtrl {
                OobTxCtrl(0)
            }
        }
        impl core::fmt::Debug for OobTxCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobTxCtrl")
                    .field("tx_strt", &self.tx_strt())
                    .field("outg_tag", &self.outg_tag())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobTxCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "OobTxCtrl {{ tx_strt: {=bool:?}, outg_tag: {=u8:?} }}",
                    self.tx_strt(),
                    self.outg_tag()
                )
            }
        }
        #[doc = "OOB Channel Transmit Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobTxIen(pub u32);
        impl OobTxIen {
            #[doc = "When this bit is '1' an interrupt is generated when the bit TRANSMIT_DONE_STATUS in the OOB Channel Transmit Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit TRANSMIT_DONE_STATUS in the OOB Channel Transmit Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit CHANNEL_ENABLE_CHANGE_STATUS in the OOB Channel Transmit Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn chn_en_chng(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit CHANNEL_ENABLE_CHANGE_STATUS in the OOB Channel Transmit Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_chn_en_chng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for OobTxIen {
            #[inline(always)]
            fn default() -> OobTxIen {
                OobTxIen(0)
            }
        }
        impl core::fmt::Debug for OobTxIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobTxIen")
                    .field("done", &self.done())
                    .field("chn_en_chng", &self.chn_en_chng())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobTxIen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "OobTxIen {{ done: {=bool:?}, chn_en_chng: {=bool:?} }}",
                    self.done(),
                    self.chn_en_chng()
                )
            }
        }
        #[doc = "OOB Channel Transmit Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobTxLen(pub u32);
        impl OobTxLen {
            #[doc = "This 13-bit field declares how many bytes are to be transmitted from the Tramsit Buffer memory. A value of zero, or a value greater than the defined Max Packet Size (73 decimal, or 4Dh, by default) is illegal, and will trigger Bad Request handling."]
            #[inline(always)]
            pub const fn msg(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "This 13-bit field declares how many bytes are to be transmitted from the Tramsit Buffer memory. A value of zero, or a value greater than the defined Max Packet Size (73 decimal, or 4Dh, by default) is illegal, and will trigger Bad Request handling."]
            #[inline(always)]
            pub fn set_msg(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for OobTxLen {
            #[inline(always)]
            fn default() -> OobTxLen {
                OobTxLen(0)
            }
        }
        impl core::fmt::Debug for OobTxLen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobTxLen").field("msg", &self.msg()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobTxLen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "OobTxLen {{ msg: {=u16:?} }}", self.msg())
            }
        }
        #[doc = "OOB Channel Transmit Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OobTxSts(pub u32);
        impl OobTxSts {
            #[doc = "This bit is set to '1' whenever a Transmit operation terminates (TRANSMIT_BUSY in this register goes from '1' to '0'). (R/WC)"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' whenever a Transmit operation terminates (TRANSMIT_BUSY in this register goes from '1' to '0'). (R/WC)"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to '1' whenever the eSPI Master changes the state of the OOB Message Channel Enable bit in the OOB Channel Capabilities and Configurations Master register. (R/WC)."]
            #[inline(always)]
            pub const fn chn_en_chng_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' whenever the eSPI Master changes the state of the OOB Message Channel Enable bit in the OOB Channel Capabilities and Configurations Master register. (R/WC)."]
            #[inline(always)]
            pub fn set_chn_en_chng_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This error flag indicates an internal bus violation occurred in trying to transmit. (R/WC)"]
            #[inline(always)]
            pub const fn int_bus_err_sts(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This error flag indicates an internal bus violation occurred in trying to transmit. (R/WC)"]
            #[inline(always)]
            pub fn set_int_bus_err_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This error flag indicates a Start was attempted while the channel was Busy. Any Transmit in progress is immediately halted. (R/WC)"]
            #[inline(always)]
            pub const fn strt_ovrun_sts(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This error flag indicates a Start was attempted while the channel was Busy. Any Transmit in progress is immediately halted. (R/WC)"]
            #[inline(always)]
            pub fn set_strt_ovrun_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit is intended for any situation where a firmware request cannot be started because it expresses something impossible. This bit will be set for a request to Transmit 0 bytes or if a Transmit length is more than the selected Max Payload Length. This condition brings the state machine to the Done state, as if something had actually finished, with everything including the Done interrupt triggered. (R/WC)"]
            #[inline(always)]
            pub const fn bad_req(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is intended for any situation where a firmware request cannot be started because it expresses something impossible. This bit will be set for a request to Transmit 0 bytes or if a Transmit length is more than the selected Max Payload Length. This condition brings the state machine to the Done state, as if something had actually finished, with everything including the Done interrupt triggered. (R/WC)"]
            #[inline(always)]
            pub fn set_bad_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit is set to '1' when firmware writes '1' to the TRANSMIT_START bit. It is cleared by hardware when the transfer is complete. If the TRANSMIT_START bit is written '1' while this bit is also '1', then this will set the START_OVERRUN_STATUS bit to '1' and terminate the transfer attempt immediately (Transmit Done)."]
            #[inline(always)]
            pub const fn tx_busy(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' when firmware writes '1' to the TRANSMIT_START bit. It is cleared by hardware when the transfer is complete. If the TRANSMIT_START bit is written '1' while this bit is also '1', then this will set the START_OVERRUN_STATUS bit to '1' and terminate the transfer attempt immediately (Transmit Done)."]
            #[inline(always)]
            pub fn set_tx_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This bit is an image of the OOB Channel Enabled bit in the OOB Channel Receive Control Register register. It is provided here so that it can be seen with the CHANNEL_ENABLE_CHANGE_STATUS Interrupt Status bit for efficiency."]
            #[inline(always)]
            pub const fn chn_en_img(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is an image of the OOB Channel Enabled bit in the OOB Channel Receive Control Register register. It is provided here so that it can be seen with the CHANNEL_ENABLE_CHANGE_STATUS Interrupt Status bit for efficiency."]
            #[inline(always)]
            pub fn set_chn_en_img(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for OobTxSts {
            #[inline(always)]
            fn default() -> OobTxSts {
                OobTxSts(0)
            }
        }
        impl core::fmt::Debug for OobTxSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OobTxSts")
                    .field("done", &self.done())
                    .field("chn_en_chng_sts", &self.chn_en_chng_sts())
                    .field("int_bus_err_sts", &self.int_bus_err_sts())
                    .field("strt_ovrun_sts", &self.strt_ovrun_sts())
                    .field("bad_req", &self.bad_req())
                    .field("tx_busy", &self.tx_busy())
                    .field("chn_en_img", &self.chn_en_img())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OobTxSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "OobTxSts {{ done: {=bool:?}, chn_en_chng_sts: {=bool:?}, int_bus_err_sts: {=bool:?}, strt_ovrun_sts: {=bool:?}, bad_req: {=bool:?}, tx_busy: {=bool:?}, chn_en_img: {=bool:?} }}" , self . done () , self . chn_en_chng_sts () , self . int_bus_err_sts () , self . strt_ovrun_sts () , self . bad_req () , self . tx_busy () , self . chn_en_img ())
            }
        }
        #[doc = "eSPI Peripheral Channel Capabilities Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PcCap(pub u8);
        impl PcCap {
            #[doc = "This field identifies the maximum payload size supported by the slave. It corresponds to the field Peripheral Channel Maximum Payload Size Supported, bits \\[6:4\\] of the Peripheral Channel Capabilities and Configurations Register. 111b - 100b=Reserved 011b=256 bytes address aligned max payload size 010b=128 bytes address aligned max payload size 001b=64 bytes address aligned max payload size 000b=Reserved."]
            #[inline(always)]
            pub const fn max_payld_size(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "This field identifies the maximum payload size supported by the slave. It corresponds to the field Peripheral Channel Maximum Payload Size Supported, bits \\[6:4\\] of the Peripheral Channel Capabilities and Configurations Register. 111b - 100b=Reserved 011b=256 bytes address aligned max payload size 010b=128 bytes address aligned max payload size 001b=64 bytes address aligned max payload size 000b=Reserved."]
            #[inline(always)]
            pub fn set_max_payld_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u8) & 0x07) << 0usize);
            }
        }
        impl Default for PcCap {
            #[inline(always)]
            fn default() -> PcCap {
                PcCap(0)
            }
        }
        impl core::fmt::Debug for PcCap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PcCap")
                    .field("max_payld_size", &self.max_payld_size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PcCap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PcCap {{ max_payld_size: {=u8:?} }}", self.max_payld_size())
            }
        }
        #[doc = "Peripheral Channel Error Address Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PcErrAddrLsw(pub u32);
        impl PcErrAddrLsw {
            #[doc = "This field records bits\\[31:0\\] of the 64 bit address of the most recent eSPI transaction that incurred an error."]
            #[inline(always)]
            pub const fn lsdw(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field records bits\\[31:0\\] of the 64 bit address of the most recent eSPI transaction that incurred an error."]
            #[inline(always)]
            pub fn set_lsdw(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for PcErrAddrLsw {
            #[inline(always)]
            fn default() -> PcErrAddrLsw {
                PcErrAddrLsw(0)
            }
        }
        impl core::fmt::Debug for PcErrAddrLsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PcErrAddrLsw").field("lsdw", &self.lsdw()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PcErrAddrLsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PcErrAddrLsw {{ lsdw: {=u32:?} }}", self.lsdw())
            }
        }
        #[doc = "Peripheral Channel Error Address Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PcErrAddrMsw(pub u32);
        impl PcErrAddrMsw {
            #[doc = "This field records bits\\[63:32\\] of the 64 bit address of the most recent eSPI transaction that incurred an error."]
            #[inline(always)]
            pub const fn msdw(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field records bits\\[63:32\\] of the 64 bit address of the most recent eSPI transaction that incurred an error."]
            #[inline(always)]
            pub fn set_msdw(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for PcErrAddrMsw {
            #[inline(always)]
            fn default() -> PcErrAddrMsw {
                PcErrAddrMsw(0)
            }
        }
        impl core::fmt::Debug for PcErrAddrMsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PcErrAddrMsw").field("msdw", &self.msdw()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PcErrAddrMsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PcErrAddrMsw {{ msdw: {=u32:?} }}", self.msdw())
            }
        }
        #[doc = "Peripheral Channel Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PcIen(pub u32);
        impl PcIen {
            #[doc = "When this bit is '1' an interrupt is generated when the bit PC_VIRTUAL_READ in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn vir_rd_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit PC_VIRTUAL_READ in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_vir_rd_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit PC_VIRTUAL_WRITE in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn vir_wr_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit PC_VIRTUAL_WRITE in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_vir_wr_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit PC_BUS_ERROR in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn bus_err_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit PC_BUS_ERROR in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_bus_err_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit BAR_CONFLICT in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn bar_confl_en(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit BAR_CONFLICT in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_bar_confl_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit PC_ENABLE_CHANGE in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn en_chng_en(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit PC_ENABLE_CHANGE in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_en_chng_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit PC_MASTERING_ENABLE_CHANGE in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn m_en_chng_en(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit PC_MASTERING_ENABLE_CHANGE in the Peripheral Channel Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_m_en_chng_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for PcIen {
            #[inline(always)]
            fn default() -> PcIen {
                PcIen(0)
            }
        }
        impl core::fmt::Debug for PcIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PcIen")
                    .field("vir_rd_en", &self.vir_rd_en())
                    .field("vir_wr_en", &self.vir_wr_en())
                    .field("bus_err_en", &self.bus_err_en())
                    .field("bar_confl_en", &self.bar_confl_en())
                    .field("en_chng_en", &self.en_chng_en())
                    .field("m_en_chng_en", &self.m_en_chng_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PcIen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PcIen {{ vir_rd_en: {=bool:?}, vir_wr_en: {=bool:?}, bus_err_en: {=bool:?}, bar_confl_en: {=bool:?}, en_chng_en: {=bool:?}, m_en_chng_en: {=bool:?} }}" , self . vir_rd_en () , self . vir_wr_en () , self . bus_err_en () , self . bar_confl_en () , self . en_chng_en () , self . m_en_chng_en ())
            }
        }
        #[doc = "Peripheral Channel Last Cycle Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PcLcAddrLsw(pub u32);
        impl PcLcAddrLsw {
            #[doc = "This field records bits\\[31:0\\] of the 64 bit address of the most recent eSPI transaction."]
            #[inline(always)]
            pub const fn ladr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field records bits\\[31:0\\] of the 64 bit address of the most recent eSPI transaction."]
            #[inline(always)]
            pub fn set_ladr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for PcLcAddrLsw {
            #[inline(always)]
            fn default() -> PcLcAddrLsw {
                PcLcAddrLsw(0)
            }
        }
        impl core::fmt::Debug for PcLcAddrLsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PcLcAddrLsw").field("ladr", &self.ladr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PcLcAddrLsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PcLcAddrLsw {{ ladr: {=u32:?} }}", self.ladr())
            }
        }
        #[doc = "Peripheral Channel Last Cycle Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PcLcAddrMsw(pub u32);
        impl PcLcAddrMsw {
            #[doc = "This field records bits\\[63:32\\] of the 64 bit address of the most recent eSPI transaction."]
            #[inline(always)]
            pub const fn madr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field records bits\\[63:32\\] of the 64 bit address of the most recent eSPI transaction."]
            #[inline(always)]
            pub fn set_madr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for PcLcAddrMsw {
            #[inline(always)]
            fn default() -> PcLcAddrMsw {
                PcLcAddrMsw(0)
            }
        }
        impl core::fmt::Debug for PcLcAddrMsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PcLcAddrMsw").field("madr", &self.madr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PcLcAddrMsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PcLcAddrMsw {{ madr: {=u32:?} }}", self.madr())
            }
        }
        #[doc = "Peripheral Channel Last Cycle Register (DWord 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PcLcLenTypeTag(pub u32);
        impl PcLcLenTypeTag {
            #[doc = "This field records the length of the most recent eSPI transaction."]
            #[inline(always)]
            pub const fn pc_len(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "This field records the length of the most recent eSPI transaction."]
            #[inline(always)]
            pub fn set_pc_len(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "This field records the cycle type of the most recent eSPI transaction."]
            #[inline(always)]
            pub const fn pc_cy_type(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0xff;
                val as u8
            }
            #[doc = "This field records the cycle type of the most recent eSPI transaction."]
            #[inline(always)]
            pub fn set_pc_cy_type(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 12usize)) | (((val as u32) & 0xff) << 12usize);
            }
            #[doc = "This field records the tag of the most recent eSPI transaction."]
            #[inline(always)]
            pub const fn pc_tag(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "This field records the tag of the most recent eSPI transaction."]
            #[inline(always)]
            pub fn set_pc_tag(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
        }
        impl Default for PcLcLenTypeTag {
            #[inline(always)]
            fn default() -> PcLcLenTypeTag {
                PcLcLenTypeTag(0)
            }
        }
        impl core::fmt::Debug for PcLcLenTypeTag {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PcLcLenTypeTag")
                    .field("pc_len", &self.pc_len())
                    .field("pc_cy_type", &self.pc_cy_type())
                    .field("pc_tag", &self.pc_tag())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PcLcLenTypeTag {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "PcLcLenTypeTag {{ pc_len: {=u16:?}, pc_cy_type: {=u8:?}, pc_tag: {=u8:?} }}",
                    self.pc_len(),
                    self.pc_cy_type(),
                    self.pc_tag()
                )
            }
        }
        #[doc = "eSPI Peripheral Channel Ready Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PcReady(pub u8);
        impl PcReady {
            #[doc = "Firmware sets this bit to '1' to inform the Master than the Peripheral channel is ready for transactions. It corresponds to the field Peripheral Channel Ready, bit 1 of the Config Offset 10h=Peripheral Channel Capabilities and Configurations Register. It is forced to '0' while the Peripheral Channel Enabled bit in the Capabilities and Configurations register is 0. Once set to '1' it cannot be set to '0' by firmware. It is only set to '0' by a reset, or when the Master changes the Enabled bit to '0'. While this bit is '0' all Bus Master and LTR transactions initiated by the Slave are inhibited."]
            #[inline(always)]
            pub const fn phl_chn_rdy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Firmware sets this bit to '1' to inform the Master than the Peripheral channel is ready for transactions. It corresponds to the field Peripheral Channel Ready, bit 1 of the Config Offset 10h=Peripheral Channel Capabilities and Configurations Register. It is forced to '0' while the Peripheral Channel Enabled bit in the Capabilities and Configurations register is 0. Once set to '1' it cannot be set to '0' by firmware. It is only set to '0' by a reset, or when the Master changes the Enabled bit to '0'. While this bit is '0' all Bus Master and LTR transactions initiated by the Slave are inhibited."]
            #[inline(always)]
            pub fn set_phl_chn_rdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for PcReady {
            #[inline(always)]
            fn default() -> PcReady {
                PcReady(0)
            }
        }
        impl core::fmt::Debug for PcReady {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PcReady")
                    .field("phl_chn_rdy", &self.phl_chn_rdy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PcReady {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PcReady {{ phl_chn_rdy: {=bool:?} }}", self.phl_chn_rdy())
            }
        }
        #[doc = "Peripheral Channel Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PcStatus(pub u32);
        impl PcStatus {
            #[doc = "This bit is set whenever a eSPI read transaction targeting a Logical Device with an I/O BAR or a Memory BAR in which the VIRTUALIZED bit is set. (R/WC)"]
            #[inline(always)]
            pub const fn vir_rd(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set whenever a eSPI read transaction targeting a Logical Device with an I/O BAR or a Memory BAR in which the VIRTUALIZED bit is set. (R/WC)"]
            #[inline(always)]
            pub fn set_vir_rd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set whenever a eSPI write transaction targeting a Logical Device with an I/O BAR or a Memory BAR in which the VIRTUALIZED bit is set. (R/WC)"]
            #[inline(always)]
            pub const fn vir_wr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set whenever a eSPI write transaction targeting a Logical Device with an I/O BAR or a Memory BAR in which the VIRTUALIZED bit is set. (R/WC)"]
            #[inline(always)]
            pub fn set_vir_wr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit returns the type of Virtualized eSPI transaction that is 1=Peripheral Channel Memory Address access 0=Peripheral Channel I/O Address access."]
            #[inline(always)]
            pub const fn vir_typ(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit returns the type of Virtualized eSPI transaction that is 1=Peripheral Channel Memory Address access 0=Peripheral Channel I/O Address access."]
            #[inline(always)]
            pub fn set_vir_typ(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This field returns the Logical Device Number of the device targeted by the most recent virtual transaction."]
            #[inline(always)]
            pub const fn vir_bar_ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "This field returns the Logical Device Number of the device targeted by the most recent virtual transaction."]
            #[inline(always)]
            pub fn set_vir_bar_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "This bit is set to '1' whenever an eSPI access causes an internal bus error. Once set, it remains set until cleared by being written with a 1. (R/WC)"]
            #[inline(always)]
            pub const fn pc_bus_error(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' whenever an eSPI access causes an internal bus error. Once set, it remains set until cleared by being written with a 1. (R/WC)"]
            #[inline(always)]
            pub fn set_pc_bus_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to '1' whenever a BAR conflict occurs on an eSPI address. A BAR conflict occurs when more than one BAR matches the address of an eSPI transaction. Once set, it remains set until cleared by being written with a 1. (R/WC)"]
            #[inline(always)]
            pub const fn bar_confl(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' whenever a BAR conflict occurs on an eSPI address. A BAR conflict occurs when more than one BAR matches the address of an eSPI transaction. Once set, it remains set until cleared by being written with a 1. (R/WC)"]
            #[inline(always)]
            pub fn set_bar_confl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit reflects the Host writable configuration field."]
            #[inline(always)]
            pub const fn chn_en_sts(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reflects the Host writable configuration field."]
            #[inline(always)]
            pub fn set_chn_en_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "This bit is set to '1' whenever the field PC_CHANNEL_ENABLE_STATUS in this register changes. Once set, it remains set until cleared by being written with a 1. (R/WC)"]
            #[inline(always)]
            pub const fn en_chng(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' whenever the field PC_CHANNEL_ENABLE_STATUS in this register changes. Once set, it remains set until cleared by being written with a 1. (R/WC)"]
            #[inline(always)]
            pub fn set_en_chng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "This bit is 1 if three bits in the Peripheral Channel Capabilities and Configurations register, Peripheral Channel Mastering Enable, Peripheral Channel Ready and Peripheral Channel Enable, are all 1, and 0 otherwise."]
            #[inline(always)]
            pub const fn m_en_sts(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is 1 if three bits in the Peripheral Channel Capabilities and Configurations register, Peripheral Channel Mastering Enable, Peripheral Channel Ready and Peripheral Channel Enable, are all 1, and 0 otherwise."]
            #[inline(always)]
            pub fn set_m_en_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "This bit is set to '1' whenever the field PC_MASTERING_ENABLE_STATUS in this register changes. Once set, it remains set until cleared by being written with a 1 (R/WC)"]
            #[inline(always)]
            pub const fn m_en_chng(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' whenever the field PC_MASTERING_ENABLE_STATUS in this register changes. Once set, it remains set until cleared by being written with a 1 (R/WC)"]
            #[inline(always)]
            pub fn set_m_en_chng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for PcStatus {
            #[inline(always)]
            fn default() -> PcStatus {
                PcStatus(0)
            }
        }
        impl core::fmt::Debug for PcStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PcStatus")
                    .field("vir_rd", &self.vir_rd())
                    .field("vir_wr", &self.vir_wr())
                    .field("vir_typ", &self.vir_typ())
                    .field("vir_bar_ldn", &self.vir_bar_ldn())
                    .field("pc_bus_error", &self.pc_bus_error())
                    .field("bar_confl", &self.bar_confl())
                    .field("chn_en_sts", &self.chn_en_sts())
                    .field("en_chng", &self.en_chng())
                    .field("m_en_sts", &self.m_en_sts())
                    .field("m_en_chng", &self.m_en_chng())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PcStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PcStatus {{ vir_rd: {=bool:?}, vir_wr: {=bool:?}, vir_typ: {=bool:?}, vir_bar_ldn: {=u8:?}, pc_bus_error: {=bool:?}, bar_confl: {=bool:?}, chn_en_sts: {=bool:?}, en_chng: {=bool:?}, m_en_sts: {=bool:?}, m_en_chng: {=bool:?} }}" , self . vir_rd () , self . vir_wr () , self . vir_typ () , self . vir_bar_ldn () , self . pc_bus_error () , self . bar_confl () , self . chn_en_sts () , self . en_chng () , self . m_en_sts () , self . m_en_chng ())
            }
        }
        #[doc = "PLTRST Source Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PltrstSrc(pub u8);
        impl PltrstSrc {
            #[doc = "1=The PLTRST reset signal is determined a signal external to the eSPI block. The PLTRST# virtual wire is ignored 0=The PLTRST reset signal is determined by the PLTRST# virtual wire."]
            #[inline(always)]
            pub const fn src(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The PLTRST reset signal is determined a signal external to the eSPI block. The PLTRST# virtual wire is ignored 0=The PLTRST reset signal is determined by the PLTRST# virtual wire."]
            #[inline(always)]
            pub fn set_src(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for PltrstSrc {
            #[inline(always)]
            fn default() -> PltrstSrc {
                PltrstSrc(0)
            }
        }
        impl core::fmt::Debug for PltrstSrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PltrstSrc").field("src", &self.src()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PltrstSrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PltrstSrc {{ src: {=bool:?} }}", self.src())
            }
        }
        #[doc = "BIOS Debug Port (Port 80) 0 BAR Config Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Port800addr(pub u32);
        impl Port800addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Port800addr {
            #[inline(always)]
            fn default() -> Port800addr {
                Port800addr(0)
            }
        }
        impl core::fmt::Debug for Port800addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Port800addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Port800addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Port800addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "BIOS Debug Port (Port 80) 0 BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Port800baseAddr(pub u32);
        impl Port800baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Port800baseAddr {
            #[inline(always)]
            fn default() -> Port800baseAddr {
                Port800baseAddr(0)
            }
        }
        impl core::fmt::Debug for Port800baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Port800baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Port800baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Port800baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "BIOS Debug Port (Port 80) 1 BAR Config Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Port801addr(pub u32);
        impl Port801addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Port801addr {
            #[inline(always)]
            fn default() -> Port801addr {
                Port801addr(0)
            }
        }
        impl core::fmt::Debug for Port801addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Port801addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Port801addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Port801addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "BIOS Debug Port (Port 80) 1 BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Port801baseAddr(pub u32);
        impl Port801baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Port801baseAddr {
            #[inline(always)]
            fn default() -> Port801baseAddr {
                Port801baseAddr(0)
            }
        }
        impl core::fmt::Debug for Port801baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Port801baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Port801baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Port801baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "eSPI Reset Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ResetIen(pub u8);
        impl ResetIen {
            #[doc = "1=The RESET_ESPI Interrupt will be asserted when the ESPI_RESET_INTERRUPT_STATUS bit in the eSPI Reset Interrupt Status Register register is '1' 0=The RESET_ESPI Interrupt will not be asserted."]
            #[inline(always)]
            pub const fn esp_rien(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The RESET_ESPI Interrupt will be asserted when the ESPI_RESET_INTERRUPT_STATUS bit in the eSPI Reset Interrupt Status Register register is '1' 0=The RESET_ESPI Interrupt will not be asserted."]
            #[inline(always)]
            pub fn set_esp_rien(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for ResetIen {
            #[inline(always)]
            fn default() -> ResetIen {
                ResetIen(0)
            }
        }
        impl core::fmt::Debug for ResetIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ResetIen").field("esp_rien", &self.esp_rien()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ResetIen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ResetIen {{ esp_rien: {=bool:?} }}", self.esp_rien())
            }
        }
        #[doc = "eSPI Reset Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ResetSts(pub u8);
        impl ResetSts {
            #[doc = "This bit is set to '1' whenever the ESPI_RESET_PIN_STATE bit in this register changes state. It is cleared to '0' whenever it is written with a '1'. Writes of a '0' have no effect. (R/WC) This bit is the source for the eSPI_RESET Interrupt. The interrupt is asserted when both this bit and the ESPI_RESET_INTERRUPT_ENABLE bit in the eSPI Reset Interrupt Enable Register are '1'."]
            #[inline(always)]
            pub const fn esp_intr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' whenever the ESPI_RESET_PIN_STATE bit in this register changes state. It is cleared to '0' whenever it is written with a '1'. Writes of a '0' have no effect. (R/WC) This bit is the source for the eSPI_RESET Interrupt. The interrupt is asserted when both this bit and the ESPI_RESET_INTERRUPT_ENABLE bit in the eSPI Reset Interrupt Enable Register are '1'."]
            #[inline(always)]
            pub fn set_esp_intr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This field reflects the current state of the eSPI_RESET# pin."]
            #[inline(always)]
            pub const fn espi_rst_pin_state(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This field reflects the current state of the eSPI_RESET# pin."]
            #[inline(always)]
            pub fn set_espi_rst_pin_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
        }
        impl Default for ResetSts {
            #[inline(always)]
            fn default() -> ResetSts {
                ResetSts(0)
            }
        }
        impl core::fmt::Debug for ResetSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ResetSts")
                    .field("esp_intr", &self.esp_intr())
                    .field("espi_rst_pin_state", &self.espi_rst_pin_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ResetSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "ResetSts {{ esp_intr: {=bool:?}, espi_rst_pin_state: {=bool:?} }}",
                    self.esp_intr(),
                    self.espi_rst_pin_state()
                )
            }
        }
        #[doc = "RPMC OP1 Opcode Num Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RpmcNumDispR(pub u32);
        impl RpmcNumDispR {
            #[doc = "RPMC CS0 OP1"]
            #[inline(always)]
            pub const fn cs0_op1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "RPMC CS0 OP1"]
            #[inline(always)]
            pub fn set_cs0_op1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "RPMC CS0 Count"]
            #[inline(always)]
            pub const fn cs0_cnt(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x1f;
                val as u8
            }
            #[doc = "RPMC CS0 Count"]
            #[inline(always)]
            pub fn set_cs0_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u32) & 0x1f) << 8usize);
            }
            #[doc = "RPMC CS1 OP1"]
            #[inline(always)]
            pub const fn cs1_op1(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "RPMC CS1 OP1"]
            #[inline(always)]
            pub fn set_cs1_op1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "RPMC CS1 Count"]
            #[inline(always)]
            pub const fn cs1_cnt(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "RPMC CS1 Count"]
            #[inline(always)]
            pub fn set_cs1_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for RpmcNumDispR {
            #[inline(always)]
            fn default() -> RpmcNumDispR {
                RpmcNumDispR(0)
            }
        }
        impl core::fmt::Debug for RpmcNumDispR {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RpmcNumDispR")
                    .field("cs0_op1", &self.cs0_op1())
                    .field("cs0_cnt", &self.cs0_cnt())
                    .field("cs1_op1", &self.cs1_op1())
                    .field("cs1_cnt", &self.cs1_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RpmcNumDispR {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RpmcNumDispR {{ cs0_op1: {=u8:?}, cs0_cnt: {=u8:?}, cs1_op1: {=u8:?}, cs1_cnt: {=u8:?} }}",
                    self.cs0_op1(),
                    self.cs0_cnt(),
                    self.cs1_op1(),
                    self.cs1_cnt()
                )
            }
        }
        #[doc = "RPMC OP1 Opcode Num Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RpmcNumDispRw(pub u32);
        impl RpmcNumDispRw {
            #[doc = "RPMC CS0 OP1"]
            #[inline(always)]
            pub const fn cs0_op1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "RPMC CS0 OP1"]
            #[inline(always)]
            pub fn set_cs0_op1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "RPMC CS0 Count"]
            #[inline(always)]
            pub const fn cs0_cnt(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x1f;
                val as u8
            }
            #[doc = "RPMC CS0 Count"]
            #[inline(always)]
            pub fn set_cs0_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u32) & 0x1f) << 8usize);
            }
            #[doc = "RPMC CS1 OP1"]
            #[inline(always)]
            pub const fn cs1_op1(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "RPMC CS1 OP1"]
            #[inline(always)]
            pub fn set_cs1_op1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "RPMC CS1 Count"]
            #[inline(always)]
            pub const fn cs1_cnt(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "RPMC CS1 Count"]
            #[inline(always)]
            pub fn set_cs1_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for RpmcNumDispRw {
            #[inline(always)]
            fn default() -> RpmcNumDispRw {
                RpmcNumDispRw(0)
            }
        }
        impl core::fmt::Debug for RpmcNumDispRw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RpmcNumDispRw")
                    .field("cs0_op1", &self.cs0_op1())
                    .field("cs0_cnt", &self.cs0_cnt())
                    .field("cs1_op1", &self.cs1_op1())
                    .field("cs1_cnt", &self.cs1_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RpmcNumDispRw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RpmcNumDispRw {{ cs0_op1: {=u8:?}, cs0_cnt: {=u8:?}, cs1_op1: {=u8:?}, cs1_cnt: {=u8:?} }}",
                    self.cs0_op1(),
                    self.cs0_cnt(),
                    self.cs1_op1(),
                    self.cs1_cnt()
                )
            }
        }
        #[doc = "RPMC OP1 Opcode Display Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RpmcOpDispRw(pub u32);
        impl RpmcOpDispRw {
            #[doc = "RPMC CS0 display 048 Sel"]
            #[inline(always)]
            pub const fn cs0_disp048(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RPMC CS0 display 048 Sel"]
            #[inline(always)]
            pub fn set_cs0_disp048(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "RPMC CS0 display 848 Sel"]
            #[inline(always)]
            pub const fn cs0_disp848(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RPMC CS0 display 848 Sel"]
            #[inline(always)]
            pub fn set_cs0_disp848(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "RPMC CS1 display 048 Sel"]
            #[inline(always)]
            pub const fn cs1_disp048(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RPMC CS1 display 048 Sel"]
            #[inline(always)]
            pub fn set_cs1_disp048(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "RPMC CS1 display 848 Sel"]
            #[inline(always)]
            pub const fn cs1_disp848(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "RPMC CS1 display 848 Sel"]
            #[inline(always)]
            pub fn set_cs1_disp848(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "RPMC Total"]
            #[inline(always)]
            pub const fn total(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x3f;
                val as u8
            }
            #[doc = "RPMC Total"]
            #[inline(always)]
            pub fn set_total(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 4usize)) | (((val as u32) & 0x3f) << 4usize);
            }
        }
        impl Default for RpmcOpDispRw {
            #[inline(always)]
            fn default() -> RpmcOpDispRw {
                RpmcOpDispRw(0)
            }
        }
        impl core::fmt::Debug for RpmcOpDispRw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RpmcOpDispRw")
                    .field("cs0_disp048", &self.cs0_disp048())
                    .field("cs0_disp848", &self.cs0_disp848())
                    .field("cs1_disp048", &self.cs1_disp048())
                    .field("cs1_disp848", &self.cs1_disp848())
                    .field("total", &self.total())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RpmcOpDispRw {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RpmcOpDispRw {{ cs0_disp048: {=bool:?}, cs0_disp848: {=bool:?}, cs1_disp048: {=bool:?}, cs1_disp848: {=bool:?}, total: {=u8:?} }}" , self . cs0_disp048 () , self . cs0_disp848 () , self . cs1_disp048 () , self . cs1_disp848 () , self . total ())
            }
        }
        #[doc = "RTC BAR Config Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtcAddr(pub u32);
        impl RtcAddr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn espi_host_address(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_espi_host_address(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for RtcAddr {
            #[inline(always)]
            fn default() -> RtcAddr {
                RtcAddr(0)
            }
        }
        impl core::fmt::Debug for RtcAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtcAddr")
                    .field("valid", &self.valid())
                    .field("espi_host_address", &self.espi_host_address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtcAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RtcAddr {{ valid: {=bool:?}, espi_host_address: {=u16:?} }}",
                    self.valid(),
                    self.espi_host_address()
                )
            }
        }
        #[doc = "RTC Base Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtcBaseAddr(pub u32);
        impl RtcBaseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for RtcBaseAddr {
            #[inline(always)]
            fn default() -> RtcBaseAddr {
                RtcBaseAddr(0)
            }
        }
        impl core::fmt::Debug for RtcBaseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtcBaseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtcBaseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RtcBaseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "RTC (RTC Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtcIrq(pub u8);
        impl RtcIrq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for RtcIrq {
            #[inline(always)]
            fn default() -> RtcIrq {
                RtcIrq(0)
            }
        }
        impl core::fmt::Debug for RtcIrq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtcIrq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtcIrq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RtcIrq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "UART 0 Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Uart0addr(pub u32);
        impl Uart0addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn esp_h_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Uart0addr {
            #[inline(always)]
            fn default() -> Uart0addr {
                Uart0addr(0)
            }
        }
        impl core::fmt::Debug for Uart0addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Uart0addr")
                    .field("valid", &self.valid())
                    .field("esp_h_addr", &self.esp_h_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Uart0addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Uart0addr {{ valid: {=bool:?}, esp_h_addr: {=u16:?} }}",
                    self.valid(),
                    self.esp_h_addr()
                )
            }
        }
        #[doc = "UART 0 BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Uart0baseAddr(pub u32);
        impl Uart0baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Uart0baseAddr {
            #[inline(always)]
            fn default() -> Uart0baseAddr {
                Uart0baseAddr(0)
            }
        }
        impl core::fmt::Debug for Uart0baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Uart0baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Uart0baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Uart0baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "UART 0 (UART Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Uart0irq(pub u8);
        impl Uart0irq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Uart0irq {
            #[inline(always)]
            fn default() -> Uart0irq {
                Uart0irq(0)
            }
        }
        impl core::fmt::Debug for Uart0irq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Uart0irq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Uart0irq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Uart0irq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "UART 1 Base Address Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Uart1addr(pub u32);
        impl Uart1addr {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub const fn uart1_addr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "These 16 bits are used to match eSPI I/O addresses."]
            #[inline(always)]
            pub fn set_uart1_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Uart1addr {
            #[inline(always)]
            fn default() -> Uart1addr {
                Uart1addr(0)
            }
        }
        impl core::fmt::Debug for Uart1addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Uart1addr")
                    .field("valid", &self.valid())
                    .field("uart1_addr", &self.uart1_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Uart1addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Uart1addr {{ valid: {=bool:?}, uart1_addr: {=u16:?} }}",
                    self.valid(),
                    self.uart1_addr()
                )
            }
        }
        #[doc = "UART 1 BAR Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Uart1baseAddr(pub u32);
        impl Uart1baseAddr {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Uart1baseAddr {
            #[inline(always)]
            fn default() -> Uart1baseAddr {
                Uart1baseAddr(0)
            }
        }
        impl core::fmt::Debug for Uart1baseAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Uart1baseAddr")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Uart1baseAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Uart1baseAddr {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "UART 1 (UART Interrupt) Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Uart1irq(pub u8);
        impl Uart1irq {
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub const fn irq(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "FFh= IRQ generation from this device is disabled. FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master. The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h."]
            #[inline(always)]
            pub fn set_irq(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Uart1irq {
            #[inline(always)]
            fn default() -> Uart1irq {
                Uart1irq(0)
            }
        }
        impl core::fmt::Debug for Uart1irq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Uart1irq").field("irq", &self.irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Uart1irq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Uart1irq {{ irq: {=u8:?} }}", self.irq())
            }
        }
        #[doc = "eSPI Virtual Wire Channel Capabilities Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VwCap(pub u8);
        impl VwCap {
            #[doc = "This field identifies the maximum Virtual Wire Count supported by the slave. It corresponds to the field Maximum Virtual Wire Count Supported, bits \\[13:8\\] of the Virtual Wire Channel Capabilities and Configurations Register. This field must be set to a number greater than or equal to 7h."]
            #[inline(always)]
            pub const fn max_cnt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "This field identifies the maximum Virtual Wire Count supported by the slave. It corresponds to the field Maximum Virtual Wire Count Supported, bits \\[13:8\\] of the Virtual Wire Channel Capabilities and Configurations Register. This field must be set to a number greater than or equal to 7h."]
            #[inline(always)]
            pub fn set_max_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
        }
        impl Default for VwCap {
            #[inline(always)]
            fn default() -> VwCap {
                VwCap(0)
            }
        }
        impl core::fmt::Debug for VwCap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VwCap").field("max_cnt", &self.max_cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VwCap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VwCap {{ max_cnt: {=u8:?} }}", self.max_cnt())
            }
        }
        #[doc = "Virtual Wire Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VwEnSts(pub u8);
        impl VwEnSts {
            #[doc = "This bit is a Read-only image of the bit Virtual Wire Channel Enable in the eSPI Configuration space. 1=Virtual Wire Channel Enable bit = 1; 0=Virtual Wire Channel Enable bit = 0."]
            #[inline(always)]
            pub const fn chn_en_sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is a Read-only image of the bit Virtual Wire Channel Enable in the eSPI Configuration space. 1=Virtual Wire Channel Enable bit = 1; 0=Virtual Wire Channel Enable bit = 0."]
            #[inline(always)]
            pub fn set_chn_en_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for VwEnSts {
            #[inline(always)]
            fn default() -> VwEnSts {
                VwEnSts(0)
            }
        }
        impl core::fmt::Debug for VwEnSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VwEnSts")
                    .field("chn_en_sts", &self.chn_en_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VwEnSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VwEnSts {{ chn_en_sts: {=bool:?} }}", self.chn_en_sts())
            }
        }
        #[doc = "eSPI Virtual Wire Channel Ready Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VwReady(pub u8);
        impl VwReady {
            #[doc = "Firmware sets this bit to '1' to inform the Master than the Virtual Wire channel is ready for transactions. It corresponds to the field Virtual Wire Channel Ready, bit 1 of the Config Offset 20h=Channel 1 Capabilities and Configurations Register. It is forced to '0' while the Virtual Wire Channel Enable bit in the Capabilities and Configurations register is 0. Once set to '1' it cannot be set to '0' by firmware. It is only set to '0' by a reset, or when the Master changes the Enabled bit to '0'. While this bit is '0' all Virtual Wire transactions initiated by the Slave are inhibited."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Firmware sets this bit to '1' to inform the Master than the Virtual Wire channel is ready for transactions. It corresponds to the field Virtual Wire Channel Ready, bit 1 of the Config Offset 20h=Channel 1 Capabilities and Configurations Register. It is forced to '0' while the Virtual Wire Channel Enable bit in the Capabilities and Configurations register is 0. Once set to '1' it cannot be set to '0' by firmware. It is only set to '0' by a reset, or when the Master changes the Enabled bit to '0'. While this bit is '0' all Virtual Wire transactions initiated by the Slave are inhibited."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for VwReady {
            #[inline(always)]
            fn default() -> VwReady {
                VwReady(0)
            }
        }
        impl core::fmt::Debug for VwReady {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VwReady").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VwReady {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VwReady {{ chn: {=bool:?} }}", self.chn())
            }
        }
    }
}
pub mod espi_memory {
    #[doc = "The eSPI Memory Component is one of two Logical Devices (along with the I/O Component) that provide access to all the registers in the device."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EspiMemory {
        ptr: *mut u8,
    }
    unsafe impl Send for EspiMemory {}
    unsafe impl Sync for EspiMemory {}
    impl EspiMemory {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Mailbox Memory Base Address"]
        #[inline(always)]
        pub const fn bar_ldi_mbx_h0(self) -> crate::common::Reg<regs::BarLdiMbxH0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR (LSB)"]
        #[inline(always)]
        pub const fn bar_ldi_acpi_ec0_h0(self) -> crate::common::Reg<regs::BarLdiAcpiEc0h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013ausize) as _) }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR (MSB)"]
        #[inline(always)]
        pub const fn bar_ldi_acpi_ec0_h1(self) -> crate::common::Reg<regs::BarLdiAcpiEc0h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013cusize) as _) }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR"]
        #[inline(always)]
        pub const fn bar_ldi_acpi_ec1_h0(self) -> crate::common::Reg<regs::BarLdiAcpiEc1h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0144usize) as _) }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR (LSB)"]
        #[inline(always)]
        pub const fn bar_ldi_acpi_ec2_h0(self) -> crate::common::Reg<regs::BarLdiAcpiEc2h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x014eusize) as _) }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR (MSB)"]
        #[inline(always)]
        pub const fn bar_ldi_acpi_ec2_h1(self) -> crate::common::Reg<regs::BarLdiAcpiEc2h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0150usize) as _) }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR"]
        #[inline(always)]
        pub const fn bar_ldi_acpi_ec3_h0(self) -> crate::common::Reg<regs::BarLdiAcpiEc3h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0158usize) as _) }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR"]
        #[inline(always)]
        pub const fn bar_ldi_acpi_ec4_h0(self) -> crate::common::Reg<regs::BarLdiAcpiEc4h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x015cusize) as _) }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR (MSB)"]
        #[inline(always)]
        pub const fn bar_ldi_acpi_ec4_h1(self) -> crate::common::Reg<regs::BarLdiAcpiEc4h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0160usize) as _) }
        }
        #[doc = "Embedded Memory Interface (EMI) 0 Memory Base Address"]
        #[inline(always)]
        pub const fn bar_ldi_em0_h0(self) -> crate::common::Reg<regs::BarLdiEm0h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x016cusize) as _) }
        }
        #[doc = "Embedded Memory Interface (EMI) 1 Memory Base Address (LSB)"]
        #[inline(always)]
        pub const fn bar_ldi_em1_h0(self) -> crate::common::Reg<regs::BarLdiEm1h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0176usize) as _) }
        }
        #[doc = "Embedded Memory Interface (EMI) 1 Memory Base Address (MSB)"]
        #[inline(always)]
        pub const fn bar_ldi_em1_h1(self) -> crate::common::Reg<regs::BarLdiEm1h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0178usize) as _) }
        }
        #[doc = "Embedded Memory Interface (EMI) 2 Memory Base Address"]
        #[inline(always)]
        pub const fn bar_ldi_em2_h0(self) -> crate::common::Reg<regs::BarLdiEm2h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "SRAM 0 Memory Base Address Config"]
        #[inline(always)]
        pub const fn bar_sram0_h0(self) -> crate::common::Reg<regs::BarSram0h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01acusize) as _) }
        }
        #[doc = "SRAM 0 Memory Base Address LSB"]
        #[inline(always)]
        pub const fn bar_sram0_h1(self) -> crate::common::Reg<regs::BarSram0h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01aeusize) as _) }
        }
        #[doc = "SRAM 0 Memory Base Address MSB"]
        #[inline(always)]
        pub const fn bar_sram0_h2(self) -> crate::common::Reg<regs::BarSram0h2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b0usize) as _) }
        }
        #[doc = "SRAM 1 Memory Base Address Config"]
        #[inline(always)]
        pub const fn bar_sram1_h0(self) -> crate::common::Reg<regs::BarSram1h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b6usize) as _) }
        }
        #[doc = "SRAM 1 Memory Base Address LSB"]
        #[inline(always)]
        pub const fn bar_sram1_h1(self) -> crate::common::Reg<regs::BarSram1h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b8usize) as _) }
        }
        #[doc = "SRAM 1 Memory Base Address MSB"]
        #[inline(always)]
        pub const fn bar_sram1_h2(self) -> crate::common::Reg<regs::BarSram1h2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01bausize) as _) }
        }
        #[doc = "Bus Master Status Register"]
        #[inline(always)]
        pub const fn bm_sts(self) -> crate::common::Reg<regs::BmSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Bus Master Interrupt Enable Register"]
        #[inline(always)]
        pub const fn bm_ien(self) -> crate::common::Reg<regs::BmIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize) as _) }
        }
        #[doc = "Bus Master Configuration Register"]
        #[inline(always)]
        pub const fn bm_cfg(self) -> crate::common::Reg<regs::BmCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize) as _) }
        }
        #[doc = "Bus Master 1 Control Register"]
        #[inline(always)]
        pub const fn bm1_ctrl(self) -> crate::common::Reg<regs::Bm1ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0210usize) as _) }
        }
        #[doc = "Bus Master 1 Host Address Register (DWord 0)"]
        #[inline(always)]
        pub const fn bm1_host_addr_lsw(self) -> crate::common::Reg<regs::Bm1hostAddrLsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0214usize) as _) }
        }
        #[doc = "Bus Master 1 Host Address Register (DWord 1)"]
        #[inline(always)]
        pub const fn bm1_host_addr_msw(self) -> crate::common::Reg<regs::Bm1hostAddrMsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0218usize) as _) }
        }
        #[doc = "Bus Master 1 Internal Address Register"]
        #[inline(always)]
        pub const fn bm1_ec_addr_lsw(self) -> crate::common::Reg<regs::Bm1ecAddrLsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x021cusize) as _) }
        }
        #[doc = "Bus Master 2 Control Register"]
        #[inline(always)]
        pub const fn bm2_ctrl(self) -> crate::common::Reg<regs::Bm2ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0224usize) as _) }
        }
        #[doc = "Bus Master 2 Host Address Register (DWord 0)"]
        #[inline(always)]
        pub const fn bm2_host_addr_lsw(self) -> crate::common::Reg<regs::Bm2hostAddrLsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0228usize) as _) }
        }
        #[doc = "Bus Master 2 Host Address Register (DWord 1)"]
        #[inline(always)]
        pub const fn bm2_host_addr_msw(self) -> crate::common::Reg<regs::Bm2hostAddrMsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x022cusize) as _) }
        }
        #[doc = "Bus Master 2 Internal Address Register"]
        #[inline(always)]
        pub const fn bm2_ec_addr_lsw(self) -> crate::common::Reg<regs::Bm2ecAddrLsw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0230usize) as _) }
        }
        #[doc = "Mailbox Memory BAR Configuration Register (Word 0)"]
        #[inline(always)]
        pub const fn bar_ldh_mbx_h0(self) -> crate::common::Reg<regs::BarLdhMbxH0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "Mailbox Memory BAR Configuration Register (Word 1)"]
        #[inline(always)]
        pub const fn bar_ldh_mbx_h1(self) -> crate::common::Reg<regs::BarLdhMbxH1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0332usize) as _) }
        }
        #[doc = "Mailbox Memory BAR Configuration Register (Word 2)"]
        #[inline(always)]
        pub const fn bar_ldh_mbx_h2(self) -> crate::common::Reg<regs::BarLdhMbxH2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0334usize) as _) }
        }
        #[doc = "Mailbox Memory BAR Configuration Register (Word 3)"]
        #[inline(always)]
        pub const fn bar_ldh_mbx_h3(self) -> crate::common::Reg<regs::BarLdhMbxH3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0336usize) as _) }
        }
        #[doc = "Mailbox Memory BAR Configuration Register (Word 4)"]
        #[inline(always)]
        pub const fn bar_ldh_mbx_h4(self) -> crate::common::Reg<regs::BarLdhMbxH4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0338usize) as _) }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR Configuration Register (Word 0)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec0_h0(self) -> crate::common::Reg<regs::BarLdhAcpiEc0h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x033ausize) as _) }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR Configuration Register (Word 1)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec0_h1(self) -> crate::common::Reg<regs::BarLdhAcpiEc0h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x033cusize) as _) }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR Configuration Register (Word 2)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec0_h2(self) -> crate::common::Reg<regs::BarLdhAcpiEc0h2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x033eusize) as _) }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR Configuration Register (Word 3)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec0_h3(self) -> crate::common::Reg<regs::BarLdhAcpiEc0h3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0340usize) as _) }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR Configuration Register (Word 4)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec0_h4(self) -> crate::common::Reg<regs::BarLdhAcpiEc0h4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0342usize) as _) }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR Configuration Register (Word 0)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec1_h0(self) -> crate::common::Reg<regs::BarLdhAcpiEc1h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0344usize) as _) }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR Configuration Register (Word 1)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec1_h1(self) -> crate::common::Reg<regs::BarLdhAcpiEc1h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0346usize) as _) }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR Configuration Register (Word 2)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec1_h2(self) -> crate::common::Reg<regs::BarLdhAcpiEc1h2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0348usize) as _) }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR Configuration Register (Word 3)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec1_h3(self) -> crate::common::Reg<regs::BarLdhAcpiEc1h3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x034ausize) as _) }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR Configuration Register (Word 4)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec1_h4(self) -> crate::common::Reg<regs::BarLdhAcpiEc1h4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x034cusize) as _) }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR Configuration Register (Word 0)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec2_h0(self) -> crate::common::Reg<regs::BarLdhAcpiEc2h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x034eusize) as _) }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR Configuration Register (Word 1)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec2_h1(self) -> crate::common::Reg<regs::BarLdhAcpiEc2h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0350usize) as _) }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR Configuration Register (Word 2)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec2_h2(self) -> crate::common::Reg<regs::BarLdhAcpiEc2h2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0352usize) as _) }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR Configuration Register (Word 3)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec2_h3(self) -> crate::common::Reg<regs::BarLdhAcpiEc2h3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0354usize) as _) }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR Configuration Register (Word 4)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec2_h4(self) -> crate::common::Reg<regs::BarLdhAcpiEc2h4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0356usize) as _) }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR Configuration Register (Word 0)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec3_h0(self) -> crate::common::Reg<regs::BarLdhAcpiEc3h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0358usize) as _) }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR Configuration Register (Word 1)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec3_h1(self) -> crate::common::Reg<regs::BarLdhAcpiEc3h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x035ausize) as _) }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR Configuration Register (Word 2)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec3_h2(self) -> crate::common::Reg<regs::BarLdhAcpiEc3h2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x035cusize) as _) }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR Configuration Register (Word 3)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec3_h3(self) -> crate::common::Reg<regs::BarLdhAcpiEc3h3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x035eusize) as _) }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR Configuration Register (Word 4)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec3_h4(self) -> crate::common::Reg<regs::BarLdhAcpiEc3h4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0360usize) as _) }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR Configuration Register (Word 0)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec4_h0(self) -> crate::common::Reg<regs::BarLdhAcpiEc4h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0362usize) as _) }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR Configuration Register (Word 1)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec4_h1(self) -> crate::common::Reg<regs::BarLdhAcpiEc4h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0364usize) as _) }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR Configuration Register (Word 2)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec4_h2(self) -> crate::common::Reg<regs::BarLdhAcpiEc4h2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0366usize) as _) }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR Configuration Register (Word 3)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec4_h3(self) -> crate::common::Reg<regs::BarLdhAcpiEc4h3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0368usize) as _) }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR Configuration Register (Word 4)"]
        #[inline(always)]
        pub const fn bar_ldh_acpi_ec4_h4(self) -> crate::common::Reg<regs::BarLdhAcpiEc4h4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x036ausize) as _) }
        }
        #[doc = "EMI 0 Memory BAR Configuration Register (Word 0)"]
        #[inline(always)]
        pub const fn bar_ldh_em0_h0(self) -> crate::common::Reg<regs::BarLdhEm0h0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x036cusize) as _) }
        }
        #[doc = "EMI 0 Memory BAR Configuration Address Register (Word 1)"]
        #[inline(always)]
        pub const fn bar_ldh_em0_h1(self) -> crate::common::Reg<regs::BarLdhEm0h1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x036eusize) as _) }
        }
        #[doc = "EMI 0 Memory BAR Configuration Address Register (Word 2)"]
        #[inline(always)]
        pub const fn bar_ldh_em0_h2(self) -> crate::common::Reg<regs::BarLdhEm0h2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0370usize) as _) }
        }
        #[doc = "EMI 0 Memory BAR Configuration Address Register (Word 3)"]
        #[inline(always)]
        pub const fn emi_0_mem_bar_cfg_w3(self) -> crate::common::Reg<regs::Emi0memBarCfgW3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0372usize) as _) }
        }
        #[doc = "EMI 0 Memory BAR Configuration Address Register (Word 4)"]
        #[inline(always)]
        pub const fn emi_0_mem_bar_cfg_w4(self) -> crate::common::Reg<regs::Emi0memBarCfgW4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0374usize) as _) }
        }
        #[doc = "EMI 1 Memory BAR Configuration Register (Word 0) )"]
        #[inline(always)]
        pub const fn emi_1_mem_bar_cfg_w0(self) -> crate::common::Reg<regs::Emi1memBarCfgW0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0376usize) as _) }
        }
        #[doc = "EMI 1 Memory BAR Configuration Register (Word 1) )"]
        #[inline(always)]
        pub const fn emi_1_mem_bar_cfg_w1(self) -> crate::common::Reg<regs::Emi1memBarCfgW1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0378usize) as _) }
        }
        #[doc = "EMI 1 Memory BAR Configuration Register (Word 2) )"]
        #[inline(always)]
        pub const fn emi_1_mem_bar_cfg_w2(self) -> crate::common::Reg<regs::Emi1memBarCfgW2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x037ausize) as _) }
        }
        #[doc = "EMI 1 Memory BAR Configuration Register (Word 3) )"]
        #[inline(always)]
        pub const fn emi_1_mem_bar_cfg_w3(self) -> crate::common::Reg<regs::Emi1memBarCfgW3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x037cusize) as _) }
        }
        #[doc = "EMI 1 Memory BAR Configuration Register (Word 4) )"]
        #[inline(always)]
        pub const fn emi_1_mem_bar_cfg_w4(self) -> crate::common::Reg<regs::Emi1memBarCfgW4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x037eusize) as _) }
        }
        #[doc = "EMI 2 Memory BAR Configuration Register (Word 0) )"]
        #[inline(always)]
        pub const fn emi_2_mem_bar_cfg_w0(self) -> crate::common::Reg<regs::Emi2memBarCfgW0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0380usize) as _) }
        }
        #[doc = "EMI 2 Memory BAR Configuration Register (Word 1) )"]
        #[inline(always)]
        pub const fn emi_2_mem_bar_cfg_w1(self) -> crate::common::Reg<regs::Emi2memBarCfgW1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0382usize) as _) }
        }
        #[doc = "EMI 2 Memory BAR Configuration Register (Word 2) )"]
        #[inline(always)]
        pub const fn emi_2_mem_bar_cfg_w2(self) -> crate::common::Reg<regs::Emi2memBarCfgW2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0384usize) as _) }
        }
        #[doc = "EMI 2 Memory BAR Configuration Register (Word 3) )"]
        #[inline(always)]
        pub const fn emi_2_mem_bar_cfg_w3(self) -> crate::common::Reg<regs::Emi2memBarCfgW3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0386usize) as _) }
        }
        #[doc = "EMI 2 Memory BAR Configuration Register (Word 4) )"]
        #[inline(always)]
        pub const fn emi_2_mem_bar_cfg_w4(self) -> crate::common::Reg<regs::Emi2memBarCfgW4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0388usize) as _) }
        }
        #[doc = "SRAM BAR 0 Configuration Register (Word 0) )"]
        #[inline(always)]
        pub const fn sram_0_mem_bar_cfg_w0(self) -> crate::common::Reg<regs::Sram0memBarCfgW0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03acusize) as _) }
        }
        #[doc = "SRAM BAR 0 Configuration Register (Word 1) )"]
        #[inline(always)]
        pub const fn sram_0_mem_bar_cfg_w1(self) -> crate::common::Reg<regs::Sram0memBarCfgW1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03aeusize) as _) }
        }
        #[doc = "SRAM BAR 0 Configuration Register (Word 2) )"]
        #[inline(always)]
        pub const fn sram_0_mem_bar_cfg_w2(self) -> crate::common::Reg<regs::Sram0memBarCfgW2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b0usize) as _) }
        }
        #[doc = "SRAM BAR 0 Configuration Register (Word 3) )"]
        #[inline(always)]
        pub const fn sram_0_mem_bar_cfg_w3(self) -> crate::common::Reg<regs::Sram0memBarCfgW3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b2usize) as _) }
        }
        #[doc = "SRAM BAR 0 Configuration Register (Word 4) )"]
        #[inline(always)]
        pub const fn sram_0_mem_bar_cfg_w4(self) -> crate::common::Reg<regs::Sram0memBarCfgW4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b4usize) as _) }
        }
        #[doc = "SRAM BAR 1 Configuration Register (Word 0) )"]
        #[inline(always)]
        pub const fn sram_1_mem_bar_cfg_w0(self) -> crate::common::Reg<regs::Sram1memBarCfgW0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b6usize) as _) }
        }
        #[doc = "SRAM BAR 1 Configuration Register (Word 1) )"]
        #[inline(always)]
        pub const fn sram_1_mem_bar_cfg_w1(self) -> crate::common::Reg<regs::Sram1memBarCfgW1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03b8usize) as _) }
        }
        #[doc = "SRAM BAR 1 Configuration Register (Word 2) )"]
        #[inline(always)]
        pub const fn sram_1_mem_bar_cfg_w2(self) -> crate::common::Reg<regs::Sram1memBarCfgW2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03bausize) as _) }
        }
        #[doc = "SRAM BAR 1 Configuration Register (Word 3) )"]
        #[inline(always)]
        pub const fn sram_1_mem_bar_cfg_w3(self) -> crate::common::Reg<regs::Sram1memBarCfgW3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03bcusize) as _) }
        }
        #[doc = "SRAM BAR 1 Configuration Register (Word 4) )"]
        #[inline(always)]
        pub const fn sram_1_mem_bar_cfg_w4(self) -> crate::common::Reg<regs::Sram1memBarCfgW4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03beusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "ACPI EC Channel 0 Memory BAR Configuration Register (Word 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc0h0(pub u16);
        impl BarLdhAcpiEc0h0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc0h0 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc0h0 {
                BarLdhAcpiEc0h0(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc0h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc0h0").field("valid", &self.valid()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc0h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc0h0 {{ valid: {=bool:?} }}", self.valid())
            }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR Configuration Register (Word 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc0h1(pub u16);
        impl BarLdhAcpiEc0h1 {
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc0h1 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc0h1 {
                BarLdhAcpiEc0h1(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc0h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc0h1")
                    .field("esp_h_addr_w0", &self.esp_h_addr_w0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc0h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc0h1 {{ esp_h_addr_w0: {=u16:?} }}", self.esp_h_addr_w0())
            }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR Configuration Register (Word 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc0h2(pub u16);
        impl BarLdhAcpiEc0h2 {
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc0h2 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc0h2 {
                BarLdhAcpiEc0h2(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc0h2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc0h2")
                    .field("esp_h_addr_w1", &self.esp_h_addr_w1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc0h2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc0h2 {{ esp_h_addr_w1: {=u16:?} }}", self.esp_h_addr_w1())
            }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR Configuration Register (Word 3)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc0h3(pub u16);
        impl BarLdhAcpiEc0h3 {
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc0h3 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc0h3 {
                BarLdhAcpiEc0h3(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc0h3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc0h3")
                    .field("esp_h_addr_w2", &self.esp_h_addr_w2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc0h3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc0h3 {{ esp_h_addr_w2: {=u16:?} }}", self.esp_h_addr_w2())
            }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR Configuration Register (Word 4)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc0h4(pub u16);
        impl BarLdhAcpiEc0h4 {
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w3(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w3(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc0h4 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc0h4 {
                BarLdhAcpiEc0h4(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc0h4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc0h4")
                    .field("esp_h_addr_w3", &self.esp_h_addr_w3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc0h4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc0h4 {{ esp_h_addr_w3: {=u16:?} }}", self.esp_h_addr_w3())
            }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR Configuration Register (Word 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc1h0(pub u16);
        impl BarLdhAcpiEc1h0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc1h0 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc1h0 {
                BarLdhAcpiEc1h0(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc1h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc1h0").field("valid", &self.valid()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc1h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc1h0 {{ valid: {=bool:?} }}", self.valid())
            }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR Configuration Register (Word 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc1h1(pub u16);
        impl BarLdhAcpiEc1h1 {
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc1h1 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc1h1 {
                BarLdhAcpiEc1h1(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc1h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc1h1")
                    .field("esp_h_addr_w0", &self.esp_h_addr_w0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc1h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc1h1 {{ esp_h_addr_w0: {=u16:?} }}", self.esp_h_addr_w0())
            }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR Configuration Register (Word 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc1h2(pub u16);
        impl BarLdhAcpiEc1h2 {
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc1h2 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc1h2 {
                BarLdhAcpiEc1h2(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc1h2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc1h2")
                    .field("esp_h_addr_w1", &self.esp_h_addr_w1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc1h2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc1h2 {{ esp_h_addr_w1: {=u16:?} }}", self.esp_h_addr_w1())
            }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR Configuration Register (Word 3)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc1h3(pub u16);
        impl BarLdhAcpiEc1h3 {
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc1h3 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc1h3 {
                BarLdhAcpiEc1h3(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc1h3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc1h3")
                    .field("esp_h_addr_w2", &self.esp_h_addr_w2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc1h3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc1h3 {{ esp_h_addr_w2: {=u16:?} }}", self.esp_h_addr_w2())
            }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR Configuration Register (Word 4)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc1h4(pub u16);
        impl BarLdhAcpiEc1h4 {
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w3(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w3(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc1h4 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc1h4 {
                BarLdhAcpiEc1h4(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc1h4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc1h4")
                    .field("esp_h_addr_w3", &self.esp_h_addr_w3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc1h4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc1h4 {{ esp_h_addr_w3: {=u16:?} }}", self.esp_h_addr_w3())
            }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR Configuration Register (Word 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc2h0(pub u16);
        impl BarLdhAcpiEc2h0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc2h0 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc2h0 {
                BarLdhAcpiEc2h0(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc2h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc2h0").field("valid", &self.valid()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc2h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc2h0 {{ valid: {=bool:?} }}", self.valid())
            }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR Configuration Register (Word 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc2h1(pub u16);
        impl BarLdhAcpiEc2h1 {
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc2h1 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc2h1 {
                BarLdhAcpiEc2h1(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc2h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc2h1")
                    .field("esp_h_addr_w0", &self.esp_h_addr_w0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc2h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc2h1 {{ esp_h_addr_w0: {=u16:?} }}", self.esp_h_addr_w0())
            }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR Configuration Register (Word 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc2h2(pub u16);
        impl BarLdhAcpiEc2h2 {
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc2h2 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc2h2 {
                BarLdhAcpiEc2h2(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc2h2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc2h2")
                    .field("esp_h_addr_w1", &self.esp_h_addr_w1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc2h2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc2h2 {{ esp_h_addr_w1: {=u16:?} }}", self.esp_h_addr_w1())
            }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR Configuration Register (Word 3)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc2h3(pub u16);
        impl BarLdhAcpiEc2h3 {
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc2h3 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc2h3 {
                BarLdhAcpiEc2h3(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc2h3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc2h3")
                    .field("esp_h_addr_w2", &self.esp_h_addr_w2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc2h3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc2h3 {{ esp_h_addr_w2: {=u16:?} }}", self.esp_h_addr_w2())
            }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR Configuration Register (Word 4)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc2h4(pub u16);
        impl BarLdhAcpiEc2h4 {
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w3(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w3(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc2h4 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc2h4 {
                BarLdhAcpiEc2h4(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc2h4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc2h4")
                    .field("esp_h_addr_w3", &self.esp_h_addr_w3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc2h4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc2h4 {{ esp_h_addr_w3: {=u16:?} }}", self.esp_h_addr_w3())
            }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR Configuration Register (Word 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc3h0(pub u16);
        impl BarLdhAcpiEc3h0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc3h0 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc3h0 {
                BarLdhAcpiEc3h0(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc3h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc3h0").field("valid", &self.valid()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc3h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc3h0 {{ valid: {=bool:?} }}", self.valid())
            }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR Configuration Register (Word 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc3h1(pub u16);
        impl BarLdhAcpiEc3h1 {
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc3h1 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc3h1 {
                BarLdhAcpiEc3h1(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc3h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc3h1")
                    .field("esp_h_addr_w0", &self.esp_h_addr_w0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc3h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc3h1 {{ esp_h_addr_w0: {=u16:?} }}", self.esp_h_addr_w0())
            }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR Configuration Register (Word 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc3h2(pub u16);
        impl BarLdhAcpiEc3h2 {
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc3h2 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc3h2 {
                BarLdhAcpiEc3h2(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc3h2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc3h2")
                    .field("esp_h_addr_w1", &self.esp_h_addr_w1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc3h2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc3h2 {{ esp_h_addr_w1: {=u16:?} }}", self.esp_h_addr_w1())
            }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR Configuration Register (Word 3)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc3h3(pub u16);
        impl BarLdhAcpiEc3h3 {
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc3h3 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc3h3 {
                BarLdhAcpiEc3h3(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc3h3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc3h3")
                    .field("esp_h_addr_w2", &self.esp_h_addr_w2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc3h3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc3h3 {{ esp_h_addr_w2: {=u16:?} }}", self.esp_h_addr_w2())
            }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR Configuration Register (Word 4)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc3h4(pub u16);
        impl BarLdhAcpiEc3h4 {
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w3(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w3(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc3h4 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc3h4 {
                BarLdhAcpiEc3h4(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc3h4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc3h4")
                    .field("esp_h_addr_w3", &self.esp_h_addr_w3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc3h4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc3h4 {{ esp_h_addr_w3: {=u16:?} }}", self.esp_h_addr_w3())
            }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR Configuration Register (Word 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc4h0(pub u16);
        impl BarLdhAcpiEc4h0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc4h0 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc4h0 {
                BarLdhAcpiEc4h0(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc4h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc4h0").field("valid", &self.valid()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc4h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc4h0 {{ valid: {=bool:?} }}", self.valid())
            }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR Configuration Register (Word 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc4h1(pub u16);
        impl BarLdhAcpiEc4h1 {
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc4h1 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc4h1 {
                BarLdhAcpiEc4h1(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc4h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc4h1")
                    .field("esp_h_addr_w0", &self.esp_h_addr_w0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc4h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc4h1 {{ esp_h_addr_w0: {=u16:?} }}", self.esp_h_addr_w0())
            }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR Configuration Register (Word 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc4h2(pub u16);
        impl BarLdhAcpiEc4h2 {
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc4h2 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc4h2 {
                BarLdhAcpiEc4h2(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc4h2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc4h2")
                    .field("esp_h_addr_w1", &self.esp_h_addr_w1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc4h2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc4h2 {{ esp_h_addr_w1: {=u16:?} }}", self.esp_h_addr_w1())
            }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR Configuration Register (Word 3)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc4h3(pub u16);
        impl BarLdhAcpiEc4h3 {
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc4h3 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc4h3 {
                BarLdhAcpiEc4h3(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc4h3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc4h3")
                    .field("esp_h_addr_w2", &self.esp_h_addr_w2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc4h3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc4h3 {{ esp_h_addr_w2: {=u16:?} }}", self.esp_h_addr_w2())
            }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR Configuration Register (Word 4)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhAcpiEc4h4(pub u16);
        impl BarLdhAcpiEc4h4 {
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w3(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w3(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhAcpiEc4h4 {
            #[inline(always)]
            fn default() -> BarLdhAcpiEc4h4 {
                BarLdhAcpiEc4h4(0)
            }
        }
        impl core::fmt::Debug for BarLdhAcpiEc4h4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhAcpiEc4h4")
                    .field("esp_h_addr_w3", &self.esp_h_addr_w3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhAcpiEc4h4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhAcpiEc4h4 {{ esp_h_addr_w3: {=u16:?} }}", self.esp_h_addr_w3())
            }
        }
        #[doc = "EMI 0 Memory BAR Configuration Register (Word 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhEm0h0(pub u16);
        impl BarLdhEm0h0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for BarLdhEm0h0 {
            #[inline(always)]
            fn default() -> BarLdhEm0h0 {
                BarLdhEm0h0(0)
            }
        }
        impl core::fmt::Debug for BarLdhEm0h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhEm0h0").field("valid", &self.valid()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhEm0h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhEm0h0 {{ valid: {=bool:?} }}", self.valid())
            }
        }
        #[doc = "EMI 0 Memory BAR Configuration Address Register (Word 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhEm0h1(pub u16);
        impl BarLdhEm0h1 {
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhEm0h1 {
            #[inline(always)]
            fn default() -> BarLdhEm0h1 {
                BarLdhEm0h1(0)
            }
        }
        impl core::fmt::Debug for BarLdhEm0h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhEm0h1")
                    .field("esp_h_addr_w0", &self.esp_h_addr_w0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhEm0h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhEm0h1 {{ esp_h_addr_w0: {=u16:?} }}", self.esp_h_addr_w0())
            }
        }
        #[doc = "EMI 0 Memory BAR Configuration Address Register (Word 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhEm0h2(pub u16);
        impl BarLdhEm0h2 {
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhEm0h2 {
            #[inline(always)]
            fn default() -> BarLdhEm0h2 {
                BarLdhEm0h2(0)
            }
        }
        impl core::fmt::Debug for BarLdhEm0h2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhEm0h2")
                    .field("esp_h_addr_w1", &self.esp_h_addr_w1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhEm0h2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhEm0h2 {{ esp_h_addr_w1: {=u16:?} }}", self.esp_h_addr_w1())
            }
        }
        #[doc = "Mailbox Memory BAR Configuration Register (Word 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhMbxH0(pub u16);
        impl BarLdhMbxH0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for BarLdhMbxH0 {
            #[inline(always)]
            fn default() -> BarLdhMbxH0 {
                BarLdhMbxH0(0)
            }
        }
        impl core::fmt::Debug for BarLdhMbxH0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhMbxH0").field("valid", &self.valid()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhMbxH0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhMbxH0 {{ valid: {=bool:?} }}", self.valid())
            }
        }
        #[doc = "Mailbox Memory BAR Configuration Register (Word 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhMbxH1(pub u16);
        impl BarLdhMbxH1 {
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhMbxH1 {
            #[inline(always)]
            fn default() -> BarLdhMbxH1 {
                BarLdhMbxH1(0)
            }
        }
        impl core::fmt::Debug for BarLdhMbxH1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhMbxH1")
                    .field("esp_h_addr_w0", &self.esp_h_addr_w0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhMbxH1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhMbxH1 {{ esp_h_addr_w0: {=u16:?} }}", self.esp_h_addr_w0())
            }
        }
        #[doc = "Mailbox Memory BAR Configuration Register (Word 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhMbxH2(pub u16);
        impl BarLdhMbxH2 {
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhMbxH2 {
            #[inline(always)]
            fn default() -> BarLdhMbxH2 {
                BarLdhMbxH2(0)
            }
        }
        impl core::fmt::Debug for BarLdhMbxH2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhMbxH2")
                    .field("esp_h_addr_w1", &self.esp_h_addr_w1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhMbxH2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhMbxH2 {{ esp_h_addr_w1: {=u16:?} }}", self.esp_h_addr_w1())
            }
        }
        #[doc = "Mailbox Memory BAR Configuration Register (Word 3)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhMbxH3(pub u16);
        impl BarLdhMbxH3 {
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhMbxH3 {
            #[inline(always)]
            fn default() -> BarLdhMbxH3 {
                BarLdhMbxH3(0)
            }
        }
        impl core::fmt::Debug for BarLdhMbxH3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhMbxH3")
                    .field("esp_h_addr_w2", &self.esp_h_addr_w2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhMbxH3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhMbxH3 {{ esp_h_addr_w2: {=u16:?} }}", self.esp_h_addr_w2())
            }
        }
        #[doc = "Mailbox Memory BAR Configuration Register (Word 4)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdhMbxH4(pub u16);
        impl BarLdhMbxH4 {
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn esp_h_addr_w3(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_esp_h_addr_w3(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarLdhMbxH4 {
            #[inline(always)]
            fn default() -> BarLdhMbxH4 {
                BarLdhMbxH4(0)
            }
        }
        impl core::fmt::Debug for BarLdhMbxH4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdhMbxH4")
                    .field("esp_h_addr_w3", &self.esp_h_addr_w3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdhMbxH4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdhMbxH4 {{ esp_h_addr_w3: {=u16:?} }}", self.esp_h_addr_w3())
            }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR (LSB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiAcpiEc0h0(pub u16);
        impl BarLdiAcpiEc0h0 {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u16) & 0x3f) << 8usize);
            }
        }
        impl Default for BarLdiAcpiEc0h0 {
            #[inline(always)]
            fn default() -> BarLdiAcpiEc0h0 {
                BarLdiAcpiEc0h0(0)
            }
        }
        impl core::fmt::Debug for BarLdiAcpiEc0h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiAcpiEc0h0")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiAcpiEc0h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BarLdiAcpiEc0h0 {{ mask: {=u8:?}, ldn: {=u8:?} }}",
                    self.mask(),
                    self.ldn()
                )
            }
        }
        #[doc = "ACPI EC Channel 0 Memory BAR (MSB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiAcpiEc0h1(pub u16);
        impl BarLdiAcpiEc0h1 {
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for BarLdiAcpiEc0h1 {
            #[inline(always)]
            fn default() -> BarLdiAcpiEc0h1 {
                BarLdiAcpiEc0h1(0)
            }
        }
        impl core::fmt::Debug for BarLdiAcpiEc0h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiAcpiEc0h1").field("vir", &self.vir()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiAcpiEc0h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdiAcpiEc0h1 {{ vir: {=bool:?} }}", self.vir())
            }
        }
        #[doc = "ACPI EC Channel 1 Memory BAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiAcpiEc1h0(pub u32);
        impl BarLdiAcpiEc1h0 {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for BarLdiAcpiEc1h0 {
            #[inline(always)]
            fn default() -> BarLdiAcpiEc1h0 {
                BarLdiAcpiEc1h0(0)
            }
        }
        impl core::fmt::Debug for BarLdiAcpiEc1h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiAcpiEc1h0")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiAcpiEc1h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BarLdiAcpiEc1h0 {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR (LSB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiAcpiEc2h0(pub u16);
        impl BarLdiAcpiEc2h0 {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u16) & 0x3f) << 8usize);
            }
        }
        impl Default for BarLdiAcpiEc2h0 {
            #[inline(always)]
            fn default() -> BarLdiAcpiEc2h0 {
                BarLdiAcpiEc2h0(0)
            }
        }
        impl core::fmt::Debug for BarLdiAcpiEc2h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiAcpiEc2h0")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiAcpiEc2h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BarLdiAcpiEc2h0 {{ mask: {=u8:?}, ldn: {=u8:?} }}",
                    self.mask(),
                    self.ldn()
                )
            }
        }
        #[doc = "ACPI EC Channel 2 Memory BAR (MSB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiAcpiEc2h1(pub u16);
        impl BarLdiAcpiEc2h1 {
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for BarLdiAcpiEc2h1 {
            #[inline(always)]
            fn default() -> BarLdiAcpiEc2h1 {
                BarLdiAcpiEc2h1(0)
            }
        }
        impl core::fmt::Debug for BarLdiAcpiEc2h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiAcpiEc2h1").field("vir", &self.vir()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiAcpiEc2h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdiAcpiEc2h1 {{ vir: {=bool:?} }}", self.vir())
            }
        }
        #[doc = "ACPI EC Channel 3 Memory BAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiAcpiEc3h0(pub u32);
        impl BarLdiAcpiEc3h0 {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for BarLdiAcpiEc3h0 {
            #[inline(always)]
            fn default() -> BarLdiAcpiEc3h0 {
                BarLdiAcpiEc3h0(0)
            }
        }
        impl core::fmt::Debug for BarLdiAcpiEc3h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiAcpiEc3h0")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiAcpiEc3h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BarLdiAcpiEc3h0 {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiAcpiEc4h0(pub u32);
        impl BarLdiAcpiEc4h0 {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for BarLdiAcpiEc4h0 {
            #[inline(always)]
            fn default() -> BarLdiAcpiEc4h0 {
                BarLdiAcpiEc4h0(0)
            }
        }
        impl core::fmt::Debug for BarLdiAcpiEc4h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiAcpiEc4h0")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiAcpiEc4h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BarLdiAcpiEc4h0 {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "ACPI EC Channel 4 Memory BAR (MSB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiAcpiEc4h1(pub u16);
        impl BarLdiAcpiEc4h1 {
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for BarLdiAcpiEc4h1 {
            #[inline(always)]
            fn default() -> BarLdiAcpiEc4h1 {
                BarLdiAcpiEc4h1(0)
            }
        }
        impl core::fmt::Debug for BarLdiAcpiEc4h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiAcpiEc4h1").field("vir", &self.vir()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiAcpiEc4h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdiAcpiEc4h1 {{ vir: {=bool:?} }}", self.vir())
            }
        }
        #[doc = "Embedded Memory Interface (EMI) 0 Memory Base Address"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiEm0h0(pub u32);
        impl BarLdiEm0h0 {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for BarLdiEm0h0 {
            #[inline(always)]
            fn default() -> BarLdiEm0h0 {
                BarLdiEm0h0(0)
            }
        }
        impl core::fmt::Debug for BarLdiEm0h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiEm0h0")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiEm0h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BarLdiEm0h0 {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "Embedded Memory Interface (EMI) 1 Memory Base Address (LSB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiEm1h0(pub u16);
        impl BarLdiEm1h0 {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u16) & 0x3f) << 8usize);
            }
        }
        impl Default for BarLdiEm1h0 {
            #[inline(always)]
            fn default() -> BarLdiEm1h0 {
                BarLdiEm1h0(0)
            }
        }
        impl core::fmt::Debug for BarLdiEm1h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiEm1h0")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiEm1h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BarLdiEm1h0 {{ mask: {=u8:?}, ldn: {=u8:?} }}",
                    self.mask(),
                    self.ldn()
                )
            }
        }
        #[doc = "Embedded Memory Interface (EMI) 1 Memory Base Address (MSB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiEm1h1(pub u16);
        impl BarLdiEm1h1 {
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for BarLdiEm1h1 {
            #[inline(always)]
            fn default() -> BarLdiEm1h1 {
                BarLdiEm1h1(0)
            }
        }
        impl core::fmt::Debug for BarLdiEm1h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiEm1h1").field("vir", &self.vir()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiEm1h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarLdiEm1h1 {{ vir: {=bool:?} }}", self.vir())
            }
        }
        #[doc = "Embedded Memory Interface (EMI) 2 Memory Base Address"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiEm2h0(pub u32);
        impl BarLdiEm2h0 {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for BarLdiEm2h0 {
            #[inline(always)]
            fn default() -> BarLdiEm2h0 {
                BarLdiEm2h0(0)
            }
        }
        impl core::fmt::Debug for BarLdiEm2h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiEm2h0")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiEm2h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BarLdiEm2h0 {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "Mailbox Memory Base Address"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarLdiMbxH0(pub u32);
        impl BarLdiMbxH0 {
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub const fn mask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs. A block of up to 256 8-bit registers can be assigned to one base address."]
            #[inline(always)]
            pub fn set_mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub const fn ldn(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid."]
            #[inline(always)]
            pub fn set_ldn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub const fn vir(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware 0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware."]
            #[inline(always)]
            pub fn set_vir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for BarLdiMbxH0 {
            #[inline(always)]
            fn default() -> BarLdiMbxH0 {
                BarLdiMbxH0(0)
            }
        }
        impl core::fmt::Debug for BarLdiMbxH0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarLdiMbxH0")
                    .field("mask", &self.mask())
                    .field("ldn", &self.ldn())
                    .field("vir", &self.vir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarLdiMbxH0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BarLdiMbxH0 {{ mask: {=u8:?}, ldn: {=u8:?}, vir: {=bool:?} }}",
                    self.mask(),
                    self.ldn(),
                    self.vir()
                )
            }
        }
        #[doc = "SRAM 0 Memory Base Address Config"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarSram0h0(pub u16);
        impl BarSram0h0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "These 2 bits define the access type of access to this SRAM region. 3=Host has Read/write access to the region 2=Host has Write-only access to the region 1=Host has Read-only access to the region 0=Host has no access to this region"]
            #[inline(always)]
            pub const fn access(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x03;
                val as u8
            }
            #[doc = "These 2 bits define the access type of access to this SRAM region. 3=Host has Read/write access to the region 2=Host has Write-only access to the region 1=Host has Read-only access to the region 0=Host has no access to this region"]
            #[inline(always)]
            pub fn set_access(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val as u16) & 0x03) << 1usize);
            }
            #[doc = "This field defines the size of the region mapped from Host Memory address space into the internal address space, in powers of 2. 15=The region is 64KB in extent 14=The region is 32KB in extent ... 1=The region is 2B in extent 0=The region is 1B in extent."]
            #[inline(always)]
            pub const fn size(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "This field defines the size of the region mapped from Host Memory address space into the internal address space, in powers of 2. 15=The region is 64KB in extent 14=The region is 32KB in extent ... 1=The region is 2B in extent 0=The region is 1B in extent."]
            #[inline(always)]
            pub fn set_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u16) & 0x0f) << 4usize);
            }
        }
        impl Default for BarSram0h0 {
            #[inline(always)]
            fn default() -> BarSram0h0 {
                BarSram0h0(0)
            }
        }
        impl core::fmt::Debug for BarSram0h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarSram0h0")
                    .field("valid", &self.valid())
                    .field("access", &self.access())
                    .field("size", &self.size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarSram0h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BarSram0h0 {{ valid: {=bool:?}, access: {=u8:?}, size: {=u8:?} }}",
                    self.valid(),
                    self.access(),
                    self.size()
                )
            }
        }
        #[doc = "SRAM 0 Memory Base Address LSB"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarSram0h1(pub u16);
        impl BarSram0h1 {
            #[doc = "This is the LSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored."]
            #[inline(always)]
            pub const fn addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is the LSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarSram0h1 {
            #[inline(always)]
            fn default() -> BarSram0h1 {
                BarSram0h1(0)
            }
        }
        impl core::fmt::Debug for BarSram0h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarSram0h1").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarSram0h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarSram0h1 {{ addr: {=u16:?} }}", self.addr())
            }
        }
        #[doc = "SRAM 0 Memory Base Address MSB"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarSram0h2(pub u32);
        impl BarSram0h2 {
            #[doc = "This is the MSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored."]
            #[inline(always)]
            pub const fn addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is the MSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for BarSram0h2 {
            #[inline(always)]
            fn default() -> BarSram0h2 {
                BarSram0h2(0)
            }
        }
        impl core::fmt::Debug for BarSram0h2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarSram0h2").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarSram0h2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarSram0h2 {{ addr: {=u16:?} }}", self.addr())
            }
        }
        #[doc = "SRAM 1 Memory Base Address Config"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarSram1h0(pub u16);
        impl BarSram1h0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "These 2 bits define the access type of access to this SRAM region. 3=Host has Read/write access to the region 2=Host has Write-only access to the region 1=Host has Read-only access to the region 0=Host has no access to this region"]
            #[inline(always)]
            pub const fn access(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x03;
                val as u8
            }
            #[doc = "These 2 bits define the access type of access to this SRAM region. 3=Host has Read/write access to the region 2=Host has Write-only access to the region 1=Host has Read-only access to the region 0=Host has no access to this region"]
            #[inline(always)]
            pub fn set_access(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val as u16) & 0x03) << 1usize);
            }
            #[doc = "This field defines the size of the region mapped from Host Memory address space into the internal address space, in powers of 2. 15=The region is 64KB in extent 14=The region is 32KB in extent ... 1=The region is 2B in extent 0=The region is 1B in extent."]
            #[inline(always)]
            pub const fn size(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "This field defines the size of the region mapped from Host Memory address space into the internal address space, in powers of 2. 15=The region is 64KB in extent 14=The region is 32KB in extent ... 1=The region is 2B in extent 0=The region is 1B in extent."]
            #[inline(always)]
            pub fn set_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u16) & 0x0f) << 4usize);
            }
        }
        impl Default for BarSram1h0 {
            #[inline(always)]
            fn default() -> BarSram1h0 {
                BarSram1h0(0)
            }
        }
        impl core::fmt::Debug for BarSram1h0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarSram1h0")
                    .field("valid", &self.valid())
                    .field("access", &self.access())
                    .field("size", &self.size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarSram1h0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BarSram1h0 {{ valid: {=bool:?}, access: {=u8:?}, size: {=u8:?} }}",
                    self.valid(),
                    self.access(),
                    self.size()
                )
            }
        }
        #[doc = "SRAM 1 Memory Base Address LSB"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarSram1h1(pub u16);
        impl BarSram1h1 {
            #[doc = "This is the LSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored."]
            #[inline(always)]
            pub const fn addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is the LSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarSram1h1 {
            #[inline(always)]
            fn default() -> BarSram1h1 {
                BarSram1h1(0)
            }
        }
        impl core::fmt::Debug for BarSram1h1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarSram1h1").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarSram1h1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarSram1h1 {{ addr: {=u16:?} }}", self.addr())
            }
        }
        #[doc = "SRAM 1 Memory Base Address MSB"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BarSram1h2(pub u16);
        impl BarSram1h2 {
            #[doc = "This the MSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored."]
            #[inline(always)]
            pub const fn addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This the MSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for BarSram1h2 {
            #[inline(always)]
            fn default() -> BarSram1h2 {
                BarSram1h2(0)
            }
        }
        impl core::fmt::Debug for BarSram1h2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BarSram1h2").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BarSram1h2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BarSram1h2 {{ addr: {=u16:?} }}", self.addr())
            }
        }
        #[doc = "Bus Master 1 Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bm1ctrl(pub u32);
        impl Bm1ctrl {
            #[doc = "A write of '1' to this bit starts a Bus Master transfer on Bus Master Channel 1. A write of 0 has no effect. Reads of this bit return 0. The transmission will be inhibited if the Peripheral channel is not Ready, as defined in the eSPI Peripheral Channel Ready Register."]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "A write of '1' to this bit starts a Bus Master transfer on Bus Master Channel 1. A write of 0 has no effect. Reads of this bit return 0. The transmission will be inhibited if the Peripheral channel is not Ready, as defined in the eSPI Peripheral Channel Ready Register."]
            #[inline(always)]
            pub fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "A write of '1' to this bit will cause an active transfer on Bus Master Channel 1 to terminate at the next point allowed by the eSPI protocol. A write of 0 has no effect. Reads of this bit return 0. If this bit is written to 1 by firmware, there is no guarantee that any data will have been transferred."]
            #[inline(always)]
            pub const fn abort(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "A write of '1' to this bit will cause an active transfer on Bus Master Channel 1 to terminate at the next point allowed by the eSPI protocol. A write of 0 has no effect. Reads of this bit return 0. If this bit is written to 1 by firmware, there is no guarantee that any data will have been transferred."]
            #[inline(always)]
            pub fn set_abort(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1=The internal address will be incremented after each transfer to eSPI 0=The internal address will remain fixed for the entire Bus Master transfer. This may be used to transfer data to or from an on-chip FIFO instead of a region of memory, or to fill a region of Host memory from a single byte value."]
            #[inline(always)]
            pub const fn en_inter_incr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=The internal address will be incremented after each transfer to eSPI 0=The internal address will remain fixed for the entire Bus Master transfer. This may be used to transfer data to or from an on-chip FIFO instead of a region of memory, or to fill a region of Host memory from a single byte value."]
            #[inline(always)]
            pub fn set_en_inter_incr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=The transfer on Bus Master Channel 1 will be held until a transfer in progress on Bus Master Channel 2 has completed. If that transfer completes unsuccessfully, then this transfer will also terminate, before generating any traffic, with the BM1_ABORTED_BY_CH2_ERROR flag set. 0=The transfer on Bus Master Channel 1 will proceed independently of the status of Bus Master Channel 2."]
            #[inline(always)]
            pub const fn bm1wait_bm2notbusy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=The transfer on Bus Master Channel 1 will be held until a transfer in progress on Bus Master Channel 2 has completed. If that transfer completes unsuccessfully, then this transfer will also terminate, before generating any traffic, with the BM1_ABORTED_BY_CH2_ERROR flag set. 0=The transfer on Bus Master Channel 1 will proceed independently of the status of Bus Master Channel 2."]
            #[inline(always)]
            pub fn set_bm1wait_bm2notbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This field provides the cycle type to use inside the eSPI transaction header: 11b=Memory Write, 64-bit addressing 10b=Memory Read, 64-bit addressing 01b=Memory Write, 32-bit addressing 00b=Memory Read, 32-bit addressing."]
            #[inline(always)]
            pub const fn cyc_type(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field provides the cycle type to use inside the eSPI transaction header: 11b=Memory Write, 64-bit addressing 10b=Memory Read, 64-bit addressing 01b=Memory Write, 32-bit addressing 00b=Memory Read, 32-bit addressing."]
            #[inline(always)]
            pub fn set_cyc_type(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "This field sets the length in bytes of a transfer on Bus Master Channel 1. A value of zero, or a value greater than exactly 4K (0x1000) is illegal. Any length which, in combination with the Bus Master 1 Host Address register, will cause the transfer to cross a 4K-byte boundary in System Memory is also illegal. These illegal settings will cause a request to terminate immediately, with no traffic, and with Bad Request error status posted."]
            #[inline(always)]
            pub const fn len(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x1fff;
                val as u16
            }
            #[doc = "This field sets the length in bytes of a transfer on Bus Master Channel 1. A value of zero, or a value greater than exactly 4K (0x1000) is illegal. Any length which, in combination with the Bus Master 1 Host Address register, will cause the transfer to cross a 4K-byte boundary in System Memory is also illegal. These illegal settings will cause a request to terminate immediately, with no traffic, and with Bad Request error status posted."]
            #[inline(always)]
            pub fn set_len(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 16usize)) | (((val as u32) & 0x1fff) << 16usize);
            }
        }
        impl Default for Bm1ctrl {
            #[inline(always)]
            fn default() -> Bm1ctrl {
                Bm1ctrl(0)
            }
        }
        impl core::fmt::Debug for Bm1ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bm1ctrl")
                    .field("start", &self.start())
                    .field("abort", &self.abort())
                    .field("en_inter_incr", &self.en_inter_incr())
                    .field("bm1wait_bm2notbusy", &self.bm1wait_bm2notbusy())
                    .field("cyc_type", &self.cyc_type())
                    .field("len", &self.len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bm1ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bm1ctrl {{ start: {=bool:?}, abort: {=bool:?}, en_inter_incr: {=bool:?}, bm1wait_bm2notbusy: {=bool:?}, cyc_type: {=u8:?}, len: {=u16:?} }}" , self . start () , self . abort () , self . en_inter_incr () , self . bm1wait_bm2notbusy () , self . cyc_type () , self . len ())
            }
        }
        #[doc = "Bus Master 1 Internal Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bm1ecAddrLsw(pub u32);
        impl Bm1ecAddrLsw {
            #[doc = "This register sets the internal address to be used for a transfer on Bus Master Channel 1."]
            #[inline(always)]
            pub const fn in_addr(&self) -> u32 {
                let val = (self.0 >> 2usize) & 0x3fff_ffff;
                val as u32
            }
            #[doc = "This register sets the internal address to be used for a transfer on Bus Master Channel 1."]
            #[inline(always)]
            pub fn set_in_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0x3fff_ffff << 2usize)) | (((val as u32) & 0x3fff_ffff) << 2usize);
            }
        }
        impl Default for Bm1ecAddrLsw {
            #[inline(always)]
            fn default() -> Bm1ecAddrLsw {
                Bm1ecAddrLsw(0)
            }
        }
        impl core::fmt::Debug for Bm1ecAddrLsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bm1ecAddrLsw")
                    .field("in_addr", &self.in_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bm1ecAddrLsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bm1ecAddrLsw {{ in_addr: {=u32:?} }}", self.in_addr())
            }
        }
        #[doc = "Bus Master 1 Host Address Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bm1hostAddrLsw(pub u32);
        impl Bm1hostAddrLsw {
            #[doc = "This register sets bits \\[31:0\\] of the Host address used for a transfer on Bus Master Channel 1. This address, combined with the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status."]
            #[inline(always)]
            pub const fn lsdw(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register sets bits \\[31:0\\] of the Host address used for a transfer on Bus Master Channel 1. This address, combined with the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status."]
            #[inline(always)]
            pub fn set_lsdw(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Bm1hostAddrLsw {
            #[inline(always)]
            fn default() -> Bm1hostAddrLsw {
                Bm1hostAddrLsw(0)
            }
        }
        impl core::fmt::Debug for Bm1hostAddrLsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bm1hostAddrLsw").field("lsdw", &self.lsdw()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bm1hostAddrLsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bm1hostAddrLsw {{ lsdw: {=u32:?} }}", self.lsdw())
            }
        }
        #[doc = "Bus Master 1 Host Address Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bm1hostAddrMsw(pub u32);
        impl Bm1hostAddrMsw {
            #[doc = "This register sets bits \\[63:32\\] of the Host address used for a transfer on Bus Master Channel 1. This address, combined with the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status."]
            #[inline(always)]
            pub const fn msdw(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register sets bits \\[63:32\\] of the Host address used for a transfer on Bus Master Channel 1. This address, combined with the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status."]
            #[inline(always)]
            pub fn set_msdw(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Bm1hostAddrMsw {
            #[inline(always)]
            fn default() -> Bm1hostAddrMsw {
                Bm1hostAddrMsw(0)
            }
        }
        impl core::fmt::Debug for Bm1hostAddrMsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bm1hostAddrMsw").field("msdw", &self.msdw()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bm1hostAddrMsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bm1hostAddrMsw {{ msdw: {=u32:?} }}", self.msdw())
            }
        }
        #[doc = "Bus Master 2 Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bm2ctrl(pub u32);
        impl Bm2ctrl {
            #[doc = "A write of '1' to this bit starts a Bus Master transfer on Bus Master Channel 2. A write of 0 has no effect. Reads of this bit return 0. The transmission will be inhibited if the Peripheral channel is not Ready, as defined in the eSPI Peripheral Channel Ready Register."]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "A write of '1' to this bit starts a Bus Master transfer on Bus Master Channel 2. A write of 0 has no effect. Reads of this bit return 0. The transmission will be inhibited if the Peripheral channel is not Ready, as defined in the eSPI Peripheral Channel Ready Register."]
            #[inline(always)]
            pub fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "A write of '1' to this bit will cause an active transfer on Bus Master Channel 2 to terminate at the next point allowed by the eSPI protocol. A write of 0 has no effect. Reads of this bit return 0. If this bit is written to 1 by firmware, there is no guarantee that any data will have been transferred."]
            #[inline(always)]
            pub const fn abort(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "A write of '1' to this bit will cause an active transfer on Bus Master Channel 2 to terminate at the next point allowed by the eSPI protocol. A write of 0 has no effect. Reads of this bit return 0. If this bit is written to 1 by firmware, there is no guarantee that any data will have been transferred."]
            #[inline(always)]
            pub fn set_abort(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1=The internal address will be incremented after each transfer to eSPI 0=The internal address will remain fixed for the entire Bus Master transfer. This may be used to transfer data to or from an on-chip FIFO instead of a region of memory, or to fill a region of Host memory from a single byte value."]
            #[inline(always)]
            pub const fn en_inter_incr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=The internal address will be incremented after each transfer to eSPI 0=The internal address will remain fixed for the entire Bus Master transfer. This may be used to transfer data to or from an on-chip FIFO instead of a region of memory, or to fill a region of Host memory from a single byte value."]
            #[inline(always)]
            pub fn set_en_inter_incr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=The transfer on Bus Master Channel 2 will be held until a transfer in progress on Bus Master Channel 1 has completed. If that transfer completes unsuccessfully, then this transfer will also terminate, before generating any traffic, with the BM2_ABORTED_BY_CH1_ERROR flag set. 0=The transfer on Bus Master Channel 2 will proceed independently of the status of Bus Master Channel 1."]
            #[inline(always)]
            pub const fn bm2wait_bm1notbusy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=The transfer on Bus Master Channel 2 will be held until a transfer in progress on Bus Master Channel 1 has completed. If that transfer completes unsuccessfully, then this transfer will also terminate, before generating any traffic, with the BM2_ABORTED_BY_CH1_ERROR flag set. 0=The transfer on Bus Master Channel 2 will proceed independently of the status of Bus Master Channel 1."]
            #[inline(always)]
            pub fn set_bm2wait_bm1notbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This field provides the cycle type to use inside the eSPI transaction header: 11b=Memory Write, 64-bit addressing 10b=Memory Read, 64-bit addressing 01b=Memory Write, 32-bit addressing 00b=Memory Read, 32-bit addressing."]
            #[inline(always)]
            pub const fn cyc_type(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field provides the cycle type to use inside the eSPI transaction header: 11b=Memory Write, 64-bit addressing 10b=Memory Read, 64-bit addressing 01b=Memory Write, 32-bit addressing 00b=Memory Read, 32-bit addressing."]
            #[inline(always)]
            pub fn set_cyc_type(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "This field sets the length in bytes of a transfer on Bus Master Channel 2. A value of zero, or a value greater than exactly 4K (0x1000) is illegal. Any length which, in combination with the Bus Master 2 Host Address register, will cause the transfer to cross a 4K-byte boundary in System Memory is also illegal. These illegal settings will cause a request to terminate immediately, with no traffic, and with Bad Request error status posted."]
            #[inline(always)]
            pub const fn len(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x1fff;
                val as u16
            }
            #[doc = "This field sets the length in bytes of a transfer on Bus Master Channel 2. A value of zero, or a value greater than exactly 4K (0x1000) is illegal. Any length which, in combination with the Bus Master 2 Host Address register, will cause the transfer to cross a 4K-byte boundary in System Memory is also illegal. These illegal settings will cause a request to terminate immediately, with no traffic, and with Bad Request error status posted."]
            #[inline(always)]
            pub fn set_len(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 16usize)) | (((val as u32) & 0x1fff) << 16usize);
            }
        }
        impl Default for Bm2ctrl {
            #[inline(always)]
            fn default() -> Bm2ctrl {
                Bm2ctrl(0)
            }
        }
        impl core::fmt::Debug for Bm2ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bm2ctrl")
                    .field("start", &self.start())
                    .field("abort", &self.abort())
                    .field("en_inter_incr", &self.en_inter_incr())
                    .field("bm2wait_bm1notbusy", &self.bm2wait_bm1notbusy())
                    .field("cyc_type", &self.cyc_type())
                    .field("len", &self.len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bm2ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bm2ctrl {{ start: {=bool:?}, abort: {=bool:?}, en_inter_incr: {=bool:?}, bm2wait_bm1notbusy: {=bool:?}, cyc_type: {=u8:?}, len: {=u16:?} }}" , self . start () , self . abort () , self . en_inter_incr () , self . bm2wait_bm1notbusy () , self . cyc_type () , self . len ())
            }
        }
        #[doc = "Bus Master 2 Internal Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bm2ecAddrLsw(pub u32);
        impl Bm2ecAddrLsw {
            #[doc = "This register sets the internal address to be used for a transfer on Bus Master Channel 2."]
            #[inline(always)]
            pub const fn in_addr(&self) -> u32 {
                let val = (self.0 >> 2usize) & 0x3fff_ffff;
                val as u32
            }
            #[doc = "This register sets the internal address to be used for a transfer on Bus Master Channel 2."]
            #[inline(always)]
            pub fn set_in_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0x3fff_ffff << 2usize)) | (((val as u32) & 0x3fff_ffff) << 2usize);
            }
        }
        impl Default for Bm2ecAddrLsw {
            #[inline(always)]
            fn default() -> Bm2ecAddrLsw {
                Bm2ecAddrLsw(0)
            }
        }
        impl core::fmt::Debug for Bm2ecAddrLsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bm2ecAddrLsw")
                    .field("in_addr", &self.in_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bm2ecAddrLsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bm2ecAddrLsw {{ in_addr: {=u32:?} }}", self.in_addr())
            }
        }
        #[doc = "Bus Master 2 Host Address Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bm2hostAddrLsw(pub u32);
        impl Bm2hostAddrLsw {
            #[doc = "This register sets bits \\[31:0\\] of the Host address used for a transfer on Bus Master Channel 2. This address, combined with the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status."]
            #[inline(always)]
            pub const fn lsdw(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register sets bits \\[31:0\\] of the Host address used for a transfer on Bus Master Channel 2. This address, combined with the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status."]
            #[inline(always)]
            pub fn set_lsdw(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Bm2hostAddrLsw {
            #[inline(always)]
            fn default() -> Bm2hostAddrLsw {
                Bm2hostAddrLsw(0)
            }
        }
        impl core::fmt::Debug for Bm2hostAddrLsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bm2hostAddrLsw").field("lsdw", &self.lsdw()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bm2hostAddrLsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bm2hostAddrLsw {{ lsdw: {=u32:?} }}", self.lsdw())
            }
        }
        #[doc = "Bus Master 2 Host Address Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bm2hostAddrMsw(pub u32);
        impl Bm2hostAddrMsw {
            #[doc = "This register sets bits \\[63:32\\] of the Host address used for a transfer on Bus Master Channel 2. This address, combined with the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status."]
            #[inline(always)]
            pub const fn msdw(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register sets bits \\[63:32\\] of the Host address used for a transfer on Bus Master Channel 2. This address, combined with the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status."]
            #[inline(always)]
            pub fn set_msdw(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Bm2hostAddrMsw {
            #[inline(always)]
            fn default() -> Bm2hostAddrMsw {
                Bm2hostAddrMsw(0)
            }
        }
        impl core::fmt::Debug for Bm2hostAddrMsw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bm2hostAddrMsw").field("msdw", &self.msdw()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bm2hostAddrMsw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bm2hostAddrMsw {{ msdw: {=u32:?} }}", self.msdw())
            }
        }
        #[doc = "Bus Master Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BmCfg(pub u32);
        impl BmCfg {
            #[doc = "This 4-bit Tag value is included in all eSPI traffic originating from the BM1 Bus Master instance. This bit should not be modified while the bit BM1_BUSY in the Bus Master Status Register is '1'."]
            #[inline(always)]
            pub const fn tag1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This 4-bit Tag value is included in all eSPI traffic originating from the BM1 Bus Master instance. This bit should not be modified while the bit BM1_BUSY in the Bus Master Status Register is '1'."]
            #[inline(always)]
            pub fn set_tag1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "This 4-bit Tag value is included in all eSPI traffic originating from the BM2 Bus Master instance. This bit should not be modified while the bit BM2_BUSY in the Bus Master Status Register is '1'."]
            #[inline(always)]
            pub const fn tag2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "This 4-bit Tag value is included in all eSPI traffic originating from the BM2 Bus Master instance. This bit should not be modified while the bit BM2_BUSY in the Bus Master Status Register is '1'."]
            #[inline(always)]
            pub fn set_tag2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
        }
        impl Default for BmCfg {
            #[inline(always)]
            fn default() -> BmCfg {
                BmCfg(0)
            }
        }
        impl core::fmt::Debug for BmCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BmCfg")
                    .field("tag1", &self.tag1())
                    .field("tag2", &self.tag2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BmCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BmCfg {{ tag1: {=u8:?}, tag2: {=u8:?} }}", self.tag1(), self.tag2())
            }
        }
        #[doc = "Bus Master Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BmIen(pub u32);
        impl BmIen {
            #[doc = "When this bit is '1' an interrupt is generated when the bit BM1_TRANSFER_DONE in the Bus Master Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn tx1_done_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit BM1_TRANSFER_DONE in the Bus Master Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_tx1_done_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit BM2_TRANSFER_DONE in the Bus Master Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub const fn tx2_done_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1' an interrupt is generated when the bit BM2_TRANSFER_DONE in the Bus Master Status Register is 1. When this bit is '0', the status bit will not generate an interrupt."]
            #[inline(always)]
            pub fn set_tx2_done_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for BmIen {
            #[inline(always)]
            fn default() -> BmIen {
                BmIen(0)
            }
        }
        impl core::fmt::Debug for BmIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BmIen")
                    .field("tx1_done_en", &self.tx1_done_en())
                    .field("tx2_done_en", &self.tx2_done_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BmIen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BmIen {{ tx1_done_en: {=bool:?}, tx2_done_en: {=bool:?} }}",
                    self.tx1_done_en(),
                    self.tx2_done_en()
                )
            }
        }
        #[doc = "Bus Master Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BmSts(pub u32);
        impl BmSts {
            #[doc = "This bit is set to '1' when a START transfer on Bus Master Channel 1 has completed, and occurs simultaneously with the clearing of the BM1_BUSY bit. This may happen normally, but it is also guaranteed to happen if any of the Error bits in this register section (bits\\[11:2\\]) is set by an error condition. At the time that this bit is set to '1', the Error bits are guaranteed to be in their final states, and can be examined. Firmware is required to clear this bit, by writing '1' to this bit position, before altering any BM1 registers or making a new START request, otherwise interrupts from this block will be unreliable. (R/WC)"]
            #[inline(always)]
            pub const fn tx_done1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' when a START transfer on Bus Master Channel 1 has completed, and occurs simultaneously with the clearing of the BM1_BUSY bit. This may happen normally, but it is also guaranteed to happen if any of the Error bits in this register section (bits\\[11:2\\]) is set by an error condition. At the time that this bit is set to '1', the Error bits are guaranteed to be in their final states, and can be examined. Firmware is required to clear this bit, by writing '1' to this bit position, before altering any BM1 registers or making a new START request, otherwise interrupts from this block will be unreliable. (R/WC)"]
            #[inline(always)]
            pub fn set_tx_done1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Hardware sets this bit to 1 when the control bit BM1_START in the Bus Master 1 Control Register is written with a 1. This bit is cleared when the transfer completes. This may happen normally, but it is guaranteed to happen also if any of the Error bits in this register section (bits\\[11:2\\]) is set by an error condition."]
            #[inline(always)]
            pub const fn busy1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Hardware sets this bit to 1 when the control bit BM1_START in the Bus Master 1 Control Register is written with a 1. This bit is cleared when the transfer completes. This may happen normally, but it is guaranteed to happen also if any of the Error bits in this register section (bits\\[11:2\\]) is set by an error condition."]
            #[inline(always)]
            pub fn set_busy1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is set when the control bit BM1_ABORT in the Bus Master 1 Control Register is written with a 1 during an active transfer. (R/WC)"]
            #[inline(always)]
            pub const fn abort1_ec(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the control bit BM1_ABORT in the Bus Master 1 Control Register is written with a 1 during an active transfer. (R/WC)"]
            #[inline(always)]
            pub fn set_abort1_ec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "A '1' in this bit indicates that the last requested Mastering operation was aborted because Bus Mastering has been disabled by the Host. Bus Mastering is disabled whenever the Peripheral Channel Mastering Enable bit in that register is '0', or the Peripheral Channel Enable bit is '0'. (R/WC)"]
            #[inline(always)]
            pub const fn abort1_h(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "A '1' in this bit indicates that the last requested Mastering operation was aborted because Bus Mastering has been disabled by the Host. Bus Mastering is disabled whenever the Peripheral Channel Mastering Enable bit in that register is '0', or the Peripheral Channel Enable bit is '0'. (R/WC)"]
            #[inline(always)]
            pub fn set_abort1_h(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit is set if an error occurs on Bus Master Channel 2 while a Channel 1 transfer is in progress, if the two channels are linked. Linkage occurs when bit BM1_WAIT_BM2_NOT_BUSY in register Bus Master 1 Control Register is set to '1'. No traffic will occur from this channel before the error is posted and the BM1_TRANSFER_DONE bit is set. (R/WC)"]
            #[inline(always)]
            pub const fn abort_ch2_err(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if an error occurs on Bus Master Channel 2 while a Channel 1 transfer is in progress, if the two channels are linked. Linkage occurs when bit BM1_WAIT_BM2_NOT_BUSY in register Bus Master 1 Control Register is set to '1'. No traffic will occur from this channel before the error is posted and the BM1_TRANSFER_DONE bit is set. (R/WC)"]
            #[inline(always)]
            pub fn set_abort_ch2_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit is set if the bit BM1_START in the Bus Master 1 Control Register is written with a 1 while the bit BM1_BUSY is 1. This condition immediately halts the transfer in progress also (BM1_TRANSFER_DONE=1). (R/WC)"]
            #[inline(always)]
            pub const fn strt1_ovrflw(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if the bit BM1_START in the Bus Master 1 Control Register is written with a 1 while the bit BM1_BUSY is 1. This condition immediately halts the transfer in progress also (BM1_TRANSFER_DONE=1). (R/WC)"]
            #[inline(always)]
            pub fn set_strt1_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit is set if the transfer on Bus Master Channel 1 completed but too many bytes were delivered by the eSPI Host. Some of the data will not be delivered on the internal bus. (R/WC)"]
            #[inline(always)]
            pub const fn dat1_ovrun(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if the transfer on Bus Master Channel 1 completed but too many bytes were delivered by the eSPI Host. Some of the data will not be delivered on the internal bus. (R/WC)"]
            #[inline(always)]
            pub fn set_dat1_ovrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit is set if the transfer on Bus Master Channel 1 completed but an insufficient number of bytes were transferred. Some of the data will not be delivered on the internal bus. (R/WC)"]
            #[inline(always)]
            pub const fn incmpl1(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if the transfer on Bus Master Channel 1 completed but an insufficient number of bytes were transferred. Some of the data will not be delivered on the internal bus. (R/WC)"]
            #[inline(always)]
            pub fn set_incmpl1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This bit is set if a Layer 3 transaction from Bus Master Channel 1 completes with an Unsuccessful Completion packet from the eSPI Host. For example, this will happen if the START request attempts to read from a forbidden or unmapped address in System Memory. Bad Writes, however, cannot be flagged this way, and will be silently dropped by the eSPI Host without setting this bit. (R/WC)"]
            #[inline(always)]
            pub const fn fail1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if a Layer 3 transaction from Bus Master Channel 1 completes with an Unsuccessful Completion packet from the eSPI Host. For example, this will happen if the START request attempts to read from a forbidden or unmapped address in System Memory. Bad Writes, however, cannot be flagged this way, and will be silently dropped by the eSPI Host without setting this bit. (R/WC)"]
            #[inline(always)]
            pub fn set_fail1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This bit is set if a transfer on Bus Master Channel 1 is terminated due to a bus error internal to the EC. This can happen if an invalid address is provided in the Bus Master 1 internal Address register. (R/WC)"]
            #[inline(always)]
            pub const fn intr1_bus_err(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if a transfer on Bus Master Channel 1 is terminated due to a bus error internal to the EC. This can happen if an invalid address is provided in the Bus Master 1 internal Address register. (R/WC)"]
            #[inline(always)]
            pub fn set_intr1_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This bit is set, and the START request is terminated immediately (BM1_TRANSFER_DONE=1) without triggering traffic, if register contents are invalid at the time the BM1_START bit is written to '1' by firmware. (R/WC) Examples of a Bad Request are: Length of zero Length greater than 4K (1000h) Host Address and Length together specifying a request that crosses a 4KByte boundary. This might violate the Scatter/Gather structure of the Host memory, so is not allowed."]
            #[inline(always)]
            pub const fn bad1_req(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set, and the START request is terminated immediately (BM1_TRANSFER_DONE=1) without triggering traffic, if register contents are invalid at the time the BM1_START bit is written to '1' by firmware. (R/WC) Examples of a Bad Request are: Length of zero Length greater than 4K (1000h) Host Address and Length together specifying a request that crosses a 4KByte boundary. This might violate the Scatter/Gather structure of the Host memory, so is not allowed."]
            #[inline(always)]
            pub fn set_bad1_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "This bit is set to '1' when a START transfer on Bus Master Channel 2 has completed, and occurs simultaneously with the clearing of the BM2_BUSY bit. This may happen normally, but it is guaranteed to happen also if any of the Error bits in this register section (bits\\[27:18\\]) is set by an error condition. At the time that this bit is set to '1', the Error bits are guaranteed to be in their final states, and can be examined. (R/WC)"]
            #[inline(always)]
            pub const fn tx_done2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' when a START transfer on Bus Master Channel 2 has completed, and occurs simultaneously with the clearing of the BM2_BUSY bit. This may happen normally, but it is guaranteed to happen also if any of the Error bits in this register section (bits\\[27:18\\]) is set by an error condition. At the time that this bit is set to '1', the Error bits are guaranteed to be in their final states, and can be examined. (R/WC)"]
            #[inline(always)]
            pub fn set_tx_done2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Hardware sets this bit to 1 when the control bit BM2_START in the Bus Master 2 Control Register is written with a 1. This bit is cleared when the transfer completes. This may happen normally, but it is guaranteed to happen also if any of the Error bits in this register section (bits\\[27:18\\]) is set by an error condition."]
            #[inline(always)]
            pub const fn busy2(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Hardware sets this bit to 1 when the control bit BM2_START in the Bus Master 2 Control Register is written with a 1. This bit is cleared when the transfer completes. This may happen normally, but it is guaranteed to happen also if any of the Error bits in this register section (bits\\[27:18\\]) is set by an error condition."]
            #[inline(always)]
            pub fn set_busy2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set when the control bit BM2_ABORT in the Bus Master 2 Control Register is written with a 1 during an active transfer. (R/WC)"]
            #[inline(always)]
            pub const fn abort2_ec(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the control bit BM2_ABORT in the Bus Master 2 Control Register is written with a 1 during an active transfer. (R/WC)"]
            #[inline(always)]
            pub fn set_abort2_ec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "A '1' in this bit indicates that the last requested Mastering operation was aborted because Bus Mastering has been disabled by the Host. Bus Mastering is disabled whenever the Peripheral Channel Mastering Enable bit in that register is '0', or the Peripheral Channel Enable bit is '0'. (R/WC)"]
            #[inline(always)]
            pub const fn abort2_h(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "A '1' in this bit indicates that the last requested Mastering operation was aborted because Bus Mastering has been disabled by the Host. Bus Mastering is disabled whenever the Peripheral Channel Mastering Enable bit in that register is '0', or the Peripheral Channel Enable bit is '0'. (R/WC)"]
            #[inline(always)]
            pub fn set_abort2_h(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This bit is set if an error occurs on Bus Master Channel 1 while a Channel 2 transfer is in progress, if the two channels are linked. Linkage occurs when bit BM2_WAIT_BM1_NOT_BUSY in register Bus Master 2 Control Register is set to '1'. No traffic will occur from this channel before the error is posted and the BM2_TRANSFER_DONE bit is set. (R/WC)"]
            #[inline(always)]
            pub const fn abort_ch1_err(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if an error occurs on Bus Master Channel 1 while a Channel 2 transfer is in progress, if the two channels are linked. Linkage occurs when bit BM2_WAIT_BM1_NOT_BUSY in register Bus Master 2 Control Register is set to '1'. No traffic will occur from this channel before the error is posted and the BM2_TRANSFER_DONE bit is set. (R/WC)"]
            #[inline(always)]
            pub fn set_abort_ch1_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "This bit is set if the bit BM2_START in the Bus Master 2 Control Register is written with a 1 while the bit BM2_BUSY is 1. This condition immediately halts the transfer in progress also (BM2_TRANSFER_DONE=1). (R/WC)"]
            #[inline(always)]
            pub const fn strt2_ovrflw(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if the bit BM2_START in the Bus Master 2 Control Register is written with a 1 while the bit BM2_BUSY is 1. This condition immediately halts the transfer in progress also (BM2_TRANSFER_DONE=1). (R/WC)"]
            #[inline(always)]
            pub fn set_strt2_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "This bit is set if the transfer on Bus Master Channel 2 completed but too many bytes were delivered by the eSPI Host. Some of the data will not be delivered on the internal bus. (R/WC)"]
            #[inline(always)]
            pub const fn dat2_ovrun(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if the transfer on Bus Master Channel 2 completed but too many bytes were delivered by the eSPI Host. Some of the data will not be delivered on the internal bus. (R/WC)"]
            #[inline(always)]
            pub fn set_dat2_ovrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "This bit is set if the transfer on Bus Master Channel 2 completed but an insufficient number of bytes were transferred. Some of the data will not be delivered on the internal bus. (R/WC)"]
            #[inline(always)]
            pub const fn incmpl2(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if the transfer on Bus Master Channel 2 completed but an insufficient number of bytes were transferred. Some of the data will not be delivered on the internal bus. (R/WC)"]
            #[inline(always)]
            pub fn set_incmpl2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "This bit is set if a Layer 3 transaction from Bus Master Channel 2 completes with an Unsuccessful Completion packet from the eSPI Host. For example, this will happen if the START request attempts to read from a forbidden or unmapped address in System Memory. Bad Writes, however, cannot be flagged this way, and will be silently dropped by the eSPI Host without setting this bit. (R/WC)"]
            #[inline(always)]
            pub const fn fail2(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if a Layer 3 transaction from Bus Master Channel 2 completes with an Unsuccessful Completion packet from the eSPI Host. For example, this will happen if the START request attempts to read from a forbidden or unmapped address in System Memory. Bad Writes, however, cannot be flagged this way, and will be silently dropped by the eSPI Host without setting this bit. (R/WC)"]
            #[inline(always)]
            pub fn set_fail2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "This bit is set if a transfer on Bus Master Channel 2 is terminated due to a bus error internal to the EC. This can happen if an invalid address is provided in the Bus Master 2 internal Address register. (R/WC)"]
            #[inline(always)]
            pub const fn intr2_bus_err(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if a transfer on Bus Master Channel 2 is terminated due to a bus error internal to the EC. This can happen if an invalid address is provided in the Bus Master 2 internal Address register. (R/WC)"]
            #[inline(always)]
            pub fn set_intr2_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "This bit is set, and the START request is terminated immediately (BM2_TRANSFER_DONE=1) without triggering traffic, if register contents are invalid at the time the BM2_START bit is written to '1' by firmware. (R/WC) Examples of a Bad Request are: Length of zero, or Length greater than 4K (1000h) Host Address and Length together specifying a request that crosses a 4KByte boundary. This might violate the Scatter/Gather structure of the Host memory, so is not allowed."]
            #[inline(always)]
            pub const fn bad2_req(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set, and the START request is terminated immediately (BM2_TRANSFER_DONE=1) without triggering traffic, if register contents are invalid at the time the BM2_START bit is written to '1' by firmware. (R/WC) Examples of a Bad Request are: Length of zero, or Length greater than 4K (1000h) Host Address and Length together specifying a request that crosses a 4KByte boundary. This might violate the Scatter/Gather structure of the Host memory, so is not allowed."]
            #[inline(always)]
            pub fn set_bad2_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
        }
        impl Default for BmSts {
            #[inline(always)]
            fn default() -> BmSts {
                BmSts(0)
            }
        }
        impl core::fmt::Debug for BmSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BmSts")
                    .field("tx_done1", &self.tx_done1())
                    .field("busy1", &self.busy1())
                    .field("abort1_ec", &self.abort1_ec())
                    .field("abort1_h", &self.abort1_h())
                    .field("abort_ch2_err", &self.abort_ch2_err())
                    .field("strt1_ovrflw", &self.strt1_ovrflw())
                    .field("dat1_ovrun", &self.dat1_ovrun())
                    .field("incmpl1", &self.incmpl1())
                    .field("fail1", &self.fail1())
                    .field("intr1_bus_err", &self.intr1_bus_err())
                    .field("bad1_req", &self.bad1_req())
                    .field("tx_done2", &self.tx_done2())
                    .field("busy2", &self.busy2())
                    .field("abort2_ec", &self.abort2_ec())
                    .field("abort2_h", &self.abort2_h())
                    .field("abort_ch1_err", &self.abort_ch1_err())
                    .field("strt2_ovrflw", &self.strt2_ovrflw())
                    .field("dat2_ovrun", &self.dat2_ovrun())
                    .field("incmpl2", &self.incmpl2())
                    .field("fail2", &self.fail2())
                    .field("intr2_bus_err", &self.intr2_bus_err())
                    .field("bad2_req", &self.bad2_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BmSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "BmSts {{ tx_done1: {=bool:?}, busy1: {=bool:?}, abort1_ec: {=bool:?}, abort1_h: {=bool:?}, abort_ch2_err: {=bool:?}, strt1_ovrflw: {=bool:?}, dat1_ovrun: {=bool:?}, incmpl1: {=bool:?}, fail1: {=bool:?}, intr1_bus_err: {=bool:?}, bad1_req: {=bool:?}, tx_done2: {=bool:?}, busy2: {=bool:?}, abort2_ec: {=bool:?}, abort2_h: {=bool:?}, abort_ch1_err: {=bool:?}, strt2_ovrflw: {=bool:?}, dat2_ovrun: {=bool:?}, incmpl2: {=bool:?}, fail2: {=bool:?}, intr2_bus_err: {=bool:?}, bad2_req: {=bool:?} }}" , self . tx_done1 () , self . busy1 () , self . abort1_ec () , self . abort1_h () , self . abort_ch2_err () , self . strt1_ovrflw () , self . dat1_ovrun () , self . incmpl1 () , self . fail1 () , self . intr1_bus_err () , self . bad1_req () , self . tx_done2 () , self . busy2 () , self . abort2_ec () , self . abort2_h () , self . abort_ch1_err () , self . strt2_ovrflw () , self . dat2_ovrun () , self . incmpl2 () , self . fail2 () , self . intr2_bus_err () , self . bad2_req ())
            }
        }
        #[doc = "EMI 0 Memory BAR Configuration Address Register (Word 3)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi0memBarCfgW3(pub u16);
        impl Emi0memBarCfgW3 {
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Emi0memBarCfgW3 {
            #[inline(always)]
            fn default() -> Emi0memBarCfgW3 {
                Emi0memBarCfgW3(0)
            }
        }
        impl core::fmt::Debug for Emi0memBarCfgW3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi0memBarCfgW3")
                    .field("espi_host_address_w2", &self.espi_host_address_w2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi0memBarCfgW3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi0memBarCfgW3 {{ espi_host_address_w2: {=u16:?} }}",
                    self.espi_host_address_w2()
                )
            }
        }
        #[doc = "EMI 0 Memory BAR Configuration Address Register (Word 4)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi0memBarCfgW4(pub u16);
        impl Emi0memBarCfgW4 {
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w3(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w3(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Emi0memBarCfgW4 {
            #[inline(always)]
            fn default() -> Emi0memBarCfgW4 {
                Emi0memBarCfgW4(0)
            }
        }
        impl core::fmt::Debug for Emi0memBarCfgW4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi0memBarCfgW4")
                    .field("espi_host_address_w3", &self.espi_host_address_w3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi0memBarCfgW4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi0memBarCfgW4 {{ espi_host_address_w3: {=u16:?} }}",
                    self.espi_host_address_w3()
                )
            }
        }
        #[doc = "EMI 1 Memory BAR Configuration Register (Word 0) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi1memBarCfgW0(pub u16);
        impl Emi1memBarCfgW0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Emi1memBarCfgW0 {
            #[inline(always)]
            fn default() -> Emi1memBarCfgW0 {
                Emi1memBarCfgW0(0)
            }
        }
        impl core::fmt::Debug for Emi1memBarCfgW0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi1memBarCfgW0").field("valid", &self.valid()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi1memBarCfgW0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Emi1memBarCfgW0 {{ valid: {=bool:?} }}", self.valid())
            }
        }
        #[doc = "EMI 1 Memory BAR Configuration Register (Word 1) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi1memBarCfgW1(pub u16);
        impl Emi1memBarCfgW1 {
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Emi1memBarCfgW1 {
            #[inline(always)]
            fn default() -> Emi1memBarCfgW1 {
                Emi1memBarCfgW1(0)
            }
        }
        impl core::fmt::Debug for Emi1memBarCfgW1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi1memBarCfgW1")
                    .field("espi_host_address_w0", &self.espi_host_address_w0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi1memBarCfgW1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi1memBarCfgW1 {{ espi_host_address_w0: {=u16:?} }}",
                    self.espi_host_address_w0()
                )
            }
        }
        #[doc = "EMI 1 Memory BAR Configuration Register (Word 2) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi1memBarCfgW2(pub u16);
        impl Emi1memBarCfgW2 {
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Emi1memBarCfgW2 {
            #[inline(always)]
            fn default() -> Emi1memBarCfgW2 {
                Emi1memBarCfgW2(0)
            }
        }
        impl core::fmt::Debug for Emi1memBarCfgW2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi1memBarCfgW2")
                    .field("espi_host_address_w1", &self.espi_host_address_w1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi1memBarCfgW2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi1memBarCfgW2 {{ espi_host_address_w1: {=u16:?} }}",
                    self.espi_host_address_w1()
                )
            }
        }
        #[doc = "EMI 1 Memory BAR Configuration Register (Word 3) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi1memBarCfgW3(pub u16);
        impl Emi1memBarCfgW3 {
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Emi1memBarCfgW3 {
            #[inline(always)]
            fn default() -> Emi1memBarCfgW3 {
                Emi1memBarCfgW3(0)
            }
        }
        impl core::fmt::Debug for Emi1memBarCfgW3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi1memBarCfgW3")
                    .field("espi_host_address_w2", &self.espi_host_address_w2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi1memBarCfgW3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi1memBarCfgW3 {{ espi_host_address_w2: {=u16:?} }}",
                    self.espi_host_address_w2()
                )
            }
        }
        #[doc = "EMI 1 Memory BAR Configuration Register (Word 4) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi1memBarCfgW4(pub u16);
        impl Emi1memBarCfgW4 {
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w3(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w3(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Emi1memBarCfgW4 {
            #[inline(always)]
            fn default() -> Emi1memBarCfgW4 {
                Emi1memBarCfgW4(0)
            }
        }
        impl core::fmt::Debug for Emi1memBarCfgW4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi1memBarCfgW4")
                    .field("espi_host_address_w3", &self.espi_host_address_w3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi1memBarCfgW4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi1memBarCfgW4 {{ espi_host_address_w3: {=u16:?} }}",
                    self.espi_host_address_w3()
                )
            }
        }
        #[doc = "EMI 2 Memory BAR Configuration Register (Word 0) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi2memBarCfgW0(pub u16);
        impl Emi2memBarCfgW0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Emi2memBarCfgW0 {
            #[inline(always)]
            fn default() -> Emi2memBarCfgW0 {
                Emi2memBarCfgW0(0)
            }
        }
        impl core::fmt::Debug for Emi2memBarCfgW0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi2memBarCfgW0").field("valid", &self.valid()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi2memBarCfgW0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Emi2memBarCfgW0 {{ valid: {=bool:?} }}", self.valid())
            }
        }
        #[doc = "EMI 2 Memory BAR Configuration Register (Word 1) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi2memBarCfgW1(pub u16);
        impl Emi2memBarCfgW1 {
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Emi2memBarCfgW1 {
            #[inline(always)]
            fn default() -> Emi2memBarCfgW1 {
                Emi2memBarCfgW1(0)
            }
        }
        impl core::fmt::Debug for Emi2memBarCfgW1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi2memBarCfgW1")
                    .field("espi_host_address_w0", &self.espi_host_address_w0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi2memBarCfgW1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi2memBarCfgW1 {{ espi_host_address_w0: {=u16:?} }}",
                    self.espi_host_address_w0()
                )
            }
        }
        #[doc = "EMI 2 Memory BAR Configuration Register (Word 2) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi2memBarCfgW2(pub u16);
        impl Emi2memBarCfgW2 {
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Emi2memBarCfgW2 {
            #[inline(always)]
            fn default() -> Emi2memBarCfgW2 {
                Emi2memBarCfgW2(0)
            }
        }
        impl core::fmt::Debug for Emi2memBarCfgW2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi2memBarCfgW2")
                    .field("espi_host_address_w1", &self.espi_host_address_w1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi2memBarCfgW2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi2memBarCfgW2 {{ espi_host_address_w1: {=u16:?} }}",
                    self.espi_host_address_w1()
                )
            }
        }
        #[doc = "EMI 2 Memory BAR Configuration Register (Word 3) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi2memBarCfgW3(pub u16);
        impl Emi2memBarCfgW3 {
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Emi2memBarCfgW3 {
            #[inline(always)]
            fn default() -> Emi2memBarCfgW3 {
                Emi2memBarCfgW3(0)
            }
        }
        impl core::fmt::Debug for Emi2memBarCfgW3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi2memBarCfgW3")
                    .field("espi_host_address_w2", &self.espi_host_address_w2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi2memBarCfgW3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi2memBarCfgW3 {{ espi_host_address_w2: {=u16:?} }}",
                    self.espi_host_address_w2()
                )
            }
        }
        #[doc = "EMI 2 Memory BAR Configuration Register (Word 4) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Emi2memBarCfgW4(pub u16);
        impl Emi2memBarCfgW4 {
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w3(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w3(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Emi2memBarCfgW4 {
            #[inline(always)]
            fn default() -> Emi2memBarCfgW4 {
                Emi2memBarCfgW4(0)
            }
        }
        impl core::fmt::Debug for Emi2memBarCfgW4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Emi2memBarCfgW4")
                    .field("espi_host_address_w3", &self.espi_host_address_w3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Emi2memBarCfgW4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Emi2memBarCfgW4 {{ espi_host_address_w3: {=u16:?} }}",
                    self.espi_host_address_w3()
                )
            }
        }
        #[doc = "SRAM BAR 0 Configuration Register (Word 0) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sram0memBarCfgW0(pub u16);
        impl Sram0memBarCfgW0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Sram0memBarCfgW0 {
            #[inline(always)]
            fn default() -> Sram0memBarCfgW0 {
                Sram0memBarCfgW0(0)
            }
        }
        impl core::fmt::Debug for Sram0memBarCfgW0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sram0memBarCfgW0")
                    .field("valid", &self.valid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sram0memBarCfgW0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sram0memBarCfgW0 {{ valid: {=bool:?} }}", self.valid())
            }
        }
        #[doc = "SRAM BAR 0 Configuration Register (Word 1) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sram0memBarCfgW1(pub u16);
        impl Sram0memBarCfgW1 {
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Sram0memBarCfgW1 {
            #[inline(always)]
            fn default() -> Sram0memBarCfgW1 {
                Sram0memBarCfgW1(0)
            }
        }
        impl core::fmt::Debug for Sram0memBarCfgW1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sram0memBarCfgW1")
                    .field("espi_host_address_w0", &self.espi_host_address_w0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sram0memBarCfgW1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sram0memBarCfgW1 {{ espi_host_address_w0: {=u16:?} }}",
                    self.espi_host_address_w0()
                )
            }
        }
        #[doc = "SRAM BAR 0 Configuration Register (Word 2) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sram0memBarCfgW2(pub u16);
        impl Sram0memBarCfgW2 {
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Sram0memBarCfgW2 {
            #[inline(always)]
            fn default() -> Sram0memBarCfgW2 {
                Sram0memBarCfgW2(0)
            }
        }
        impl core::fmt::Debug for Sram0memBarCfgW2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sram0memBarCfgW2")
                    .field("espi_host_address_w1", &self.espi_host_address_w1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sram0memBarCfgW2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sram0memBarCfgW2 {{ espi_host_address_w1: {=u16:?} }}",
                    self.espi_host_address_w1()
                )
            }
        }
        #[doc = "SRAM BAR 0 Configuration Register (Word 3) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sram0memBarCfgW3(pub u16);
        impl Sram0memBarCfgW3 {
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Sram0memBarCfgW3 {
            #[inline(always)]
            fn default() -> Sram0memBarCfgW3 {
                Sram0memBarCfgW3(0)
            }
        }
        impl core::fmt::Debug for Sram0memBarCfgW3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sram0memBarCfgW3")
                    .field("espi_host_address_w2", &self.espi_host_address_w2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sram0memBarCfgW3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sram0memBarCfgW3 {{ espi_host_address_w2: {=u16:?} }}",
                    self.espi_host_address_w2()
                )
            }
        }
        #[doc = "SRAM BAR 0 Configuration Register (Word 4) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sram0memBarCfgW4(pub u16);
        impl Sram0memBarCfgW4 {
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w3(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w3(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Sram0memBarCfgW4 {
            #[inline(always)]
            fn default() -> Sram0memBarCfgW4 {
                Sram0memBarCfgW4(0)
            }
        }
        impl core::fmt::Debug for Sram0memBarCfgW4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sram0memBarCfgW4")
                    .field("espi_host_address_w3", &self.espi_host_address_w3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sram0memBarCfgW4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sram0memBarCfgW4 {{ espi_host_address_w3: {=u16:?} }}",
                    self.espi_host_address_w3()
                )
            }
        }
        #[doc = "SRAM BAR 1 Configuration Register (Word 0) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sram1memBarCfgW0(pub u16);
        impl Sram1memBarCfgW0 {
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Sram1memBarCfgW0 {
            #[inline(always)]
            fn default() -> Sram1memBarCfgW0 {
                Sram1memBarCfgW0(0)
            }
        }
        impl core::fmt::Debug for Sram1memBarCfgW0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sram1memBarCfgW0")
                    .field("valid", &self.valid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sram1memBarCfgW0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sram1memBarCfgW0 {{ valid: {=bool:?} }}", self.valid())
            }
        }
        #[doc = "SRAM BAR 1 Configuration Register (Word 1) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sram1memBarCfgW1(pub u16);
        impl Sram1memBarCfgW1 {
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[15:0\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w0(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Sram1memBarCfgW1 {
            #[inline(always)]
            fn default() -> Sram1memBarCfgW1 {
                Sram1memBarCfgW1(0)
            }
        }
        impl core::fmt::Debug for Sram1memBarCfgW1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sram1memBarCfgW1")
                    .field("espi_host_address_w0", &self.espi_host_address_w0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sram1memBarCfgW1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sram1memBarCfgW1 {{ espi_host_address_w0: {=u16:?} }}",
                    self.espi_host_address_w0()
                )
            }
        }
        #[doc = "SRAM BAR 1 Configuration Register (Word 2) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sram1memBarCfgW2(pub u16);
        impl Sram1memBarCfgW2 {
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[31:16\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w1(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Sram1memBarCfgW2 {
            #[inline(always)]
            fn default() -> Sram1memBarCfgW2 {
                Sram1memBarCfgW2(0)
            }
        }
        impl core::fmt::Debug for Sram1memBarCfgW2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sram1memBarCfgW2")
                    .field("espi_host_address_w1", &self.espi_host_address_w1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sram1memBarCfgW2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sram1memBarCfgW2 {{ espi_host_address_w1: {=u16:?} }}",
                    self.espi_host_address_w1()
                )
            }
        }
        #[doc = "SRAM BAR 1 Configuration Register (Word 3) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sram1memBarCfgW3(pub u16);
        impl Sram1memBarCfgW3 {
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[47:32\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Sram1memBarCfgW3 {
            #[inline(always)]
            fn default() -> Sram1memBarCfgW3 {
                Sram1memBarCfgW3(0)
            }
        }
        impl core::fmt::Debug for Sram1memBarCfgW3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sram1memBarCfgW3")
                    .field("espi_host_address_w2", &self.espi_host_address_w2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sram1memBarCfgW3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sram1memBarCfgW3 {{ espi_host_address_w2: {=u16:?} }}",
                    self.espi_host_address_w2()
                )
            }
        }
        #[doc = "SRAM BAR 1 Configuration Register (Word 4) )"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sram1memBarCfgW4(pub u16);
        impl Sram1memBarCfgW4 {
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub const fn espi_host_address_w3(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Bits\\[63:48\\] of the 64 bits that are used to match eSPI memory addresses."]
            #[inline(always)]
            pub fn set_espi_host_address_w3(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Sram1memBarCfgW4 {
            #[inline(always)]
            fn default() -> Sram1memBarCfgW4 {
                Sram1memBarCfgW4(0)
            }
        }
        impl core::fmt::Debug for Sram1memBarCfgW4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sram1memBarCfgW4")
                    .field("espi_host_address_w3", &self.espi_host_address_w3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sram1memBarCfgW4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sram1memBarCfgW4 {{ espi_host_address_w3: {=u16:?} }}",
                    self.espi_host_address_w3()
                )
            }
        }
    }
}
pub mod espi_msvw00_06 {
    #[doc = "The Virtual Wire Channel permits the System to emulate a set of wires that interconnect the system Core Logic with the EC."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EspiMsvw0006 {
        ptr: *mut u8,
    }
    unsafe impl Send for EspiMsvw0006 {}
    unsafe impl Sync for EspiMsvw0006 {}
    impl EspiMsvw0006 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Master-to-Slave Virtual Wire 0 Register (DW 0)"]
        #[inline(always)]
        pub const fn msvw00_dw0(self) -> crate::common::Reg<regs::Msvw00dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 0 Register (DW 1)"]
        #[inline(always)]
        pub const fn msvw00_dw1(self) -> crate::common::Reg<regs::Msvw00dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 0 Register (DW 2)"]
        #[inline(always)]
        pub const fn msvw00_dw2(self) -> crate::common::Reg<regs::Msvw00dw2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 1 Register (DW 0)"]
        #[inline(always)]
        pub const fn msvw01_dw0(self) -> crate::common::Reg<regs::Msvw01dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 1 Register (DW 1)"]
        #[inline(always)]
        pub const fn msvw01_dw1(self) -> crate::common::Reg<regs::Msvw01dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 1 Register (DW 2)"]
        #[inline(always)]
        pub const fn msvw01_dw2(self) -> crate::common::Reg<regs::Msvw01dw2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 2 Register (DW 0)"]
        #[inline(always)]
        pub const fn msvw02_dw0(self) -> crate::common::Reg<regs::Msvw02dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 2 Register (DW 1)"]
        #[inline(always)]
        pub const fn msvw02_dw1(self) -> crate::common::Reg<regs::Msvw02dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 2 Register (DW 2)"]
        #[inline(always)]
        pub const fn msvw02_dw2(self) -> crate::common::Reg<regs::Msvw02dw2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 3 Register (DW 0)"]
        #[inline(always)]
        pub const fn msvw03_dw0(self) -> crate::common::Reg<regs::Msvw03dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 3 Register (DW 1)"]
        #[inline(always)]
        pub const fn msvw03_dw1(self) -> crate::common::Reg<regs::Msvw03dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 3 Register (DW 2)"]
        #[inline(always)]
        pub const fn msvw03_dw2(self) -> crate::common::Reg<regs::Msvw03dw2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 4 Register (DW 0)"]
        #[inline(always)]
        pub const fn msvw04_dw0(self) -> crate::common::Reg<regs::Msvw04dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 4 Register (DW 1)"]
        #[inline(always)]
        pub const fn msvw04_dw1(self) -> crate::common::Reg<regs::Msvw04dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 4 Register (DW 2)"]
        #[inline(always)]
        pub const fn msvw04_dw2(self) -> crate::common::Reg<regs::Msvw04dw2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 5 Register (DW 0)"]
        #[inline(always)]
        pub const fn msvw05_dw0(self) -> crate::common::Reg<regs::Msvw05dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 5 Register (DW 1)"]
        #[inline(always)]
        pub const fn msvw05_dw1(self) -> crate::common::Reg<regs::Msvw05dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 5 Register (DW 2)"]
        #[inline(always)]
        pub const fn msvw05_dw2(self) -> crate::common::Reg<regs::Msvw05dw2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 6 Register (DW 0)"]
        #[inline(always)]
        pub const fn msvw06_dw0(self) -> crate::common::Reg<regs::Msvw06dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 6 Register (DW 1)"]
        #[inline(always)]
        pub const fn msvw06_dw1(self) -> crate::common::Reg<regs::Msvw06dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 6 Register (DW 2)"]
        #[inline(always)]
        pub const fn msvw06_dw2(self) -> crate::common::Reg<regs::Msvw06dw2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Master-to-Slave Virtual Wire 0 Register (DW 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw00dw0(pub u32);
        impl Msvw00dw0 {
            #[doc = "The Boot ROM firmware will copy this field into the SRC3 to SRC0 bits of the Master-to-Slave Virtual Wire Register that corresponds to Virtual Wire Index 2h on a RESET_SYS. If software always saves the state of the Index 2h SRC bits on the falling edge of the SUSWARN# virtual wire, the state of the four SRC bits will be synchronized to the state of the four bits in the core logic."]
            #[inline(always)]
            pub const fn m2s_2h_backup(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The Boot ROM firmware will copy this field into the SRC3 to SRC0 bits of the Master-to-Slave Virtual Wire Register that corresponds to Virtual Wire Index 2h on a RESET_SYS. If software always saves the state of the Index 2h SRC bits on the falling edge of the SUSWARN# virtual wire, the state of the four SRC bits will be synchronized to the state of the four bits in the core logic."]
            #[inline(always)]
            pub fn set_m2s_2h_backup(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn index(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_index(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn mtos_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_mtos_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn mtos_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_mtos_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Msvw00dw0 {
            #[inline(always)]
            fn default() -> Msvw00dw0 {
                Msvw00dw0(0)
            }
        }
        impl core::fmt::Debug for Msvw00dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw00dw0")
                    .field("m2s_2h_backup", &self.m2s_2h_backup())
                    .field("index", &self.index())
                    .field("mtos_src", &self.mtos_src())
                    .field("mtos_r_state", &self.mtos_r_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw00dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw00dw0 {{ m2s_2h_backup: {=u8:?}, index: {=u8:?}, mtos_src: {=u8:?}, mtos_r_state: {=u8:?} }}",
                    self.m2s_2h_backup(),
                    self.index(),
                    self.mtos_src(),
                    self.mtos_r_state()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 0 Register (DW 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw00dw1(pub u32);
        impl Msvw00dw1 {
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src0irq_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src0irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src1irq_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src1irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src2irq_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src2irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src3irq_sel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src3irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Msvw00dw1 {
            #[inline(always)]
            fn default() -> Msvw00dw1 {
                Msvw00dw1(0)
            }
        }
        impl core::fmt::Debug for Msvw00dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw00dw1")
                    .field("src0irq_sel", &self.src0irq_sel())
                    .field("src1irq_sel", &self.src1irq_sel())
                    .field("src2irq_sel", &self.src2irq_sel())
                    .field("src3irq_sel", &self.src3irq_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw00dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Msvw00dw1 {{ src0irq_sel: {=u8:?}, src1irq_sel: {=u8:?}, src2irq_sel: {=u8:?}, src3irq_sel: {=u8:?} }}" , self . src0irq_sel () , self . src1irq_sel () , self . src2irq_sel () , self . src3irq_sel ())
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 0 Register (DW 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw00dw2(pub u32);
        impl Msvw00dw2 {
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Msvw00dw2 {
            #[inline(always)]
            fn default() -> Msvw00dw2 {
                Msvw00dw2(0)
            }
        }
        impl core::fmt::Debug for Msvw00dw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw00dw2")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw00dw2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw00dw2 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 1 Register (DW 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw01dw0(pub u32);
        impl Msvw01dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn mtos_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_mtos_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn mtos_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_mtos_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Msvw01dw0 {
            #[inline(always)]
            fn default() -> Msvw01dw0 {
                Msvw01dw0(0)
            }
        }
        impl core::fmt::Debug for Msvw01dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw01dw0")
                    .field("ind", &self.ind())
                    .field("mtos_src", &self.mtos_src())
                    .field("mtos_r_state", &self.mtos_r_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw01dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw01dw0 {{ ind: {=u8:?}, mtos_src: {=u8:?}, mtos_r_state: {=u8:?} }}",
                    self.ind(),
                    self.mtos_src(),
                    self.mtos_r_state()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 1 Register (DW 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw01dw1(pub u32);
        impl Msvw01dw1 {
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src0irq_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src0irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src1irq_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src1irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src2irq_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src2irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src3irq_sel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src3irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Msvw01dw1 {
            #[inline(always)]
            fn default() -> Msvw01dw1 {
                Msvw01dw1(0)
            }
        }
        impl core::fmt::Debug for Msvw01dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw01dw1")
                    .field("src0irq_sel", &self.src0irq_sel())
                    .field("src1irq_sel", &self.src1irq_sel())
                    .field("src2irq_sel", &self.src2irq_sel())
                    .field("src3irq_sel", &self.src3irq_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw01dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Msvw01dw1 {{ src0irq_sel: {=u8:?}, src1irq_sel: {=u8:?}, src2irq_sel: {=u8:?}, src3irq_sel: {=u8:?} }}" , self . src0irq_sel () , self . src1irq_sel () , self . src2irq_sel () , self . src3irq_sel ())
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 1 Register (DW 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw01dw2(pub u32);
        impl Msvw01dw2 {
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Msvw01dw2 {
            #[inline(always)]
            fn default() -> Msvw01dw2 {
                Msvw01dw2(0)
            }
        }
        impl core::fmt::Debug for Msvw01dw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw01dw2")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw01dw2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw01dw2 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 2 Register (DW 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw02dw0(pub u32);
        impl Msvw02dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn mtos_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_mtos_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn mtos_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_mtos_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Msvw02dw0 {
            #[inline(always)]
            fn default() -> Msvw02dw0 {
                Msvw02dw0(0)
            }
        }
        impl core::fmt::Debug for Msvw02dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw02dw0")
                    .field("ind", &self.ind())
                    .field("mtos_src", &self.mtos_src())
                    .field("mtos_r_state", &self.mtos_r_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw02dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw02dw0 {{ ind: {=u8:?}, mtos_src: {=u8:?}, mtos_r_state: {=u8:?} }}",
                    self.ind(),
                    self.mtos_src(),
                    self.mtos_r_state()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 2 Register (DW 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw02dw1(pub u32);
        impl Msvw02dw1 {
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src0irq_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src0irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src1irq_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src1irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src2irq_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src2irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src3irq_sel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src3irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Msvw02dw1 {
            #[inline(always)]
            fn default() -> Msvw02dw1 {
                Msvw02dw1(0)
            }
        }
        impl core::fmt::Debug for Msvw02dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw02dw1")
                    .field("src0irq_sel", &self.src0irq_sel())
                    .field("src1irq_sel", &self.src1irq_sel())
                    .field("src2irq_sel", &self.src2irq_sel())
                    .field("src3irq_sel", &self.src3irq_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw02dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Msvw02dw1 {{ src0irq_sel: {=u8:?}, src1irq_sel: {=u8:?}, src2irq_sel: {=u8:?}, src3irq_sel: {=u8:?} }}" , self . src0irq_sel () , self . src1irq_sel () , self . src2irq_sel () , self . src3irq_sel ())
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 2 Register (DW 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw02dw2(pub u32);
        impl Msvw02dw2 {
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Msvw02dw2 {
            #[inline(always)]
            fn default() -> Msvw02dw2 {
                Msvw02dw2(0)
            }
        }
        impl core::fmt::Debug for Msvw02dw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw02dw2")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw02dw2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw02dw2 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 3 Register (DW 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw03dw0(pub u32);
        impl Msvw03dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn mtos_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_mtos_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn mtos_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_mtos_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Msvw03dw0 {
            #[inline(always)]
            fn default() -> Msvw03dw0 {
                Msvw03dw0(0)
            }
        }
        impl core::fmt::Debug for Msvw03dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw03dw0")
                    .field("ind", &self.ind())
                    .field("mtos_src", &self.mtos_src())
                    .field("mtos_r_state", &self.mtos_r_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw03dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw03dw0 {{ ind: {=u8:?}, mtos_src: {=u8:?}, mtos_r_state: {=u8:?} }}",
                    self.ind(),
                    self.mtos_src(),
                    self.mtos_r_state()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 3 Register (DW 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw03dw1(pub u32);
        impl Msvw03dw1 {
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src0irq_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src0irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src1irq_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src1irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src2irq_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src2irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src3irq_sel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src3irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Msvw03dw1 {
            #[inline(always)]
            fn default() -> Msvw03dw1 {
                Msvw03dw1(0)
            }
        }
        impl core::fmt::Debug for Msvw03dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw03dw1")
                    .field("src0irq_sel", &self.src0irq_sel())
                    .field("src1irq_sel", &self.src1irq_sel())
                    .field("src2irq_sel", &self.src2irq_sel())
                    .field("src3irq_sel", &self.src3irq_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw03dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Msvw03dw1 {{ src0irq_sel: {=u8:?}, src1irq_sel: {=u8:?}, src2irq_sel: {=u8:?}, src3irq_sel: {=u8:?} }}" , self . src0irq_sel () , self . src1irq_sel () , self . src2irq_sel () , self . src3irq_sel ())
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 3 Register (DW 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw03dw2(pub u32);
        impl Msvw03dw2 {
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Msvw03dw2 {
            #[inline(always)]
            fn default() -> Msvw03dw2 {
                Msvw03dw2(0)
            }
        }
        impl core::fmt::Debug for Msvw03dw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw03dw2")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw03dw2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw03dw2 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 4 Register (DW 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw04dw0(pub u32);
        impl Msvw04dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn mtos_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_mtos_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn mtos_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_mtos_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Msvw04dw0 {
            #[inline(always)]
            fn default() -> Msvw04dw0 {
                Msvw04dw0(0)
            }
        }
        impl core::fmt::Debug for Msvw04dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw04dw0")
                    .field("ind", &self.ind())
                    .field("mtos_src", &self.mtos_src())
                    .field("mtos_r_state", &self.mtos_r_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw04dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw04dw0 {{ ind: {=u8:?}, mtos_src: {=u8:?}, mtos_r_state: {=u8:?} }}",
                    self.ind(),
                    self.mtos_src(),
                    self.mtos_r_state()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 4 Register (DW 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw04dw1(pub u32);
        impl Msvw04dw1 {
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src0irq_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src0irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src1irq_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src1irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src2irq_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src2irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src3irq_sel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src3irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Msvw04dw1 {
            #[inline(always)]
            fn default() -> Msvw04dw1 {
                Msvw04dw1(0)
            }
        }
        impl core::fmt::Debug for Msvw04dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw04dw1")
                    .field("src0irq_sel", &self.src0irq_sel())
                    .field("src1irq_sel", &self.src1irq_sel())
                    .field("src2irq_sel", &self.src2irq_sel())
                    .field("src3irq_sel", &self.src3irq_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw04dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Msvw04dw1 {{ src0irq_sel: {=u8:?}, src1irq_sel: {=u8:?}, src2irq_sel: {=u8:?}, src3irq_sel: {=u8:?} }}" , self . src0irq_sel () , self . src1irq_sel () , self . src2irq_sel () , self . src3irq_sel ())
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 4 Register (DW 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw04dw2(pub u32);
        impl Msvw04dw2 {
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Msvw04dw2 {
            #[inline(always)]
            fn default() -> Msvw04dw2 {
                Msvw04dw2(0)
            }
        }
        impl core::fmt::Debug for Msvw04dw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw04dw2")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw04dw2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw04dw2 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 5 Register (DW 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw05dw0(pub u32);
        impl Msvw05dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn mtos_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_mtos_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn mtos_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_mtos_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Msvw05dw0 {
            #[inline(always)]
            fn default() -> Msvw05dw0 {
                Msvw05dw0(0)
            }
        }
        impl core::fmt::Debug for Msvw05dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw05dw0")
                    .field("ind", &self.ind())
                    .field("mtos_src", &self.mtos_src())
                    .field("mtos_r_state", &self.mtos_r_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw05dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw05dw0 {{ ind: {=u8:?}, mtos_src: {=u8:?}, mtos_r_state: {=u8:?} }}",
                    self.ind(),
                    self.mtos_src(),
                    self.mtos_r_state()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 5 Register (DW 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw05dw1(pub u32);
        impl Msvw05dw1 {
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src0irq_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src0irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src1irq_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src1irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src2irq_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src2irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src3irq_sel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src3irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Msvw05dw1 {
            #[inline(always)]
            fn default() -> Msvw05dw1 {
                Msvw05dw1(0)
            }
        }
        impl core::fmt::Debug for Msvw05dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw05dw1")
                    .field("src0irq_sel", &self.src0irq_sel())
                    .field("src1irq_sel", &self.src1irq_sel())
                    .field("src2irq_sel", &self.src2irq_sel())
                    .field("src3irq_sel", &self.src3irq_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw05dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Msvw05dw1 {{ src0irq_sel: {=u8:?}, src1irq_sel: {=u8:?}, src2irq_sel: {=u8:?}, src3irq_sel: {=u8:?} }}" , self . src0irq_sel () , self . src1irq_sel () , self . src2irq_sel () , self . src3irq_sel ())
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 5 Register (DW 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw05dw2(pub u32);
        impl Msvw05dw2 {
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Msvw05dw2 {
            #[inline(always)]
            fn default() -> Msvw05dw2 {
                Msvw05dw2(0)
            }
        }
        impl core::fmt::Debug for Msvw05dw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw05dw2")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw05dw2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw05dw2 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 6 Register (DW 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw06dw0(pub u32);
        impl Msvw06dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn mtos_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_mtos_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn mtos_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_mtos_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Msvw06dw0 {
            #[inline(always)]
            fn default() -> Msvw06dw0 {
                Msvw06dw0(0)
            }
        }
        impl core::fmt::Debug for Msvw06dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw06dw0")
                    .field("ind", &self.ind())
                    .field("mtos_src", &self.mtos_src())
                    .field("mtos_r_state", &self.mtos_r_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw06dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw06dw0 {{ ind: {=u8:?}, mtos_src: {=u8:?}, mtos_r_state: {=u8:?} }}",
                    self.ind(),
                    self.mtos_src(),
                    self.mtos_r_state()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 6 Register (DW 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw06dw1(pub u32);
        impl Msvw06dw1 {
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src0irq_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src0irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src1irq_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src1irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src2irq_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src2irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src3irq_sel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src3irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Msvw06dw1 {
            #[inline(always)]
            fn default() -> Msvw06dw1 {
                Msvw06dw1(0)
            }
        }
        impl core::fmt::Debug for Msvw06dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw06dw1")
                    .field("src0irq_sel", &self.src0irq_sel())
                    .field("src1irq_sel", &self.src1irq_sel())
                    .field("src2irq_sel", &self.src2irq_sel())
                    .field("src3irq_sel", &self.src3irq_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw06dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Msvw06dw1 {{ src0irq_sel: {=u8:?}, src1irq_sel: {=u8:?}, src2irq_sel: {=u8:?}, src3irq_sel: {=u8:?} }}" , self . src0irq_sel () , self . src1irq_sel () , self . src2irq_sel () , self . src3irq_sel ())
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 6 Register (DW 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw06dw2(pub u32);
        impl Msvw06dw2 {
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Msvw06dw2 {
            #[inline(always)]
            fn default() -> Msvw06dw2 {
                Msvw06dw2(0)
            }
        }
        impl core::fmt::Debug for Msvw06dw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw06dw2")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw06dw2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw06dw2 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
    }
}
pub mod espi_msvw07_10 {
    #[doc = "The ESPI VW Channel permits the System to emulate a set of wires that interconnect the system Core Logic with the EC."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EspiMsvw0710 {
        ptr: *mut u8,
    }
    unsafe impl Send for EspiMsvw0710 {}
    unsafe impl Sync for EspiMsvw0710 {}
    impl EspiMsvw0710 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Master-to-Slave Virtual Wire 7 Register (DW 0)"]
        #[inline(always)]
        pub const fn msvw07_dw0(self) -> crate::common::Reg<regs::Msvw07dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 7 Register (DW 1)"]
        #[inline(always)]
        pub const fn msvw07_dw1(self) -> crate::common::Reg<regs::Msvw07dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 7 Register (DW 2)"]
        #[inline(always)]
        pub const fn msvw07_dw2(self) -> crate::common::Reg<regs::Msvw07dw2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 8 Register (DW 0)"]
        #[inline(always)]
        pub const fn msvw08_dw0(self) -> crate::common::Reg<regs::Msvw08dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 8 Register (DW 1)"]
        #[inline(always)]
        pub const fn msvw08_dw1(self) -> crate::common::Reg<regs::Msvw08dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 8 Register (DW 2)"]
        #[inline(always)]
        pub const fn msvw08_dw2(self) -> crate::common::Reg<regs::Msvw08dw2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 9 Register (DW 0)"]
        #[inline(always)]
        pub const fn msvw09_dw0(self) -> crate::common::Reg<regs::Msvw09dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 9 Register (DW 1)"]
        #[inline(always)]
        pub const fn msvw09_dw1(self) -> crate::common::Reg<regs::Msvw09dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 9 Register (DW 2)"]
        #[inline(always)]
        pub const fn msvw09_dw2(self) -> crate::common::Reg<regs::Msvw09dw2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 10 Register (DW 0)"]
        #[inline(always)]
        pub const fn msvw10_dw0(self) -> crate::common::Reg<regs::Msvw10dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 10 Register (DW 1)"]
        #[inline(always)]
        pub const fn msvw10_dw1(self) -> crate::common::Reg<regs::Msvw10dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Master-to-Slave Virtual Wire 10 Register (DW 2)"]
        #[inline(always)]
        pub const fn msvw10_dw2(self) -> crate::common::Reg<regs::Msvw10dw2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Master-to-Slave Virtual Wire 7 Register (DW 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw07dw0(pub u32);
        impl Msvw07dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn mtos_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_mtos_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn mtos_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_mtos_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Msvw07dw0 {
            #[inline(always)]
            fn default() -> Msvw07dw0 {
                Msvw07dw0(0)
            }
        }
        impl core::fmt::Debug for Msvw07dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw07dw0")
                    .field("ind", &self.ind())
                    .field("mtos_src", &self.mtos_src())
                    .field("mtos_r_state", &self.mtos_r_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw07dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw07dw0 {{ ind: {=u8:?}, mtos_src: {=u8:?}, mtos_r_state: {=u8:?} }}",
                    self.ind(),
                    self.mtos_src(),
                    self.mtos_r_state()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 7 Register (DW 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw07dw1(pub u32);
        impl Msvw07dw1 {
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src0irq_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src0irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src1irq_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src1irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src2irq_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src2irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src3irq_sel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src3irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Msvw07dw1 {
            #[inline(always)]
            fn default() -> Msvw07dw1 {
                Msvw07dw1(0)
            }
        }
        impl core::fmt::Debug for Msvw07dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw07dw1")
                    .field("src0irq_sel", &self.src0irq_sel())
                    .field("src1irq_sel", &self.src1irq_sel())
                    .field("src2irq_sel", &self.src2irq_sel())
                    .field("src3irq_sel", &self.src3irq_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw07dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Msvw07dw1 {{ src0irq_sel: {=u8:?}, src1irq_sel: {=u8:?}, src2irq_sel: {=u8:?}, src3irq_sel: {=u8:?} }}" , self . src0irq_sel () , self . src1irq_sel () , self . src2irq_sel () , self . src3irq_sel ())
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 7 Register (DW 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw07dw2(pub u32);
        impl Msvw07dw2 {
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Msvw07dw2 {
            #[inline(always)]
            fn default() -> Msvw07dw2 {
                Msvw07dw2(0)
            }
        }
        impl core::fmt::Debug for Msvw07dw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw07dw2")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw07dw2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw07dw2 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 8 Register (DW 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw08dw0(pub u32);
        impl Msvw08dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn mtos_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_mtos_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn mtos_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_mtos_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Msvw08dw0 {
            #[inline(always)]
            fn default() -> Msvw08dw0 {
                Msvw08dw0(0)
            }
        }
        impl core::fmt::Debug for Msvw08dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw08dw0")
                    .field("ind", &self.ind())
                    .field("mtos_src", &self.mtos_src())
                    .field("mtos_r_state", &self.mtos_r_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw08dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw08dw0 {{ ind: {=u8:?}, mtos_src: {=u8:?}, mtos_r_state: {=u8:?} }}",
                    self.ind(),
                    self.mtos_src(),
                    self.mtos_r_state()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 8 Register (DW 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw08dw1(pub u32);
        impl Msvw08dw1 {
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src0irq_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src0irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src1irq_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src1irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src2irq_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src2irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src3irq_sel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src3irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Msvw08dw1 {
            #[inline(always)]
            fn default() -> Msvw08dw1 {
                Msvw08dw1(0)
            }
        }
        impl core::fmt::Debug for Msvw08dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw08dw1")
                    .field("src0irq_sel", &self.src0irq_sel())
                    .field("src1irq_sel", &self.src1irq_sel())
                    .field("src2irq_sel", &self.src2irq_sel())
                    .field("src3irq_sel", &self.src3irq_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw08dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Msvw08dw1 {{ src0irq_sel: {=u8:?}, src1irq_sel: {=u8:?}, src2irq_sel: {=u8:?}, src3irq_sel: {=u8:?} }}" , self . src0irq_sel () , self . src1irq_sel () , self . src2irq_sel () , self . src3irq_sel ())
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 8 Register (DW 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw08dw2(pub u32);
        impl Msvw08dw2 {
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Msvw08dw2 {
            #[inline(always)]
            fn default() -> Msvw08dw2 {
                Msvw08dw2(0)
            }
        }
        impl core::fmt::Debug for Msvw08dw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw08dw2")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw08dw2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw08dw2 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 9 Register (DW 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw09dw0(pub u32);
        impl Msvw09dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn mtos_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_mtos_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn mtos_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_mtos_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Msvw09dw0 {
            #[inline(always)]
            fn default() -> Msvw09dw0 {
                Msvw09dw0(0)
            }
        }
        impl core::fmt::Debug for Msvw09dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw09dw0")
                    .field("ind", &self.ind())
                    .field("mtos_src", &self.mtos_src())
                    .field("mtos_r_state", &self.mtos_r_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw09dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw09dw0 {{ ind: {=u8:?}, mtos_src: {=u8:?}, mtos_r_state: {=u8:?} }}",
                    self.ind(),
                    self.mtos_src(),
                    self.mtos_r_state()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 9 Register (DW 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw09dw1(pub u32);
        impl Msvw09dw1 {
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src0irq_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src0irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src1irq_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src1irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src2irq_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src2irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src3irq_sel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src3irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Msvw09dw1 {
            #[inline(always)]
            fn default() -> Msvw09dw1 {
                Msvw09dw1(0)
            }
        }
        impl core::fmt::Debug for Msvw09dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw09dw1")
                    .field("src0irq_sel", &self.src0irq_sel())
                    .field("src1irq_sel", &self.src1irq_sel())
                    .field("src2irq_sel", &self.src2irq_sel())
                    .field("src3irq_sel", &self.src3irq_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw09dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Msvw09dw1 {{ src0irq_sel: {=u8:?}, src1irq_sel: {=u8:?}, src2irq_sel: {=u8:?}, src3irq_sel: {=u8:?} }}" , self . src0irq_sel () , self . src1irq_sel () , self . src2irq_sel () , self . src3irq_sel ())
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 9 Register (DW 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw09dw2(pub u32);
        impl Msvw09dw2 {
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Msvw09dw2 {
            #[inline(always)]
            fn default() -> Msvw09dw2 {
                Msvw09dw2(0)
            }
        }
        impl core::fmt::Debug for Msvw09dw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw09dw2")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw09dw2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw09dw2 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 10 Register (DW 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw10dw0(pub u32);
        impl Msvw10dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn mtos_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_mtos_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn mtos_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_mtos_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Msvw10dw0 {
            #[inline(always)]
            fn default() -> Msvw10dw0 {
                Msvw10dw0(0)
            }
        }
        impl core::fmt::Debug for Msvw10dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw10dw0")
                    .field("ind", &self.ind())
                    .field("mtos_src", &self.mtos_src())
                    .field("mtos_r_state", &self.mtos_r_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw10dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw10dw0 {{ ind: {=u8:?}, mtos_src: {=u8:?}, mtos_r_state: {=u8:?} }}",
                    self.ind(),
                    self.mtos_src(),
                    self.mtos_r_state()
                )
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 10 Register (DW 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw10dw1(pub u32);
        impl Msvw10dw1 {
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src0irq_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src0irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src1irq_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src1irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src2irq_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src2irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub const fn src3irq_sel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event do not generate an interrupt."]
            #[inline(always)]
            pub fn set_src3irq_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Msvw10dw1 {
            #[inline(always)]
            fn default() -> Msvw10dw1 {
                Msvw10dw1(0)
            }
        }
        impl core::fmt::Debug for Msvw10dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw10dw1")
                    .field("src0irq_sel", &self.src0irq_sel())
                    .field("src1irq_sel", &self.src1irq_sel())
                    .field("src2irq_sel", &self.src2irq_sel())
                    .field("src3irq_sel", &self.src3irq_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw10dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Msvw10dw1 {{ src0irq_sel: {=u8:?}, src1irq_sel: {=u8:?}, src2irq_sel: {=u8:?}, src3irq_sel: {=u8:?} }}" , self . src0irq_sel () , self . src1irq_sel () , self . src2irq_sel () , self . src3irq_sel ())
            }
        }
        #[doc = "Master-to-Slave Virtual Wire 10 Register (DW 2)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msvw10dw2(pub u32);
        impl Msvw10dw2 {
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Msvw10dw2 {
            #[inline(always)]
            fn default() -> Msvw10dw2 {
                Msvw10dw2(0)
            }
        }
        impl core::fmt::Debug for Msvw10dw2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msvw10dw2")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msvw10dw2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msvw10dw2 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
    }
}
pub mod espi_scratch {
    #[doc = "32 Byte ESPI Test Register"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EspiScratch {
        ptr: *mut u8,
    }
    unsafe impl Send for EspiScratch {}
    unsafe impl Sync for EspiScratch {}
    impl EspiScratch {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Scratch 0 Register"]
        #[inline(always)]
        pub const fn scratch0(self) -> crate::common::Reg<regs::Scratch0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Scratch 1 Register"]
        #[inline(always)]
        pub const fn scratch1(self) -> crate::common::Reg<regs::Scratch1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Scratch 2 Register"]
        #[inline(always)]
        pub const fn scratch2(self) -> crate::common::Reg<regs::Scratch2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Scratch 3 Register"]
        #[inline(always)]
        pub const fn scratch3(self) -> crate::common::Reg<regs::Scratch3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Scratch 4 Register"]
        #[inline(always)]
        pub const fn scratch4(self) -> crate::common::Reg<regs::Scratch4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Scratch 5 Register"]
        #[inline(always)]
        pub const fn scratch5(self) -> crate::common::Reg<regs::Scratch5, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Scratch 6 Register"]
        #[inline(always)]
        pub const fn scratch6(self) -> crate::common::Reg<regs::Scratch6, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Scratch 7 Register"]
        #[inline(always)]
        pub const fn scratch7(self) -> crate::common::Reg<regs::Scratch7, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Scratch 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scratch0(pub u32);
        impl Scratch0 {
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr0(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr0(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Scratch0 {
            #[inline(always)]
            fn default() -> Scratch0 {
                Scratch0(0)
            }
        }
        impl core::fmt::Debug for Scratch0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scratch0").field("scr0", &self.scr0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scratch0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Scratch0 {{ scr0: {=u32:?} }}", self.scr0())
            }
        }
        #[doc = "Scratch 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scratch1(pub u32);
        impl Scratch1 {
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr1(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr1(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Scratch1 {
            #[inline(always)]
            fn default() -> Scratch1 {
                Scratch1(0)
            }
        }
        impl core::fmt::Debug for Scratch1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scratch1").field("scr1", &self.scr1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scratch1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Scratch1 {{ scr1: {=u32:?} }}", self.scr1())
            }
        }
        #[doc = "Scratch 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scratch2(pub u32);
        impl Scratch2 {
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr2(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr2(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Scratch2 {
            #[inline(always)]
            fn default() -> Scratch2 {
                Scratch2(0)
            }
        }
        impl core::fmt::Debug for Scratch2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scratch2").field("scr2", &self.scr2()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scratch2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Scratch2 {{ scr2: {=u32:?} }}", self.scr2())
            }
        }
        #[doc = "Scratch 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scratch3(pub u32);
        impl Scratch3 {
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr3(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr3(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Scratch3 {
            #[inline(always)]
            fn default() -> Scratch3 {
                Scratch3(0)
            }
        }
        impl core::fmt::Debug for Scratch3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scratch3").field("scr3", &self.scr3()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scratch3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Scratch3 {{ scr3: {=u32:?} }}", self.scr3())
            }
        }
        #[doc = "Scratch 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scratch4(pub u32);
        impl Scratch4 {
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr4(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr4(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Scratch4 {
            #[inline(always)]
            fn default() -> Scratch4 {
                Scratch4(0)
            }
        }
        impl core::fmt::Debug for Scratch4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scratch4").field("scr4", &self.scr4()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scratch4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Scratch4 {{ scr4: {=u32:?} }}", self.scr4())
            }
        }
        #[doc = "Scratch 5 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scratch5(pub u32);
        impl Scratch5 {
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr5(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr5(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Scratch5 {
            #[inline(always)]
            fn default() -> Scratch5 {
                Scratch5(0)
            }
        }
        impl core::fmt::Debug for Scratch5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scratch5").field("scr5", &self.scr5()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scratch5 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Scratch5 {{ scr5: {=u32:?} }}", self.scr5())
            }
        }
        #[doc = "Scratch 6 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scratch6(pub u32);
        impl Scratch6 {
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr6(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr6(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Scratch6 {
            #[inline(always)]
            fn default() -> Scratch6 {
                Scratch6(0)
            }
        }
        impl core::fmt::Debug for Scratch6 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scratch6").field("scr6", &self.scr6()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scratch6 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Scratch6 {{ scr6: {=u32:?} }}", self.scr6())
            }
        }
        #[doc = "Scratch 7 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scratch7(pub u32);
        impl Scratch7 {
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub const fn scr7(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This field has no functionality other than storage. This register is aliased to ESPI Config Scratch Register."]
            #[inline(always)]
            pub fn set_scr7(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Scratch7 {
            #[inline(always)]
            fn default() -> Scratch7 {
                Scratch7(0)
            }
        }
        impl core::fmt::Debug for Scratch7 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scratch7").field("scr7", &self.scr7()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scratch7 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Scratch7 {{ scr7: {=u32:?} }}", self.scr7())
            }
        }
    }
}
pub mod espi_smvw00_10 {
    #[doc = "The ESPI VW Channel permits the System to emulate a set of wires that interconnect the system Core Logic with the EC."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EspiSmvw0010 {
        ptr: *mut u8,
    }
    unsafe impl Send for EspiSmvw0010 {}
    unsafe impl Sync for EspiSmvw0010 {}
    impl EspiSmvw0010 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Slave-to-Master Virtual Wire 0 Register (DWord 0)"]
        #[inline(always)]
        pub const fn smvw00_dw0(self) -> crate::common::Reg<regs::Smvw00dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 0 Register (DWord 1)"]
        #[inline(always)]
        pub const fn smvw00_dw1(self) -> crate::common::Reg<regs::Smvw00dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 1 Register (DWord 0)"]
        #[inline(always)]
        pub const fn smvw01_dw0(self) -> crate::common::Reg<regs::Smvw01dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 1 Register (DWord 1)"]
        #[inline(always)]
        pub const fn smvw01_dw1(self) -> crate::common::Reg<regs::Smvw01dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 2 Register (DWord 0)"]
        #[inline(always)]
        pub const fn smvw02_dw0(self) -> crate::common::Reg<regs::Smvw02dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 2 Register (DWord 1)"]
        #[inline(always)]
        pub const fn smvw02_dw1(self) -> crate::common::Reg<regs::Smvw02dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 3 Register (DWord 0)"]
        #[inline(always)]
        pub const fn smvw03_dw0(self) -> crate::common::Reg<regs::Smvw03dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 3 Register (DWord 1)"]
        #[inline(always)]
        pub const fn smvw03_dw1(self) -> crate::common::Reg<regs::Smvw03dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 4 Register (DWord 0)"]
        #[inline(always)]
        pub const fn smvw04_dw0(self) -> crate::common::Reg<regs::Smvw04dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 4 Register (DWord 1)"]
        #[inline(always)]
        pub const fn smvw04_dw1(self) -> crate::common::Reg<regs::Smvw04dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 5 Register (DWord 0)"]
        #[inline(always)]
        pub const fn smvw05_dw0(self) -> crate::common::Reg<regs::Smvw05dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 5 Register (DWord 1)"]
        #[inline(always)]
        pub const fn smvw05_dw1(self) -> crate::common::Reg<regs::Smvw05dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 6 Register (DWord 0)"]
        #[inline(always)]
        pub const fn smvw06_dw0(self) -> crate::common::Reg<regs::Smvw06dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 6 Register (DWord 1)"]
        #[inline(always)]
        pub const fn smvw06_dw1(self) -> crate::common::Reg<regs::Smvw06dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 7 Register (DWord 0)"]
        #[inline(always)]
        pub const fn smvw07_dw0(self) -> crate::common::Reg<regs::Smvw07dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 7 Register (DWord 1)"]
        #[inline(always)]
        pub const fn smvw07_dw1(self) -> crate::common::Reg<regs::Smvw07dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 8 Register (DWord 0)"]
        #[inline(always)]
        pub const fn smvw08_dw0(self) -> crate::common::Reg<regs::Smvw08dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 8 Register (DWord 1)"]
        #[inline(always)]
        pub const fn smvw08_dw1(self) -> crate::common::Reg<regs::Smvw08dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 9 Register (DWord 0)"]
        #[inline(always)]
        pub const fn smvw09_dw0(self) -> crate::common::Reg<regs::Smvw09dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 9 Register (DWord 1)"]
        #[inline(always)]
        pub const fn smvw09_dw1(self) -> crate::common::Reg<regs::Smvw09dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 10 Register (DWord 0)"]
        #[inline(always)]
        pub const fn smvw10_dw0(self) -> crate::common::Reg<regs::Smvw10dw0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "Slave-to-Master Virtual Wire 10 Register (DWord 1)"]
        #[inline(always)]
        pub const fn smvw10_dw1(self) -> crate::common::Reg<regs::Smvw10dw1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Slave-to-Master Virtual Wire 0 Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw00dw0(pub u32);
        impl Smvw00dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn stom_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_stom_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn stom_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_stom_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Smvw00dw0 {
            #[inline(always)]
            fn default() -> Smvw00dw0 {
                Smvw00dw0(0)
            }
        }
        impl core::fmt::Debug for Smvw00dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw00dw0")
                    .field("ind", &self.ind())
                    .field("stom_src", &self.stom_src())
                    .field("stom_r_state", &self.stom_r_state())
                    .field("chng0", &self.chng0())
                    .field("chng1", &self.chng1())
                    .field("chng2", &self.chng2())
                    .field("chng3", &self.chng3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw00dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smvw00dw0 {{ ind: {=u8:?}, stom_src: {=u8:?}, stom_r_state: {=u8:?}, chng0: {=bool:?}, chng1: {=bool:?}, chng2: {=bool:?}, chng3: {=bool:?} }}" , self . ind () , self . stom_src () , self . stom_r_state () , self . chng0 () , self . chng1 () , self . chng2 () , self . chng3 ())
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 0 Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw00dw1(pub u32);
        impl Smvw00dw1 {
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Smvw00dw1 {
            #[inline(always)]
            fn default() -> Smvw00dw1 {
                Smvw00dw1(0)
            }
        }
        impl core::fmt::Debug for Smvw00dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw00dw1")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw00dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smvw00dw1 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 1 Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw01dw0(pub u32);
        impl Smvw01dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn stom_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_stom_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn stom_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_stom_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Smvw01dw0 {
            #[inline(always)]
            fn default() -> Smvw01dw0 {
                Smvw01dw0(0)
            }
        }
        impl core::fmt::Debug for Smvw01dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw01dw0")
                    .field("ind", &self.ind())
                    .field("stom_src", &self.stom_src())
                    .field("stom_r_state", &self.stom_r_state())
                    .field("chng0", &self.chng0())
                    .field("chng1", &self.chng1())
                    .field("chng2", &self.chng2())
                    .field("chng3", &self.chng3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw01dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smvw01dw0 {{ ind: {=u8:?}, stom_src: {=u8:?}, stom_r_state: {=u8:?}, chng0: {=bool:?}, chng1: {=bool:?}, chng2: {=bool:?}, chng3: {=bool:?} }}" , self . ind () , self . stom_src () , self . stom_r_state () , self . chng0 () , self . chng1 () , self . chng2 () , self . chng3 ())
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 1 Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw01dw1(pub u32);
        impl Smvw01dw1 {
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Smvw01dw1 {
            #[inline(always)]
            fn default() -> Smvw01dw1 {
                Smvw01dw1(0)
            }
        }
        impl core::fmt::Debug for Smvw01dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw01dw1")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw01dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smvw01dw1 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 2 Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw02dw0(pub u32);
        impl Smvw02dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn stom_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_stom_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn stom_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_stom_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Smvw02dw0 {
            #[inline(always)]
            fn default() -> Smvw02dw0 {
                Smvw02dw0(0)
            }
        }
        impl core::fmt::Debug for Smvw02dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw02dw0")
                    .field("ind", &self.ind())
                    .field("stom_src", &self.stom_src())
                    .field("stom_r_state", &self.stom_r_state())
                    .field("chng0", &self.chng0())
                    .field("chng1", &self.chng1())
                    .field("chng2", &self.chng2())
                    .field("chng3", &self.chng3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw02dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smvw02dw0 {{ ind: {=u8:?}, stom_src: {=u8:?}, stom_r_state: {=u8:?}, chng0: {=bool:?}, chng1: {=bool:?}, chng2: {=bool:?}, chng3: {=bool:?} }}" , self . ind () , self . stom_src () , self . stom_r_state () , self . chng0 () , self . chng1 () , self . chng2 () , self . chng3 ())
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 2 Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw02dw1(pub u32);
        impl Smvw02dw1 {
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Smvw02dw1 {
            #[inline(always)]
            fn default() -> Smvw02dw1 {
                Smvw02dw1(0)
            }
        }
        impl core::fmt::Debug for Smvw02dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw02dw1")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw02dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smvw02dw1 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 3 Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw03dw0(pub u32);
        impl Smvw03dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn stom_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_stom_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn stom_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_stom_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Smvw03dw0 {
            #[inline(always)]
            fn default() -> Smvw03dw0 {
                Smvw03dw0(0)
            }
        }
        impl core::fmt::Debug for Smvw03dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw03dw0")
                    .field("ind", &self.ind())
                    .field("stom_src", &self.stom_src())
                    .field("stom_r_state", &self.stom_r_state())
                    .field("chng0", &self.chng0())
                    .field("chng1", &self.chng1())
                    .field("chng2", &self.chng2())
                    .field("chng3", &self.chng3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw03dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smvw03dw0 {{ ind: {=u8:?}, stom_src: {=u8:?}, stom_r_state: {=u8:?}, chng0: {=bool:?}, chng1: {=bool:?}, chng2: {=bool:?}, chng3: {=bool:?} }}" , self . ind () , self . stom_src () , self . stom_r_state () , self . chng0 () , self . chng1 () , self . chng2 () , self . chng3 ())
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 3 Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw03dw1(pub u32);
        impl Smvw03dw1 {
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Smvw03dw1 {
            #[inline(always)]
            fn default() -> Smvw03dw1 {
                Smvw03dw1(0)
            }
        }
        impl core::fmt::Debug for Smvw03dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw03dw1")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw03dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smvw03dw1 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 4 Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw04dw0(pub u32);
        impl Smvw04dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn stom_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_stom_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn stom_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_stom_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Smvw04dw0 {
            #[inline(always)]
            fn default() -> Smvw04dw0 {
                Smvw04dw0(0)
            }
        }
        impl core::fmt::Debug for Smvw04dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw04dw0")
                    .field("ind", &self.ind())
                    .field("stom_src", &self.stom_src())
                    .field("stom_r_state", &self.stom_r_state())
                    .field("chng0", &self.chng0())
                    .field("chng1", &self.chng1())
                    .field("chng2", &self.chng2())
                    .field("chng3", &self.chng3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw04dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smvw04dw0 {{ ind: {=u8:?}, stom_src: {=u8:?}, stom_r_state: {=u8:?}, chng0: {=bool:?}, chng1: {=bool:?}, chng2: {=bool:?}, chng3: {=bool:?} }}" , self . ind () , self . stom_src () , self . stom_r_state () , self . chng0 () , self . chng1 () , self . chng2 () , self . chng3 ())
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 4 Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw04dw1(pub u32);
        impl Smvw04dw1 {
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Smvw04dw1 {
            #[inline(always)]
            fn default() -> Smvw04dw1 {
                Smvw04dw1(0)
            }
        }
        impl core::fmt::Debug for Smvw04dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw04dw1")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw04dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smvw04dw1 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 5 Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw05dw0(pub u32);
        impl Smvw05dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn stom_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_stom_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn stom_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_stom_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Smvw05dw0 {
            #[inline(always)]
            fn default() -> Smvw05dw0 {
                Smvw05dw0(0)
            }
        }
        impl core::fmt::Debug for Smvw05dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw05dw0")
                    .field("ind", &self.ind())
                    .field("stom_src", &self.stom_src())
                    .field("stom_r_state", &self.stom_r_state())
                    .field("chng0", &self.chng0())
                    .field("chng1", &self.chng1())
                    .field("chng2", &self.chng2())
                    .field("chng3", &self.chng3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw05dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smvw05dw0 {{ ind: {=u8:?}, stom_src: {=u8:?}, stom_r_state: {=u8:?}, chng0: {=bool:?}, chng1: {=bool:?}, chng2: {=bool:?}, chng3: {=bool:?} }}" , self . ind () , self . stom_src () , self . stom_r_state () , self . chng0 () , self . chng1 () , self . chng2 () , self . chng3 ())
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 5 Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw05dw1(pub u32);
        impl Smvw05dw1 {
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Smvw05dw1 {
            #[inline(always)]
            fn default() -> Smvw05dw1 {
                Smvw05dw1(0)
            }
        }
        impl core::fmt::Debug for Smvw05dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw05dw1")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw05dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smvw05dw1 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 6 Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw06dw0(pub u32);
        impl Smvw06dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn stom_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_stom_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn stom_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_stom_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Smvw06dw0 {
            #[inline(always)]
            fn default() -> Smvw06dw0 {
                Smvw06dw0(0)
            }
        }
        impl core::fmt::Debug for Smvw06dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw06dw0")
                    .field("ind", &self.ind())
                    .field("stom_src", &self.stom_src())
                    .field("stom_r_state", &self.stom_r_state())
                    .field("chng0", &self.chng0())
                    .field("chng1", &self.chng1())
                    .field("chng2", &self.chng2())
                    .field("chng3", &self.chng3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw06dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smvw06dw0 {{ ind: {=u8:?}, stom_src: {=u8:?}, stom_r_state: {=u8:?}, chng0: {=bool:?}, chng1: {=bool:?}, chng2: {=bool:?}, chng3: {=bool:?} }}" , self . ind () , self . stom_src () , self . stom_r_state () , self . chng0 () , self . chng1 () , self . chng2 () , self . chng3 ())
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 6 Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw06dw1(pub u32);
        impl Smvw06dw1 {
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Smvw06dw1 {
            #[inline(always)]
            fn default() -> Smvw06dw1 {
                Smvw06dw1(0)
            }
        }
        impl core::fmt::Debug for Smvw06dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw06dw1")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw06dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smvw06dw1 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 7 Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw07dw0(pub u32);
        impl Smvw07dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn stom_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_stom_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn stom_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_stom_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Smvw07dw0 {
            #[inline(always)]
            fn default() -> Smvw07dw0 {
                Smvw07dw0(0)
            }
        }
        impl core::fmt::Debug for Smvw07dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw07dw0")
                    .field("ind", &self.ind())
                    .field("stom_src", &self.stom_src())
                    .field("stom_r_state", &self.stom_r_state())
                    .field("chng0", &self.chng0())
                    .field("chng1", &self.chng1())
                    .field("chng2", &self.chng2())
                    .field("chng3", &self.chng3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw07dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smvw07dw0 {{ ind: {=u8:?}, stom_src: {=u8:?}, stom_r_state: {=u8:?}, chng0: {=bool:?}, chng1: {=bool:?}, chng2: {=bool:?}, chng3: {=bool:?} }}" , self . ind () , self . stom_src () , self . stom_r_state () , self . chng0 () , self . chng1 () , self . chng2 () , self . chng3 ())
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 7 Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw07dw1(pub u32);
        impl Smvw07dw1 {
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Smvw07dw1 {
            #[inline(always)]
            fn default() -> Smvw07dw1 {
                Smvw07dw1(0)
            }
        }
        impl core::fmt::Debug for Smvw07dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw07dw1")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw07dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smvw07dw1 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 8 Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw08dw0(pub u32);
        impl Smvw08dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn stom_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_stom_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn stom_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_stom_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Smvw08dw0 {
            #[inline(always)]
            fn default() -> Smvw08dw0 {
                Smvw08dw0(0)
            }
        }
        impl core::fmt::Debug for Smvw08dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw08dw0")
                    .field("ind", &self.ind())
                    .field("stom_src", &self.stom_src())
                    .field("stom_r_state", &self.stom_r_state())
                    .field("chng0", &self.chng0())
                    .field("chng1", &self.chng1())
                    .field("chng2", &self.chng2())
                    .field("chng3", &self.chng3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw08dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smvw08dw0 {{ ind: {=u8:?}, stom_src: {=u8:?}, stom_r_state: {=u8:?}, chng0: {=bool:?}, chng1: {=bool:?}, chng2: {=bool:?}, chng3: {=bool:?} }}" , self . ind () , self . stom_src () , self . stom_r_state () , self . chng0 () , self . chng1 () , self . chng2 () , self . chng3 ())
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 8 Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw08dw1(pub u32);
        impl Smvw08dw1 {
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Smvw08dw1 {
            #[inline(always)]
            fn default() -> Smvw08dw1 {
                Smvw08dw1(0)
            }
        }
        impl core::fmt::Debug for Smvw08dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw08dw1")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw08dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smvw08dw1 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 9 Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw09dw0(pub u32);
        impl Smvw09dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn stom_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_stom_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn stom_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_stom_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Smvw09dw0 {
            #[inline(always)]
            fn default() -> Smvw09dw0 {
                Smvw09dw0(0)
            }
        }
        impl core::fmt::Debug for Smvw09dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw09dw0")
                    .field("ind", &self.ind())
                    .field("stom_src", &self.stom_src())
                    .field("stom_r_state", &self.stom_r_state())
                    .field("chng0", &self.chng0())
                    .field("chng1", &self.chng1())
                    .field("chng2", &self.chng2())
                    .field("chng3", &self.chng3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw09dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smvw09dw0 {{ ind: {=u8:?}, stom_src: {=u8:?}, stom_r_state: {=u8:?}, chng0: {=bool:?}, chng1: {=bool:?}, chng2: {=bool:?}, chng3: {=bool:?} }}" , self . ind () , self . stom_src () , self . stom_r_state () , self . chng0 () , self . chng1 () , self . chng2 () , self . chng3 ())
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 9 Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw09dw1(pub u32);
        impl Smvw09dw1 {
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Smvw09dw1 {
            #[inline(always)]
            fn default() -> Smvw09dw1 {
                Smvw09dw1(0)
            }
        }
        impl core::fmt::Debug for Smvw09dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw09dw1")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw09dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smvw09dw1 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 10 Register (DWord 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw10dw0(pub u32);
        impl Smvw10dw0 {
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub const fn ind(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1, SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ."]
            #[inline(always)]
            pub fn set_ind(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub const fn stom_src(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines which reset signal in addition to RESET_SYS resets SRC\\[3:0\\] in this register: 3=PLTRST 2=RESET_SIO 1=RESET_SYS. This is the only reset signal that will reset the SRC fields. 0=RESET_ESPI."]
            #[inline(always)]
            pub fn set_stom_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub const fn stom_r_state(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value, since this field is also reset on RESET_SYS."]
            #[inline(always)]
            pub fn set_stom_r_state(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub const fn chng3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is reset, ignoring any change in the data bit value caused by the reset event."]
            #[inline(always)]
            pub fn set_chng3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Smvw10dw0 {
            #[inline(always)]
            fn default() -> Smvw10dw0 {
                Smvw10dw0(0)
            }
        }
        impl core::fmt::Debug for Smvw10dw0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw10dw0")
                    .field("ind", &self.ind())
                    .field("stom_src", &self.stom_src())
                    .field("stom_r_state", &self.stom_r_state())
                    .field("chng0", &self.chng0())
                    .field("chng1", &self.chng1())
                    .field("chng2", &self.chng2())
                    .field("chng3", &self.chng3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw10dw0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smvw10dw0 {{ ind: {=u8:?}, stom_src: {=u8:?}, stom_r_state: {=u8:?}, chng0: {=bool:?}, chng1: {=bool:?}, chng2: {=bool:?}, chng3: {=bool:?} }}" , self . ind () , self . stom_src () , self . stom_r_state () , self . chng0 () , self . chng1 () , self . chng2 () , self . chng3 ())
            }
        }
        #[doc = "Slave-to-Master Virtual Wire 10 Register (DWord 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smvw10dw1(pub u32);
        impl Smvw10dw1 {
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src1(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src2(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub const fn src3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction."]
            #[inline(always)]
            pub fn set_src3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Smvw10dw1 {
            #[inline(always)]
            fn default() -> Smvw10dw1 {
                Smvw10dw1(0)
            }
        }
        impl core::fmt::Debug for Smvw10dw1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smvw10dw1")
                    .field("src0", &self.src0())
                    .field("src1", &self.src1())
                    .field("src2", &self.src2())
                    .field("src3", &self.src3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smvw10dw1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smvw10dw1 {{ src0: {=bool:?}, src1: {=bool:?}, src2: {=bool:?}, src3: {=bool:?} }}",
                    self.src0(),
                    self.src1(),
                    self.src2(),
                    self.src3()
                )
            }
        }
    }
}
pub mod fan0 {
    #[doc = "The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors the fan's speed and automatically adjusts the drive to maintain the desired fan speed. This RPM based Fan Control Algorithm controls a PWM output based on a tachometer input."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fan0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Fan0 {}
    unsafe impl Sync for Fan0 {}
    impl Fan0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The Fan Driver Setting used to control the output of the Fan Driver."]
        #[inline(always)]
        pub const fn setng(self) -> crate::common::Reg<regs::Setng, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "The Fan Configuration Register controls the general operation of the RPM based Fan Control Algorithm used by the fan driver."]
        #[inline(always)]
        pub const fn cnfg(self) -> crate::common::Reg<regs::Cnfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "PWM Divide"]
        #[inline(always)]
        pub const fn pwm_divide(self) -> crate::common::Reg<regs::PwmDivide, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Gain Register stores the gain terms used by the proportional and integral portions of the RPM based Fan Control Algorithm."]
        #[inline(always)]
        pub const fn gain(self) -> crate::common::Reg<regs::Gain, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "The Fan Spin Up Configuration Register controls the settings of Spin Up Routine."]
        #[inline(always)]
        pub const fn spn_up_cnfg(self) -> crate::common::Reg<regs::SpnUpCnfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "FAN_STEP The Fan Step value represents the maximum step size the fan driver will take between update times"]
        #[inline(always)]
        pub const fn step(self) -> crate::common::Reg<regs::Step, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "the minimum drive setting for the RPM based Fan Control Algorithm."]
        #[inline(always)]
        pub const fn min_drv(self) -> crate::common::Reg<regs::MinDrv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "The maximum TACH Reading Register value to indicate that the fan is spinning properly."]
        #[inline(always)]
        pub const fn valid_tch_cnt(self) -> crate::common::Reg<regs::ValidTchCnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "The number of Tach counts used by the Fan Drive Fail detection circuitry"]
        #[inline(always)]
        pub const fn drv_fal_bnd(self) -> crate::common::Reg<regs::DrvFalBnd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "The target tachometer value."]
        #[inline(always)]
        pub const fn tach_trgt(self) -> crate::common::Reg<regs::TachTrgt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "15:3\\] The current tachometer reading value."]
        #[inline(always)]
        pub const fn tach_rdng(self) -> crate::common::Reg<regs::TachRdng, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "1:0\\] Determines the frequency range of the PWM fan driver"]
        #[inline(always)]
        pub const fn drv_bs_freq(self) -> crate::common::Reg<regs::DrvBsFreq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "The bits in this register are routed to interrupts."]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x11usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "The Fan Configuration Register controls the general operation of the RPM based Fan Control Algorithm used by the fan driver."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cnfg(pub u16);
        impl Cnfg {
            #[doc = "Determines the base time between fan driver updates. The Update Time, along with the Fan Step Register, is used to control the ramp rate of the drive response to provide a cleaner transition of the actual fan operation as the desired fan speed changes. 7=1600ms 6=1200ms 5=800ms 4=500ms 3=400ms 2=300ms 1=200ms 0=100ms Note: This ramp rate control applies for all changes to the active PWM output including when the RPM based Fan Speed Control Algorithm is disabled."]
            #[inline(always)]
            pub const fn update(&self) -> super::vals::Update {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Update::from_bits(val as u8)
            }
            #[doc = "Determines the base time between fan driver updates. The Update Time, along with the Fan Step Register, is used to control the ramp rate of the drive response to provide a cleaner transition of the actual fan operation as the desired fan speed changes. 7=1600ms 6=1200ms 5=800ms 4=500ms 3=400ms 2=300ms 1=200ms 0=100ms Note: This ramp rate control applies for all changes to the active PWM output including when the RPM based Fan Speed Control Algorithm is disabled."]
            #[inline(always)]
            pub fn set_update(&mut self, val: super::vals::Update) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u16) & 0x07) << 0usize);
            }
            #[doc = "Determines the minimum number of edges that must be detected on the TACH signal to determine a single rotation. A typical fan measured 5 edges (for a 2-pole fan). Increasing the number of edges measured with respect to the number of poles of the fan will cause the TACH Reading registers to indicate a fan speed that is higher or lower than the actual speed. In order for the FSC Algorithm to operate correctly, the TACH Target must be updated by the user to accommodate this shift. The Effective Tach Multiplier is used as a direct multiplier term that is applied to the Actual RPM to achieve the Reported RPM. It should only be applied if the number of edges measured does not match the number of edges expected based on the number of poles of the fan (which is fixed for any given fan)."]
            #[inline(always)]
            pub const fn edges(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x03;
                val as u8
            }
            #[doc = "Determines the minimum number of edges that must be detected on the TACH signal to determine a single rotation. A typical fan measured 5 edges (for a 2-pole fan). Increasing the number of edges measured with respect to the number of poles of the fan will cause the TACH Reading registers to indicate a fan speed that is higher or lower than the actual speed. In order for the FSC Algorithm to operate correctly, the TACH Target must be updated by the user to accommodate this shift. The Effective Tach Multiplier is used as a direct multiplier term that is applied to the Actual RPM to achieve the Reported RPM. It should only be applied if the number of edges measured does not match the number of edges expected based on the number of poles of the fan (which is fixed for any given fan)."]
            #[inline(always)]
            pub fn set_edges(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val as u16) & 0x03) << 3usize);
            }
            #[doc = "Adjusts the range of reported and programmed tachometer reading values. The RANGE bits determine the weighting of all TACH values (including the Valid TACH Count, TACH Target, and TACH reading). 3=Reported Minimum RPM: 4000. Tach Count Multiplier: 1 2=Reported Minimum RPM: 2000. Tach Count Multiplier: 2 1=Reported Minimum RPM: 1000. Tach Count Multiplier: 4 0=Reported Minimum RPM: 500. Tach Count Multiplier: 8"]
            #[inline(always)]
            pub const fn range(&self) -> super::vals::Range {
                let val = (self.0 >> 5usize) & 0x03;
                super::vals::Range::from_bits(val as u8)
            }
            #[doc = "Adjusts the range of reported and programmed tachometer reading values. The RANGE bits determine the weighting of all TACH values (including the Valid TACH Count, TACH Target, and TACH reading). 3=Reported Minimum RPM: 4000. Tach Count Multiplier: 1 2=Reported Minimum RPM: 2000. Tach Count Multiplier: 2 1=Reported Minimum RPM: 1000. Tach Count Multiplier: 4 0=Reported Minimum RPM: 500. Tach Count Multiplier: 8"]
            #[inline(always)]
            pub fn set_range(&mut self, val: super::vals::Range) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val.to_bits() as u16) & 0x03) << 5usize);
            }
            #[doc = "Enables the RPM based Fan Control Algorithm. 1=The control circuitry is enabled and the Fan Driver output will be automatically updated to maintain the programmed fan speed as indicated by the TACH Target Register. 0=The control circuitry is disabled and the fan driver output is determined by the Fan Driver Setting Register."]
            #[inline(always)]
            pub const fn en_algo(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the RPM based Fan Control Algorithm. 1=The control circuitry is enabled and the Fan Driver output will be automatically updated to maintain the programmed fan speed as indicated by the TACH Target Register. 0=The control circuitry is disabled and the fan driver output is determined by the Fan Driver Setting Register."]
            #[inline(always)]
            pub fn set_en_algo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u16) & 0x01) << 7usize);
            }
            #[doc = "Determines the polarity of the PWM driver. This does NOT affect the drive setting registers. A setting of 0% drive will still correspond to 0% drive independent of the polarity. 1 - The Polarity of the PWM driver is inverted. A drive setting of 00h will cause the output to be set at 100% duty cycle and a drive setting of FFh will cause the output to be set at 0% duty cycle. 0 - the Polarity of the PWM driver is normal. A drive setting of 00h will cause the output to be set at 0% duty cycle and a drive setting of FFh will cause the output to be set at 100% duty cycle."]
            #[inline(always)]
            pub const fn polarity(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Determines the polarity of the PWM driver. This does NOT affect the drive setting registers. A setting of 0% drive will still correspond to 0% drive independent of the polarity. 1 - The Polarity of the PWM driver is inverted. A drive setting of 00h will cause the output to be set at 100% duty cycle and a drive setting of FFh will cause the output to be set at 0% duty cycle. 0 - the Polarity of the PWM driver is normal. A drive setting of 00h will cause the output to be set at 0% duty cycle and a drive setting of FFh will cause the output to be set at 100% duty cycle."]
            #[inline(always)]
            pub fn set_polarity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u16) & 0x01) << 9usize);
            }
            #[doc = "Control some of the advanced options that affect the error window. When the measured fan speed is within the programmed error window around the target speed, the fan drive setting is not updated. These bits only apply if the Fan Speed Control Algorithm is used. 3=200 RPM 2=100 RPM 1=50 RPM 0=0 RPM"]
            #[inline(always)]
            pub const fn err_rng(&self) -> super::vals::ErrRng {
                let val = (self.0 >> 10usize) & 0x03;
                super::vals::ErrRng::from_bits(val as u8)
            }
            #[doc = "Control some of the advanced options that affect the error window. When the measured fan speed is within the programmed error window around the target speed, the fan drive setting is not updated. These bits only apply if the Fan Speed Control Algorithm is used. 3=200 RPM 2=100 RPM 1=50 RPM 0=0 RPM"]
            #[inline(always)]
            pub fn set_err_rng(&mut self, val: super::vals::ErrRng) {
                self.0 = (self.0 & !(0x03 << 10usize)) | (((val.to_bits() as u16) & 0x03) << 10usize);
            }
            #[doc = "Control some of the advanced options that affect the derivative portion of the RPM based fan control algorithm. These bits only apply if the Fan Speed Control Algorithm is used."]
            #[inline(always)]
            pub const fn der_opt(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x03;
                val as u8
            }
            #[doc = "Control some of the advanced options that affect the derivative portion of the RPM based fan control algorithm. These bits only apply if the Fan Speed Control Algorithm is used."]
            #[inline(always)]
            pub fn set_der_opt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 12usize)) | (((val as u16) & 0x03) << 12usize);
            }
            #[doc = "Disables the low pass glitch filter that removes high frequency noise injected on the TACH pin. 1 - The glitch filter is disabled. 0 - The glitch filter is enabled."]
            #[inline(always)]
            pub const fn dis_glitch(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Disables the low pass glitch filter that removes high frequency noise injected on the TACH pin. 1 - The glitch filter is disabled. 0 - The glitch filter is enabled."]
            #[inline(always)]
            pub fn set_dis_glitch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u16) & 0x01) << 14usize);
            }
            #[doc = "Enables the ramp rate control circuitry during the Manual Mode of operation. 1=The ramp rate control circuitry for the Manual Mode of operation is enabled. The PWM setting will follow the ramp rate controls as determined by the Fan Step and Update Time settings. The maximum PWM step is capped at the Fan Step setting and is updated based on the Update Time as given by the field UPDATE. 0=The ramp rate control circuitry for the Manual Mode of operation is disabled. When the Fan Drive Setting values are changed and the RPM based Fan Control Algorithm is disabled, the fan driver will be set to the new setting immediately."]
            #[inline(always)]
            pub const fn en_rrc(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the ramp rate control circuitry during the Manual Mode of operation. 1=The ramp rate control circuitry for the Manual Mode of operation is enabled. The PWM setting will follow the ramp rate controls as determined by the Fan Step and Update Time settings. The maximum PWM step is capped at the Fan Step setting and is updated based on the Update Time as given by the field UPDATE. 0=The ramp rate control circuitry for the Manual Mode of operation is disabled. When the Fan Drive Setting values are changed and the RPM based Fan Control Algorithm is disabled, the fan driver will be set to the new setting immediately."]
            #[inline(always)]
            pub fn set_en_rrc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Cnfg {
            #[inline(always)]
            fn default() -> Cnfg {
                Cnfg(0)
            }
        }
        impl core::fmt::Debug for Cnfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cnfg")
                    .field("update", &self.update())
                    .field("edges", &self.edges())
                    .field("range", &self.range())
                    .field("en_algo", &self.en_algo())
                    .field("polarity", &self.polarity())
                    .field("err_rng", &self.err_rng())
                    .field("der_opt", &self.der_opt())
                    .field("dis_glitch", &self.dis_glitch())
                    .field("en_rrc", &self.en_rrc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cnfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cnfg {{ update: {:?}, edges: {=u8:?}, range: {:?}, en_algo: {=bool:?}, polarity: {=bool:?}, err_rng: {:?}, der_opt: {=u8:?}, dis_glitch: {=bool:?}, en_rrc: {=bool:?} }}" , self . update () , self . edges () , self . range () , self . en_algo () , self . polarity () , self . err_rng () , self . der_opt () , self . dis_glitch () , self . en_rrc ())
            }
        }
        #[doc = "1:0\\] Determines the frequency range of the PWM fan driver"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DrvBsFreq(pub u8);
        impl DrvBsFreq {
            #[doc = "Determines the frequency range of the PWM fan driver (when enabled). PWM resolution is 10-bit, except when this field is set to '0b', when it is 8-bit. 3=2.34KHz 2=4.67KHz 1=23.4KHz 0=26.8KHz"]
            #[inline(always)]
            pub const fn pwm_base(&self) -> super::vals::PwmBase {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::PwmBase::from_bits(val as u8)
            }
            #[doc = "Determines the frequency range of the PWM fan driver (when enabled). PWM resolution is 10-bit, except when this field is set to '0b', when it is 8-bit. 3=2.34KHz 2=4.67KHz 1=23.4KHz 0=26.8KHz"]
            #[inline(always)]
            pub fn set_pwm_base(&mut self, val: super::vals::PwmBase) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for DrvBsFreq {
            #[inline(always)]
            fn default() -> DrvBsFreq {
                DrvBsFreq(0)
            }
        }
        impl core::fmt::Debug for DrvBsFreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DrvBsFreq").field("pwm_base", &self.pwm_base()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DrvBsFreq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DrvBsFreq {{ pwm_base: {:?} }}", self.pwm_base())
            }
        }
        #[doc = "The number of Tach counts used by the Fan Drive Fail detection circuitry"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DrvFalBnd(pub u16);
        impl DrvFalBnd {
            #[doc = "The number of Tach counts used by the Fan Drive Fail detection circuitry."]
            #[inline(always)]
            pub const fn fan_drive_fail_band(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x1fff;
                val as u16
            }
            #[doc = "The number of Tach counts used by the Fan Drive Fail detection circuitry."]
            #[inline(always)]
            pub fn set_fan_drive_fail_band(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 3usize)) | (((val as u16) & 0x1fff) << 3usize);
            }
        }
        impl Default for DrvFalBnd {
            #[inline(always)]
            fn default() -> DrvFalBnd {
                DrvFalBnd(0)
            }
        }
        impl core::fmt::Debug for DrvFalBnd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DrvFalBnd")
                    .field("fan_drive_fail_band", &self.fan_drive_fail_band())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DrvFalBnd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DrvFalBnd {{ fan_drive_fail_band: {=u16:?} }}",
                    self.fan_drive_fail_band()
                )
            }
        }
        #[doc = "Gain Register stores the gain terms used by the proportional and integral portions of the RPM based Fan Control Algorithm."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gain(pub u8);
        impl Gain {
            #[doc = "The proportional gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub const fn gainp(&self) -> super::vals::Gainp {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Gainp::from_bits(val as u8)
            }
            #[doc = "The proportional gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub fn set_gainp(&mut self, val: super::vals::Gainp) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "The integral gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub const fn gaini(&self) -> super::vals::Gaini {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Gaini::from_bits(val as u8)
            }
            #[doc = "The integral gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub fn set_gaini(&mut self, val: super::vals::Gaini) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u8) & 0x03) << 2usize);
            }
            #[doc = "The derivative gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub const fn gaind(&self) -> super::vals::Gaind {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Gaind::from_bits(val as u8)
            }
            #[doc = "The derivative gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub fn set_gaind(&mut self, val: super::vals::Gaind) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Gain {
            #[inline(always)]
            fn default() -> Gain {
                Gain(0)
            }
        }
        impl core::fmt::Debug for Gain {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gain")
                    .field("gainp", &self.gainp())
                    .field("gaini", &self.gaini())
                    .field("gaind", &self.gaind())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gain {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gain {{ gainp: {:?}, gaini: {:?}, gaind: {:?} }}",
                    self.gainp(),
                    self.gaini(),
                    self.gaind()
                )
            }
        }
        #[doc = "the minimum drive setting for the RPM based Fan Control Algorithm."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MinDrv(pub u8);
        impl MinDrv {
            #[doc = "The minimum drive setting."]
            #[inline(always)]
            pub const fn min_drive(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The minimum drive setting."]
            #[inline(always)]
            pub fn set_min_drive(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MinDrv {
            #[inline(always)]
            fn default() -> MinDrv {
                MinDrv(0)
            }
        }
        impl core::fmt::Debug for MinDrv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MinDrv").field("min_drive", &self.min_drive()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MinDrv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MinDrv {{ min_drive: {=u8:?} }}", self.min_drive())
            }
        }
        #[doc = "PWM Divide"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PwmDivide(pub u8);
        impl PwmDivide {
            #[doc = "The PWM Divide value determines the final frequency of the PWM driver. The driver base frequency is divided by the PWM Divide value to determine the final frequency."]
            #[inline(always)]
            pub const fn pwm_divide(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The PWM Divide value determines the final frequency of the PWM driver. The driver base frequency is divided by the PWM Divide value to determine the final frequency."]
            #[inline(always)]
            pub fn set_pwm_divide(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for PwmDivide {
            #[inline(always)]
            fn default() -> PwmDivide {
                PwmDivide(0)
            }
        }
        impl core::fmt::Debug for PwmDivide {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PwmDivide")
                    .field("pwm_divide", &self.pwm_divide())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PwmDivide {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PwmDivide {{ pwm_divide: {=u8:?} }}", self.pwm_divide())
            }
        }
        #[doc = "The Fan Driver Setting used to control the output of the Fan Driver."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Setng(pub u16);
        impl Setng {
            #[doc = "The Fan Driver Setting used to control the output of the Fan Driver."]
            #[inline(always)]
            pub const fn fan_setng(&self) -> u16 {
                let val = (self.0 >> 6usize) & 0x03ff;
                val as u16
            }
            #[doc = "The Fan Driver Setting used to control the output of the Fan Driver."]
            #[inline(always)]
            pub fn set_fan_setng(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 6usize)) | (((val as u16) & 0x03ff) << 6usize);
            }
        }
        impl Default for Setng {
            #[inline(always)]
            fn default() -> Setng {
                Setng(0)
            }
        }
        impl core::fmt::Debug for Setng {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Setng").field("fan_setng", &self.fan_setng()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Setng {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Setng {{ fan_setng: {=u16:?} }}", self.fan_setng())
            }
        }
        #[doc = "The Fan Spin Up Configuration Register controls the settings of Spin Up Routine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpnUpCnfg(pub u8);
        impl SpnUpCnfg {
            #[doc = "Determines the maximum Spin Time that the Spin Up Routine will run for. If a valid tachometer measurement is not detected before the Spin Time has elapsed, an interrupt will be generated. When the RPM based Fan Control Algorithm is active, the fan driver will attempt to re-start the fan immediately after the end of the last spin up attempt. 3=2 seconds 2=1 second 1=500 ms 0=250 ms"]
            #[inline(always)]
            pub const fn spinup_time(&self) -> super::vals::SpinupTime {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SpinupTime::from_bits(val as u8)
            }
            #[doc = "Determines the maximum Spin Time that the Spin Up Routine will run for. If a valid tachometer measurement is not detected before the Spin Time has elapsed, an interrupt will be generated. When the RPM based Fan Control Algorithm is active, the fan driver will attempt to re-start the fan immediately after the end of the last spin up attempt. 3=2 seconds 2=1 second 1=500 ms 0=250 ms"]
            #[inline(always)]
            pub fn set_spinup_time(&mut self, val: super::vals::SpinupTime) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Determines the final drive level that is used by the Spin Up Routine. 7=65% 6=60% 5=55% 4=50% 3=45% 2=40% 1=35% 0=30%"]
            #[inline(always)]
            pub const fn spin_lvl(&self) -> super::vals::SpinLvl {
                let val = (self.0 >> 2usize) & 0x07;
                super::vals::SpinLvl::from_bits(val as u8)
            }
            #[doc = "Determines the final drive level that is used by the Spin Up Routine. 7=65% 6=60% 5=55% 4=50% 3=45% 2=40% 1=35% 0=30%"]
            #[inline(always)]
            pub fn set_spin_lvl(&mut self, val: super::vals::SpinLvl) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val.to_bits() as u8) & 0x07) << 2usize);
            }
            #[doc = "Determines if the Spin Up Routine will drive the fan to 100% duty cycle for 1/4 of the programmed spin up time before driving it at the programmed level. 1=The Spin Up Routine will not drive the PWM to 100%. It will set the drive at the programmed spin level for the entire duration of the programmed spin up time 0=The Spin Up Routine will drive the PWM to 100% for 1/4 of the programmed spin up time before reverting to the programmed spin level."]
            #[inline(always)]
            pub const fn nokick(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Determines if the Spin Up Routine will drive the fan to 100% duty cycle for 1/4 of the programmed spin up time before driving it at the programmed level. 1=The Spin Up Routine will not drive the PWM to 100%. It will set the drive at the programmed spin level for the entire duration of the programmed spin up time 0=The Spin Up Routine will drive the PWM to 100% for 1/4 of the programmed spin up time before reverting to the programmed spin level."]
            #[inline(always)]
            pub fn set_nokick(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Determines how many update cycles are used for the Drive Fail detection function. This circuitry determines whether the fan can be driven to the desired Tach target. These settings only apply if the Fan Speed Control Algorithm is enabled. 3=Drive Fail detection circuitry will count for 64 update periods 2=Drive Fail detection circuitry will count for 32 update periods 1=Drive Fail detection circuitry will count for 16 update periods 0=Drive Fail detection circuitry is disabled."]
            #[inline(always)]
            pub const fn drv_fail_cnt(&self) -> super::vals::DrvFailCnt {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::DrvFailCnt::from_bits(val as u8)
            }
            #[doc = "Determines how many update cycles are used for the Drive Fail detection function. This circuitry determines whether the fan can be driven to the desired Tach target. These settings only apply if the Fan Speed Control Algorithm is enabled. 3=Drive Fail detection circuitry will count for 64 update periods 2=Drive Fail detection circuitry will count for 32 update periods 1=Drive Fail detection circuitry will count for 16 update periods 0=Drive Fail detection circuitry is disabled."]
            #[inline(always)]
            pub fn set_drv_fail_cnt(&mut self, val: super::vals::DrvFailCnt) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for SpnUpCnfg {
            #[inline(always)]
            fn default() -> SpnUpCnfg {
                SpnUpCnfg(0)
            }
        }
        impl core::fmt::Debug for SpnUpCnfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpnUpCnfg")
                    .field("spinup_time", &self.spinup_time())
                    .field("spin_lvl", &self.spin_lvl())
                    .field("nokick", &self.nokick())
                    .field("drv_fail_cnt", &self.drv_fail_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpnUpCnfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SpnUpCnfg {{ spinup_time: {:?}, spin_lvl: {:?}, nokick: {=bool:?}, drv_fail_cnt: {:?} }}",
                    self.spinup_time(),
                    self.spin_lvl(),
                    self.nokick(),
                    self.drv_fail_cnt()
                )
            }
        }
        #[doc = "FAN_STEP The Fan Step value represents the maximum step size the fan driver will take between update times"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Step(pub u8);
        impl Step {
            #[doc = "The Fan Step value represents the maximum step size the fan driver will take between update times. When the PWM_BASE frequency range field in the PWM Driver Base Frequency Register is set to the value 1, 2 or 3, this 8-bit field is added to the 10-bit PWM duty cycle, for a maximum step size of 25%. When the PWM_BASE field is set to 0, the PWM operates in an 8-bit mode. In 8-bit mode, this 8-bit field is added to the 8-bit duty cycle, for a maximum step size of 100%."]
            #[inline(always)]
            pub const fn fan_step(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Fan Step value represents the maximum step size the fan driver will take between update times. When the PWM_BASE frequency range field in the PWM Driver Base Frequency Register is set to the value 1, 2 or 3, this 8-bit field is added to the 10-bit PWM duty cycle, for a maximum step size of 25%. When the PWM_BASE field is set to 0, the PWM operates in an 8-bit mode. In 8-bit mode, this 8-bit field is added to the 8-bit duty cycle, for a maximum step size of 100%."]
            #[inline(always)]
            pub fn set_fan_step(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Step {
            #[inline(always)]
            fn default() -> Step {
                Step(0)
            }
        }
        impl core::fmt::Debug for Step {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Step").field("fan_step", &self.fan_step()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Step {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Step {{ fan_step: {=u8:?} }}", self.fan_step())
            }
        }
        #[doc = "The bits in this register are routed to interrupts."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u8);
        impl Sts {
            #[doc = "The bit Indicates that the tachometer measurement on the Fan detects a stalled fan. (R/WC) 0 - Stalled fan not detected. 1 - Stalled fan detected."]
            #[inline(always)]
            pub const fn fan_stall(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The bit Indicates that the tachometer measurement on the Fan detects a stalled fan. (R/WC) 0 - Stalled fan not detected. 1 - Stalled fan detected."]
            #[inline(always)]
            pub fn set_fan_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "The bit Indicates that the Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum time window. (R/WC) 1 - The Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum time window. 0 - The Spin up Routine for the Fan detected a valid tachometer reading within its maximum time window."]
            #[inline(always)]
            pub const fn fan_spin(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The bit Indicates that the Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum time window. (R/WC) 1 - The Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum time window. 0 - The Spin up Routine for the Fan detected a valid tachometer reading within its maximum time window."]
            #[inline(always)]
            pub fn set_fan_spin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "The bit Indicates that the RPM-based Fan Speed Control Algorithm cannot drive the Fan to the desired target setting at maximum drive. (R/WC) 1- The RPM-based Fan Speed Control Algorithm cannot drive Fan to the desired target setting at maximum drive. 0- The RPM-based Fan Speed Control Algorithm can drive Fan to the desired target setting."]
            #[inline(always)]
            pub const fn drive_fail(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "The bit Indicates that the RPM-based Fan Speed Control Algorithm cannot drive the Fan to the desired target setting at maximum drive. (R/WC) 1- The RPM-based Fan Speed Control Algorithm cannot drive Fan to the desired target setting at maximum drive. 0- The RPM-based Fan Speed Control Algorithm can drive Fan to the desired target setting."]
            #[inline(always)]
            pub fn set_drive_fail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("fan_stall", &self.fan_stall())
                    .field("fan_spin", &self.fan_spin())
                    .field("drive_fail", &self.drive_fail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sts {{ fan_stall: {=bool:?}, fan_spin: {=bool:?}, drive_fail: {=bool:?} }}",
                    self.fan_stall(),
                    self.fan_spin(),
                    self.drive_fail()
                )
            }
        }
        #[doc = "15:3\\] The current tachometer reading value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TachRdng(pub u16);
        impl TachRdng {
            #[doc = "The current tachometer reading value."]
            #[inline(always)]
            pub const fn tach_reading(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x1fff;
                val as u16
            }
            #[doc = "The current tachometer reading value."]
            #[inline(always)]
            pub fn set_tach_reading(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 3usize)) | (((val as u16) & 0x1fff) << 3usize);
            }
        }
        impl Default for TachRdng {
            #[inline(always)]
            fn default() -> TachRdng {
                TachRdng(0)
            }
        }
        impl core::fmt::Debug for TachRdng {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TachRdng")
                    .field("tach_reading", &self.tach_reading())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TachRdng {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TachRdng {{ tach_reading: {=u16:?} }}", self.tach_reading())
            }
        }
        #[doc = "The target tachometer value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TachTrgt(pub u16);
        impl TachTrgt {
            #[doc = "The target tachometer value."]
            #[inline(always)]
            pub const fn tach_target(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x1fff;
                val as u16
            }
            #[doc = "The target tachometer value."]
            #[inline(always)]
            pub fn set_tach_target(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 3usize)) | (((val as u16) & 0x1fff) << 3usize);
            }
        }
        impl Default for TachTrgt {
            #[inline(always)]
            fn default() -> TachTrgt {
                TachTrgt(0)
            }
        }
        impl core::fmt::Debug for TachTrgt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TachTrgt")
                    .field("tach_target", &self.tach_target())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TachTrgt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TachTrgt {{ tach_target: {=u16:?} }}", self.tach_target())
            }
        }
        #[doc = "The maximum TACH Reading Register value to indicate that the fan is spinning properly."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ValidTchCnt(pub u8);
        impl ValidTchCnt {
            #[doc = "The maximum TACH Reading Register value to indicate that the fan is spinning properly."]
            #[inline(always)]
            pub const fn valid_tach_cnt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The maximum TACH Reading Register value to indicate that the fan is spinning properly."]
            #[inline(always)]
            pub fn set_valid_tach_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ValidTchCnt {
            #[inline(always)]
            fn default() -> ValidTchCnt {
                ValidTchCnt(0)
            }
        }
        impl core::fmt::Debug for ValidTchCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ValidTchCnt")
                    .field("valid_tach_cnt", &self.valid_tach_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ValidTchCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ValidTchCnt {{ valid_tach_cnt: {=u8:?} }}", self.valid_tach_cnt())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DrvFailCnt {
            #[doc = "0=Drive Fail detection circuitry is disabled."]
            DRIVE_FAIL_CNT_DIS = 0x0,
            #[doc = "1=Drive Fail detection circuitry will count for 16 update periods"]
            DRIVE_FAIL_CNT_16_PERIOD = 0x01,
            #[doc = "2=Drive Fail detection circuitry will count for 32 update periods"]
            DRIVE_FAIL_CNT_32_PERIOD = 0x02,
            #[doc = "3=Drive Fail detection circuitry will count for 64 update periods"]
            DRIVE_FAIL_CNT_64_PERIOD = 0x03,
        }
        impl DrvFailCnt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DrvFailCnt {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DrvFailCnt {
            #[inline(always)]
            fn from(val: u8) -> DrvFailCnt {
                DrvFailCnt::from_bits(val)
            }
        }
        impl From<DrvFailCnt> for u8 {
            #[inline(always)]
            fn from(val: DrvFailCnt) -> u8 {
                DrvFailCnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ErrRng {
            #[doc = "0=0 RPM"]
            RPM_0 = 0x0,
            #[doc = "1=50 RPM"]
            RPM_50 = 0x01,
            #[doc = "2=100 RPM"]
            RPM_100 = 0x02,
            #[doc = "3=200 RPM"]
            RPM_200 = 0x03,
        }
        impl ErrRng {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ErrRng {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ErrRng {
            #[inline(always)]
            fn from(val: u8) -> ErrRng {
                ErrRng::from_bits(val)
            }
        }
        impl From<ErrRng> for u8 {
            #[inline(always)]
            fn from(val: ErrRng) -> u8 {
                ErrRng::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gaind {
            #[doc = "Gain Factor: 0=1x"]
            GAIND_1X = 0x0,
            #[doc = "Gain Factor: 1=2x"]
            GAIND_2X = 0x01,
            #[doc = "Gain Factor: 2=4x"]
            GAIND_4X = 0x02,
            #[doc = "Gain Factor: 3=8x"]
            GAIND_8X = 0x03,
        }
        impl Gaind {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gaind {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gaind {
            #[inline(always)]
            fn from(val: u8) -> Gaind {
                Gaind::from_bits(val)
            }
        }
        impl From<Gaind> for u8 {
            #[inline(always)]
            fn from(val: Gaind) -> u8 {
                Gaind::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gaini {
            #[doc = "Gain Factor: 0=1x"]
            GAINI_1X = 0x0,
            #[doc = "Gain Factor: 1=2x"]
            GAINI_2X = 0x01,
            #[doc = "Gain Factor: 2=4x"]
            GAINI_4X = 0x02,
            #[doc = "Gain Factor: 3=8x"]
            GAINI_8X = 0x03,
        }
        impl Gaini {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gaini {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gaini {
            #[inline(always)]
            fn from(val: u8) -> Gaini {
                Gaini::from_bits(val)
            }
        }
        impl From<Gaini> for u8 {
            #[inline(always)]
            fn from(val: Gaini) -> u8 {
                Gaini::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gainp {
            #[doc = "Gain Factor: 0=1x"]
            GAINP_1X = 0x0,
            #[doc = "Gain Factor: 1=2x"]
            GAINP_2X = 0x01,
            #[doc = "Gain Factor: 2=4x"]
            GAINP_4X = 0x02,
            #[doc = "Gain Factor: 3=8x"]
            GAINP_8X = 0x03,
        }
        impl Gainp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gainp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gainp {
            #[inline(always)]
            fn from(val: u8) -> Gainp {
                Gainp::from_bits(val)
            }
        }
        impl From<Gainp> for u8 {
            #[inline(always)]
            fn from(val: Gainp) -> u8 {
                Gainp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PwmBase {
            #[doc = "0=26.8KHz"]
            PWM_FAN_FREQ_26KHZ = 0x0,
            #[doc = "1=23.4KHz"]
            PWM_FAN_FREQ_23KHZ = 0x01,
            #[doc = "2=4.67KHz"]
            PWM_FAN_FREQ_4KHZ = 0x02,
            #[doc = "3=2.34KHz"]
            PWM_FAN_FREQ_2KHZ = 0x03,
        }
        impl PwmBase {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PwmBase {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PwmBase {
            #[inline(always)]
            fn from(val: u8) -> PwmBase {
                PwmBase::from_bits(val)
            }
        }
        impl From<PwmBase> for u8 {
            #[inline(always)]
            fn from(val: PwmBase) -> u8 {
                PwmBase::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Range {
            #[doc = "0=Reported Minimum RPM: 500. Tach Count Multiplier: 1"]
            TACH_COUNT_MULTIPLIER_1 = 0x0,
            #[doc = "1=Reported Minimum RPM: 1000. Tach Count Multiplier: 2"]
            TACH_COUNT_MULTIPLIER_2 = 0x01,
            #[doc = "2=Reported Minimum RPM: 2000. Tach Count Multiplier: 4"]
            TACH_COUNT_MULTIPLIER_4 = 0x02,
            #[doc = "3=Reported Minimum RPM: 4000. Tach Count Multiplier: 8"]
            TACH_COUNT_MULTIPLIER_8 = 0x03,
        }
        impl Range {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Range {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Range {
            #[inline(always)]
            fn from(val: u8) -> Range {
                Range::from_bits(val)
            }
        }
        impl From<Range> for u8 {
            #[inline(always)]
            fn from(val: Range) -> u8 {
                Range::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpinLvl {
            #[doc = "0=30%"]
            SPIN_LVL_30 = 0x0,
            #[doc = "1=35%"]
            SPIN_LVL_35 = 0x01,
            #[doc = "2=40%"]
            SPIN_LVL_40 = 0x02,
            #[doc = "3=45%"]
            SPIN_LVL_45 = 0x03,
            #[doc = "4=50%"]
            SPIN_LVL_50 = 0x04,
            #[doc = "5=55%"]
            SPIN_LVL_55 = 0x05,
            #[doc = "6=60%"]
            SPIN_LVL_60 = 0x06,
            #[doc = "7=65%"]
            SPIN_LVL_65 = 0x07,
        }
        impl SpinLvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpinLvl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpinLvl {
            #[inline(always)]
            fn from(val: u8) -> SpinLvl {
                SpinLvl::from_bits(val)
            }
        }
        impl From<SpinLvl> for u8 {
            #[inline(always)]
            fn from(val: SpinLvl) -> u8 {
                SpinLvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpinupTime {
            #[doc = "0=250 ms"]
            SPINUP_250_MSEC = 0x0,
            #[doc = "1=500 ms"]
            SPINUP_500_MSEC = 0x01,
            #[doc = "2=1 second"]
            SPINUP_1_SEC = 0x02,
            #[doc = "3=2 seconds"]
            SPINUP_2_SEC = 0x03,
        }
        impl SpinupTime {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpinupTime {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpinupTime {
            #[inline(always)]
            fn from(val: u8) -> SpinupTime {
                SpinupTime::from_bits(val)
            }
        }
        impl From<SpinupTime> for u8 {
            #[inline(always)]
            fn from(val: SpinupTime) -> u8 {
                SpinupTime::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Update {
            #[doc = "0=100ms"]
            BASE_TIME_100MS = 0x0,
            #[doc = "1=200ms"]
            BASE_TIME_200MS = 0x01,
            #[doc = "2=300ms"]
            BASE_TIME_300MS = 0x02,
            #[doc = "3=400ms"]
            BASE_TIME_400MS = 0x03,
            #[doc = "4=500ms"]
            BASE_TIME_500MS = 0x04,
            #[doc = "5=800ms"]
            BASE_TIME_800MS = 0x05,
            #[doc = "6=1200ms"]
            BASE_TIME_1200MS = 0x06,
            #[doc = "7=1600ms"]
            BASE_TIME_1600MS = 0x07,
        }
        impl Update {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Update {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Update {
            #[inline(always)]
            fn from(val: u8) -> Update {
                Update::from_bits(val)
            }
        }
        impl From<Update> for u8 {
            #[inline(always)]
            fn from(val: Update) -> u8 {
                Update::to_bits(val)
            }
        }
    }
}
pub mod fpu {
    #[doc = "Floating Point Unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fpu {
        ptr: *mut u8,
    }
    unsafe impl Send for Fpu {}
    unsafe impl Sync for Fpu {}
    impl Fpu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Floating-Point Context Control Register"]
        #[inline(always)]
        pub const fn fpccr(self) -> crate::common::Reg<regs::Fpccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Floating-Point Context Address Register"]
        #[inline(always)]
        pub const fn fpcar(self) -> crate::common::Reg<regs::Fpcar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Floating-Point Default Status Control Register"]
        #[inline(always)]
        pub const fn fpdscr(self) -> crate::common::Reg<regs::Fpdscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Media and FP Feature Register 0"]
        #[inline(always)]
        pub const fn mvfr0(self) -> crate::common::Reg<regs::Mvfr0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Media and FP Feature Register 1"]
        #[inline(always)]
        pub const fn mvfr1(self) -> crate::common::Reg<regs::Mvfr1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Floating-Point Context Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpcar(pub u32);
        impl Fpcar {
            #[doc = "Address for FP registers in exception stack frame"]
            #[inline(always)]
            pub const fn address(&self) -> u32 {
                let val = (self.0 >> 3usize) & 0x1fff_ffff;
                val as u32
            }
            #[doc = "Address for FP registers in exception stack frame"]
            #[inline(always)]
            pub fn set_address(&mut self, val: u32) {
                self.0 = (self.0 & !(0x1fff_ffff << 3usize)) | (((val as u32) & 0x1fff_ffff) << 3usize);
            }
        }
        impl Default for Fpcar {
            #[inline(always)]
            fn default() -> Fpcar {
                Fpcar(0)
            }
        }
        impl core::fmt::Debug for Fpcar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpcar").field("address", &self.address()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpcar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fpcar {{ address: {=u32:?} }}", self.address())
            }
        }
        #[doc = "Floating-Point Context Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpccr(pub u32);
        impl Fpccr {
            #[inline(always)]
            pub const fn lspact(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_lspact(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[inline(always)]
            pub const fn user(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_user(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn thread(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_thread(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[inline(always)]
            pub const fn hfrdy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_hfrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn mmrdy(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_mmrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn bfrdy(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_bfrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[inline(always)]
            pub const fn monrdy(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_monrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[inline(always)]
            pub const fn lspen(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_lspen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[inline(always)]
            pub const fn aspen(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_aspen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Fpccr {
            #[inline(always)]
            fn default() -> Fpccr {
                Fpccr(0)
            }
        }
        impl core::fmt::Debug for Fpccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpccr")
                    .field("lspact", &self.lspact())
                    .field("user", &self.user())
                    .field("thread", &self.thread())
                    .field("hfrdy", &self.hfrdy())
                    .field("mmrdy", &self.mmrdy())
                    .field("bfrdy", &self.bfrdy())
                    .field("monrdy", &self.monrdy())
                    .field("lspen", &self.lspen())
                    .field("aspen", &self.aspen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpccr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Fpccr {{ lspact: {=bool:?}, user: {=bool:?}, thread: {=bool:?}, hfrdy: {=bool:?}, mmrdy: {=bool:?}, bfrdy: {=bool:?}, monrdy: {=bool:?}, lspen: {=bool:?}, aspen: {=bool:?} }}" , self . lspact () , self . user () , self . thread () , self . hfrdy () , self . mmrdy () , self . bfrdy () , self . monrdy () , self . lspen () , self . aspen ())
            }
        }
        #[doc = "Floating-Point Default Status Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpdscr(pub u32);
        impl Fpdscr {
            #[doc = "Default value for FPSCR.RMODE"]
            #[inline(always)]
            pub const fn rmode(&self) -> super::vals::Rmode {
                let val = (self.0 >> 22usize) & 0x03;
                super::vals::Rmode::from_bits(val as u8)
            }
            #[doc = "Default value for FPSCR.RMODE"]
            #[inline(always)]
            pub fn set_rmode(&mut self, val: super::vals::Rmode) {
                self.0 = (self.0 & !(0x03 << 22usize)) | (((val.to_bits() as u32) & 0x03) << 22usize);
            }
            #[doc = "Default value for FPSCR.FZ"]
            #[inline(always)]
            pub const fn fz(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Default value for FPSCR.FZ"]
            #[inline(always)]
            pub fn set_fz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Default value for FPSCR.DN"]
            #[inline(always)]
            pub const fn dn(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Default value for FPSCR.DN"]
            #[inline(always)]
            pub fn set_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Default value for FPSCR.AHP"]
            #[inline(always)]
            pub const fn ahp(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Default value for FPSCR.AHP"]
            #[inline(always)]
            pub fn set_ahp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
        }
        impl Default for Fpdscr {
            #[inline(always)]
            fn default() -> Fpdscr {
                Fpdscr(0)
            }
        }
        impl core::fmt::Debug for Fpdscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpdscr")
                    .field("rmode", &self.rmode())
                    .field("fz", &self.fz())
                    .field("dn", &self.dn())
                    .field("ahp", &self.ahp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpdscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fpdscr {{ rmode: {:?}, fz: {=bool:?}, dn: {=bool:?}, ahp: {=bool:?} }}",
                    self.rmode(),
                    self.fz(),
                    self.dn(),
                    self.ahp()
                )
            }
        }
        #[doc = "Media and FP Feature Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mvfr0(pub u32);
        impl Mvfr0 {
            #[inline(always)]
            pub const fn a_simd_registers(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_a_simd_registers(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[inline(always)]
            pub const fn single_precision(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_single_precision(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[inline(always)]
            pub const fn double_precision(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_double_precision(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[inline(always)]
            pub const fn fp_excep_trapping(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_fp_excep_trapping(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[inline(always)]
            pub const fn divide(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_divide(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[inline(always)]
            pub const fn square_root(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_square_root(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[inline(always)]
            pub const fn short_vectors(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_short_vectors(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[inline(always)]
            pub const fn fp_rounding_modes(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_fp_rounding_modes(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Mvfr0 {
            #[inline(always)]
            fn default() -> Mvfr0 {
                Mvfr0(0)
            }
        }
        impl core::fmt::Debug for Mvfr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mvfr0")
                    .field("a_simd_registers", &self.a_simd_registers())
                    .field("single_precision", &self.single_precision())
                    .field("double_precision", &self.double_precision())
                    .field("fp_excep_trapping", &self.fp_excep_trapping())
                    .field("divide", &self.divide())
                    .field("square_root", &self.square_root())
                    .field("short_vectors", &self.short_vectors())
                    .field("fp_rounding_modes", &self.fp_rounding_modes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mvfr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mvfr0 {{ a_simd_registers: {=u8:?}, single_precision: {=u8:?}, double_precision: {=u8:?}, fp_excep_trapping: {=u8:?}, divide: {=u8:?}, square_root: {=u8:?}, short_vectors: {=u8:?}, fp_rounding_modes: {=u8:?} }}" , self . a_simd_registers () , self . single_precision () , self . double_precision () , self . fp_excep_trapping () , self . divide () , self . square_root () , self . short_vectors () , self . fp_rounding_modes ())
            }
        }
        #[doc = "Media and FP Feature Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mvfr1(pub u32);
        impl Mvfr1 {
            #[inline(always)]
            pub const fn ft_z_mode(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_ft_z_mode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[inline(always)]
            pub const fn d_na_n_mode(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_d_na_n_mode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[inline(always)]
            pub const fn fp_hpfp(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_fp_hpfp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[inline(always)]
            pub const fn fp_fused_mac(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_fp_fused_mac(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Mvfr1 {
            #[inline(always)]
            fn default() -> Mvfr1 {
                Mvfr1(0)
            }
        }
        impl core::fmt::Debug for Mvfr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mvfr1")
                    .field("ft_z_mode", &self.ft_z_mode())
                    .field("d_na_n_mode", &self.d_na_n_mode())
                    .field("fp_hpfp", &self.fp_hpfp())
                    .field("fp_fused_mac", &self.fp_fused_mac())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mvfr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mvfr1 {{ ft_z_mode: {=u8:?}, d_na_n_mode: {=u8:?}, fp_hpfp: {=u8:?}, fp_fused_mac: {=u8:?} }}",
                    self.ft_z_mode(),
                    self.d_na_n_mode(),
                    self.fp_hpfp(),
                    self.fp_fused_mac()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rmode {
            #[doc = "Round to Nearest"]
            RN = 0x0,
            #[doc = "Round towards Positive Infinity"]
            RP = 0x01,
            #[doc = "Round towards Negative Infinity"]
            RM = 0x02,
            #[doc = "Round towards Zero"]
            RZ = 0x03,
        }
        impl Rmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rmode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rmode {
            #[inline(always)]
            fn from(val: u8) -> Rmode {
                Rmode::from_bits(val)
            }
        }
        impl From<Rmode> for u8 {
            #[inline(always)]
            fn from(val: Rmode) -> u8 {
                Rmode::to_bits(val)
            }
        }
    }
}
pub mod gcr {
    #[doc = "The Logical Device Configuration registers support motherboard designs in which the resources required by their components are known and assigned by the BIOS at POST."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gcr {
        ptr: *mut u8,
    }
    unsafe impl Send for Gcr {}
    unsafe impl Sync for Gcr {}
    impl Gcr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "A write to this register selects the current logical device. This allows access to the control and configuration registers for each logical device. Note: The Activate command operates only on the selected logical device."]
        #[inline(always)]
        pub const fn ldn(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "A read-only register which provides device revision information."]
        #[inline(always)]
        pub const fn dev_rev(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "A read-only register which provides device sub ID information."]
        #[inline(always)]
        pub const fn dev_subid(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1dusize) as _) }
        }
        #[doc = "A read-only register which provides device identification LSB."]
        #[inline(always)]
        pub const fn dev_id(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1eusize) as _) }
        }
        #[doc = "A read-only register which provides legacy device identification."]
        #[inline(always)]
        pub const fn leg_dev_id(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "A read-only register which provides legacy device revision information."]
        #[inline(always)]
        pub const fn leg_dev_rev(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x21usize) as _) }
        }
        #[doc = "A read-only register which provides OTP ID information."]
        #[inline(always)]
        pub const fn otp_id(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "A read-only register which provides Validation ID information."]
        #[inline(always)]
        pub const fn vld_id(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x25usize) as _) }
        }
        #[doc = "A read-only register which provides Boot ROM Revision ID information."]
        #[inline(always)]
        pub const fn br_rev_id(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x26usize) as _) }
        }
    }
}
pub mod gp_spi0 {
    #[doc = "The General Purpose Serial Peripheral Interface (GP-SPI) may be used to communicate with various peripheral devices, e.g., EEPROMS, DACs, ADCs, that use a standard Serial Peripheral Interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct GpSpi0 {
        ptr: *mut u8,
    }
    unsafe impl Send for GpSpi0 {}
    unsafe impl Sync for GpSpi0 {}
    impl GpSpi0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "0:0\\] 1=Enabled. The device is fully operational 0=Disabled. Clocks are gated to conserve power and the SPDOUT and SPI_CLK signals are set to their inactive state"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SPI Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Status"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "7:0\\] A write to this register when the Tx_Data buffer is empty (TXBE in the SPI Status Register is '1') initiates a SPI transaction."]
        #[inline(always)]
        pub const fn tx_data(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "7:0\\] This register is used to read the value returned by the external SPI device."]
        #[inline(always)]
        pub const fn rx_data(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "SPI Clock Control. This register should not be changed during an active SPI transaction."]
        #[inline(always)]
        pub const fn clk_ctrl(self) -> crate::common::Reg<regs::ClkCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "5:0\\] PRELOAD SPI Clock Generator Preload value."]
        #[inline(always)]
        pub const fn clk_gen(self) -> crate::common::Reg<regs::ClkGen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "SPI Clock Control. This register should not be changed during an active SPI transaction."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkCtrl(pub u32);
        impl ClkCtrl {
            #[doc = "1=Valid data is clocked out on the first SPI_CLK edge on SPDOUT signal. The slave device should sample this data on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is clocked out on the SPDOUT signal prior to the first SPI_CLK edge. The slave device should sample this data on the first and following odd SPI_CLK edges (i.e., sample data on rising edge)"]
            #[inline(always)]
            pub const fn tclkph(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Valid data is clocked out on the first SPI_CLK edge on SPDOUT signal. The slave device should sample this data on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is clocked out on the SPDOUT signal prior to the first SPI_CLK edge. The slave device should sample this data on the first and following odd SPI_CLK edges (i.e., sample data on rising edge)"]
            #[inline(always)]
            pub fn set_tclkph(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=Valid data on SPDIN signal is expected after the first SPI_CLK edge. This data is sampled on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is expected on the SPDIN signal on the first SPI_CLK edge. This data is sampled on the first and following odd SPI_-CLK edges (i.e., sample data on rising edge)"]
            #[inline(always)]
            pub const fn rclkph(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=Valid data on SPDIN signal is expected after the first SPI_CLK edge. This data is sampled on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is expected on the SPDIN signal on the first SPI_CLK edge. This data is sampled on the first and following odd SPI_-CLK edges (i.e., sample data on rising edge)"]
            #[inline(always)]
            pub fn set_rclkph(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1=The SPI_CLK signal is high when the interface is idle and the first clock edge is a falling edge 0=The SPI_CLK is low when the interface is idle and the first clock edge is a rising edge"]
            #[inline(always)]
            pub const fn clkpol(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=The SPI_CLK signal is high when the interface is idle and the first clock edge is a falling edge 0=The SPI_CLK is low when the interface is idle and the first clock edge is a rising edge"]
            #[inline(always)]
            pub fn set_clkpol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=2MHz, 0=48 MHz Ring Oscillator"]
            #[inline(always)]
            pub const fn clksrc(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "1=2MHz, 0=48 MHz Ring Oscillator"]
            #[inline(always)]
            pub fn set_clksrc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for ClkCtrl {
            #[inline(always)]
            fn default() -> ClkCtrl {
                ClkCtrl(0)
            }
        }
        impl core::fmt::Debug for ClkCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkCtrl")
                    .field("tclkph", &self.tclkph())
                    .field("rclkph", &self.rclkph())
                    .field("clkpol", &self.clkpol())
                    .field("clksrc", &self.clksrc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "ClkCtrl {{ tclkph: {=bool:?}, rclkph: {=bool:?}, clkpol: {=bool:?}, clksrc: {=bool:?} }}",
                    self.tclkph(),
                    self.rclkph(),
                    self.clkpol(),
                    self.clksrc()
                )
            }
        }
        #[doc = "5:0\\] PRELOAD SPI Clock Generator Preload value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkGen(pub u32);
        impl ClkGen {
            #[doc = "SPI Clock Generator Preload Value"]
            #[inline(always)]
            pub const fn preload(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "SPI Clock Generator Preload Value"]
            #[inline(always)]
            pub fn set_preload(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for ClkGen {
            #[inline(always)]
            fn default() -> ClkGen {
                ClkGen(0)
            }
        }
        impl core::fmt::Debug for ClkGen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkGen").field("preload", &self.preload()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkGen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ClkGen {{ preload: {=u8:?} }}", self.preload())
            }
        }
        #[doc = "SPI Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "Least Significant Bit First 1= The data is transferred in LSB-first order. 0= The data is transferred in MSB-first order. (default)"]
            #[inline(always)]
            pub const fn lsbf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Least Significant Bit First 1= The data is transferred in LSB-first order. 0= The data is transferred in MSB-first order. (default)"]
            #[inline(always)]
            pub fn set_lsbf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Bidirectional Output Enable control. 1=The SPDOUT_Direction signal configures the SPDOUT signal as an output. 0=The SPDOUT_Direction signal configures the SPDOUT signal as an input."]
            #[inline(always)]
            pub const fn bioen(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Bidirectional Output Enable control. 1=The SPDOUT_Direction signal configures the SPDOUT signal as an output. 0=The SPDOUT_Direction signal configures the SPDOUT signal as an input."]
            #[inline(always)]
            pub fn set_bioen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "3:2\\] 1xb=SPDIN1 and SPDIN2. Select this option for Dual Mode \\[3:2\\] 01b=SPDIN2 only. Select this option for Half Duplex \\[3:2\\] 00b=SPDIN1 only. Select this option for Full Duplex"]
            #[inline(always)]
            pub const fn spdin_select(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "3:2\\] 1xb=SPDIN1 and SPDIN2. Select this option for Dual Mode \\[3:2\\] 01b=SPDIN2 only. Select this option for Half Duplex \\[3:2\\] 00b=SPDIN1 only. Select this option for Full Duplex"]
            #[inline(always)]
            pub fn set_spdin_select(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "Soft Reset is a self-clearing bit. Writing zero to this bit has no effect. Writing a one to this bit resets the entire SPI Interface, including all counters and registers back to their initial state."]
            #[inline(always)]
            pub const fn soft_reset(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Soft Reset is a self-clearing bit. Writing zero to this bit has no effect. Writing a one to this bit resets the entire SPI Interface, including all counters and registers back to their initial state."]
            #[inline(always)]
            pub fn set_soft_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Auto Read Enable. 1=A read of the SPI RX_DATA Register will clear both the RXBF status bit and the TXBE status bit 0=A read of the SPI RX_DATA Register will clear the RXBF status bit. The TXBE status bit will not be modified"]
            #[inline(always)]
            pub const fn auto_read(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Auto Read Enable. 1=A read of the SPI RX_DATA Register will clear both the RXBF status bit and the TXBE status bit 0=A read of the SPI RX_DATA Register will clear the RXBF status bit. The TXBE status bit will not be modified"]
            #[inline(always)]
            pub fn set_auto_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "SPI Chip Select Enable. 1= SPI_CS# output signal is asserted, i.e., driven to logic '0' 0= SPI_CS# output signal is deasserted, i.e., driven to logic '1'"]
            #[inline(always)]
            pub const fn ce(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Chip Select Enable. 1= SPI_CS# output signal is asserted, i.e., driven to logic '0' 0= SPI_CS# output signal is deasserted, i.e., driven to logic '1'"]
            #[inline(always)]
            pub fn set_ce(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("lsbf", &self.lsbf())
                    .field("bioen", &self.bioen())
                    .field("spdin_select", &self.spdin_select())
                    .field("soft_reset", &self.soft_reset())
                    .field("auto_read", &self.auto_read())
                    .field("ce", &self.ce())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ lsbf: {=bool:?}, bioen: {=bool:?}, spdin_select: {=u8:?}, soft_reset: {=bool:?}, auto_read: {=bool:?}, ce: {=bool:?} }}" , self . lsbf () , self . bioen () , self . spdin_select () , self . soft_reset () , self . auto_read () , self . ce ())
            }
        }
        #[doc = "SPI Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "1=TX_Data buffer is empty, 0=TX_Data buffer is not empty"]
            #[inline(always)]
            pub const fn txbe(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=TX_Data buffer is empty, 0=TX_Data buffer is not empty"]
            #[inline(always)]
            pub fn set_txbe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=RX_Data buffer is full, 0=RX_Data buffer is not full"]
            #[inline(always)]
            pub const fn rxbf(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=RX_Data buffer is full, 0=RX_Data buffer is not full"]
            #[inline(always)]
            pub fn set_rxbf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "ACTIVE status"]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "ACTIVE status"]
            #[inline(always)]
            pub fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("txbe", &self.txbe())
                    .field("rxbf", &self.rxbf())
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sts {{ txbe: {=bool:?}, rxbf: {=bool:?}, active: {=bool:?} }}",
                    self.txbe(),
                    self.rxbf(),
                    self.active()
                )
            }
        }
    }
}
pub mod gpio {
    #[doc = "GPIO Pin Control Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpio {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpio {}
    unsafe impl Sync for Gpio {}
    impl Gpio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[inline(always)]
        pub const fn port0(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[inline(always)]
        pub const fn port1(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[inline(always)]
        pub const fn port2(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[inline(always)]
        pub const fn port3(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[inline(always)]
        pub const fn port4(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[inline(always)]
        pub const fn port5(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[inline(always)]
        pub const fn port6(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[inline(always)]
        pub const fn port7(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0xe0usize) as _) }
        }
        #[inline(always)]
        pub const fn port10(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[inline(always)]
        pub const fn port11(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[inline(always)]
        pub const fn port12(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[inline(always)]
        pub const fn port13(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0160usize) as _) }
        }
        #[inline(always)]
        pub const fn port14(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[inline(always)]
        pub const fn port15(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x01a0usize) as _) }
        }
        #[inline(always)]
        pub const fn port16(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x01c0usize) as _) }
        }
        #[inline(always)]
        pub const fn port17(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x01e0usize) as _) }
        }
        #[inline(always)]
        pub const fn port20(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[inline(always)]
        pub const fn port21(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0220usize) as _) }
        }
        #[inline(always)]
        pub const fn port22(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0240usize) as _) }
        }
        #[inline(always)]
        pub const fn port23(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0260usize) as _) }
        }
        #[inline(always)]
        pub const fn port24(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0280usize) as _) }
        }
        #[inline(always)]
        pub const fn port25(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x02a0usize) as _) }
        }
        #[inline(always)]
        pub const fn port26(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x02c0usize) as _) }
        }
        #[doc = "The GPIO Input Registers."]
        #[inline(always)]
        pub const fn parin(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize + n * 4usize) as _) }
        }
        #[doc = "The GPIO Output Registers."]
        #[inline(always)]
        pub const fn parout(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0380usize + n * 4usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port {
        ptr: *mut u8,
    }
    unsafe impl Send for Port {}
    unsafe impl Sync for Port {}
    impl Port {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "GPIO Pin Control Register"]
        #[inline(always)]
        pub const fn ctrl1(self, n: usize) -> crate::common::Reg<regs::Ctrl1, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "The GPIO PIN_CTRL2 Registers"]
        #[inline(always)]
        pub const fn ctrl2(self, n: usize) -> crate::common::Reg<regs::Ctrl2, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "GPIO Pin Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl1(pub u32);
        impl Ctrl1 {
            #[doc = "These bits are used to enable an internal pull-up or pull-down resistor."]
            #[inline(always)]
            pub const fn pu_pd(&self) -> super::super::Pull {
                let val = (self.0 >> 0usize) & 0x03;
                super::super::Pull::from_bits(val as u8)
            }
            #[doc = "These bits are used to enable an internal pull-up or pull-down resistor."]
            #[inline(always)]
            pub fn set_pu_pd(&mut self, val: super::super::Pull) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "The GPIO pin will be tristated when the selected power well is off."]
            #[inline(always)]
            pub const fn pwr_gating(&self) -> super::super::Pgs {
                let val = (self.0 >> 2usize) & 0x03;
                super::super::Pgs::from_bits(val as u8)
            }
            #[doc = "The GPIO pin will be tristated when the selected power well is off."]
            #[inline(always)]
            pub fn set_pwr_gating(&mut self, val: super::super::Pgs) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Determines the interrupt capability of the GPIO input."]
            #[inline(always)]
            pub const fn intr_det(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "Determines the interrupt capability of the GPIO input."]
            #[inline(always)]
            pub fn set_intr_det(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
            }
            #[doc = "Determines the interrupt capability of the GPIO input."]
            #[inline(always)]
            pub const fn edge_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Determines the interrupt capability of the GPIO input."]
            #[inline(always)]
            pub fn set_edge_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "0 = Push-Pull, 1 = Open Drain"]
            #[inline(always)]
            pub const fn out_buff_type(&self) -> super::super::BufferType {
                let val = (self.0 >> 8usize) & 0x01;
                super::super::BufferType::from_bits(val as u8)
            }
            #[doc = "0 = Push-Pull, 1 = Open Drain"]
            #[inline(always)]
            pub fn set_out_buff_type(&mut self, val: super::super::BufferType) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"]
            #[inline(always)]
            pub const fn dir(&self) -> super::super::Dir {
                let val = (self.0 >> 9usize) & 0x01;
                super::super::Dir::from_bits(val as u8)
            }
            #[doc = "Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::super::Dir) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."]
            #[inline(always)]
            pub const fn out_sel(&self) -> super::super::Sel {
                let val = (self.0 >> 10usize) & 0x01;
                super::super::Sel::from_bits(val as u8)
            }
            #[doc = "GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."]
            #[inline(always)]
            pub fn set_out_sel(&mut self, val: super::super::Sel) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "1=Inverted; 0=Non-inverted"]
            #[inline(always)]
            pub const fn pol(&self) -> super::super::Pol {
                let val = (self.0 >> 11usize) & 0x01;
                super::super::Pol::from_bits(val as u8)
            }
            #[doc = "1=Inverted; 0=Non-inverted"]
            #[inline(always)]
            pub fn set_pol(&mut self, val: super::super::Pol) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3."]
            #[inline(always)]
            pub const fn mux_ctrl(&self) -> super::super::Function {
                let val = (self.0 >> 12usize) & 0x07;
                super::super::Function::from_bits(val as u8)
            }
            #[doc = "00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3."]
            #[inline(always)]
            pub fn set_mux_ctrl(&mut self, val: super::super::Function) {
                self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
            }
            #[doc = "GPIO input disable"]
            #[inline(always)]
            pub const fn inp_dis(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO input disable"]
            #[inline(always)]
            pub fn set_inp_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "GPIO Alternate Data Register."]
            #[inline(always)]
            pub const fn alt_data(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO Alternate Data Register."]
            #[inline(always)]
            pub fn set_alt_data(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPIO input from pin, independent of the Mux selection for the pin or the Direction."]
            #[inline(always)]
            pub const fn inp(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO input from pin, independent of the Mux selection for the pin or the Direction."]
            #[inline(always)]
            pub fn set_inp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Ctrl1 {
            #[inline(always)]
            fn default() -> Ctrl1 {
                Ctrl1(0)
            }
        }
        impl core::fmt::Debug for Ctrl1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl1")
                    .field("pu_pd", &self.pu_pd())
                    .field("pwr_gating", &self.pwr_gating())
                    .field("intr_det", &self.intr_det())
                    .field("edge_en", &self.edge_en())
                    .field("out_buff_type", &self.out_buff_type())
                    .field("dir", &self.dir())
                    .field("out_sel", &self.out_sel())
                    .field("pol", &self.pol())
                    .field("mux_ctrl", &self.mux_ctrl())
                    .field("inp_dis", &self.inp_dis())
                    .field("alt_data", &self.alt_data())
                    .field("inp", &self.inp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl1 {{ pu_pd: {:?}, pwr_gating: {:?}, intr_det: {=u8:?}, edge_en: {=bool:?}, out_buff_type: {:?}, dir: {:?}, out_sel: {:?}, pol: {:?}, mux_ctrl: {:?}, inp_dis: {=bool:?}, alt_data: {=bool:?}, inp: {=bool:?} }}" , self . pu_pd () , self . pwr_gating () , self . intr_det () , self . edge_en () , self . out_buff_type () , self . dir () , self . out_sel () , self . pol () , self . mux_ctrl () , self . inp_dis () , self . alt_data () , self . inp ())
            }
        }
        #[doc = "The GPIO PIN_CTRL2 Registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl2(pub u32);
        impl Ctrl2 {
            #[doc = "Selects slew rate on the pin. 1=fast 0=slow"]
            #[inline(always)]
            pub const fn slew_ctrl(&self) -> super::super::SlewCtrl {
                let val = (self.0 >> 0usize) & 0x01;
                super::super::SlewCtrl::from_bits(val as u8)
            }
            #[doc = "Selects slew rate on the pin. 1=fast 0=slow"]
            #[inline(always)]
            pub fn set_slew_ctrl(&mut self, val: super::super::SlewCtrl) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA"]
            #[inline(always)]
            pub const fn driv_stren(&self) -> super::super::Strength {
                let val = (self.0 >> 4usize) & 0x03;
                super::super::Strength::from_bits(val as u8)
            }
            #[doc = "Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA"]
            #[inline(always)]
            pub fn set_driv_stren(&mut self, val: super::super::Strength) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
        }
        impl Default for Ctrl2 {
            #[inline(always)]
            fn default() -> Ctrl2 {
                Ctrl2(0)
            }
        }
        impl core::fmt::Debug for Ctrl2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl2")
                    .field("slew_ctrl", &self.slew_ctrl())
                    .field("driv_stren", &self.driv_stren())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl2 {{ slew_ctrl: {:?}, driv_stren: {:?} }}",
                    self.slew_ctrl(),
                    self.driv_stren()
                )
            }
        }
    }
}
pub mod htm0 {
    #[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Htm0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Htm0 {}
    unsafe impl Sync for Htm0 {}
    impl Htm0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "15:0\\] This register is used to set the Hibernation Timer Preload value."]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "HTimer Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The current state of the Hibernation Timer."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "HTimer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u16);
        impl Ctrl {
            #[doc = "1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours. 0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds."]
            #[inline(always)]
            pub const fn ctrl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours. 0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds."]
            #[inline(always)]
            pub fn set_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl").field("ctrl", &self.ctrl()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctrl {{ ctrl: {=bool:?} }}", self.ctrl())
            }
        }
    }
}
pub mod imspi {
    #[doc = "Internal Master SPI."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Imspi {
        ptr: *mut u8,
    }
    unsafe impl Send for Imspi {}
    unsafe impl Sync for Imspi {}
    impl Imspi {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "IMSPI Mode Register"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "IMSPI Status Register"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "IMSPI Interrupt Enable Register"]
        #[inline(always)]
        pub const fn int_enable(self) -> crate::common::Reg<regs::IntEnable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "IMSPI Timeout Control Register"]
        #[inline(always)]
        pub const fn timeout_control(self) -> crate::common::Reg<regs::TimeoutControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "IMSPI Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntEnable(pub u32);
        impl IntEnable {
            #[doc = "Assert an IMSPI interrupt when the TIMEOUT status is asserted. 1=Enable Interrupt; 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn timeout_le(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Assert an IMSPI interrupt when the TIMEOUT status is asserted. 1=Enable Interrupt; 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_timeout_le(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Assert an EEPROM interrupt when the INVALID_RESPONSE status is asserted. 1=Enable Interrupt; 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn invalid_response_le(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Assert an EEPROM interrupt when the INVALID_RESPONSE status is asserted. 1=Enable Interrupt; 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_invalid_response_le(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for IntEnable {
            #[inline(always)]
            fn default() -> IntEnable {
                IntEnable(0)
            }
        }
        impl core::fmt::Debug for IntEnable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntEnable")
                    .field("timeout_le", &self.timeout_le())
                    .field("invalid_response_le", &self.invalid_response_le())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntEnable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "IntEnable {{ timeout_le: {=bool:?}, invalid_response_le: {=bool:?} }}",
                    self.timeout_le(),
                    self.invalid_response_le()
                )
            }
        }
        #[doc = "IMSPI Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "This bit enables the controller. 1=The controller is enabled; 0=The controller is disabled and placed in its lowest power state."]
            #[inline(always)]
            pub const fn activate(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the controller. 1=The controller is enabled; 0=The controller is disabled and placed in its lowest power state."]
            #[inline(always)]
            pub fn set_activate(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "A write of '1b' to this bit resets the controller. This bit is self-clearing."]
            #[inline(always)]
            pub const fn soft_reset(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "A write of '1b' to this bit resets the controller. This bit is self-clearing."]
            #[inline(always)]
            pub fn set_soft_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is routed to the DLY2_SUSB# pin function."]
            #[inline(always)]
            pub const fn dly2_susb(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is routed to the DLY2_SUSB# pin function."]
            #[inline(always)]
            pub fn set_dly2_susb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit corresponds to the Polarity control for the underlying SPI controller. It describes the default state of the SPI Clock signal. 1=The clock starts in a high state; 0=The clock starts in a low state."]
            #[inline(always)]
            pub const fn cpol(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit corresponds to the Polarity control for the underlying SPI controller. It describes the default state of the SPI Clock signal. 1=The clock starts in a high state; 0=The clock starts in a low state."]
            #[inline(always)]
            pub fn set_cpol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This field is the CPHA field of the underlying SPI controller which affects only the MOSI Data. This field changes determines the clock edge on which data are sent, in combination with the CPOL field. 1=If CPOL=0, data sent on Rising Edge; if CPOL=1, data sent on Falling Edge ; 0=If CPOL=0, data sent on Falling Edge; if CPOL=1, data sent on Rising Edge."]
            #[inline(always)]
            pub const fn cpha_mosi(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This field is the CPHA field of the underlying SPI controller which affects only the MOSI Data. This field changes determines the clock edge on which data are sent, in combination with the CPOL field. 1=If CPOL=0, data sent on Rising Edge; if CPOL=1, data sent on Falling Edge ; 0=If CPOL=0, data sent on Falling Edge; if CPOL=1, data sent on Rising Edge."]
            #[inline(always)]
            pub fn set_cpha_mosi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This field is the CPHA field of the underlying SPI controller which affects only the MISO Data. This field changes determines the clock edge on which data are captured, in combination with the CPOL field. For standard SPI Modes, this must be programmed with the same value as CPHA_MOSI. 1=If CPOL=0, data captured on Falling Edge; if CPOL=1, data captured on Rising Edge 0=If CPOL=0, data captured on Rising Edge; if CPOL=1, data captured on Falling Edge."]
            #[inline(always)]
            pub const fn cpha_miso(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This field is the CPHA field of the underlying SPI controller which affects only the MISO Data. This field changes determines the clock edge on which data are captured, in combination with the CPOL field. For standard SPI Modes, this must be programmed with the same value as CPHA_MOSI. 1=If CPOL=0, data captured on Falling Edge; if CPOL=1, data captured on Rising Edge 0=If CPOL=0, data captured on Rising Edge; if CPOL=1, data captured on Falling Edge."]
            #[inline(always)]
            pub fn set_cpha_miso(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This SPI clock divide in terms of the number of system clocks. 255:1=The SPI clock period is equal to this number of system clocks. 0=The SPI clock period is equal to 256 system clocks."]
            #[inline(always)]
            pub const fn clock_divide(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This SPI clock divide in terms of the number of system clocks. 255:1=The SPI clock period is equal to this number of system clocks. 0=The SPI clock period is equal to 256 system clocks."]
            #[inline(always)]
            pub fn set_clock_divide(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field sets the interface mode for the SPI controller. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single Mode."]
            #[inline(always)]
            pub const fn if_mode(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x03;
                val as u8
            }
            #[doc = "This field sets the interface mode for the SPI controller. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single Mode."]
            #[inline(always)]
            pub fn set_if_mode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("activate", &self.activate())
                    .field("soft_reset", &self.soft_reset())
                    .field("dly2_susb", &self.dly2_susb())
                    .field("cpol", &self.cpol())
                    .field("cpha_mosi", &self.cpha_mosi())
                    .field("cpha_miso", &self.cpha_miso())
                    .field("clock_divide", &self.clock_divide())
                    .field("if_mode", &self.if_mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mode {{ activate: {=bool:?}, soft_reset: {=bool:?}, dly2_susb: {=bool:?}, cpol: {=bool:?}, cpha_mosi: {=bool:?}, cpha_miso: {=bool:?}, clock_divide: {=u8:?}, if_mode: {=u8:?} }}" , self . activate () , self . soft_reset () , self . dly2_susb () , self . cpol () , self . cpha_mosi () , self . cpha_miso () , self . clock_divide () , self . if_mode ())
            }
        }
        #[doc = "IMSPI Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "This flags when a transfer has terminated due to timeout on the response phase. 1=A transfer error occurred due to an invalid response; 0=No error occurred. (R/WC)"]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This flags when a transfer has terminated due to timeout on the response phase. 1=A transfer error occurred due to an invalid response; 0=No error occurred. (R/WC)"]
            #[inline(always)]
            pub fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The IMSPI has detected an invalid response field and therefore is aborting the transfer in failure. 1=A transfer error occurred due to an invalid response; 0=No error occurred. (R/WC)"]
            #[inline(always)]
            pub const fn invalid_response(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The IMSPI has detected an invalid response field and therefore is aborting the transfer in failure. 1=A transfer error occurred due to an invalid response; 0=No error occurred. (R/WC)"]
            #[inline(always)]
            pub fn set_invalid_response(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("timeout", &self.timeout())
                    .field("invalid_response", &self.invalid_response())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Status {{ timeout: {=bool:?}, invalid_response: {=bool:?} }}",
                    self.timeout(),
                    self.invalid_response()
                )
            }
        }
        #[doc = "IMSPI Timeout Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TimeoutControl(pub u32);
        impl TimeoutControl {
            #[doc = "This field is the maximum number of response cycles the IMSPI will wait until flagging a timeout. A setting of 0 will disable the timeout feature."]
            #[inline(always)]
            pub const fn response_timeout(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "This field is the maximum number of response cycles the IMSPI will wait until flagging a timeout. A setting of 0 will disable the timeout feature."]
            #[inline(always)]
            pub fn set_response_timeout(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for TimeoutControl {
            #[inline(always)]
            fn default() -> TimeoutControl {
                TimeoutControl(0)
            }
        }
        impl core::fmt::Debug for TimeoutControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TimeoutControl")
                    .field("response_timeout", &self.response_timeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TimeoutControl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TimeoutControl {{ response_timeout: {=u8:?} }}",
                    self.response_timeout()
                )
            }
        }
    }
}
pub mod kbc {
    #[doc = "The Keyboard Controller is a Host/EC Message Interface with hardware assists to emulate 8042 behavior."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Kbc {
        ptr: *mut u8,
    }
    unsafe impl Send for Kbc {}
    unsafe impl Sync for Kbc {}
    impl Kbc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "READ_DATA. This 8-bit register is read-only. When read by the Host, the PCOBF and/or AUXOBF interrupts are cleared and the OBF flag in the status register is cleared."]
        #[inline(always)]
        pub const fn host_data(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "WRITE_DATA. This 8-bit register is write-only. When written, the C/D bit in the Keyboard Status Read Register is cleared to '0', signifying data, and the IBF in the same register is set to '1'. When the Runtime Register at offset 0h is read by the Host, it functions as the EC_HOST Data / AUX Data Register."]
        #[inline(always)]
        pub const fn host_ec_data(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Keyboard Status Read Register. This register is a read-only alias of the EC Keyboard Status Register."]
        #[inline(always)]
        pub const fn host_rs(self) -> crate::common::Reg<regs::HostRs, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "WRITE_CMD. This 8-bit register is write-only and is an alias of the register at offset 0h. When written, the C/D bit in the Keyboard Status Read Register is set to '1', signifying a command, and the IBF in the same register is set to '1'. When the Runtime Register at offset 4h is read by the Host, it functions as the Keyboard Status Read Register."]
        #[inline(always)]
        pub const fn host_wc(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "EC_Host Data Register"]
        #[inline(always)]
        pub const fn ec_data(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Host_EC Data/Cmd Register This register is an alias of the HOST_EC Data / CMD Register. When read at the EC-Only offset of 0h, it returns the data written by the Host to either Runtime Register offset 0h or Runtime Register offset 04h."]
        #[inline(always)]
        pub const fn h2ec_data(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Keyboard Status Register"]
        #[inline(always)]
        pub const fn ec_kbd_sts(self) -> crate::common::Reg<regs::EcKbdSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Keyboard Control Register"]
        #[inline(always)]
        pub const fn kbctrl(self) -> crate::common::Reg<regs::Kbctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "EC_Host Aux Register. This 8-bit register is write-only. When written, the C/D in the Keyboard Status Read Register is cleared to '0', signifying data, and the IBF in the same register is set to '1'. When the Runtime Register at offset 0h is read by the Host, it functions as the EC_HOST Data / AUX Data Register."]
        #[inline(always)]
        pub const fn ec_aux_data(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "8042 Emulated Keyboard Controller PCOBF Register"]
        #[inline(always)]
        pub const fn pcobf(self) -> crate::common::Reg<regs::Pcobf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Activate Register"]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<regs::Activate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Activate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate(pub u8);
        impl Activate {
            #[doc = "1=The 8042 Interface is powered and functional. 0=The 8042 Interface is powered down and inactive."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=The 8042 Interface is powered and functional. 0=The 8042 Interface is powered down and inactive."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate {
            #[inline(always)]
            fn default() -> Activate {
                Activate(0)
            }
        }
        impl core::fmt::Debug for Activate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate").field("act", &self.act()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate {{ act: {=bool:?} }}", self.act())
            }
        }
        #[doc = "Keyboard Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcKbdSts(pub u8);
        impl EcKbdSts {
            #[doc = "Output Buffer Full."]
            #[inline(always)]
            pub const fn obf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Output Buffer Full."]
            #[inline(always)]
            pub fn set_obf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Input Buffer Full."]
            #[inline(always)]
            pub const fn ibf(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Input Buffer Full."]
            #[inline(always)]
            pub fn set_ibf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub const fn ud0(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub fn set_ud0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Command Data. This bit specifies whether the input data register contains data or a command ('0' = data, '1' = command)."]
            #[inline(always)]
            pub const fn cmd_dat(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Command Data. This bit specifies whether the input data register contains data or a command ('0' = data, '1' = command)."]
            #[inline(always)]
            pub fn set_cmd_dat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub const fn ud1(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub fn set_ud1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "Auxiliary Output Buffer Full."]
            #[inline(always)]
            pub const fn auxobf(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Auxiliary Output Buffer Full."]
            #[inline(always)]
            pub fn set_auxobf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub const fn ud2(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub fn set_ud2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for EcKbdSts {
            #[inline(always)]
            fn default() -> EcKbdSts {
                EcKbdSts(0)
            }
        }
        impl core::fmt::Debug for EcKbdSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcKbdSts")
                    .field("obf", &self.obf())
                    .field("ibf", &self.ibf())
                    .field("ud0", &self.ud0())
                    .field("cmd_dat", &self.cmd_dat())
                    .field("ud1", &self.ud1())
                    .field("auxobf", &self.auxobf())
                    .field("ud2", &self.ud2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcKbdSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcKbdSts {{ obf: {=bool:?}, ibf: {=bool:?}, ud0: {=bool:?}, cmd_dat: {=bool:?}, ud1: {=bool:?}, auxobf: {=bool:?}, ud2: {=u8:?} }}" , self . obf () , self . ibf () , self . ud0 () , self . cmd_dat () , self . ud1 () , self . auxobf () , self . ud2 ())
            }
        }
        #[doc = "Keyboard Status Read Register. This register is a read-only alias of the EC Keyboard Status Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostRs(pub u8);
        impl HostRs {
            #[doc = "Output Buffer Full."]
            #[inline(always)]
            pub const fn obf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Output Buffer Full."]
            #[inline(always)]
            pub fn set_obf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Input Buffer Full."]
            #[inline(always)]
            pub const fn ibf(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Input Buffer Full."]
            #[inline(always)]
            pub fn set_ibf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub const fn ud0(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub fn set_ud0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Command Data. This bit specifies whether the input data register contains data or a command ('0' = data, '1' = command)."]
            #[inline(always)]
            pub const fn cmd_dat(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Command Data. This bit specifies whether the input data register contains data or a command ('0' = data, '1' = command)."]
            #[inline(always)]
            pub fn set_cmd_dat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub const fn ud1(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub fn set_ud1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "Auxiliary Output Buffer Full."]
            #[inline(always)]
            pub const fn auxobf(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Auxiliary Output Buffer Full."]
            #[inline(always)]
            pub fn set_auxobf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub const fn ud2(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub fn set_ud2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for HostRs {
            #[inline(always)]
            fn default() -> HostRs {
                HostRs(0)
            }
        }
        impl core::fmt::Debug for HostRs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostRs")
                    .field("obf", &self.obf())
                    .field("ibf", &self.ibf())
                    .field("ud0", &self.ud0())
                    .field("cmd_dat", &self.cmd_dat())
                    .field("ud1", &self.ud1())
                    .field("auxobf", &self.auxobf())
                    .field("ud2", &self.ud2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostRs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "HostRs {{ obf: {=bool:?}, ibf: {=bool:?}, ud0: {=bool:?}, cmd_dat: {=bool:?}, ud1: {=bool:?}, auxobf: {=bool:?}, ud2: {=u8:?} }}" , self . obf () , self . ibf () , self . ud0 () , self . cmd_dat () , self . ud1 () , self . auxobf () , self . ud2 ())
            }
        }
        #[doc = "Keyboard Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Kbctrl(pub u8);
        impl Kbctrl {
            #[doc = "User-defined data."]
            #[inline(always)]
            pub const fn ud3(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub fn set_ud3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Software-assist enable. 1=This bit allows control of the GATEA20 signal via firmware 0=GATEA20 corresponds to either the last Host-initiated control of GATEA20 or the firmware write to the Keyboard Control Register or the EC AUX Data Register."]
            #[inline(always)]
            pub const fn saen(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Software-assist enable. 1=This bit allows control of the GATEA20 signal via firmware 0=GATEA20 corresponds to either the last Host-initiated control of GATEA20 or the firmware write to the Keyboard Control Register or the EC AUX Data Register."]
            #[inline(always)]
            pub fn set_saen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "1= reflects the value written to the PCOBF Register, 0=PCOBF reflects the status of writes to the EC Data Register"]
            #[inline(always)]
            pub const fn pcobfen(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1= reflects the value written to the PCOBF Register, 0=PCOBF reflects the status of writes to the EC Data Register"]
            #[inline(always)]
            pub fn set_pcobfen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub const fn ud4(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x03;
                val as u8
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub fn set_ud4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val as u8) & 0x03) << 3usize);
            }
            #[doc = "When this bit is '1', the system interrupt signal KIRQ is driven by the bit PCOBF and MIRQ is driven by AUXOBF. When this bit is '0', KIRQ and MIRQ are driven low. This bit must not be changed when OBF of the status register is equal to '1'."]
            #[inline(always)]
            pub const fn obfen(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1', the system interrupt signal KIRQ is driven by the bit PCOBF and MIRQ is driven by AUXOBF. When this bit is '0', KIRQ and MIRQ are driven low. This bit must not be changed when OBF of the status register is equal to '1'."]
            #[inline(always)]
            pub fn set_obfen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub const fn ud5(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "User-defined data."]
            #[inline(always)]
            pub fn set_ud5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "AUX in Hardware. 1=AUXOBF of the Keyboard Status Read Register is set in hardware by a write to the EC AUX Data Register 0=AUXOBF is not modified in hardware, but can be read and written by the EC using the EC-Only alias of the EC Keyboard Status Register"]
            #[inline(always)]
            pub const fn auxh(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "AUX in Hardware. 1=AUXOBF of the Keyboard Status Read Register is set in hardware by a write to the EC AUX Data Register 0=AUXOBF is not modified in hardware, but can be read and written by the EC using the EC-Only alias of the EC Keyboard Status Register"]
            #[inline(always)]
            pub fn set_auxh(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Kbctrl {
            #[inline(always)]
            fn default() -> Kbctrl {
                Kbctrl(0)
            }
        }
        impl core::fmt::Debug for Kbctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Kbctrl")
                    .field("ud3", &self.ud3())
                    .field("saen", &self.saen())
                    .field("pcobfen", &self.pcobfen())
                    .field("ud4", &self.ud4())
                    .field("obfen", &self.obfen())
                    .field("ud5", &self.ud5())
                    .field("auxh", &self.auxh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Kbctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Kbctrl {{ ud3: {=bool:?}, saen: {=bool:?}, pcobfen: {=bool:?}, ud4: {=u8:?}, obfen: {=bool:?}, ud5: {=bool:?}, auxh: {=bool:?} }}" , self . ud3 () , self . saen () , self . pcobfen () , self . ud4 () , self . obfen () , self . ud5 () , self . auxh ())
            }
        }
        #[doc = "8042 Emulated Keyboard Controller PCOBF Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcobf(pub u8);
        impl Pcobf {
            #[doc = "PCOBF Register: If enabled by the bit OBFEN, the bit PCOBF is gated onto KIRQ. The KIRQ signal is a system interrupt which signifies that the EC has written to the HOST2EC Data Register (EC-Only offset 0h)."]
            #[inline(always)]
            pub const fn pcobf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PCOBF Register: If enabled by the bit OBFEN, the bit PCOBF is gated onto KIRQ. The KIRQ signal is a system interrupt which signifies that the EC has written to the HOST2EC Data Register (EC-Only offset 0h)."]
            #[inline(always)]
            pub fn set_pcobf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Pcobf {
            #[inline(always)]
            fn default() -> Pcobf {
                Pcobf(0)
            }
        }
        impl core::fmt::Debug for Pcobf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcobf").field("pcobf", &self.pcobf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcobf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pcobf {{ pcobf: {=bool:?} }}", self.pcobf())
            }
        }
    }
}
pub mod kms {
    #[doc = "The Keyboard Scan Interface block provides a register interface to directly scan an external keyboard matrix of size up to 18x8."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Kms {
        ptr: *mut u8,
    }
    unsafe impl Send for Kms {}
    unsafe impl Sync for Kms {}
    impl Kms {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "KSO Select and control"]
        #[inline(always)]
        pub const fn kso_sel(self) -> crate::common::Reg<regs::KsoSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "7:0\\] This field returns the current state of the KSI pins."]
        #[inline(always)]
        pub const fn ksi(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "7:0\\] Each bit in this field is set on the falling edge of the corresponding KSI input pin. A KSI interrupt is generated when its corresponding status bit and interrupt enable bit are both set. KSI interrupts are logically ORed together to produce KSC_INT and KSC_INT_WAKE. Writing a '1' to a bit will clear it. Writing a '0' to a bit has no effect."]
        #[inline(always)]
        pub const fn ksi_sts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "7:0\\] Each bit in KSI_INT_EN enables interrupt generation due to highto-low transition on a KSI input. An interrupt is generated when the corresponding bits in KSI_STATUS and KSI_INT_EN are both set."]
        #[inline(always)]
        pub const fn ksi_ien(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "0:0\\] PREDRIVE_ENABLE enables the PREDRIVE mode to actively drive the KSO pins high for approximately 100ns before switching to open-drain operation. 0=Disable predrive on KSO pins 1=Enable predrive on KSO pins."]
        #[inline(always)]
        pub const fn ext_ctrl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "KSO Select and control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct KsoSel(pub u32);
        impl KsoSel {
            #[doc = "This field selects a KSO line (00000b = KSO\\[0\\] etc.) for output according to the value off KSO_INVERT in this register."]
            #[inline(always)]
            pub const fn sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "This field selects a KSO line (00000b = KSO\\[0\\] etc.) for output according to the value off KSO_INVERT in this register."]
            #[inline(always)]
            pub fn set_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "0=When key scan is enabled, KSO output controlled by the KSO_SELECT field. 1=KSO\\[x\\] driven high when selected."]
            #[inline(always)]
            pub const fn all(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "0=When key scan is enabled, KSO output controlled by the KSO_SELECT field. 1=KSO\\[x\\] driven high when selected."]
            #[inline(always)]
            pub fn set_all(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "0= Keyboard scan enabled, 1= Keyboard scan disabled. All KSO output buffers disabled."]
            #[inline(always)]
            pub const fn ksen(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "0= Keyboard scan enabled, 1= Keyboard scan disabled. All KSO output buffers disabled."]
            #[inline(always)]
            pub fn set_ksen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "0= KSO\\[x\\] driven low when selected, 1= KSO\\[x\\] driven high when selected."]
            #[inline(always)]
            pub const fn inv(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "0= KSO\\[x\\] driven low when selected, 1= KSO\\[x\\] driven high when selected."]
            #[inline(always)]
            pub fn set_inv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for KsoSel {
            #[inline(always)]
            fn default() -> KsoSel {
                KsoSel(0)
            }
        }
        impl core::fmt::Debug for KsoSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("KsoSel")
                    .field("sel", &self.sel())
                    .field("all", &self.all())
                    .field("ksen", &self.ksen())
                    .field("inv", &self.inv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for KsoSel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "KsoSel {{ sel: {=u8:?}, all: {=bool:?}, ksen: {=bool:?}, inv: {=bool:?} }}",
                    self.sel(),
                    self.all(),
                    self.ksen(),
                    self.inv()
                )
            }
        }
    }
}
pub mod led0 {
    #[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Led0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Led0 {}
    unsafe impl Sync for Led0 {}
    impl Led0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "LED Configuration"]
        #[inline(always)]
        pub const fn cfg(self) -> crate::common::Reg<regs::Cfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "LED Limits This register may be written at any time. Values written into the register are held in an holding register, which is transferred into the actual register at the end of a PWM period. The two byte fields may be written independently. Reads of this register return the current contents and not the value of the holding register."]
        #[inline(always)]
        pub const fn limit(self) -> crate::common::Reg<regs::Limit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "LED Delay"]
        #[inline(always)]
        pub const fn dly(self) -> crate::common::Reg<regs::Dly, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This register has eight segment fields which provide the amount the current duty cycle is adjusted at the end of every PWM period. Segment field selection is decoded based on the segment index. The segment index equation utilized depends on the SYMMETRY bit in the LED Configuration Register Register) . In Symmetric Mode the Segment_Index\\[2:0\\] = Duty Cycle Bits\\[7:5\\] . In Asymmetric Mode the Segment_Index\\[2:0\\] is the bit concatenation of following: Segment_Index\\[2\\] = (FALLING RAMP TIME in Figure 30-3, Clipping Example) and Segment_Index\\[1:0\\] = Duty Cycle Bits\\[7:6\\]."]
        #[inline(always)]
        pub const fn step(self) -> crate::common::Reg<regs::Step, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "LED Update Interval"]
        #[inline(always)]
        pub const fn intrvl(self) -> crate::common::Reg<regs::Intrvl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "LED Output Delay"]
        #[inline(always)]
        pub const fn outdly(self) -> crate::common::Reg<regs::Outdly, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "LED Configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfg(pub u32);
        impl Cfg {
            #[doc = "CONTROL 3=PWM is always on 2=LED blinking (standard PWM) 1=LED breathing configuration 0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated"]
            #[inline(always)]
            pub const fn ctrl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "CONTROL 3=PWM is always on 2=LED blinking (standard PWM) 1=LED breathing configuration 0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated"]
            #[inline(always)]
            pub fn set_ctrl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock"]
            #[inline(always)]
            pub const fn clk_src(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock"]
            #[inline(always)]
            pub fn set_clk_src(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SYNCHRONIZE When this bit is '1', all counters for all LEDs are reset to their initial values. When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required."]
            #[inline(always)]
            pub const fn synch(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SYNCHRONIZE When this bit is '1', all counters for all LEDs are reset to their initial values. When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required."]
            #[inline(always)]
            pub fn set_synch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "PWM_SIZE This bit controls the behavior of PWM: 3=Reserved 2=PWM is configured as a 6-bit PWM 1=PWM is configured as a 7-bit PWM 0=PWM is configured as an 8-bit PWM"]
            #[inline(always)]
            pub const fn pwm_size(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "PWM_SIZE This bit controls the behavior of PWM: 3=Reserved 2=PWM is configured as a 6-bit PWM 1=PWM is configured as a 7-bit PWM 0=PWM is configured as an 8-bit PWM"]
            #[inline(always)]
            pub fn set_pwm_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "ENABLE_UPDATE This bit is set to 1 when written with a '1'. Writes of '0' have no effect. Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time."]
            #[inline(always)]
            pub const fn en_update(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "ENABLE_UPDATE This bit is set to 1 when written with a '1'. Writes of '0' have no effect. Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time."]
            #[inline(always)]
            pub fn set_en_update(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "RESET Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing. Writes of '0' to this bit have no effect."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "RESET Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing. Writes of '0' to this bit have no effect."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "WDT_RELOAD The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value."]
            #[inline(always)]
            pub const fn wdt_reload(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "WDT_RELOAD The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value."]
            #[inline(always)]
            pub fn set_wdt_reload(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "SYMMETRY 1=The rising and falling ramp times are in Asymmetric mode. 0=The rising and falling ramp times are in Symmetric mode."]
            #[inline(always)]
            pub const fn symmetry(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "SYMMETRY 1=The rising and falling ramp times are in Asymmetric mode. 0=The rising and falling ramp times are in Symmetric mode."]
            #[inline(always)]
            pub fn set_symmetry(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Cfg {
            #[inline(always)]
            fn default() -> Cfg {
                Cfg(0)
            }
        }
        impl core::fmt::Debug for Cfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfg")
                    .field("ctrl", &self.ctrl())
                    .field("clk_src", &self.clk_src())
                    .field("synch", &self.synch())
                    .field("pwm_size", &self.pwm_size())
                    .field("en_update", &self.en_update())
                    .field("rst", &self.rst())
                    .field("wdt_reload", &self.wdt_reload())
                    .field("symmetry", &self.symmetry())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cfg {{ ctrl: {=u8:?}, clk_src: {=bool:?}, synch: {=bool:?}, pwm_size: {=u8:?}, en_update: {=bool:?}, rst: {=bool:?}, wdt_reload: {=u8:?}, symmetry: {=bool:?} }}" , self . ctrl () , self . clk_src () , self . synch () , self . pwm_size () , self . en_update () , self . rst () , self . wdt_reload () , self . symmetry ())
            }
        }
        #[doc = "LED Delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dly(pub u32);
        impl Dly {
            #[doc = "The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MIN in register LED_LIMIT."]
            #[inline(always)]
            pub const fn low_pulse(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MIN in register LED_LIMIT."]
            #[inline(always)]
            pub fn set_low_pulse(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MAX in register LED_LIMIT."]
            #[inline(always)]
            pub const fn high_pulse(&self) -> u16 {
                let val = (self.0 >> 12usize) & 0x0fff;
                val as u16
            }
            #[doc = "In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MAX in register LED_LIMIT."]
            #[inline(always)]
            pub fn set_high_pulse(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 12usize)) | (((val as u32) & 0x0fff) << 12usize);
            }
        }
        impl Default for Dly {
            #[inline(always)]
            fn default() -> Dly {
                Dly(0)
            }
        }
        impl core::fmt::Debug for Dly {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dly")
                    .field("low_pulse", &self.low_pulse())
                    .field("high_pulse", &self.high_pulse())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dly {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dly {{ low_pulse: {=u16:?}, high_pulse: {=u16:?} }}",
                    self.low_pulse(),
                    self.high_pulse()
                )
            }
        }
        #[doc = "LED Update Interval"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Intrvl(pub u32);
        impl Intrvl {
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b."]
            #[inline(always)]
            pub const fn i0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b."]
            #[inline(always)]
            pub fn set_i0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b."]
            #[inline(always)]
            pub const fn i1(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b."]
            #[inline(always)]
            pub fn set_i1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b."]
            #[inline(always)]
            pub const fn i2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b."]
            #[inline(always)]
            pub fn set_i2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b."]
            #[inline(always)]
            pub const fn i3(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b."]
            #[inline(always)]
            pub fn set_i3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b."]
            #[inline(always)]
            pub const fn i4(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b."]
            #[inline(always)]
            pub fn set_i4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b."]
            #[inline(always)]
            pub const fn i5(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b."]
            #[inline(always)]
            pub fn set_i5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b."]
            #[inline(always)]
            pub const fn i6(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b."]
            #[inline(always)]
            pub fn set_i6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b."]
            #[inline(always)]
            pub const fn i7(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b."]
            #[inline(always)]
            pub fn set_i7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Intrvl {
            #[inline(always)]
            fn default() -> Intrvl {
                Intrvl(0)
            }
        }
        impl core::fmt::Debug for Intrvl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Intrvl")
                    .field("i0", &self.i0())
                    .field("i1", &self.i1())
                    .field("i2", &self.i2())
                    .field("i3", &self.i3())
                    .field("i4", &self.i4())
                    .field("i5", &self.i5())
                    .field("i6", &self.i6())
                    .field("i7", &self.i7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Intrvl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Intrvl {{ i0: {=u8:?}, i1: {=u8:?}, i2: {=u8:?}, i3: {=u8:?}, i4: {=u8:?}, i5: {=u8:?}, i6: {=u8:?}, i7: {=u8:?} }}" , self . i0 () , self . i1 () , self . i2 () , self . i3 () , self . i4 () , self . i5 () , self . i6 () , self . i7 ())
            }
        }
        #[doc = "LED Limits This register may be written at any time. Values written into the register are held in an holding register, which is transferred into the actual register at the end of a PWM period. The two byte fields may be written independently. Reads of this register return the current contents and not the value of the holding register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Limit(pub u32);
        impl Limit {
            #[doc = "In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode, this field defines the duty cycle of the blink function."]
            #[inline(always)]
            pub const fn min(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode, this field defines the duty cycle of the blink function."]
            #[inline(always)]
            pub fn set_min(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle"]
            #[inline(always)]
            pub const fn max(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle"]
            #[inline(always)]
            pub fn set_max(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Limit {
            #[inline(always)]
            fn default() -> Limit {
                Limit(0)
            }
        }
        impl core::fmt::Debug for Limit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Limit")
                    .field("min", &self.min())
                    .field("max", &self.max())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Limit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Limit {{ min: {=u8:?}, max: {=u8:?} }}", self.min(), self.max())
            }
        }
        #[doc = "LED Output Delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outdly(pub u32);
        impl Outdly {
            #[doc = "The delay, in counts of the clock defined in Clock Source (CLKSRC), in which output transitions are delayed. When this field is 0, there is no added transition delay. When the LED is programmed to be Always On or Always Off, the Output Delay field has no effect."]
            #[inline(always)]
            pub const fn delay(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The delay, in counts of the clock defined in Clock Source (CLKSRC), in which output transitions are delayed. When this field is 0, there is no added transition delay. When the LED is programmed to be Always On or Always Off, the Output Delay field has no effect."]
            #[inline(always)]
            pub fn set_delay(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Outdly {
            #[inline(always)]
            fn default() -> Outdly {
                Outdly(0)
            }
        }
        impl core::fmt::Debug for Outdly {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outdly").field("delay", &self.delay()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outdly {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Outdly {{ delay: {=u8:?} }}", self.delay())
            }
        }
        #[doc = "This register has eight segment fields which provide the amount the current duty cycle is adjusted at the end of every PWM period. Segment field selection is decoded based on the segment index. The segment index equation utilized depends on the SYMMETRY bit in the LED Configuration Register Register) . In Symmetric Mode the Segment_Index\\[2:0\\] = Duty Cycle Bits\\[7:5\\] . In Asymmetric Mode the Segment_Index\\[2:0\\] is the bit concatenation of following: Segment_Index\\[2\\] = (FALLING RAMP TIME in Figure 30-3, Clipping Example) and Segment_Index\\[1:0\\] = Duty Cycle Bits\\[7:6\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Step(pub u32);
        impl Step {
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000."]
            #[inline(always)]
            pub const fn s0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000."]
            #[inline(always)]
            pub fn set_s0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001."]
            #[inline(always)]
            pub const fn s1(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001."]
            #[inline(always)]
            pub fn set_s1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010."]
            #[inline(always)]
            pub const fn s2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010."]
            #[inline(always)]
            pub fn set_s2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011."]
            #[inline(always)]
            pub const fn s3(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011."]
            #[inline(always)]
            pub fn set_s3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100."]
            #[inline(always)]
            pub const fn s4(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100."]
            #[inline(always)]
            pub fn set_s4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101"]
            #[inline(always)]
            pub const fn s5(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101"]
            #[inline(always)]
            pub fn set_s5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110."]
            #[inline(always)]
            pub const fn s6(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110."]
            #[inline(always)]
            pub fn set_s6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111."]
            #[inline(always)]
            pub const fn s7(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111."]
            #[inline(always)]
            pub fn set_s7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Step {
            #[inline(always)]
            fn default() -> Step {
                Step(0)
            }
        }
        impl core::fmt::Debug for Step {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Step")
                    .field("s0", &self.s0())
                    .field("s1", &self.s1())
                    .field("s2", &self.s2())
                    .field("s3", &self.s3())
                    .field("s4", &self.s4())
                    .field("s5", &self.s5())
                    .field("s6", &self.s6())
                    .field("s7", &self.s7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Step {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Step {{ s0: {=u8:?}, s1: {=u8:?}, s2: {=u8:?}, s3: {=u8:?}, s4: {=u8:?}, s5: {=u8:?}, s6: {=u8:?}, s7: {=u8:?} }}" , self . s0 () , self . s1 () , self . s2 () , self . s3 () , self . s4 () , self . s5 () , self . s6 () , self . s7 ())
            }
        }
    }
}
pub mod mbx {
    #[doc = "The Mailbox provides a standard run-time mechanism for the host to communicate with the Embedded Controller (EC)."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mbx {
        ptr: *mut u8,
    }
    unsafe impl Send for Mbx {}
    unsafe impl Sync for Mbx {}
    impl Mbx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "MBX_Index Register"]
        #[inline(always)]
        pub const fn rt_idx(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "MBX_Data_Register"]
        #[inline(always)]
        pub const fn rt_data(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "If enabled, an interrupt to the EC marked by the MBX_DATA bit in the Interrupt Aggregator will be generated whenever the Host writes this register. This register is cleared when written with FFh."]
        #[inline(always)]
        pub const fn h2ec(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "An EC write to this register will set bit EC_WR in the SMI Interrupt Source Register to '1b'. If enabled, this will generate a Host SMI. This register is cleared when written with FFh."]
        #[inline(always)]
        pub const fn ec2h(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "SMI Interrupt Source Register"]
        #[inline(always)]
        pub const fn smi_src(self) -> crate::common::Reg<regs::SmiSrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "SMI Interrupt Mask Register"]
        #[inline(always)]
        pub const fn smi_mask(self) -> crate::common::Reg<regs::SmiMask, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[inline(always)]
        pub const fn mbx_reg(self, n: usize) -> MbxReg {
            assert!(n < 8usize);
            unsafe { MbxReg::from_ptr(self.ptr.add(0x0110usize + n * 4usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MbxReg {
        ptr: *mut u8,
    }
    unsafe impl Send for MbxReg {}
    unsafe impl Sync for MbxReg {}
    impl MbxReg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RESULT"]
        #[inline(always)]
        pub const fn u08(self, n: usize) -> crate::common::Reg<u8, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 1usize) as _) }
        }
        #[doc = "ENABLE SET"]
        #[inline(always)]
        pub const fn u16(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 2usize) as _) }
        }
        #[doc = "SOURCE"]
        #[inline(always)]
        pub const fn u32(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "SMI Interrupt Mask Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SmiMask(pub u32);
        impl SmiMask {
            #[doc = "EC Mailbox Write.Interrupt Enable. Each bit in this field that is '1b' enables the generation of SIRQ interrupts when the corresponding bit in the EC_SWI field in the SMI Interrupt Source Register is '1b'."]
            #[inline(always)]
            pub const fn ecwr_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "EC Mailbox Write.Interrupt Enable. Each bit in this field that is '1b' enables the generation of SIRQ interrupts when the corresponding bit in the EC_SWI field in the SMI Interrupt Source Register is '1b'."]
            #[inline(always)]
            pub fn set_ecwr_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "EC Software Interrupt Enable. If this bit is '1b', the bit EC_WR in the SMI Interrupt Source Register is enabled for the generation of SIRQ or nSMI events."]
            #[inline(always)]
            pub const fn ecswi_en(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "EC Software Interrupt Enable. If this bit is '1b', the bit EC_WR in the SMI Interrupt Source Register is enabled for the generation of SIRQ or nSMI events."]
            #[inline(always)]
            pub fn set_ecswi_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u32) & 0x7f) << 1usize);
            }
        }
        impl Default for SmiMask {
            #[inline(always)]
            fn default() -> SmiMask {
                SmiMask(0)
            }
        }
        impl core::fmt::Debug for SmiMask {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SmiMask")
                    .field("ecwr_en", &self.ecwr_en())
                    .field("ecswi_en", &self.ecswi_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SmiMask {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SmiMask {{ ecwr_en: {=bool:?}, ecswi_en: {=u8:?} }}",
                    self.ecwr_en(),
                    self.ecswi_en()
                )
            }
        }
        #[doc = "SMI Interrupt Source Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SmiSrc(pub u32);
        impl SmiSrc {
            #[doc = "EC Mailbox Write. This bit is set automatically when the EC-to-Host Mailbox Register has been written. An SMI or SIRQ to the Host is generated when n this bit is '1b' and the corresponding bit in the SMI Interrupt Mask Register register is '1b'. This bit is automatically cleared by a read of the EC-to-Host Mailbox Register through the Host Access Port."]
            #[inline(always)]
            pub const fn ec_wr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "EC Mailbox Write. This bit is set automatically when the EC-to-Host Mailbox Register has been written. An SMI or SIRQ to the Host is generated when n this bit is '1b' and the corresponding bit in the SMI Interrupt Mask Register register is '1b'. This bit is automatically cleared by a read of the EC-to-Host Mailbox Register through the Host Access Port."]
            #[inline(always)]
            pub fn set_ec_wr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "EC Software Interrupt. An SIRQ to the Host is generated when any bit in this register when this bit is set to '1b' and the corresponding bit in the SMI Interrupt Mask Register register is '1b'."]
            #[inline(always)]
            pub const fn ec_swi(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "EC Software Interrupt. An SIRQ to the Host is generated when any bit in this register when this bit is set to '1b' and the corresponding bit in the SMI Interrupt Mask Register register is '1b'."]
            #[inline(always)]
            pub fn set_ec_swi(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u32) & 0x7f) << 1usize);
            }
        }
        impl Default for SmiSrc {
            #[inline(always)]
            fn default() -> SmiSrc {
                SmiSrc(0)
            }
        }
        impl core::fmt::Debug for SmiSrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SmiSrc")
                    .field("ec_wr", &self.ec_wr())
                    .field("ec_swi", &self.ec_swi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SmiSrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SmiSrc {{ ec_wr: {=bool:?}, ec_swi: {=u8:?} }}",
                    self.ec_wr(),
                    self.ec_swi()
                )
            }
        }
    }
}
pub mod otp {
    #[doc = "OTP Programming registers."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Otp {
        ptr: *mut u8,
    }
    unsafe impl Send for Otp {}
    unsafe impl Sync for Otp {}
    impl Otp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This is the Write Lock Register."]
        #[inline(always)]
        pub const fn wr_lock0(self) -> crate::common::Reg<regs::WrLock0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "This is the Write Lock Register."]
        #[inline(always)]
        pub const fn wr_lock1(self) -> crate::common::Reg<regs::WrLock1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x45usize) as _) }
        }
        #[doc = "This is the Write Lock Register."]
        #[inline(always)]
        pub const fn wr_lock2(self) -> crate::common::Reg<regs::WrLock2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x46usize) as _) }
        }
        #[doc = "This is the Write Lock Register."]
        #[inline(always)]
        pub const fn wr_lock3(self) -> crate::common::Reg<regs::WrLock3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x47usize) as _) }
        }
        #[doc = "This is the Read Lock Register."]
        #[inline(always)]
        pub const fn rd_lock0(self) -> crate::common::Reg<regs::RdLock0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "This is the Read Lock Register."]
        #[inline(always)]
        pub const fn rd_lock1(self) -> crate::common::Reg<regs::RdLock1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x49usize) as _) }
        }
        #[doc = "This is the Read Lock Register."]
        #[inline(always)]
        pub const fn rd_lock2(self) -> crate::common::Reg<regs::RdLock2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4ausize) as _) }
        }
        #[doc = "This is the Read Lock Register."]
        #[inline(always)]
        pub const fn rd_lock3(self) -> crate::common::Reg<regs::RdLock3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4busize) as _) }
        }
        #[doc = "This is the Write Fine Lock Register."]
        #[inline(always)]
        pub const fn wr_fine_lck(self) -> crate::common::Reg<regs::WrFineLck, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "This is the Read Fine Lock Register."]
        #[inline(always)]
        pub const fn rd_fine_lck(self) -> crate::common::Reg<regs::RdFineLck, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This is the Read Fine Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RdFineLck(pub u32);
        impl RdFineLck {
            #[doc = "Each bit locks read to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked."]
            #[inline(always)]
            pub const fn rd_fine_lck(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Each bit locks read to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked."]
            #[inline(always)]
            pub fn set_rd_fine_lck(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for RdFineLck {
            #[inline(always)]
            fn default() -> RdFineLck {
                RdFineLck(0)
            }
        }
        impl core::fmt::Debug for RdFineLck {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RdFineLck")
                    .field("rd_fine_lck", &self.rd_fine_lck())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RdFineLck {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RdFineLck {{ rd_fine_lck: {=u32:?} }}", self.rd_fine_lck())
            }
        }
        #[doc = "This is the Read Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RdLock0(pub u8);
        impl RdLock0 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub const fn rl0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub fn set_rl0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for RdLock0 {
            #[inline(always)]
            fn default() -> RdLock0 {
                RdLock0(0)
            }
        }
        impl core::fmt::Debug for RdLock0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RdLock0").field("rl0", &self.rl0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RdLock0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RdLock0 {{ rl0: {=u8:?} }}", self.rl0())
            }
        }
        #[doc = "This is the Read Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RdLock1(pub u8);
        impl RdLock1 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub const fn rl1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub fn set_rl1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for RdLock1 {
            #[inline(always)]
            fn default() -> RdLock1 {
                RdLock1(0)
            }
        }
        impl core::fmt::Debug for RdLock1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RdLock1").field("rl1", &self.rl1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RdLock1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RdLock1 {{ rl1: {=u8:?} }}", self.rl1())
            }
        }
        #[doc = "This is the Read Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RdLock2(pub u8);
        impl RdLock2 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub const fn rl2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub fn set_rl2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for RdLock2 {
            #[inline(always)]
            fn default() -> RdLock2 {
                RdLock2(0)
            }
        }
        impl core::fmt::Debug for RdLock2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RdLock2").field("rl2", &self.rl2()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RdLock2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RdLock2 {{ rl2: {=u8:?} }}", self.rl2())
            }
        }
        #[doc = "This is the Read Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RdLock3(pub u8);
        impl RdLock3 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub const fn rl3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub fn set_rl3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for RdLock3 {
            #[inline(always)]
            fn default() -> RdLock3 {
                RdLock3(0)
            }
        }
        impl core::fmt::Debug for RdLock3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RdLock3").field("rl3", &self.rl3()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RdLock3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RdLock3 {{ rl3: {=u8:?} }}", self.rl3())
            }
        }
        #[doc = "This is the Write Fine Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WrFineLck(pub u32);
        impl WrFineLck {
            #[doc = "Each bit locks write to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked."]
            #[inline(always)]
            pub const fn wr_fine_lck(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Each bit locks write to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked."]
            #[inline(always)]
            pub fn set_wr_fine_lck(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for WrFineLck {
            #[inline(always)]
            fn default() -> WrFineLck {
                WrFineLck(0)
            }
        }
        impl core::fmt::Debug for WrFineLck {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WrFineLck")
                    .field("wr_fine_lck", &self.wr_fine_lck())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WrFineLck {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WrFineLck {{ wr_fine_lck: {=u32:?} }}", self.wr_fine_lck())
            }
        }
        #[doc = "This is the Write Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WrLock0(pub u8);
        impl WrLock0 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub const fn wl0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub fn set_wl0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for WrLock0 {
            #[inline(always)]
            fn default() -> WrLock0 {
                WrLock0(0)
            }
        }
        impl core::fmt::Debug for WrLock0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WrLock0").field("wl0", &self.wl0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WrLock0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WrLock0 {{ wl0: {=u8:?} }}", self.wl0())
            }
        }
        #[doc = "This is the Write Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WrLock1(pub u8);
        impl WrLock1 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub const fn wl1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub fn set_wl1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for WrLock1 {
            #[inline(always)]
            fn default() -> WrLock1 {
                WrLock1(0)
            }
        }
        impl core::fmt::Debug for WrLock1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WrLock1").field("wl1", &self.wl1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WrLock1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WrLock1 {{ wl1: {=u8:?} }}", self.wl1())
            }
        }
        #[doc = "This is the Write Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WrLock2(pub u8);
        impl WrLock2 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub const fn wl2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub fn set_wl2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for WrLock2 {
            #[inline(always)]
            fn default() -> WrLock2 {
                WrLock2(0)
            }
        }
        impl core::fmt::Debug for WrLock2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WrLock2").field("wl2", &self.wl2()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WrLock2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WrLock2 {{ wl2: {=u8:?} }}", self.wl2())
            }
        }
        #[doc = "This is the Write Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WrLock3(pub u8);
        impl WrLock3 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub const fn wl3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub fn set_wl3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for WrLock3 {
            #[inline(always)]
            fn default() -> WrLock3 {
                WrLock3(0)
            }
        }
        impl core::fmt::Debug for WrLock3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WrLock3").field("wl3", &self.wl3()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WrLock3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WrLock3 {{ wl3: {=u8:?} }}", self.wl3())
            }
        }
    }
}
pub mod pcr {
    #[doc = "The Power, Clocks, and Resets (PCR) Section identifies clock sources, and reset inputs to the chip."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pcr {
        ptr: *mut u8,
    }
    unsafe impl Send for Pcr {}
    unsafe impl Sync for Pcr {}
    impl Pcr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "System Sleep Control"]
        #[inline(always)]
        pub const fn sys_slp_ctrl(self) -> crate::common::Reg<regs::SysSlpCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Processor Clock Control Register \\[7:0\\] Processor Clock Divide Value (PROC_DIV)"]
        #[inline(always)]
        pub const fn proc_clk_ctrl(self) -> crate::common::Reg<regs::ProcClkCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Configures the EC_CLK clock domain"]
        #[inline(always)]
        pub const fn slow_clk_ctrl(self) -> crate::common::Reg<regs::SlowClkCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Oscillator ID Register"]
        #[inline(always)]
        pub const fn osc_id(self) -> crate::common::Reg<regs::OscId, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "PCR Power Reset Status Register"]
        #[inline(always)]
        pub const fn pwr_rst_sts(self) -> crate::common::Reg<regs::PwrRstSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Power Reset Control Register"]
        #[inline(always)]
        pub const fn pwr_rst_ctrl(self) -> crate::common::Reg<regs::PwrRstCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "System Reset Register"]
        #[inline(always)]
        pub const fn sys_rst(self) -> crate::common::Reg<regs::SysRst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Sleep Enable 0 Register"]
        #[inline(always)]
        pub const fn slp_en_0(self) -> crate::common::Reg<regs::SlpEn0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Sleep Enable 1 Register"]
        #[inline(always)]
        pub const fn slp_en_1(self) -> crate::common::Reg<regs::SlpEn1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Sleep Enable 2 Register"]
        #[inline(always)]
        pub const fn slp_en_2(self) -> crate::common::Reg<regs::SlpEn2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Sleep Enable 3 Register"]
        #[inline(always)]
        pub const fn slp_en_3(self) -> crate::common::Reg<regs::SlpEn3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Sleep Enable 4 Register"]
        #[inline(always)]
        pub const fn slp_en_4(self) -> crate::common::Reg<regs::SlpEn4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Clock Required 0 Register"]
        #[inline(always)]
        pub const fn clk_req_0(self) -> crate::common::Reg<regs::ClkReq0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "Clock Required 1 Register"]
        #[inline(always)]
        pub const fn clk_req_1(self) -> crate::common::Reg<regs::ClkReq1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "Clock Required 2 Register"]
        #[inline(always)]
        pub const fn clk_req_2(self) -> crate::common::Reg<regs::ClkReq2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "Clock Required 3 Register"]
        #[inline(always)]
        pub const fn clk_req_3(self) -> crate::common::Reg<regs::ClkReq3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "Clock Required 4 Register"]
        #[inline(always)]
        pub const fn clk_req_4(self) -> crate::common::Reg<regs::ClkReq4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Reset Enable 0 Register"]
        #[inline(always)]
        pub const fn rst_en_0(self) -> crate::common::Reg<regs::RstEn0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "Reset Enable 1 Register"]
        #[inline(always)]
        pub const fn rst_en_1(self) -> crate::common::Reg<regs::RstEn1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "Reset Enable 2 Register"]
        #[inline(always)]
        pub const fn rst_en_2(self) -> crate::common::Reg<regs::RstEn2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "Reset Enable 3 Register"]
        #[inline(always)]
        pub const fn rst_en_3(self) -> crate::common::Reg<regs::RstEn3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "Reset Enable 4 Register"]
        #[inline(always)]
        pub const fn rst_en_4(self) -> crate::common::Reg<regs::RstEn4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "LOCK Register"]
        #[inline(always)]
        pub const fn lock_reg(self) -> crate::common::Reg<regs::LockReg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "SOFT VBAT Register"]
        #[inline(always)]
        pub const fn sft_vbat_por(self) -> crate::common::Reg<regs::SftVbatPor, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "PLL reference clock select."]
        #[inline(always)]
        pub const fn pll_ref(self) -> crate::common::Reg<regs::PllRef, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Regulator Control Running Register"]
        #[inline(always)]
        pub const fn reg_ctrl_run(self) -> crate::common::Reg<regs::RegCtrlRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "Regulator Control Sleeping Register"]
        #[inline(always)]
        pub const fn reg_ctrl_slp(self) -> crate::common::Reg<regs::RegCtrlSlp, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "Regulator Time Register"]
        #[inline(always)]
        pub const fn reg_tim(self) -> crate::common::Reg<regs::RegTim, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9cusize) as _) }
        }
        #[doc = "Bandgap Control Running Register"]
        #[inline(always)]
        pub const fn bndgp_ctrl_run(self) -> crate::common::Reg<regs::BndgpCtrlRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "Bandgap Control Sleeping Register"]
        #[inline(always)]
        pub const fn bndgp_ctrl_slp(self) -> crate::common::Reg<regs::BndgpCtrlSlp, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "32KHz Period Counter Register"]
        #[inline(always)]
        pub const fn clk_prd(self) -> crate::common::Reg<regs::ClkPrd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "32KHz Clock High Pulse Register"]
        #[inline(always)]
        pub const fn clk_hghpls(self) -> crate::common::Reg<regs::ClkHghpls, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc4usize) as _) }
        }
        #[doc = "32KHz Clock Min Period Register"]
        #[inline(always)]
        pub const fn clk_minprd(self) -> crate::common::Reg<regs::ClkMinprd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc8usize) as _) }
        }
        #[doc = "32KHz Clock Max Period Register"]
        #[inline(always)]
        pub const fn clk_maxprd(self) -> crate::common::Reg<regs::ClkMaxprd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xccusize) as _) }
        }
        #[doc = "32KHz Clock Duty Variation Register"]
        #[inline(always)]
        pub const fn clk_dtyvrtn(self) -> crate::common::Reg<regs::ClkDtyvrtn, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd0usize) as _) }
        }
        #[doc = "32KHz Maximum Clock Duty Variation Register"]
        #[inline(always)]
        pub const fn clk_maxdtyvrtn(self) -> crate::common::Reg<regs::ClkMaxdtyvrtn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd4usize) as _) }
        }
        #[doc = "32KHz Clock Valid Count Register"]
        #[inline(always)]
        pub const fn clk_vldcnt(self) -> crate::common::Reg<regs::ClkVldcnt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd8usize) as _) }
        }
        #[doc = "32KHz Clock Valid Minimum Count Register"]
        #[inline(always)]
        pub const fn clk_vldmin(self) -> crate::common::Reg<regs::ClkVldmin, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdcusize) as _) }
        }
        #[doc = "32KHz Clock Control Register"]
        #[inline(always)]
        pub const fn clk_32khz_ctrl(self) -> crate::common::Reg<regs::Clk32khzCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize) as _) }
        }
        #[doc = "32KHz Clock Monitor Status Register"]
        #[inline(always)]
        pub const fn clk_sts(self) -> crate::common::Reg<regs::ClkSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe4usize) as _) }
        }
        #[doc = "32KHz Clock Monitor Interrupt Enable Register"]
        #[inline(always)]
        pub const fn clk_int_en(self) -> crate::common::Reg<regs::ClkIntEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe8usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Bandgap Control Running Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BndgpCtrlRun(pub u32);
        impl BndgpCtrlRun {
            #[doc = "Regulator Control Running Register."]
            #[inline(always)]
            pub const fn ctrl_run(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Regulator Control Running Register."]
            #[inline(always)]
            pub fn set_ctrl_run(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for BndgpCtrlRun {
            #[inline(always)]
            fn default() -> BndgpCtrlRun {
                BndgpCtrlRun(0)
            }
        }
        impl core::fmt::Debug for BndgpCtrlRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BndgpCtrlRun")
                    .field("ctrl_run", &self.ctrl_run())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BndgpCtrlRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BndgpCtrlRun {{ ctrl_run: {=u32:?} }}", self.ctrl_run())
            }
        }
        #[doc = "Bandgap Control Sleeping Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BndgpCtrlSlp(pub u32);
        impl BndgpCtrlSlp {
            #[doc = "Regulator Control Running Register."]
            #[inline(always)]
            pub const fn ctrl_slp(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Regulator Control Running Register."]
            #[inline(always)]
            pub fn set_ctrl_slp(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for BndgpCtrlSlp {
            #[inline(always)]
            fn default() -> BndgpCtrlSlp {
                BndgpCtrlSlp(0)
            }
        }
        impl core::fmt::Debug for BndgpCtrlSlp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BndgpCtrlSlp")
                    .field("ctrl_slp", &self.ctrl_slp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BndgpCtrlSlp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BndgpCtrlSlp {{ ctrl_slp: {=u32:?} }}", self.ctrl_slp())
            }
        }
        #[doc = "32KHz Clock Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clk32khzCtrl(pub u32);
        impl Clk32khzCtrl {
            #[doc = "Enables the Period Counter."]
            #[inline(always)]
            pub const fn prd_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the Period Counter."]
            #[inline(always)]
            pub fn set_prd_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enables the Duty cycle Counter."]
            #[inline(always)]
            pub const fn dty_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the Duty cycle Counter."]
            #[inline(always)]
            pub fn set_dty_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enables the Counter for Valid count."]
            #[inline(always)]
            pub const fn vld_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the Counter for Valid count."]
            #[inline(always)]
            pub fn set_vld_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Counter 32kHz Source Selects the source 32kHz clock that is measured."]
            #[inline(always)]
            pub const fn src_sel(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Source Selects the source 32kHz clock that is measured."]
            #[inline(always)]
            pub fn set_src_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Counter 32kHz Clear Clears the counters."]
            #[inline(always)]
            pub const fn clr_cnt(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Clear Clears the counters."]
            #[inline(always)]
            pub fn set_clr_cnt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Clk32khzCtrl {
            #[inline(always)]
            fn default() -> Clk32khzCtrl {
                Clk32khzCtrl(0)
            }
        }
        impl core::fmt::Debug for Clk32khzCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clk32khzCtrl")
                    .field("prd_en", &self.prd_en())
                    .field("dty_en", &self.dty_en())
                    .field("vld_en", &self.vld_en())
                    .field("src_sel", &self.src_sel())
                    .field("clr_cnt", &self.clr_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clk32khzCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Clk32khzCtrl {{ prd_en: {=bool:?}, dty_en: {=bool:?}, vld_en: {=bool:?}, src_sel: {=bool:?}, clr_cnt: {=bool:?} }}" , self . prd_en () , self . dty_en () , self . vld_en () , self . src_sel () , self . clr_cnt ())
            }
        }
        #[doc = "32KHz Clock Duty Variation Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkDtyvrtn(pub u32);
        impl ClkDtyvrtn {
            #[doc = "This is the difference in system clocks between the 32kHz clocks High Pulse Width and its Low Pulse Width."]
            #[inline(always)]
            pub const fn clk_dtyvrtn(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the difference in system clocks between the 32kHz clocks High Pulse Width and its Low Pulse Width."]
            #[inline(always)]
            pub fn set_clk_dtyvrtn(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ClkDtyvrtn {
            #[inline(always)]
            fn default() -> ClkDtyvrtn {
                ClkDtyvrtn(0)
            }
        }
        impl core::fmt::Debug for ClkDtyvrtn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkDtyvrtn")
                    .field("clk_dtyvrtn", &self.clk_dtyvrtn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkDtyvrtn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ClkDtyvrtn {{ clk_dtyvrtn: {=u32:?} }}", self.clk_dtyvrtn())
            }
        }
        #[doc = "32KHz Clock High Pulse Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkHghpls(pub u32);
        impl ClkHghpls {
            #[doc = "Counter 32khz High Counts how many system clock cycles the 32kHz clock remains HIGH for."]
            #[inline(always)]
            pub const fn clk_hghpls(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Counter 32khz High Counts how many system clock cycles the 32kHz clock remains HIGH for."]
            #[inline(always)]
            pub fn set_clk_hghpls(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ClkHghpls {
            #[inline(always)]
            fn default() -> ClkHghpls {
                ClkHghpls(0)
            }
        }
        impl core::fmt::Debug for ClkHghpls {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkHghpls")
                    .field("clk_hghpls", &self.clk_hghpls())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkHghpls {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ClkHghpls {{ clk_hghpls: {=u32:?} }}", self.clk_hghpls())
            }
        }
        #[doc = "32KHz Clock Monitor Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkIntEn(pub u32);
        impl ClkIntEn {
            #[doc = "Counter 32kHz Pulse Ready Interrupt Enable."]
            #[inline(always)]
            pub const fn pulse_rdy_ie(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Pulse Ready Interrupt Enable."]
            #[inline(always)]
            pub fn set_pulse_rdy_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Counter 32kHz Pass Period Interrupt Enable."]
            #[inline(always)]
            pub const fn pass_prd_ie(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Pass Period Interrupt Enable."]
            #[inline(always)]
            pub fn set_pass_prd_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Counter 32kHz Pass Duty Interrupt Enable."]
            #[inline(always)]
            pub const fn pass_dty_ie(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Pass Duty Interrupt Enable."]
            #[inline(always)]
            pub fn set_pass_dty_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Counter 32kHz Fail Interrupt Enable."]
            #[inline(always)]
            pub const fn fail_ie(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Fail Interrupt Enable."]
            #[inline(always)]
            pub fn set_fail_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Counter 32kHz Stall Interrupt Enable."]
            #[inline(always)]
            pub const fn stall_ie(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Stall Interrupt Enable."]
            #[inline(always)]
            pub fn set_stall_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Counter 32kHz Valid Interrupt Enable."]
            #[inline(always)]
            pub const fn vld_ie(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Valid Interrupt Enable."]
            #[inline(always)]
            pub fn set_vld_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Counter 32kHz Unwell Interrupt Enable."]
            #[inline(always)]
            pub const fn nvl_ie(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Unwell Interrupt Enable."]
            #[inline(always)]
            pub fn set_nvl_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for ClkIntEn {
            #[inline(always)]
            fn default() -> ClkIntEn {
                ClkIntEn(0)
            }
        }
        impl core::fmt::Debug for ClkIntEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkIntEn")
                    .field("pulse_rdy_ie", &self.pulse_rdy_ie())
                    .field("pass_prd_ie", &self.pass_prd_ie())
                    .field("pass_dty_ie", &self.pass_dty_ie())
                    .field("fail_ie", &self.fail_ie())
                    .field("stall_ie", &self.stall_ie())
                    .field("vld_ie", &self.vld_ie())
                    .field("nvl_ie", &self.nvl_ie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkIntEn {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkIntEn {{ pulse_rdy_ie: {=bool:?}, pass_prd_ie: {=bool:?}, pass_dty_ie: {=bool:?}, fail_ie: {=bool:?}, stall_ie: {=bool:?}, vld_ie: {=bool:?}, nvl_ie: {=bool:?} }}" , self . pulse_rdy_ie () , self . pass_prd_ie () , self . pass_dty_ie () , self . fail_ie () , self . stall_ie () , self . vld_ie () , self . nvl_ie ())
            }
        }
        #[doc = "32KHz Maximum Clock Duty Variation Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkMaxdtyvrtn(pub u32);
        impl ClkMaxdtyvrtn {
            #[doc = "This is the difference maximum variation allowed to generate a PASS condition for the 32kHz clock"]
            #[inline(always)]
            pub const fn clk_maxdtyvrtn(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the difference maximum variation allowed to generate a PASS condition for the 32kHz clock"]
            #[inline(always)]
            pub fn set_clk_maxdtyvrtn(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ClkMaxdtyvrtn {
            #[inline(always)]
            fn default() -> ClkMaxdtyvrtn {
                ClkMaxdtyvrtn(0)
            }
        }
        impl core::fmt::Debug for ClkMaxdtyvrtn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkMaxdtyvrtn")
                    .field("clk_maxdtyvrtn", &self.clk_maxdtyvrtn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkMaxdtyvrtn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ClkMaxdtyvrtn {{ clk_maxdtyvrtn: {=u32:?} }}", self.clk_maxdtyvrtn())
            }
        }
        #[doc = "32KHz Clock Max Period Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkMaxprd(pub u32);
        impl ClkMaxprd {
            #[doc = "This is the maximum period count that is acceptable for the 32kHz counter to flag a PASS status."]
            #[inline(always)]
            pub const fn clk_maxprd(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the maximum period count that is acceptable for the 32kHz counter to flag a PASS status."]
            #[inline(always)]
            pub fn set_clk_maxprd(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ClkMaxprd {
            #[inline(always)]
            fn default() -> ClkMaxprd {
                ClkMaxprd(0)
            }
        }
        impl core::fmt::Debug for ClkMaxprd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkMaxprd")
                    .field("clk_maxprd", &self.clk_maxprd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkMaxprd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ClkMaxprd {{ clk_maxprd: {=u32:?} }}", self.clk_maxprd())
            }
        }
        #[doc = "32KHz Clock Min Period Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkMinprd(pub u32);
        impl ClkMinprd {
            #[doc = "This is the minimum period count that is acceptable for the 32kHz counter to flag a PASS status."]
            #[inline(always)]
            pub const fn clk_minprd(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the minimum period count that is acceptable for the 32kHz counter to flag a PASS status."]
            #[inline(always)]
            pub fn set_clk_minprd(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ClkMinprd {
            #[inline(always)]
            fn default() -> ClkMinprd {
                ClkMinprd(0)
            }
        }
        impl core::fmt::Debug for ClkMinprd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkMinprd")
                    .field("clk_minprd", &self.clk_minprd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkMinprd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ClkMinprd {{ clk_minprd: {=u32:?} }}", self.clk_minprd())
            }
        }
        #[doc = "32KHz Period Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkPrd(pub u32);
        impl ClkPrd {
            #[doc = "Counter 32khz period Counts system clock cycles between 2 positive edges of an 32kHz clock."]
            #[inline(always)]
            pub const fn clk_prd(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Counter 32khz period Counts system clock cycles between 2 positive edges of an 32kHz clock."]
            #[inline(always)]
            pub fn set_clk_prd(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ClkPrd {
            #[inline(always)]
            fn default() -> ClkPrd {
                ClkPrd(0)
            }
        }
        impl core::fmt::Debug for ClkPrd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkPrd").field("clk_prd", &self.clk_prd()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkPrd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ClkPrd {{ clk_prd: {=u32:?} }}", self.clk_prd())
            }
        }
        #[doc = "Clock Required 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkReq0(pub u32);
        impl ClkReq0 {
            #[doc = "JTAG STAP Enable"]
            #[inline(always)]
            pub const fn jtag_stap_clk_req(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "JTAG STAP Enable"]
            #[inline(always)]
            pub fn set_jtag_stap_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "OTP Enable"]
            #[inline(always)]
            pub const fn otp_clk_req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OTP Enable"]
            #[inline(always)]
            pub fn set_otp_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "IMSPI Sleep clock Required"]
            #[inline(always)]
            pub const fn imspi_clk_req(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "IMSPI Sleep clock Required"]
            #[inline(always)]
            pub fn set_imspi_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for ClkReq0 {
            #[inline(always)]
            fn default() -> ClkReq0 {
                ClkReq0(0)
            }
        }
        impl core::fmt::Debug for ClkReq0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkReq0")
                    .field("jtag_stap_clk_req", &self.jtag_stap_clk_req())
                    .field("otp_clk_req", &self.otp_clk_req())
                    .field("imspi_clk_req", &self.imspi_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkReq0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "ClkReq0 {{ jtag_stap_clk_req: {=bool:?}, otp_clk_req: {=bool:?}, imspi_clk_req: {=bool:?} }}",
                    self.jtag_stap_clk_req(),
                    self.otp_clk_req(),
                    self.imspi_clk_req()
                )
            }
        }
        #[doc = "Clock Required 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkReq1(pub u32);
        impl ClkReq1 {
            #[doc = "Interrupt Clock Required"]
            #[inline(always)]
            pub const fn int_clk_req(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt Clock Required"]
            #[inline(always)]
            pub fn set_int_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PECI Clock Required"]
            #[inline(always)]
            pub const fn peci_clk_req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PECI Clock Required"]
            #[inline(always)]
            pub fn set_peci_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "TACH0 Clock Required (TACH0_CLK_REQ)"]
            #[inline(always)]
            pub const fn tach0_clk_req(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "TACH0 Clock Required (TACH0_CLK_REQ)"]
            #[inline(always)]
            pub fn set_tach0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "PWM0 Clock Required (PWM0_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm0_clk_req(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PWM0 Clock Required (PWM0_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "PMC Clock Required (PMC_CLK_REQ)"]
            #[inline(always)]
            pub const fn pmc_clk_req(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "PMC Clock Required (PMC_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pmc_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "DMA Clock Required (DMA_CLK_REQ)"]
            #[inline(always)]
            pub const fn dma_clk_req(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA Clock Required (DMA_CLK_REQ)"]
            #[inline(always)]
            pub fn set_dma_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "TFDP Clock Required (TFDP_CLK_REQ)"]
            #[inline(always)]
            pub const fn tfdp_clk_req(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "TFDP Clock Required (TFDP_CLK_REQ)"]
            #[inline(always)]
            pub fn set_tfdp_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "PROCESSOR Clock Required (PROCESSOR_CLK_REQ)"]
            #[inline(always)]
            pub const fn proc_clk_req(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "PROCESSOR Clock Required (PROCESSOR_CLK_REQ)"]
            #[inline(always)]
            pub fn set_proc_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "WDT Clock Required (WDT_CLK_REQ)"]
            #[inline(always)]
            pub const fn wdt_clk_req(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "WDT Clock Required (WDT_CLK_REQ)"]
            #[inline(always)]
            pub fn set_wdt_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SMB0 Clock Required (SMB0_CLK_REQ)"]
            #[inline(always)]
            pub const fn smb0_clk_req(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SMB0 Clock Required (SMB0_CLK_REQ)"]
            #[inline(always)]
            pub fn set_smb0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "TACH1 Clock Required (TACH1_CLK_REQ)"]
            #[inline(always)]
            pub const fn tach1_clk_req(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "TACH1 Clock Required (TACH1_CLK_REQ)"]
            #[inline(always)]
            pub fn set_tach1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "TACH2 Clock Required (TACH2_CLK_REQ)"]
            #[inline(always)]
            pub const fn tach2_clk_req(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "TACH2 Clock Required (TACH2_CLK_REQ)"]
            #[inline(always)]
            pub fn set_tach2_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "TACH3 Clock Required (TACH3_CLK_REQ)"]
            #[inline(always)]
            pub const fn tach3_clk_req(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "TACH3 Clock Required (TACH3_CLK_REQ)"]
            #[inline(always)]
            pub fn set_tach3_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "PWM1 Clock Required (PWM1_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm1_clk_req(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "PWM1 Clock Required (PWM1_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "PWM2 Clock Required (PWM2_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm2_clk_req(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "PWM2 Clock Required (PWM2_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm2_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "PWM3 Clock Required (PWM3_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm3_clk_req(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "PWM3 Clock Required (PWM3_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm3_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "PWM4 Clock Required (PWM4_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm4_clk_req(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "PWM4 Clock Required (PWM4_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm4_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "PWM5 Clock Required (PWM5_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm5_clk_req(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "PWM5 Clock Required (PWM5_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm5_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "PWM6 Clock Required (PWM6_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm6_clk_req(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "PWM6 Clock Required (PWM6_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm6_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "PWM7 Clock Required (PWM7_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm7_clk_req(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "PWM7 Clock Required (PWM7_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm7_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "PWM8 Clock Required (PWM8_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm8_clk_req(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "PWM8 Clock Required (PWM8_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm8_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "EC_REG_BANK Clock Required (EC_REG_BANK_CLK_REQ)"]
            #[inline(always)]
            pub const fn ec_reg_bank_clk_req(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "EC_REG_BANK Clock Required (EC_REG_BANK_CLK_REQ)"]
            #[inline(always)]
            pub fn set_ec_reg_bank_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "TIMER16_0 Clock Required (TIMER16_0_CLK_REQ)"]
            #[inline(always)]
            pub const fn tmr16_0_clk_req(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_0 Clock Required (TIMER16_0_CLK_REQ)"]
            #[inline(always)]
            pub fn set_tmr16_0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "TIMER16_1 Clock Required (TIMER16_1_CLK_REQ)"]
            #[inline(always)]
            pub const fn tmr16_1_clk_req(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_1 Clock Required (TIMER16_1_CLK_REQ)"]
            #[inline(always)]
            pub fn set_tmr16_1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for ClkReq1 {
            #[inline(always)]
            fn default() -> ClkReq1 {
                ClkReq1(0)
            }
        }
        impl core::fmt::Debug for ClkReq1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkReq1")
                    .field("int_clk_req", &self.int_clk_req())
                    .field("peci_clk_req", &self.peci_clk_req())
                    .field("tach0_clk_req", &self.tach0_clk_req())
                    .field("pwm0_clk_req", &self.pwm0_clk_req())
                    .field("pmc_clk_req", &self.pmc_clk_req())
                    .field("dma_clk_req", &self.dma_clk_req())
                    .field("tfdp_clk_req", &self.tfdp_clk_req())
                    .field("proc_clk_req", &self.proc_clk_req())
                    .field("wdt_clk_req", &self.wdt_clk_req())
                    .field("smb0_clk_req", &self.smb0_clk_req())
                    .field("tach1_clk_req", &self.tach1_clk_req())
                    .field("tach2_clk_req", &self.tach2_clk_req())
                    .field("tach3_clk_req", &self.tach3_clk_req())
                    .field("pwm1_clk_req", &self.pwm1_clk_req())
                    .field("pwm2_clk_req", &self.pwm2_clk_req())
                    .field("pwm3_clk_req", &self.pwm3_clk_req())
                    .field("pwm4_clk_req", &self.pwm4_clk_req())
                    .field("pwm5_clk_req", &self.pwm5_clk_req())
                    .field("pwm6_clk_req", &self.pwm6_clk_req())
                    .field("pwm7_clk_req", &self.pwm7_clk_req())
                    .field("pwm8_clk_req", &self.pwm8_clk_req())
                    .field("ec_reg_bank_clk_req", &self.ec_reg_bank_clk_req())
                    .field("tmr16_0_clk_req", &self.tmr16_0_clk_req())
                    .field("tmr16_1_clk_req", &self.tmr16_1_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkReq1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkReq1 {{ int_clk_req: {=bool:?}, peci_clk_req: {=bool:?}, tach0_clk_req: {=bool:?}, pwm0_clk_req: {=bool:?}, pmc_clk_req: {=bool:?}, dma_clk_req: {=bool:?}, tfdp_clk_req: {=bool:?}, proc_clk_req: {=bool:?}, wdt_clk_req: {=bool:?}, smb0_clk_req: {=bool:?}, tach1_clk_req: {=bool:?}, tach2_clk_req: {=bool:?}, tach3_clk_req: {=bool:?}, pwm1_clk_req: {=bool:?}, pwm2_clk_req: {=bool:?}, pwm3_clk_req: {=bool:?}, pwm4_clk_req: {=bool:?}, pwm5_clk_req: {=bool:?}, pwm6_clk_req: {=bool:?}, pwm7_clk_req: {=bool:?}, pwm8_clk_req: {=bool:?}, ec_reg_bank_clk_req: {=bool:?}, tmr16_0_clk_req: {=bool:?}, tmr16_1_clk_req: {=bool:?} }}" , self . int_clk_req () , self . peci_clk_req () , self . tach0_clk_req () , self . pwm0_clk_req () , self . pmc_clk_req () , self . dma_clk_req () , self . tfdp_clk_req () , self . proc_clk_req () , self . wdt_clk_req () , self . smb0_clk_req () , self . tach1_clk_req () , self . tach2_clk_req () , self . tach3_clk_req () , self . pwm1_clk_req () , self . pwm2_clk_req () , self . pwm3_clk_req () , self . pwm4_clk_req () , self . pwm5_clk_req () , self . pwm6_clk_req () , self . pwm7_clk_req () , self . pwm8_clk_req () , self . ec_reg_bank_clk_req () , self . tmr16_0_clk_req () , self . tmr16_1_clk_req ())
            }
        }
        #[doc = "Clock Required 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkReq2(pub u32);
        impl ClkReq2 {
            #[doc = "IMAP Clock Required (IMAP_CLK_REQ)"]
            #[inline(always)]
            pub const fn imap_clk_req(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "IMAP Clock Required (IMAP_CLK_REQ)"]
            #[inline(always)]
            pub fn set_imap_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "UART 0 Clock Required"]
            #[inline(always)]
            pub const fn uart0_clk_req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "UART 0 Clock Required"]
            #[inline(always)]
            pub fn set_uart0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "UART 1 Clock Required"]
            #[inline(always)]
            pub const fn uart1_clk_req(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "UART 1 Clock Required"]
            #[inline(always)]
            pub fn set_uart1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GLBL_CFG (GLBL_CFG_CLK_REQ)"]
            #[inline(always)]
            pub const fn glbl_cfg_clk_req(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "GLBL_CFG (GLBL_CFG_CLK_REQ)"]
            #[inline(always)]
            pub fn set_glbl_cfg_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "8042EM Clock Required (8042EM_CLK_REQ)"]
            #[inline(always)]
            pub const fn kbcem_clk_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "8042EM Clock Required (8042EM_CLK_REQ)"]
            #[inline(always)]
            pub fn set_kbcem_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "RTC Clock Required (RTC_CLK_REQ)"]
            #[inline(always)]
            pub const fn rtc_clk_req(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "RTC Clock Required (RTC_CLK_REQ)"]
            #[inline(always)]
            pub fn set_rtc_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "eSPI Clock Required"]
            #[inline(always)]
            pub const fn espi_clk_req(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "eSPI Clock Required"]
            #[inline(always)]
            pub fn set_espi_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "ASIF Clock Required"]
            #[inline(always)]
            pub const fn asif_clk_req(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "ASIF Clock Required"]
            #[inline(always)]
            pub fn set_asif_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "SAF BRIDGE Clock Required"]
            #[inline(always)]
            pub const fn saf_brdg_clk_req(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "SAF BRIDGE Clock Required"]
            #[inline(always)]
            pub fn set_saf_brdg_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
        }
        impl Default for ClkReq2 {
            #[inline(always)]
            fn default() -> ClkReq2 {
                ClkReq2(0)
            }
        }
        impl core::fmt::Debug for ClkReq2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkReq2")
                    .field("imap_clk_req", &self.imap_clk_req())
                    .field("uart0_clk_req", &self.uart0_clk_req())
                    .field("uart1_clk_req", &self.uart1_clk_req())
                    .field("glbl_cfg_clk_req", &self.glbl_cfg_clk_req())
                    .field("kbcem_clk_req", &self.kbcem_clk_req())
                    .field("rtc_clk_req", &self.rtc_clk_req())
                    .field("espi_clk_req", &self.espi_clk_req())
                    .field("asif_clk_req", &self.asif_clk_req())
                    .field("saf_brdg_clk_req", &self.saf_brdg_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkReq2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkReq2 {{ imap_clk_req: {=bool:?}, uart0_clk_req: {=bool:?}, uart1_clk_req: {=bool:?}, glbl_cfg_clk_req: {=bool:?}, kbcem_clk_req: {=bool:?}, rtc_clk_req: {=bool:?}, espi_clk_req: {=bool:?}, asif_clk_req: {=bool:?}, saf_brdg_clk_req: {=bool:?} }}" , self . imap_clk_req () , self . uart0_clk_req () , self . uart1_clk_req () , self . glbl_cfg_clk_req () , self . kbcem_clk_req () , self . rtc_clk_req () , self . espi_clk_req () , self . asif_clk_req () , self . saf_brdg_clk_req ())
            }
        }
        #[doc = "Clock Required 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkReq3(pub u32);
        impl ClkReq3 {
            #[doc = "ADC Clock Required (ADC_CLK_REQ)"]
            #[inline(always)]
            pub const fn adc_clk_req(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ADC Clock Required (ADC_CLK_REQ)"]
            #[inline(always)]
            pub fn set_adc_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "PS2_0 Clock Required (PS2_0_CLK_REQ)"]
            #[inline(always)]
            pub const fn ps2_0_clk_req(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "PS2_0 Clock Required (PS2_0_CLK_REQ)"]
            #[inline(always)]
            pub fn set_ps2_0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPSPI 0 Clock Required (GPSPI_0_CLK_REQ)"]
            #[inline(always)]
            pub const fn gpspi_0_clk_req(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "GPSPI 0 Clock Required (GPSPI_0_CLK_REQ)"]
            #[inline(always)]
            pub fn set_gpspi_0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Hibernation TIMER 0 Clock Required (HTM_0_CLK_REQ)"]
            #[inline(always)]
            pub const fn htm0_clk_req(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation TIMER 0 Clock Required (HTM_0_CLK_REQ)"]
            #[inline(always)]
            pub fn set_htm0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "KEYSCAN Clock Required (KMS_CLK_REQ)"]
            #[inline(always)]
            pub const fn kms_clk_req(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "KEYSCAN Clock Required (KMS_CLK_REQ)"]
            #[inline(always)]
            pub fn set_kms_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "SMB1 Clock Required (SMB1_CLK_REQ)"]
            #[inline(always)]
            pub const fn smb1_clk_req(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SMB1 Clock Required (SMB1_CLK_REQ)"]
            #[inline(always)]
            pub fn set_smb1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SMB2 Clock Required (SMB2_CLK_REQ)"]
            #[inline(always)]
            pub const fn smb2_clk_req(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SMB2 Clock Required (SMB2_CLK_REQ)"]
            #[inline(always)]
            pub fn set_smb2_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "SMB3 Clock Required (SMB3_CLK_REQ)"]
            #[inline(always)]
            pub const fn smb3_clk_req(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "SMB3 Clock Required (SMB3_CLK_REQ)"]
            #[inline(always)]
            pub fn set_smb3_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "LED0 Clock Required (LED0_CLK_REQ)"]
            #[inline(always)]
            pub const fn led0_clk_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LED0 Clock Required (LED0_CLK_REQ)"]
            #[inline(always)]
            pub fn set_led0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "LED1 Clock Required (LED1_CLK_REQ)"]
            #[inline(always)]
            pub const fn led1_clk_req(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "LED1 Clock Required (LED1_CLK_REQ)"]
            #[inline(always)]
            pub fn set_led1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "LED2 Clock Required (LED2_CLK_REQ)"]
            #[inline(always)]
            pub const fn led2_clk_req(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "LED2 Clock Required (LED2_CLK_REQ)"]
            #[inline(always)]
            pub fn set_led2_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "BC_LINK0 Clock Required (BC_LINK0_CLK_REQ)"]
            #[inline(always)]
            pub const fn bc_link0_clk_req(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "BC_LINK0 Clock Required (BC_LINK0_CLK_REQ)"]
            #[inline(always)]
            pub fn set_bc_link0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "SMB 4 Clock Required (SMB_4_CLK_REQ)"]
            #[inline(always)]
            pub const fn smb_4_clk_req(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "SMB 4 Clock Required (SMB_4_CLK_REQ)"]
            #[inline(always)]
            pub fn set_smb_4_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "TIMER16_2 Clock Required (TIMER16_2_CLK_REQ)"]
            #[inline(always)]
            pub const fn tmr16_2_clk_req(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_2 Clock Required (TIMER16_2_CLK_REQ)"]
            #[inline(always)]
            pub fn set_tmr16_2_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TIMER16_3 Clock Required (TIMER16_3_CLK_REQ)"]
            #[inline(always)]
            pub const fn tmr16_3_clk_req(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_3 Clock Required (TIMER16_3_CLK_REQ)"]
            #[inline(always)]
            pub fn set_tmr16_3_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "TIMER32_0 Clock Required (TIMER32_0_CLK_REQ)"]
            #[inline(always)]
            pub const fn tmr32_0_clk_req(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0 Clock Required (TIMER32_0_CLK_REQ)"]
            #[inline(always)]
            pub fn set_tmr32_0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "TIMER32_1 Clock Required (TIMER32_1_CLK_REQ)"]
            #[inline(always)]
            pub const fn tmr32_1_clk_req(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1 Clock Required (TIMER32_1_CLK_REQ)"]
            #[inline(always)]
            pub fn set_tmr32_1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "LED3 Clock Required (LED3_CLK_REQ)"]
            #[inline(always)]
            pub const fn led3_clk_req(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "LED3 Clock Required (LED3_CLK_REQ)"]
            #[inline(always)]
            pub fn set_led3_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "PKE Clock Required"]
            #[inline(always)]
            pub const fn pke_clk_req(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "PKE Clock Required"]
            #[inline(always)]
            pub fn set_pke_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "RNG Clock Required"]
            #[inline(always)]
            pub const fn rng_clk_req(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "RNG Clock Required"]
            #[inline(always)]
            pub fn set_rng_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "AES_HASH Clock Required"]
            #[inline(always)]
            pub const fn aes_hash_clk_req(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "AES_HASH Clock Required"]
            #[inline(always)]
            pub fn set_aes_hash_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Hibernation TIMER 1 Clock Required (HTM_1_CLK_REQ)"]
            #[inline(always)]
            pub const fn htm_1_clk_req(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation TIMER 1 Clock Required (HTM_1_CLK_REQ)"]
            #[inline(always)]
            pub fn set_htm_1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Capture Compare Timer Clock Required (CCTIMER_CLK_REQ)"]
            #[inline(always)]
            pub const fn cctimer_clk_req(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Capture Compare Timer Clock Required (CCTIMER_CLK_REQ)"]
            #[inline(always)]
            pub fn set_cctimer_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "PWM9 Clock Required (PWM9_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm9_clk_req(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "PWM9 Clock Required (PWM9_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm9_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for ClkReq3 {
            #[inline(always)]
            fn default() -> ClkReq3 {
                ClkReq3(0)
            }
        }
        impl core::fmt::Debug for ClkReq3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkReq3")
                    .field("adc_clk_req", &self.adc_clk_req())
                    .field("ps2_0_clk_req", &self.ps2_0_clk_req())
                    .field("gpspi_0_clk_req", &self.gpspi_0_clk_req())
                    .field("htm0_clk_req", &self.htm0_clk_req())
                    .field("kms_clk_req", &self.kms_clk_req())
                    .field("smb1_clk_req", &self.smb1_clk_req())
                    .field("smb2_clk_req", &self.smb2_clk_req())
                    .field("smb3_clk_req", &self.smb3_clk_req())
                    .field("led0_clk_req", &self.led0_clk_req())
                    .field("led1_clk_req", &self.led1_clk_req())
                    .field("led2_clk_req", &self.led2_clk_req())
                    .field("bc_link0_clk_req", &self.bc_link0_clk_req())
                    .field("smb_4_clk_req", &self.smb_4_clk_req())
                    .field("tmr16_2_clk_req", &self.tmr16_2_clk_req())
                    .field("tmr16_3_clk_req", &self.tmr16_3_clk_req())
                    .field("tmr32_0_clk_req", &self.tmr32_0_clk_req())
                    .field("tmr32_1_clk_req", &self.tmr32_1_clk_req())
                    .field("led3_clk_req", &self.led3_clk_req())
                    .field("pke_clk_req", &self.pke_clk_req())
                    .field("rng_clk_req", &self.rng_clk_req())
                    .field("aes_hash_clk_req", &self.aes_hash_clk_req())
                    .field("htm_1_clk_req", &self.htm_1_clk_req())
                    .field("cctimer_clk_req", &self.cctimer_clk_req())
                    .field("pwm9_clk_req", &self.pwm9_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkReq3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkReq3 {{ adc_clk_req: {=bool:?}, ps2_0_clk_req: {=bool:?}, gpspi_0_clk_req: {=bool:?}, htm0_clk_req: {=bool:?}, kms_clk_req: {=bool:?}, smb1_clk_req: {=bool:?}, smb2_clk_req: {=bool:?}, smb3_clk_req: {=bool:?}, led0_clk_req: {=bool:?}, led1_clk_req: {=bool:?}, led2_clk_req: {=bool:?}, bc_link0_clk_req: {=bool:?}, smb_4_clk_req: {=bool:?}, tmr16_2_clk_req: {=bool:?}, tmr16_3_clk_req: {=bool:?}, tmr32_0_clk_req: {=bool:?}, tmr32_1_clk_req: {=bool:?}, led3_clk_req: {=bool:?}, pke_clk_req: {=bool:?}, rng_clk_req: {=bool:?}, aes_hash_clk_req: {=bool:?}, htm_1_clk_req: {=bool:?}, cctimer_clk_req: {=bool:?}, pwm9_clk_req: {=bool:?} }}" , self . adc_clk_req () , self . ps2_0_clk_req () , self . gpspi_0_clk_req () , self . htm0_clk_req () , self . kms_clk_req () , self . smb1_clk_req () , self . smb2_clk_req () , self . smb3_clk_req () , self . led0_clk_req () , self . led1_clk_req () , self . led2_clk_req () , self . bc_link0_clk_req () , self . smb_4_clk_req () , self . tmr16_2_clk_req () , self . tmr16_3_clk_req () , self . tmr32_0_clk_req () , self . tmr32_1_clk_req () , self . led3_clk_req () , self . pke_clk_req () , self . rng_clk_req () , self . aes_hash_clk_req () , self . htm_1_clk_req () , self . cctimer_clk_req () , self . pwm9_clk_req ())
            }
        }
        #[doc = "Clock Required 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkReq4(pub u32);
        impl ClkReq4 {
            #[doc = "PWM10 Clock Required (PWM10_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm10_clk_req(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PWM10 Clock Required (PWM10_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm10_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PWM11 Clock Required (PWM11_CLK_REQ)"]
            #[inline(always)]
            pub const fn pwm11_clk_req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PWM11 Clock Required (PWM11_CLK_REQ)"]
            #[inline(always)]
            pub fn set_pwm11_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "RTOS Clock Required (RTOS_CLK_REQ)"]
            #[inline(always)]
            pub const fn rtos_clk_req(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "RTOS Clock Required (RTOS_CLK_REQ)"]
            #[inline(always)]
            pub fn set_rtos_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Quad Master SPI Clock Required"]
            #[inline(always)]
            pub const fn qmspi_clk_req(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Quad Master SPI Clock Required"]
            #[inline(always)]
            pub fn set_qmspi_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "RC_ID0 Clock Required (RC_ID0_CLK_REQ)"]
            #[inline(always)]
            pub const fn rc_id0_clk_req(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID0 Clock Required (RC_ID0_CLK_REQ)"]
            #[inline(always)]
            pub fn set_rc_id0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "RC_ID1 Clock Required (RC_ID1_CLK_REQ)"]
            #[inline(always)]
            pub const fn rc_id1_clk_req(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID1 Clock Required (RC_ID1_CLK_REQ)"]
            #[inline(always)]
            pub fn set_rc_id1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "RC_ID2 Clock Required (RC_ID2_CLK_REQ)"]
            #[inline(always)]
            pub const fn rc_id2_clk_req(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID2 Clock Required (RC_ID2_CLK_REQ)"]
            #[inline(always)]
            pub fn set_rc_id2_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "SPI SLAVE Clock Required (SPI_SLAVE_CLK_REQ)"]
            #[inline(always)]
            pub const fn spi_slave_clk_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "SPI SLAVE Clock Required (SPI_SLAVE_CLK_REQ)"]
            #[inline(always)]
            pub fn set_spi_slave_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPSPI 1 Clock Required (GPSPI_1_CLK_REQ)"]
            #[inline(always)]
            pub const fn gpspi_1_clk_req(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPSPI 1 Clock Required (GPSPI_1_CLK_REQ)"]
            #[inline(always)]
            pub fn set_gpspi_1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for ClkReq4 {
            #[inline(always)]
            fn default() -> ClkReq4 {
                ClkReq4(0)
            }
        }
        impl core::fmt::Debug for ClkReq4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkReq4")
                    .field("pwm10_clk_req", &self.pwm10_clk_req())
                    .field("pwm11_clk_req", &self.pwm11_clk_req())
                    .field("rtos_clk_req", &self.rtos_clk_req())
                    .field("qmspi_clk_req", &self.qmspi_clk_req())
                    .field("rc_id0_clk_req", &self.rc_id0_clk_req())
                    .field("rc_id1_clk_req", &self.rc_id1_clk_req())
                    .field("rc_id2_clk_req", &self.rc_id2_clk_req())
                    .field("spi_slave_clk_req", &self.spi_slave_clk_req())
                    .field("gpspi_1_clk_req", &self.gpspi_1_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkReq4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkReq4 {{ pwm10_clk_req: {=bool:?}, pwm11_clk_req: {=bool:?}, rtos_clk_req: {=bool:?}, qmspi_clk_req: {=bool:?}, rc_id0_clk_req: {=bool:?}, rc_id1_clk_req: {=bool:?}, rc_id2_clk_req: {=bool:?}, spi_slave_clk_req: {=bool:?}, gpspi_1_clk_req: {=bool:?} }}" , self . pwm10_clk_req () , self . pwm11_clk_req () , self . rtos_clk_req () , self . qmspi_clk_req () , self . rc_id0_clk_req () , self . rc_id1_clk_req () , self . rc_id2_clk_req () , self . spi_slave_clk_req () , self . gpspi_1_clk_req ())
            }
        }
        #[doc = "32KHz Clock Monitor Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkSts(pub u32);
        impl ClkSts {
            #[doc = "Counter 32kHz Pulse Ready Status."]
            #[inline(always)]
            pub const fn pulse_rdy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Pulse Ready Status."]
            #[inline(always)]
            pub fn set_pulse_rdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Counter 32kHz Pass Period Status."]
            #[inline(always)]
            pub const fn pass_prd(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Pass Period Status."]
            #[inline(always)]
            pub fn set_pass_prd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Counter 32kHz Pass Duty Status."]
            #[inline(always)]
            pub const fn pass_dty(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Pass Duty Status."]
            #[inline(always)]
            pub fn set_pass_dty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Counter 32kHz Fail Status."]
            #[inline(always)]
            pub const fn fail(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Fail Status."]
            #[inline(always)]
            pub fn set_fail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Counter 32kHz Stall Status."]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Stall Status."]
            #[inline(always)]
            pub fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Counter 32kHz Valid Status."]
            #[inline(always)]
            pub const fn vld(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Valid Status."]
            #[inline(always)]
            pub fn set_vld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Counter 32kHz Unwell Status."]
            #[inline(always)]
            pub const fn nvl(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Counter 32kHz Unwell Status."]
            #[inline(always)]
            pub fn set_nvl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for ClkSts {
            #[inline(always)]
            fn default() -> ClkSts {
                ClkSts(0)
            }
        }
        impl core::fmt::Debug for ClkSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkSts")
                    .field("pulse_rdy", &self.pulse_rdy())
                    .field("pass_prd", &self.pass_prd())
                    .field("pass_dty", &self.pass_dty())
                    .field("fail", &self.fail())
                    .field("stall", &self.stall())
                    .field("vld", &self.vld())
                    .field("nvl", &self.nvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkSts {{ pulse_rdy: {=bool:?}, pass_prd: {=bool:?}, pass_dty: {=bool:?}, fail: {=bool:?}, stall: {=bool:?}, vld: {=bool:?}, nvl: {=bool:?} }}" , self . pulse_rdy () , self . pass_prd () , self . pass_dty () , self . fail () , self . stall () , self . vld () , self . nvl ())
            }
        }
        #[doc = "32KHz Clock Valid Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkVldcnt(pub u32);
        impl ClkVldcnt {
            #[doc = "This counts the number of valid 32kHz periods and pulse width variations measured in a row. This count increments on a PASS and will reset on a FAIL."]
            #[inline(always)]
            pub const fn clk_vldcnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This counts the number of valid 32kHz periods and pulse width variations measured in a row. This count increments on a PASS and will reset on a FAIL."]
            #[inline(always)]
            pub fn set_clk_vldcnt(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ClkVldcnt {
            #[inline(always)]
            fn default() -> ClkVldcnt {
                ClkVldcnt(0)
            }
        }
        impl core::fmt::Debug for ClkVldcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkVldcnt")
                    .field("clk_vldcnt", &self.clk_vldcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkVldcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ClkVldcnt {{ clk_vldcnt: {=u32:?} }}", self.clk_vldcnt())
            }
        }
        #[doc = "32KHz Clock Valid Minimum Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkVldmin(pub u32);
        impl ClkVldmin {
            #[doc = "This is the minimum value of Counter 32kHz Valid Count that will flag the status Counter Valid."]
            #[inline(always)]
            pub const fn clk_vldmin(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the minimum value of Counter 32kHz Valid Count that will flag the status Counter Valid."]
            #[inline(always)]
            pub fn set_clk_vldmin(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ClkVldmin {
            #[inline(always)]
            fn default() -> ClkVldmin {
                ClkVldmin(0)
            }
        }
        impl core::fmt::Debug for ClkVldmin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkVldmin")
                    .field("clk_vldmin", &self.clk_vldmin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkVldmin {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ClkVldmin {{ clk_vldmin: {=u32:?} }}", self.clk_vldmin())
            }
        }
        #[doc = "LOCK Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LockReg(pub u32);
        impl LockReg {
            #[doc = "PCR Reset Enable Lock Register."]
            #[inline(always)]
            pub const fn pcr_rst_en_lock(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "PCR Reset Enable Lock Register."]
            #[inline(always)]
            pub fn set_pcr_rst_en_lock(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LockReg {
            #[inline(always)]
            fn default() -> LockReg {
                LockReg(0)
            }
        }
        impl core::fmt::Debug for LockReg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LockReg")
                    .field("pcr_rst_en_lock", &self.pcr_rst_en_lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LockReg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LockReg {{ pcr_rst_en_lock: {=u32:?} }}", self.pcr_rst_en_lock())
            }
        }
        #[doc = "Oscillator ID Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OscId(pub u32);
        impl OscId {
            #[doc = "Test bits"]
            #[inline(always)]
            pub const fn test(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Test bits"]
            #[inline(always)]
            pub fn set_test(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "PLL Lock Status"]
            #[inline(always)]
            pub const fn pll_lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "PLL Lock Status"]
            #[inline(always)]
            pub fn set_pll_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for OscId {
            #[inline(always)]
            fn default() -> OscId {
                OscId(0)
            }
        }
        impl core::fmt::Debug for OscId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OscId")
                    .field("test", &self.test())
                    .field("pll_lock", &self.pll_lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OscId {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "OscId {{ test: {=u8:?}, pll_lock: {=bool:?} }}",
                    self.test(),
                    self.pll_lock()
                )
            }
        }
        #[doc = "PLL reference clock select."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PllRef(pub u32);
        impl PllRef {
            #[doc = "Source 32kHz MUX Select for the PLL reference clock source. 0 = Internal Silicon Oscillator 1 = XTAL 2 = VTR PIN 32KHZ_IN 3 = NONE-OFF"]
            #[inline(always)]
            pub const fn pll_ref(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "Source 32kHz MUX Select for the PLL reference clock source. 0 = Internal Silicon Oscillator 1 = XTAL 2 = VTR PIN 32KHZ_IN 3 = NONE-OFF"]
            #[inline(always)]
            pub fn set_pll_ref(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
        }
        impl Default for PllRef {
            #[inline(always)]
            fn default() -> PllRef {
                PllRef(0)
            }
        }
        impl core::fmt::Debug for PllRef {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PllRef").field("pll_ref", &self.pll_ref()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PllRef {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PllRef {{ pll_ref: {=u8:?} }}", self.pll_ref())
            }
        }
        #[doc = "Processor Clock Control Register \\[7:0\\] Processor Clock Divide Value (PROC_DIV)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ProcClkCtrl(pub u32);
        impl ProcClkCtrl {
            #[doc = "Selects the EC clock rate"]
            #[inline(always)]
            pub const fn div(&self) -> super::vals::Div {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Div::from_bits(val as u8)
            }
            #[doc = "Selects the EC clock rate"]
            #[inline(always)]
            pub fn set_div(&mut self, val: super::vals::Div) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
            }
        }
        impl Default for ProcClkCtrl {
            #[inline(always)]
            fn default() -> ProcClkCtrl {
                ProcClkCtrl(0)
            }
        }
        impl core::fmt::Debug for ProcClkCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ProcClkCtrl").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ProcClkCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ProcClkCtrl {{ div: {:?} }}", self.div())
            }
        }
        #[doc = "Power Reset Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PwrRstCtrl(pub u32);
        impl PwrRstCtrl {
            #[doc = "Used by FW to control internal RESET_VCC signal function and external PWROK pin. This bit is read-only when VCC_PWRGD is de-asserted low."]
            #[inline(always)]
            pub const fn pwr_inv(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Used by FW to control internal RESET_VCC signal function and external PWROK pin. This bit is read-only when VCC_PWRGD is de-asserted low."]
            #[inline(always)]
            pub fn set_pwr_inv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Determines what generates the internal platform reset signal. 1=LRESET# pin; 0=eSPI PLTRST# VWire"]
            #[inline(always)]
            pub const fn h_rst_sel(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Determines what generates the internal platform reset signal. 1=LRESET# pin; 0=eSPI PLTRST# VWire"]
            #[inline(always)]
            pub fn set_h_rst_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for PwrRstCtrl {
            #[inline(always)]
            fn default() -> PwrRstCtrl {
                PwrRstCtrl(0)
            }
        }
        impl core::fmt::Debug for PwrRstCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PwrRstCtrl")
                    .field("pwr_inv", &self.pwr_inv())
                    .field("h_rst_sel", &self.h_rst_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PwrRstCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "PwrRstCtrl {{ pwr_inv: {=bool:?}, h_rst_sel: {=bool:?} }}",
                    self.pwr_inv(),
                    self.h_rst_sel()
                )
            }
        }
        #[doc = "PCR Power Reset Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PwrRstSts(pub u32);
        impl PwrRstSts {
            #[doc = "Indicates the status of VCC_PWRGD. 0 = PWRGD not asserted. 1 = PWRGD asserte."]
            #[inline(always)]
            pub const fn vcc_pwrgd_sts(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the status of VCC_PWRGD. 0 = PWRGD not asserted. 1 = PWRGD asserte."]
            #[inline(always)]
            pub fn set_vcc_pwrgd_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates the status of RESET_VCC. 0 = reset active. 1 = reset not active."]
            #[inline(always)]
            pub const fn rst_h_sts(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the status of RESET_VCC. 0 = reset active. 1 = reset not active."]
            #[inline(always)]
            pub fn set_rst_h_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates the status of RESET_VTR. 0 = reset active. 1 = reset not active.(R/W1C)"]
            #[inline(always)]
            pub const fn rst_vtr_sts(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the status of RESET_VTR. 0 = reset active. 1 = reset not active.(R/W1C)"]
            #[inline(always)]
            pub fn set_rst_vtr_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "VBAT reset status 0 = No reset occurred while VTR was off or since the last time this bit was cleared. 1 = A reset occurred.(R/WC)"]
            #[inline(always)]
            pub const fn vbat_rst_sts(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "VBAT reset status 0 = No reset occurred while VTR was off or since the last time this bit was cleared. 1 = A reset occurred.(R/WC)"]
            #[inline(always)]
            pub fn set_vbat_rst_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Indicates the status of RESET_SYS.(R/W1C) 0 = No reset occurred since the last time this bit was cleared. 1 = A reset occurred."]
            #[inline(always)]
            pub const fn rst_sys_sts(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the status of RESET_SYS.(R/W1C) 0 = No reset occurred since the last time this bit was cleared. 1 = A reset occurred."]
            #[inline(always)]
            pub fn set_rst_sys_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Indicates status of JTAG_TRST# pin. 0 = No JTAG reset occurred since the last time this bit was cleared. 1 = A reset occurred because of a JTAG command."]
            #[inline(always)]
            pub const fn jtag_rst_sts(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates status of JTAG_TRST# pin. 0 = No JTAG reset occurred since the last time this bit was cleared. 1 = A reset occurred because of a JTAG command."]
            #[inline(always)]
            pub fn set_jtag_rst_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates that a WDT_EVENT happened. (R/W1C) 0 = Not active. 1 = A WDT_EVENT occured."]
            #[inline(always)]
            pub const fn wdt_event(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates that a WDT_EVENT happened. (R/W1C) 0 = Not active. 1 = A WDT_EVENT occured."]
            #[inline(always)]
            pub fn set_wdt_event(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "32K ACTIVE (ACTIVE_32K)"]
            #[inline(always)]
            pub const fn active_32k(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "32K ACTIVE (ACTIVE_32K)"]
            #[inline(always)]
            pub fn set_active_32k(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "PCICLK_ACTIVE (PCICLK_ACTIVE)"]
            #[inline(always)]
            pub const fn pciclk_active(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "PCICLK_ACTIVE (PCICLK_ACTIVE)"]
            #[inline(always)]
            pub fn set_pciclk_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "ESPI_CLK_ACTIVE"]
            #[inline(always)]
            pub const fn espi_clk_active(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "ESPI_CLK_ACTIVE"]
            #[inline(always)]
            pub fn set_espi_clk_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for PwrRstSts {
            #[inline(always)]
            fn default() -> PwrRstSts {
                PwrRstSts(0)
            }
        }
        impl core::fmt::Debug for PwrRstSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PwrRstSts")
                    .field("vcc_pwrgd_sts", &self.vcc_pwrgd_sts())
                    .field("rst_h_sts", &self.rst_h_sts())
                    .field("rst_vtr_sts", &self.rst_vtr_sts())
                    .field("vbat_rst_sts", &self.vbat_rst_sts())
                    .field("rst_sys_sts", &self.rst_sys_sts())
                    .field("jtag_rst_sts", &self.jtag_rst_sts())
                    .field("wdt_event", &self.wdt_event())
                    .field("active_32k", &self.active_32k())
                    .field("pciclk_active", &self.pciclk_active())
                    .field("espi_clk_active", &self.espi_clk_active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PwrRstSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PwrRstSts {{ vcc_pwrgd_sts: {=bool:?}, rst_h_sts: {=bool:?}, rst_vtr_sts: {=bool:?}, vbat_rst_sts: {=bool:?}, rst_sys_sts: {=bool:?}, jtag_rst_sts: {=bool:?}, wdt_event: {=bool:?}, active_32k: {=bool:?}, pciclk_active: {=bool:?}, espi_clk_active: {=bool:?} }}" , self . vcc_pwrgd_sts () , self . rst_h_sts () , self . rst_vtr_sts () , self . vbat_rst_sts () , self . rst_sys_sts () , self . jtag_rst_sts () , self . wdt_event () , self . active_32k () , self . pciclk_active () , self . espi_clk_active ())
            }
        }
        #[doc = "Regulator Control Running Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RegCtrlRun(pub u32);
        impl RegCtrlRun {
            #[doc = "Regulator Control Running Register."]
            #[inline(always)]
            pub const fn ctrl_run(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Regulator Control Running Register."]
            #[inline(always)]
            pub fn set_ctrl_run(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for RegCtrlRun {
            #[inline(always)]
            fn default() -> RegCtrlRun {
                RegCtrlRun(0)
            }
        }
        impl core::fmt::Debug for RegCtrlRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RegCtrlRun")
                    .field("ctrl_run", &self.ctrl_run())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RegCtrlRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RegCtrlRun {{ ctrl_run: {=u32:?} }}", self.ctrl_run())
            }
        }
        #[doc = "Regulator Control Sleeping Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RegCtrlSlp(pub u32);
        impl RegCtrlSlp {
            #[doc = "Regulator Control Running Register."]
            #[inline(always)]
            pub const fn ctrl_slp(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Regulator Control Running Register."]
            #[inline(always)]
            pub fn set_ctrl_slp(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for RegCtrlSlp {
            #[inline(always)]
            fn default() -> RegCtrlSlp {
                RegCtrlSlp(0)
            }
        }
        impl core::fmt::Debug for RegCtrlSlp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RegCtrlSlp")
                    .field("ctrl_slp", &self.ctrl_slp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RegCtrlSlp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RegCtrlSlp {{ ctrl_slp: {=u32:?} }}", self.ctrl_slp())
            }
        }
        #[doc = "Regulator Time Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RegTim(pub u32);
        impl RegTim {
            #[doc = "Regulator Power Up delay Register."]
            #[inline(always)]
            pub const fn pwrup_dly(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Regulator Power Up delay Register."]
            #[inline(always)]
            pub fn set_pwrup_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u32) & 0x3fff) << 0usize);
            }
            #[doc = "Regulator Power Down delay Register."]
            #[inline(always)]
            pub const fn pwrdn_dly(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x3fff;
                val as u16
            }
            #[doc = "Regulator Power Down delay Register."]
            #[inline(always)]
            pub fn set_pwrdn_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 16usize)) | (((val as u32) & 0x3fff) << 16usize);
            }
        }
        impl Default for RegTim {
            #[inline(always)]
            fn default() -> RegTim {
                RegTim(0)
            }
        }
        impl core::fmt::Debug for RegTim {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RegTim")
                    .field("pwrup_dly", &self.pwrup_dly())
                    .field("pwrdn_dly", &self.pwrdn_dly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RegTim {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RegTim {{ pwrup_dly: {=u16:?}, pwrdn_dly: {=u16:?} }}",
                    self.pwrup_dly(),
                    self.pwrdn_dly()
                )
            }
        }
        #[doc = "Reset Enable 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn0(pub u32);
        impl RstEn0 {
            #[doc = "OTP Reset Enable"]
            #[inline(always)]
            pub const fn otp_rst_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OTP Reset Enable"]
            #[inline(always)]
            pub fn set_otp_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for RstEn0 {
            #[inline(always)]
            fn default() -> RstEn0 {
                RstEn0(0)
            }
        }
        impl core::fmt::Debug for RstEn0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn0")
                    .field("otp_rst_en", &self.otp_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RstEn0 {{ otp_rst_en: {=bool:?} }}", self.otp_rst_en())
            }
        }
        #[doc = "Reset Enable 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn1(pub u32);
        impl RstEn1 {
            #[doc = "Interrupt Reset Enable"]
            #[inline(always)]
            pub const fn int_rst_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt Reset Enable"]
            #[inline(always)]
            pub fn set_int_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PECI Reset Enable"]
            #[inline(always)]
            pub const fn peci_rst_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PECI Reset Enable"]
            #[inline(always)]
            pub fn set_peci_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "TACH0 Reset Enable (TACH0_RST_EN)"]
            #[inline(always)]
            pub const fn tach0_rst_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "TACH0 Reset Enable (TACH0_RST_EN)"]
            #[inline(always)]
            pub fn set_tach0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "PWM0 Reset Enable (PWM0_RST_EN)"]
            #[inline(always)]
            pub const fn pwm0_rst_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PWM0 Reset Enable (PWM0_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "DMA Reset Enable (DMA_RST_EN)"]
            #[inline(always)]
            pub const fn dma_rst_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA Reset Enable (DMA_RST_EN)"]
            #[inline(always)]
            pub fn set_dma_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "TFDP Reset Enable (TFDP_RST_EN)"]
            #[inline(always)]
            pub const fn tfdp_rst_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "TFDP Reset Enable (TFDP_RST_EN)"]
            #[inline(always)]
            pub fn set_tfdp_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "WDT Reset Enable (WDT_RST_EN)"]
            #[inline(always)]
            pub const fn wdt_rst_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "WDT Reset Enable (WDT_RST_EN)"]
            #[inline(always)]
            pub fn set_wdt_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SMB0 Reset Enable (SMB0_RST_EN)"]
            #[inline(always)]
            pub const fn smb0_rst_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SMB0 Reset Enable (SMB0_RST_EN)"]
            #[inline(always)]
            pub fn set_smb0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "TACH1 Reset Enable (TACH1_RST_EN)"]
            #[inline(always)]
            pub const fn tach1_rst_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "TACH1 Reset Enable (TACH1_RST_EN)"]
            #[inline(always)]
            pub fn set_tach1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "TACH2 Reset Enable (TACH2_RST_EN)"]
            #[inline(always)]
            pub const fn tach2_rst_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "TACH2 Reset Enable (TACH2_RST_EN)"]
            #[inline(always)]
            pub fn set_tach2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "TACH3 Reset Enable (TACH3_RST_EN)"]
            #[inline(always)]
            pub const fn tach3_rst_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "TACH3 Reset Enable (TACH3_RST_EN)"]
            #[inline(always)]
            pub fn set_tach3_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "PWM1 Reset Enable (PWM1_RST_EN)"]
            #[inline(always)]
            pub const fn pwm1_rst_en(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "PWM1 Reset Enable (PWM1_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "PWM2 Reset Enable (PWM2_RST_EN)"]
            #[inline(always)]
            pub const fn pwm2_rst_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "PWM2 Reset Enable (PWM2_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "PWM3 Reset Enable (PWM3_RST_EN)"]
            #[inline(always)]
            pub const fn pwm3_rst_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "PWM3 Reset Enable (PWM3_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm3_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "PWM4 Reset Enable (PWM4_RST_EN)"]
            #[inline(always)]
            pub const fn pwm4_rst_en(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "PWM4 Reset Enable (PWM4_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm4_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "PWM5 Reset Enable (PWM5_RST_EN)"]
            #[inline(always)]
            pub const fn pwm5_rst_en(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "PWM5 Reset Enable (PWM5_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm5_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "PWM6 Reset Enable (PWM6_RST_EN)"]
            #[inline(always)]
            pub const fn pwm6_rst_en(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "PWM6 Reset Enable (PWM6_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm6_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "PWM7 Reset Enable (PWM7_RST_EN)"]
            #[inline(always)]
            pub const fn pwm7_rst_en(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "PWM7 Reset Enable (PWM7_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm7_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "PWM8 Reset Enable (PWM8_RST_EN)"]
            #[inline(always)]
            pub const fn pwm8_rst_en(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "PWM8 Reset Enable (PWM8_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm8_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "TIMER16_0 Reset Enable (TIMER16_0_RST_EN)"]
            #[inline(always)]
            pub const fn tmr16_0_rst_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_0 Reset Enable (TIMER16_0_RST_EN)"]
            #[inline(always)]
            pub fn set_tmr16_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "TIMER16_1 Reset Enable (TIMER16_1_RST_EN)"]
            #[inline(always)]
            pub const fn tmr16_1_rst_en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_1 Reset Enable (TIMER16_1_RST_EN)"]
            #[inline(always)]
            pub fn set_tmr16_1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for RstEn1 {
            #[inline(always)]
            fn default() -> RstEn1 {
                RstEn1(0)
            }
        }
        impl core::fmt::Debug for RstEn1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn1")
                    .field("int_rst_en", &self.int_rst_en())
                    .field("peci_rst_en", &self.peci_rst_en())
                    .field("tach0_rst_en", &self.tach0_rst_en())
                    .field("pwm0_rst_en", &self.pwm0_rst_en())
                    .field("dma_rst_en", &self.dma_rst_en())
                    .field("tfdp_rst_en", &self.tfdp_rst_en())
                    .field("wdt_rst_en", &self.wdt_rst_en())
                    .field("smb0_rst_en", &self.smb0_rst_en())
                    .field("tach1_rst_en", &self.tach1_rst_en())
                    .field("tach2_rst_en", &self.tach2_rst_en())
                    .field("tach3_rst_en", &self.tach3_rst_en())
                    .field("pwm1_rst_en", &self.pwm1_rst_en())
                    .field("pwm2_rst_en", &self.pwm2_rst_en())
                    .field("pwm3_rst_en", &self.pwm3_rst_en())
                    .field("pwm4_rst_en", &self.pwm4_rst_en())
                    .field("pwm5_rst_en", &self.pwm5_rst_en())
                    .field("pwm6_rst_en", &self.pwm6_rst_en())
                    .field("pwm7_rst_en", &self.pwm7_rst_en())
                    .field("pwm8_rst_en", &self.pwm8_rst_en())
                    .field("tmr16_0_rst_en", &self.tmr16_0_rst_en())
                    .field("tmr16_1_rst_en", &self.tmr16_1_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn1 {{ int_rst_en: {=bool:?}, peci_rst_en: {=bool:?}, tach0_rst_en: {=bool:?}, pwm0_rst_en: {=bool:?}, dma_rst_en: {=bool:?}, tfdp_rst_en: {=bool:?}, wdt_rst_en: {=bool:?}, smb0_rst_en: {=bool:?}, tach1_rst_en: {=bool:?}, tach2_rst_en: {=bool:?}, tach3_rst_en: {=bool:?}, pwm1_rst_en: {=bool:?}, pwm2_rst_en: {=bool:?}, pwm3_rst_en: {=bool:?}, pwm4_rst_en: {=bool:?}, pwm5_rst_en: {=bool:?}, pwm6_rst_en: {=bool:?}, pwm7_rst_en: {=bool:?}, pwm8_rst_en: {=bool:?}, tmr16_0_rst_en: {=bool:?}, tmr16_1_rst_en: {=bool:?} }}" , self . int_rst_en () , self . peci_rst_en () , self . tach0_rst_en () , self . pwm0_rst_en () , self . dma_rst_en () , self . tfdp_rst_en () , self . wdt_rst_en () , self . smb0_rst_en () , self . tach1_rst_en () , self . tach2_rst_en () , self . tach3_rst_en () , self . pwm1_rst_en () , self . pwm2_rst_en () , self . pwm3_rst_en () , self . pwm4_rst_en () , self . pwm5_rst_en () , self . pwm6_rst_en () , self . pwm7_rst_en () , self . pwm8_rst_en () , self . tmr16_0_rst_en () , self . tmr16_1_rst_en ())
            }
        }
        #[doc = "Reset Enable 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn2(pub u32);
        impl RstEn2 {
            #[doc = "IMAP Reset Enable (IMAP_RST_EN)"]
            #[inline(always)]
            pub const fn imap_rst_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "IMAP Reset Enable (IMAP_RST_EN)"]
            #[inline(always)]
            pub fn set_imap_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "UART 0 Reset Enable"]
            #[inline(always)]
            pub const fn uart0_rst_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "UART 0 Reset Enable"]
            #[inline(always)]
            pub fn set_uart0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "UART 1 Reset Enable"]
            #[inline(always)]
            pub const fn uart1_rst_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "UART 1 Reset Enable"]
            #[inline(always)]
            pub fn set_uart1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "ACPI EC 0 Reset Enable (ACPI_EC_0_RST_EN)"]
            #[inline(always)]
            pub const fn acpi_ec0_rst_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "ACPI EC 0 Reset Enable (ACPI_EC_0_RST_EN)"]
            #[inline(always)]
            pub fn set_acpi_ec0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "ACPI EC 1 Reset Enable (ACPI_EC_1_RST_EN)"]
            #[inline(always)]
            pub const fn acpi_ec1_rst_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "ACPI EC 1 Reset Enable (ACPI_EC_1_RST_EN)"]
            #[inline(always)]
            pub fn set_acpi_ec1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "ACPI PM1 Reset Enable (ACPI_PM1_RST_EN)"]
            #[inline(always)]
            pub const fn acpi_pm1_rst_en(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "ACPI PM1 Reset Enable (ACPI_PM1_RST_EN)"]
            #[inline(always)]
            pub fn set_acpi_pm1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "8042EM Reset Enable (8042EM_RST_EN)"]
            #[inline(always)]
            pub const fn kbcem_rst_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "8042EM Reset Enable (8042EM_RST_EN)"]
            #[inline(always)]
            pub fn set_kbcem_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Mailbox Reset Enable (MBX_RST_EN)"]
            #[inline(always)]
            pub const fn mbx_rst_en(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Mailbox Reset Enable (MBX_RST_EN)"]
            #[inline(always)]
            pub fn set_mbx_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "RTC Reset Enable (RTC_RST_EN)"]
            #[inline(always)]
            pub const fn rtc_rst_en(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "RTC Reset Enable (RTC_RST_EN)"]
            #[inline(always)]
            pub fn set_rtc_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "SCRATCH 32 Reset Enable"]
            #[inline(always)]
            pub const fn scratch_32_rst_en(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "SCRATCH 32 Reset Enable"]
            #[inline(always)]
            pub fn set_scratch_32_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "ACPI EC 2 Reset Enable (ACPI_EC_2_RST_EN)"]
            #[inline(always)]
            pub const fn acpi_ec_2_rst_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "ACPI EC 2 Reset Enable (ACPI_EC_2_RST_EN)"]
            #[inline(always)]
            pub fn set_acpi_ec_2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "ACPI EC 3 Reset Enable (ACPI_EC_3_RST_EN)"]
            #[inline(always)]
            pub const fn acpi_ec_3_rst_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "ACPI EC 3 Reset Enable (ACPI_EC_3_RST_EN)"]
            #[inline(always)]
            pub fn set_acpi_ec_3_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "ASIF Reset Enable"]
            #[inline(always)]
            pub const fn asif_rst_en(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "ASIF Reset Enable"]
            #[inline(always)]
            pub fn set_asif_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Port 80 0 Reset Enable"]
            #[inline(always)]
            pub const fn port_80_0_rst_en(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Port 80 0 Reset Enable"]
            #[inline(always)]
            pub fn set_port_80_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for RstEn2 {
            #[inline(always)]
            fn default() -> RstEn2 {
                RstEn2(0)
            }
        }
        impl core::fmt::Debug for RstEn2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn2")
                    .field("imap_rst_en", &self.imap_rst_en())
                    .field("uart0_rst_en", &self.uart0_rst_en())
                    .field("uart1_rst_en", &self.uart1_rst_en())
                    .field("acpi_ec0_rst_en", &self.acpi_ec0_rst_en())
                    .field("acpi_ec1_rst_en", &self.acpi_ec1_rst_en())
                    .field("acpi_pm1_rst_en", &self.acpi_pm1_rst_en())
                    .field("kbcem_rst_en", &self.kbcem_rst_en())
                    .field("mbx_rst_en", &self.mbx_rst_en())
                    .field("rtc_rst_en", &self.rtc_rst_en())
                    .field("scratch_32_rst_en", &self.scratch_32_rst_en())
                    .field("acpi_ec_2_rst_en", &self.acpi_ec_2_rst_en())
                    .field("acpi_ec_3_rst_en", &self.acpi_ec_3_rst_en())
                    .field("asif_rst_en", &self.asif_rst_en())
                    .field("port_80_0_rst_en", &self.port_80_0_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn2 {{ imap_rst_en: {=bool:?}, uart0_rst_en: {=bool:?}, uart1_rst_en: {=bool:?}, acpi_ec0_rst_en: {=bool:?}, acpi_ec1_rst_en: {=bool:?}, acpi_pm1_rst_en: {=bool:?}, kbcem_rst_en: {=bool:?}, mbx_rst_en: {=bool:?}, rtc_rst_en: {=bool:?}, scratch_32_rst_en: {=bool:?}, acpi_ec_2_rst_en: {=bool:?}, acpi_ec_3_rst_en: {=bool:?}, asif_rst_en: {=bool:?}, port_80_0_rst_en: {=bool:?} }}" , self . imap_rst_en () , self . uart0_rst_en () , self . uart1_rst_en () , self . acpi_ec0_rst_en () , self . acpi_ec1_rst_en () , self . acpi_pm1_rst_en () , self . kbcem_rst_en () , self . mbx_rst_en () , self . rtc_rst_en () , self . scratch_32_rst_en () , self . acpi_ec_2_rst_en () , self . acpi_ec_3_rst_en () , self . asif_rst_en () , self . port_80_0_rst_en ())
            }
        }
        #[doc = "Reset Enable 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn3(pub u32);
        impl RstEn3 {
            #[doc = "ADC Reset Enable (ADC_RST_EN)"]
            #[inline(always)]
            pub const fn adc_rst_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ADC Reset Enable (ADC_RST_EN)"]
            #[inline(always)]
            pub fn set_adc_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "PS2_0 Reset Enable (PS2_0_RST_EN)"]
            #[inline(always)]
            pub const fn ps2_0_rst_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "PS2_0 Reset Enable (PS2_0_RST_EN)"]
            #[inline(always)]
            pub fn set_ps2_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPSPI 0 Reset Enable (GPSPI_0_RST_EN)"]
            #[inline(always)]
            pub const fn gpspi_0_rst_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "GPSPI 0 Reset Enable (GPSPI_0_RST_EN)"]
            #[inline(always)]
            pub fn set_gpspi_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Hibernation TIMER 0 Reset Enable (HTM_0_RST_EN)"]
            #[inline(always)]
            pub const fn htm_0_rst_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation TIMER 0 Reset Enable (HTM_0_RST_EN)"]
            #[inline(always)]
            pub fn set_htm_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "KEYSCAN Reset Enable (KMS_RST_EN)"]
            #[inline(always)]
            pub const fn kms_rst_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "KEYSCAN Reset Enable (KMS_RST_EN)"]
            #[inline(always)]
            pub fn set_kms_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "SMB1 Reset Enable (SMB1_RST_EN)"]
            #[inline(always)]
            pub const fn smb1_rst_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SMB1 Reset Enable (SMB1_RST_EN)"]
            #[inline(always)]
            pub fn set_smb1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SMB2 Reset Enable (SMB2_RST_EN)"]
            #[inline(always)]
            pub const fn smb2_rst_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SMB2 Reset Enable (SMB2_RST_EN)"]
            #[inline(always)]
            pub fn set_smb2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "SMB3 Reset Enable (SMB3_RST_EN)"]
            #[inline(always)]
            pub const fn smb3_rst_en(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "SMB3 Reset Enable (SMB3_RST_EN)"]
            #[inline(always)]
            pub fn set_smb3_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "LED0 Reset Enable (LED0_RST_EN)"]
            #[inline(always)]
            pub const fn led0_rst_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LED0 Reset Enable (LED0_RST_EN)"]
            #[inline(always)]
            pub fn set_led0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "LED1 Reset Enable (LED1_RST_EN)"]
            #[inline(always)]
            pub const fn led1_rst_en(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "LED1 Reset Enable (LED1_RST_EN)"]
            #[inline(always)]
            pub fn set_led1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "LED2 Reset Enable (LED2_RST_EN)"]
            #[inline(always)]
            pub const fn led2_rst_en(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "LED2 Reset Enable (LED2_RST_EN)"]
            #[inline(always)]
            pub fn set_led2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "BC_LINK0 Reset Enable (BC_LINK0_RST_EN)"]
            #[inline(always)]
            pub const fn bc_link0_rst_en(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "BC_LINK0 Reset Enable (BC_LINK0_RST_EN)"]
            #[inline(always)]
            pub fn set_bc_link0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "SMB 4 Reset Enable (SMB_4_RST_EN)"]
            #[inline(always)]
            pub const fn smb_4_rst_en(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "SMB 4 Reset Enable (SMB_4_RST_EN)"]
            #[inline(always)]
            pub fn set_smb_4_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "TIMER16_2 Reset Enable (TIMER16_2_RST_EN)"]
            #[inline(always)]
            pub const fn tmr16_2_rst_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_2 Reset Enable (TIMER16_2_RST_EN)"]
            #[inline(always)]
            pub fn set_tmr16_2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TIMER16_3 Reset Enable (TIMER16_3_RST_EN)"]
            #[inline(always)]
            pub const fn tmr16_3_rst_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_3 Reset Enable (TIMER16_3_RST_EN)"]
            #[inline(always)]
            pub fn set_tmr16_3_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "TIMER32_0 Reset Enable (TIMER32_0_RST_EN)"]
            #[inline(always)]
            pub const fn tmr32_0_rst_en(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0 Reset Enable (TIMER32_0_RST_EN)"]
            #[inline(always)]
            pub fn set_tmr32_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "TIMER32_1 Reset Enable (TIMER32_1_RST_EN)"]
            #[inline(always)]
            pub const fn tmr32_1_rst_en(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1 Reset Enable (TIMER32_1_RST_EN)"]
            #[inline(always)]
            pub fn set_tmr32_1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "LED3 Reset Enable (LED3_RST_EN)"]
            #[inline(always)]
            pub const fn led3_rst_en(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "LED3 Reset Enable (LED3_RST_EN)"]
            #[inline(always)]
            pub fn set_led3_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "PKE Reset Enable"]
            #[inline(always)]
            pub const fn pke_rst_en(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "PKE Reset Enable"]
            #[inline(always)]
            pub fn set_pke_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "RNG Reset Enable"]
            #[inline(always)]
            pub const fn rng_rst_en(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "RNG Reset Enable"]
            #[inline(always)]
            pub fn set_rng_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "AES_HASH Reset Enable"]
            #[inline(always)]
            pub const fn aes_hash_rst_en(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "AES_HASH Reset Enable"]
            #[inline(always)]
            pub fn set_aes_hash_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Hibernation TIMER 1 Reset Enable (HTM_1_RST_EN)"]
            #[inline(always)]
            pub const fn htm_1_rst_en(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation TIMER 1 Reset Enable (HTM_1_RST_EN)"]
            #[inline(always)]
            pub fn set_htm_1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Capture Compare Timer Reset Enable (CCTIMER_RST_EN)"]
            #[inline(always)]
            pub const fn cctimer_rst_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Capture Compare Timer Reset Enable (CCTIMER_RST_EN)"]
            #[inline(always)]
            pub fn set_cctimer_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "PWM9 Reset Enable (PWM9_RST_EN)"]
            #[inline(always)]
            pub const fn pwm9_rst_en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "PWM9 Reset Enable (PWM9_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm9_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for RstEn3 {
            #[inline(always)]
            fn default() -> RstEn3 {
                RstEn3(0)
            }
        }
        impl core::fmt::Debug for RstEn3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn3")
                    .field("adc_rst_en", &self.adc_rst_en())
                    .field("ps2_0_rst_en", &self.ps2_0_rst_en())
                    .field("gpspi_0_rst_en", &self.gpspi_0_rst_en())
                    .field("htm_0_rst_en", &self.htm_0_rst_en())
                    .field("kms_rst_en", &self.kms_rst_en())
                    .field("smb1_rst_en", &self.smb1_rst_en())
                    .field("smb2_rst_en", &self.smb2_rst_en())
                    .field("smb3_rst_en", &self.smb3_rst_en())
                    .field("led0_rst_en", &self.led0_rst_en())
                    .field("led1_rst_en", &self.led1_rst_en())
                    .field("led2_rst_en", &self.led2_rst_en())
                    .field("bc_link0_rst_en", &self.bc_link0_rst_en())
                    .field("smb_4_rst_en", &self.smb_4_rst_en())
                    .field("tmr16_2_rst_en", &self.tmr16_2_rst_en())
                    .field("tmr16_3_rst_en", &self.tmr16_3_rst_en())
                    .field("tmr32_0_rst_en", &self.tmr32_0_rst_en())
                    .field("tmr32_1_rst_en", &self.tmr32_1_rst_en())
                    .field("led3_rst_en", &self.led3_rst_en())
                    .field("pke_rst_en", &self.pke_rst_en())
                    .field("rng_rst_en", &self.rng_rst_en())
                    .field("aes_hash_rst_en", &self.aes_hash_rst_en())
                    .field("htm_1_rst_en", &self.htm_1_rst_en())
                    .field("cctimer_rst_en", &self.cctimer_rst_en())
                    .field("pwm9_rst_en", &self.pwm9_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn3 {{ adc_rst_en: {=bool:?}, ps2_0_rst_en: {=bool:?}, gpspi_0_rst_en: {=bool:?}, htm_0_rst_en: {=bool:?}, kms_rst_en: {=bool:?}, smb1_rst_en: {=bool:?}, smb2_rst_en: {=bool:?}, smb3_rst_en: {=bool:?}, led0_rst_en: {=bool:?}, led1_rst_en: {=bool:?}, led2_rst_en: {=bool:?}, bc_link0_rst_en: {=bool:?}, smb_4_rst_en: {=bool:?}, tmr16_2_rst_en: {=bool:?}, tmr16_3_rst_en: {=bool:?}, tmr32_0_rst_en: {=bool:?}, tmr32_1_rst_en: {=bool:?}, led3_rst_en: {=bool:?}, pke_rst_en: {=bool:?}, rng_rst_en: {=bool:?}, aes_hash_rst_en: {=bool:?}, htm_1_rst_en: {=bool:?}, cctimer_rst_en: {=bool:?}, pwm9_rst_en: {=bool:?} }}" , self . adc_rst_en () , self . ps2_0_rst_en () , self . gpspi_0_rst_en () , self . htm_0_rst_en () , self . kms_rst_en () , self . smb1_rst_en () , self . smb2_rst_en () , self . smb3_rst_en () , self . led0_rst_en () , self . led1_rst_en () , self . led2_rst_en () , self . bc_link0_rst_en () , self . smb_4_rst_en () , self . tmr16_2_rst_en () , self . tmr16_3_rst_en () , self . tmr32_0_rst_en () , self . tmr32_1_rst_en () , self . led3_rst_en () , self . pke_rst_en () , self . rng_rst_en () , self . aes_hash_rst_en () , self . htm_1_rst_en () , self . cctimer_rst_en () , self . pwm9_rst_en ())
            }
        }
        #[doc = "Reset Enable 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn4(pub u32);
        impl RstEn4 {
            #[doc = "PWM10 Reset Enable (PWM10_RST_EN)"]
            #[inline(always)]
            pub const fn pwm10_rst_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PWM10 Reset Enable (PWM10_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm10_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PWM11 Reset Enable (PWM11_RST_EN)"]
            #[inline(always)]
            pub const fn pwm11_rst_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PWM11 Reset Enable (PWM11_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm11_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "RTOS Reset Enable (RTOS_RST_EN)"]
            #[inline(always)]
            pub const fn rtos_rst_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "RTOS Reset Enable (RTOS_RST_EN)"]
            #[inline(always)]
            pub fn set_rtos_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Quad Master SPI Reset Enable"]
            #[inline(always)]
            pub const fn qmspi_rst_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Quad Master SPI Reset Enable"]
            #[inline(always)]
            pub fn set_qmspi_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "RC_ID0 Reset Enable (RC_ID0_RST_EN)"]
            #[inline(always)]
            pub const fn rc_id0_rst_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID0 Reset Enable (RC_ID0_RST_EN)"]
            #[inline(always)]
            pub fn set_rc_id0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "RC_ID1 Reset Enable (RC_ID1_RST_EN)"]
            #[inline(always)]
            pub const fn rc_id1_rst_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID1 Reset Enable (RC_ID1_RST_EN)"]
            #[inline(always)]
            pub fn set_rc_id1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "RC_ID2 Reset Enable (RC_ID2_RST_EN)"]
            #[inline(always)]
            pub const fn rc_id2_rst_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID2 Reset Enable (RC_ID2_RST_EN)"]
            #[inline(always)]
            pub fn set_rc_id2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "SPI SLAVE Reset Enable (SPI_SLAVE_RST_EN)"]
            #[inline(always)]
            pub const fn spi_slave_rst_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "SPI SLAVE Reset Enable (SPI_SLAVE_RST_EN)"]
            #[inline(always)]
            pub fn set_spi_slave_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPSPI 1 Reset Enable (GPSPI_1_RST_EN)"]
            #[inline(always)]
            pub const fn gpspi_1_rst_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPSPI 1 Reset Enable (GPSPI_1_RST_EN)"]
            #[inline(always)]
            pub fn set_gpspi_1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for RstEn4 {
            #[inline(always)]
            fn default() -> RstEn4 {
                RstEn4(0)
            }
        }
        impl core::fmt::Debug for RstEn4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn4")
                    .field("pwm10_rst_en", &self.pwm10_rst_en())
                    .field("pwm11_rst_en", &self.pwm11_rst_en())
                    .field("rtos_rst_en", &self.rtos_rst_en())
                    .field("qmspi_rst_en", &self.qmspi_rst_en())
                    .field("rc_id0_rst_en", &self.rc_id0_rst_en())
                    .field("rc_id1_rst_en", &self.rc_id1_rst_en())
                    .field("rc_id2_rst_en", &self.rc_id2_rst_en())
                    .field("spi_slave_rst_en", &self.spi_slave_rst_en())
                    .field("gpspi_1_rst_en", &self.gpspi_1_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn4 {{ pwm10_rst_en: {=bool:?}, pwm11_rst_en: {=bool:?}, rtos_rst_en: {=bool:?}, qmspi_rst_en: {=bool:?}, rc_id0_rst_en: {=bool:?}, rc_id1_rst_en: {=bool:?}, rc_id2_rst_en: {=bool:?}, spi_slave_rst_en: {=bool:?}, gpspi_1_rst_en: {=bool:?} }}" , self . pwm10_rst_en () , self . pwm11_rst_en () , self . rtos_rst_en () , self . qmspi_rst_en () , self . rc_id0_rst_en () , self . rc_id1_rst_en () , self . rc_id2_rst_en () , self . spi_slave_rst_en () , self . gpspi_1_rst_en ())
            }
        }
        #[doc = "SOFT VBAT Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SftVbatPor(pub u32);
        impl SftVbatPor {
            #[doc = "SOFT VBAT POWER ON RESET."]
            #[inline(always)]
            pub const fn sft_vbat_por(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SOFT VBAT POWER ON RESET."]
            #[inline(always)]
            pub fn set_sft_vbat_por(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SftVbatPor {
            #[inline(always)]
            fn default() -> SftVbatPor {
                SftVbatPor(0)
            }
        }
        impl core::fmt::Debug for SftVbatPor {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SftVbatPor")
                    .field("sft_vbat_por", &self.sft_vbat_por())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SftVbatPor {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SftVbatPor {{ sft_vbat_por: {=bool:?} }}", self.sft_vbat_por())
            }
        }
        #[doc = "Configures the EC_CLK clock domain"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlowClkCtrl(pub u32);
        impl SlowClkCtrl {
            #[doc = "SLOW_CLOCK_DIVIDE. n=Divide by n; 0=Clock off"]
            #[inline(always)]
            pub const fn div(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "SLOW_CLOCK_DIVIDE. n=Divide by n; 0=Clock off"]
            #[inline(always)]
            pub fn set_div(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for SlowClkCtrl {
            #[inline(always)]
            fn default() -> SlowClkCtrl {
                SlowClkCtrl(0)
            }
        }
        impl core::fmt::Debug for SlowClkCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlowClkCtrl").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlowClkCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SlowClkCtrl {{ div: {=u16:?} }}", self.div())
            }
        }
        #[doc = "Sleep Enable 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn0(pub u32);
        impl SlpEn0 {
            #[doc = "OTP Enable"]
            #[inline(always)]
            pub const fn otp_slp_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OTP Enable"]
            #[inline(always)]
            pub fn set_otp_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "IMSPI Sleep Enable"]
            #[inline(always)]
            pub const fn imspi_slp_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "IMSPI Sleep Enable"]
            #[inline(always)]
            pub fn set_imspi_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for SlpEn0 {
            #[inline(always)]
            fn default() -> SlpEn0 {
                SlpEn0(0)
            }
        }
        impl core::fmt::Debug for SlpEn0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn0")
                    .field("otp_slp_en", &self.otp_slp_en())
                    .field("imspi_slp_en", &self.imspi_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SlpEn0 {{ otp_slp_en: {=bool:?}, imspi_slp_en: {=bool:?} }}",
                    self.otp_slp_en(),
                    self.imspi_slp_en()
                )
            }
        }
        #[doc = "Sleep Enable 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn1(pub u32);
        impl SlpEn1 {
            #[doc = "Interrupt Sleep Enable"]
            #[inline(always)]
            pub const fn int_slp_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt Sleep Enable"]
            #[inline(always)]
            pub fn set_int_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PECI Sleep Enable"]
            #[inline(always)]
            pub const fn peci_slp_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PECI Sleep Enable"]
            #[inline(always)]
            pub fn set_peci_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "TACH0 Sleep Enable (TACH0_SLP_EN)"]
            #[inline(always)]
            pub const fn tach0_slp_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "TACH0 Sleep Enable (TACH0_SLP_EN)"]
            #[inline(always)]
            pub fn set_tach0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "PWM0 Sleep Enable (PWM0_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm0_slp_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PWM0 Sleep Enable (PWM0_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "PMC Sleep Enable (PMC_SLP_EN)"]
            #[inline(always)]
            pub const fn pmc_slp_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "PMC Sleep Enable (PMC_SLP_EN)"]
            #[inline(always)]
            pub fn set_pmc_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "DMA Sleep Enable (DMA_SLP_EN)"]
            #[inline(always)]
            pub const fn dma_slp_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA Sleep Enable (DMA_SLP_EN)"]
            #[inline(always)]
            pub fn set_dma_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "TFDP Sleep Enable (TFDP_SLP_EN)"]
            #[inline(always)]
            pub const fn tfdp_slp_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "TFDP Sleep Enable (TFDP_SLP_EN)"]
            #[inline(always)]
            pub fn set_tfdp_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "PROCESSOR Sleep Enable (PROCESSOR_SLP_EN)"]
            #[inline(always)]
            pub const fn proc_slp_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "PROCESSOR Sleep Enable (PROCESSOR_SLP_EN)"]
            #[inline(always)]
            pub fn set_proc_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "SMB0 Sleep Enable (SMB0_SLP_EN)"]
            #[inline(always)]
            pub const fn smb0_slp_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SMB0 Sleep Enable (SMB0_SLP_EN)"]
            #[inline(always)]
            pub fn set_smb0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "TACH1 Sleep Enable (TACH1_SLP_EN)"]
            #[inline(always)]
            pub const fn tach1_slp_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "TACH1 Sleep Enable (TACH1_SLP_EN)"]
            #[inline(always)]
            pub fn set_tach1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "TACH2 Sleep Enable (TACH2_SLP_EN)"]
            #[inline(always)]
            pub const fn tach2_slp_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "TACH2 Sleep Enable (TACH2_SLP_EN)"]
            #[inline(always)]
            pub fn set_tach2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "TACH3 Sleep Enable (TACH3_SLP_EN)"]
            #[inline(always)]
            pub const fn tach3_slp_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "TACH3 Sleep Enable (TACH3_SLP_EN)"]
            #[inline(always)]
            pub fn set_tach3_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "PWM1 Sleep Enable (PWM1_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm1_slp_en(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "PWM1 Sleep Enable (PWM1_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "PWM2 Sleep Enable (PWM2_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm2_slp_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "PWM2 Sleep Enable (PWM2_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "PWM3 Sleep Enable (PWM3_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm3_slp_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "PWM3 Sleep Enable (PWM3_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm3_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "PWM4 Sleep Enable (PWM4_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm4_slp_en(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "PWM4 Sleep Enable (PWM4_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm4_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "PWM5 Sleep Enable (PWM5_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm5_slp_en(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "PWM5 Sleep Enable (PWM5_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm5_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "PWM6 Sleep Enable (PWM6_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm6_slp_en(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "PWM6 Sleep Enable (PWM6_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm6_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "PWM7 Sleep Enable (PWM7_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm7_slp_en(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "PWM7 Sleep Enable (PWM7_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm7_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "PWM8 Sleep Enable (PWM8_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm8_slp_en(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "PWM8 Sleep Enable (PWM8_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm8_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "EC_REG_BANK Sleep Enable (EC_REG_BANK_SLP_EN)"]
            #[inline(always)]
            pub const fn ec_reg_bank_slp_en(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "EC_REG_BANK Sleep Enable (EC_REG_BANK_SLP_EN)"]
            #[inline(always)]
            pub fn set_ec_reg_bank_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "TIMER16_0 Sleep Enable (TIMER16_0_SLP_EN)"]
            #[inline(always)]
            pub const fn tmr16_0_slp_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_0 Sleep Enable (TIMER16_0_SLP_EN)"]
            #[inline(always)]
            pub fn set_tmr16_0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "TIMER16_1 Sleep Enable (TIMER16_1_SLP_EN)"]
            #[inline(always)]
            pub const fn tmr16_1_slp_en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_1 Sleep Enable (TIMER16_1_SLP_EN)"]
            #[inline(always)]
            pub fn set_tmr16_1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for SlpEn1 {
            #[inline(always)]
            fn default() -> SlpEn1 {
                SlpEn1(0)
            }
        }
        impl core::fmt::Debug for SlpEn1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn1")
                    .field("int_slp_en", &self.int_slp_en())
                    .field("peci_slp_en", &self.peci_slp_en())
                    .field("tach0_slp_en", &self.tach0_slp_en())
                    .field("pwm0_slp_en", &self.pwm0_slp_en())
                    .field("pmc_slp_en", &self.pmc_slp_en())
                    .field("dma_slp_en", &self.dma_slp_en())
                    .field("tfdp_slp_en", &self.tfdp_slp_en())
                    .field("proc_slp_en", &self.proc_slp_en())
                    .field("smb0_slp_en", &self.smb0_slp_en())
                    .field("tach1_slp_en", &self.tach1_slp_en())
                    .field("tach2_slp_en", &self.tach2_slp_en())
                    .field("tach3_slp_en", &self.tach3_slp_en())
                    .field("pwm1_slp_en", &self.pwm1_slp_en())
                    .field("pwm2_slp_en", &self.pwm2_slp_en())
                    .field("pwm3_slp_en", &self.pwm3_slp_en())
                    .field("pwm4_slp_en", &self.pwm4_slp_en())
                    .field("pwm5_slp_en", &self.pwm5_slp_en())
                    .field("pwm6_slp_en", &self.pwm6_slp_en())
                    .field("pwm7_slp_en", &self.pwm7_slp_en())
                    .field("pwm8_slp_en", &self.pwm8_slp_en())
                    .field("ec_reg_bank_slp_en", &self.ec_reg_bank_slp_en())
                    .field("tmr16_0_slp_en", &self.tmr16_0_slp_en())
                    .field("tmr16_1_slp_en", &self.tmr16_1_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn1 {{ int_slp_en: {=bool:?}, peci_slp_en: {=bool:?}, tach0_slp_en: {=bool:?}, pwm0_slp_en: {=bool:?}, pmc_slp_en: {=bool:?}, dma_slp_en: {=bool:?}, tfdp_slp_en: {=bool:?}, proc_slp_en: {=bool:?}, smb0_slp_en: {=bool:?}, tach1_slp_en: {=bool:?}, tach2_slp_en: {=bool:?}, tach3_slp_en: {=bool:?}, pwm1_slp_en: {=bool:?}, pwm2_slp_en: {=bool:?}, pwm3_slp_en: {=bool:?}, pwm4_slp_en: {=bool:?}, pwm5_slp_en: {=bool:?}, pwm6_slp_en: {=bool:?}, pwm7_slp_en: {=bool:?}, pwm8_slp_en: {=bool:?}, ec_reg_bank_slp_en: {=bool:?}, tmr16_0_slp_en: {=bool:?}, tmr16_1_slp_en: {=bool:?} }}" , self . int_slp_en () , self . peci_slp_en () , self . tach0_slp_en () , self . pwm0_slp_en () , self . pmc_slp_en () , self . dma_slp_en () , self . tfdp_slp_en () , self . proc_slp_en () , self . smb0_slp_en () , self . tach1_slp_en () , self . tach2_slp_en () , self . tach3_slp_en () , self . pwm1_slp_en () , self . pwm2_slp_en () , self . pwm3_slp_en () , self . pwm4_slp_en () , self . pwm5_slp_en () , self . pwm6_slp_en () , self . pwm7_slp_en () , self . pwm8_slp_en () , self . ec_reg_bank_slp_en () , self . tmr16_0_slp_en () , self . tmr16_1_slp_en ())
            }
        }
        #[doc = "Sleep Enable 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn2(pub u32);
        impl SlpEn2 {
            #[doc = "UART 0 Sleep Enable"]
            #[inline(always)]
            pub const fn uart0_slp_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "UART 0 Sleep Enable"]
            #[inline(always)]
            pub fn set_uart0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "UART 1 Sleep Enable"]
            #[inline(always)]
            pub const fn uart1_slp_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "UART 1 Sleep Enable"]
            #[inline(always)]
            pub fn set_uart1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "eSPI Sleep Enable"]
            #[inline(always)]
            pub const fn espi_slp_en(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "eSPI Sleep Enable"]
            #[inline(always)]
            pub fn set_espi_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "SAF BRIDGE Sleep Enable"]
            #[inline(always)]
            pub const fn saf_brdg_slp_en(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "SAF BRIDGE Sleep Enable"]
            #[inline(always)]
            pub fn set_saf_brdg_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "GLUE Sleep Enable"]
            #[inline(always)]
            pub const fn glue_slp_en(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "GLUE Sleep Enable"]
            #[inline(always)]
            pub fn set_glue_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
        }
        impl Default for SlpEn2 {
            #[inline(always)]
            fn default() -> SlpEn2 {
                SlpEn2(0)
            }
        }
        impl core::fmt::Debug for SlpEn2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn2")
                    .field("uart0_slp_en", &self.uart0_slp_en())
                    .field("uart1_slp_en", &self.uart1_slp_en())
                    .field("espi_slp_en", &self.espi_slp_en())
                    .field("saf_brdg_slp_en", &self.saf_brdg_slp_en())
                    .field("glue_slp_en", &self.glue_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn2 {{ uart0_slp_en: {=bool:?}, uart1_slp_en: {=bool:?}, espi_slp_en: {=bool:?}, saf_brdg_slp_en: {=bool:?}, glue_slp_en: {=bool:?} }}" , self . uart0_slp_en () , self . uart1_slp_en () , self . espi_slp_en () , self . saf_brdg_slp_en () , self . glue_slp_en ())
            }
        }
        #[doc = "Sleep Enable 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn3(pub u32);
        impl SlpEn3 {
            #[doc = "ADC Sleep Enable (ADC_SLP_EN)"]
            #[inline(always)]
            pub const fn adc_slp_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ADC Sleep Enable (ADC_SLP_EN)"]
            #[inline(always)]
            pub fn set_adc_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "PS2_0 Sleep Enable (PS2_0_SLP_EN)"]
            #[inline(always)]
            pub const fn ps2_0_slp_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "PS2_0 Sleep Enable (PS2_0_SLP_EN)"]
            #[inline(always)]
            pub fn set_ps2_0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPSPI 0 Sleep Enable (GPSPI_0_SLP_EN)"]
            #[inline(always)]
            pub const fn gpspi_0_slp_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "GPSPI 0 Sleep Enable (GPSPI_0_SLP_EN)"]
            #[inline(always)]
            pub fn set_gpspi_0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Hibernation Timer 0 Sleep Enable (HTM_0_SLP_EN)"]
            #[inline(always)]
            pub const fn htm_0_slp_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation Timer 0 Sleep Enable (HTM_0_SLP_EN)"]
            #[inline(always)]
            pub fn set_htm_0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "SMB1 Sleep Enable (SMB1_SLP_EN)"]
            #[inline(always)]
            pub const fn smb1_slp_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SMB1 Sleep Enable (SMB1_SLP_EN)"]
            #[inline(always)]
            pub fn set_smb1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SMB2 Sleep Enable (SMB2_SLP_EN)"]
            #[inline(always)]
            pub const fn smb2_slp_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SMB2 Sleep Enable (SMB2_SLP_EN)"]
            #[inline(always)]
            pub fn set_smb2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "SMB3 Sleep Enable (SMB3_SLP_EN)"]
            #[inline(always)]
            pub const fn smb3_slp_en(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "SMB3 Sleep Enable (SMB3_SLP_EN)"]
            #[inline(always)]
            pub fn set_smb3_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "LED0 Sleep Enable (LED0_SLP_EN)"]
            #[inline(always)]
            pub const fn led0_slp_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LED0 Sleep Enable (LED0_SLP_EN)"]
            #[inline(always)]
            pub fn set_led0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "LED1 Sleep Enable (LED1_SLP_EN)"]
            #[inline(always)]
            pub const fn led1_slp_en(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "LED1 Sleep Enable (LED1_SLP_EN)"]
            #[inline(always)]
            pub fn set_led1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "LED2 Sleep Enable (LED2_SLP_EN)"]
            #[inline(always)]
            pub const fn led2_slp_en(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "LED2 Sleep Enable (LED2_SLP_EN)"]
            #[inline(always)]
            pub fn set_led2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "BC_LINK0 Sleep Enable (BC_LINK0_SLP_EN)"]
            #[inline(always)]
            pub const fn bc_link0_slp_en(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "BC_LINK0 Sleep Enable (BC_LINK0_SLP_EN)"]
            #[inline(always)]
            pub fn set_bc_link0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "SMB4 Sleep Enable (SMB4_SLP_EN)"]
            #[inline(always)]
            pub const fn smb4_slp_en(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "SMB4 Sleep Enable (SMB4_SLP_EN)"]
            #[inline(always)]
            pub fn set_smb4_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "TIMER16_2 Sleep Enable (TIMER16_2_SLP_EN)"]
            #[inline(always)]
            pub const fn tmr16_2_slp_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_2 Sleep Enable (TIMER16_2_SLP_EN)"]
            #[inline(always)]
            pub fn set_tmr16_2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TIMER16_3 Sleep Enable (TIMER16_3_SLP_EN)"]
            #[inline(always)]
            pub const fn tmr16_3_slp_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_3 Sleep Enable (TIMER16_3_SLP_EN)"]
            #[inline(always)]
            pub fn set_tmr16_3_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "TIMER32_0 Sleep Enable (TIMER32_0_SLP_EN)"]
            #[inline(always)]
            pub const fn tmr32_0_slp_en(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0 Sleep Enable (TIMER32_0_SLP_EN)"]
            #[inline(always)]
            pub fn set_tmr32_0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "TIMER32_1 Sleep Enable (TIMER32_1_SLP_EN)"]
            #[inline(always)]
            pub const fn tmr32_1_slp_en(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1 Sleep Enable (TIMER32_1_SLP_EN)"]
            #[inline(always)]
            pub fn set_tmr32_1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "LED3 Sleep Enable (LED3_SLP_EN)"]
            #[inline(always)]
            pub const fn led3_slp_en(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "LED3 Sleep Enable (LED3_SLP_EN)"]
            #[inline(always)]
            pub fn set_led3_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "PKE Sleep Enable"]
            #[inline(always)]
            pub const fn pke_slp_en(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "PKE Sleep Enable"]
            #[inline(always)]
            pub fn set_pke_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "RNG Sleep Enable"]
            #[inline(always)]
            pub const fn rng_slp_en(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "RNG Sleep Enable"]
            #[inline(always)]
            pub fn set_rng_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "AES_HASH Sleep Enable"]
            #[inline(always)]
            pub const fn aes_hash_slp_en(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "AES_HASH Sleep Enable"]
            #[inline(always)]
            pub fn set_aes_hash_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Hibernation TIMER 1 Sleep Enable (HTM_1_SLP_EN)"]
            #[inline(always)]
            pub const fn htm_1_slp_en(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation TIMER 1 Sleep Enable (HTM_1_SLP_EN)"]
            #[inline(always)]
            pub fn set_htm_1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Capture Compare Timer Sleep Enable (CCTIMER_SLP_EN)"]
            #[inline(always)]
            pub const fn cct_slp_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Capture Compare Timer Sleep Enable (CCTIMER_SLP_EN)"]
            #[inline(always)]
            pub fn set_cct_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "PWM9 Sleep Enable (PWM9_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm9_slp_en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "PWM9 Sleep Enable (PWM9_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm9_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for SlpEn3 {
            #[inline(always)]
            fn default() -> SlpEn3 {
                SlpEn3(0)
            }
        }
        impl core::fmt::Debug for SlpEn3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn3")
                    .field("adc_slp_en", &self.adc_slp_en())
                    .field("ps2_0_slp_en", &self.ps2_0_slp_en())
                    .field("gpspi_0_slp_en", &self.gpspi_0_slp_en())
                    .field("htm_0_slp_en", &self.htm_0_slp_en())
                    .field("smb1_slp_en", &self.smb1_slp_en())
                    .field("smb2_slp_en", &self.smb2_slp_en())
                    .field("smb3_slp_en", &self.smb3_slp_en())
                    .field("led0_slp_en", &self.led0_slp_en())
                    .field("led1_slp_en", &self.led1_slp_en())
                    .field("led2_slp_en", &self.led2_slp_en())
                    .field("bc_link0_slp_en", &self.bc_link0_slp_en())
                    .field("smb4_slp_en", &self.smb4_slp_en())
                    .field("tmr16_2_slp_en", &self.tmr16_2_slp_en())
                    .field("tmr16_3_slp_en", &self.tmr16_3_slp_en())
                    .field("tmr32_0_slp_en", &self.tmr32_0_slp_en())
                    .field("tmr32_1_slp_en", &self.tmr32_1_slp_en())
                    .field("led3_slp_en", &self.led3_slp_en())
                    .field("pke_slp_en", &self.pke_slp_en())
                    .field("rng_slp_en", &self.rng_slp_en())
                    .field("aes_hash_slp_en", &self.aes_hash_slp_en())
                    .field("htm_1_slp_en", &self.htm_1_slp_en())
                    .field("cct_slp_en", &self.cct_slp_en())
                    .field("pwm9_slp_en", &self.pwm9_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn3 {{ adc_slp_en: {=bool:?}, ps2_0_slp_en: {=bool:?}, gpspi_0_slp_en: {=bool:?}, htm_0_slp_en: {=bool:?}, smb1_slp_en: {=bool:?}, smb2_slp_en: {=bool:?}, smb3_slp_en: {=bool:?}, led0_slp_en: {=bool:?}, led1_slp_en: {=bool:?}, led2_slp_en: {=bool:?}, bc_link0_slp_en: {=bool:?}, smb4_slp_en: {=bool:?}, tmr16_2_slp_en: {=bool:?}, tmr16_3_slp_en: {=bool:?}, tmr32_0_slp_en: {=bool:?}, tmr32_1_slp_en: {=bool:?}, led3_slp_en: {=bool:?}, pke_slp_en: {=bool:?}, rng_slp_en: {=bool:?}, aes_hash_slp_en: {=bool:?}, htm_1_slp_en: {=bool:?}, cct_slp_en: {=bool:?}, pwm9_slp_en: {=bool:?} }}" , self . adc_slp_en () , self . ps2_0_slp_en () , self . gpspi_0_slp_en () , self . htm_0_slp_en () , self . smb1_slp_en () , self . smb2_slp_en () , self . smb3_slp_en () , self . led0_slp_en () , self . led1_slp_en () , self . led2_slp_en () , self . bc_link0_slp_en () , self . smb4_slp_en () , self . tmr16_2_slp_en () , self . tmr16_3_slp_en () , self . tmr32_0_slp_en () , self . tmr32_1_slp_en () , self . led3_slp_en () , self . pke_slp_en () , self . rng_slp_en () , self . aes_hash_slp_en () , self . htm_1_slp_en () , self . cct_slp_en () , self . pwm9_slp_en ())
            }
        }
        #[doc = "Sleep Enable 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn4(pub u32);
        impl SlpEn4 {
            #[doc = "PWM10 Sleep Enable (PWM10_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm10_slp_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PWM10 Sleep Enable (PWM10_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm10_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PWM11 Sleep Enable (PWM11_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm11_slp_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PWM11 Sleep Enable (PWM11_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm11_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Quad Master SPI Sleep Enable"]
            #[inline(always)]
            pub const fn qmspi_slp_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Quad Master SPI Sleep Enable"]
            #[inline(always)]
            pub fn set_qmspi_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "RC_ID0 Sleep Enable (RC_ID0_SLP_EN)"]
            #[inline(always)]
            pub const fn rc_id0_slp_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID0 Sleep Enable (RC_ID0_SLP_EN)"]
            #[inline(always)]
            pub fn set_rc_id0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "RC_ID1 Sleep Enable (RC_ID1_SLP_EN)"]
            #[inline(always)]
            pub const fn rc_id1_slp_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID1 Sleep Enable (RC_ID1_SLP_EN)"]
            #[inline(always)]
            pub fn set_rc_id1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "RC_ID2 Sleep Enable (RC_ID2_SLP_EN)"]
            #[inline(always)]
            pub const fn rc_id2_slp_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID2 Sleep Enable (RC_ID2_SLP_EN)"]
            #[inline(always)]
            pub fn set_rc_id2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "GPSPI 1 Sleep Enable (GPSPI_1_SLP_EN)"]
            #[inline(always)]
            pub const fn gpspi_1_slp_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPSPI 1 Sleep Enable (GPSPI_1_SLP_EN)"]
            #[inline(always)]
            pub fn set_gpspi_1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for SlpEn4 {
            #[inline(always)]
            fn default() -> SlpEn4 {
                SlpEn4(0)
            }
        }
        impl core::fmt::Debug for SlpEn4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn4")
                    .field("pwm10_slp_en", &self.pwm10_slp_en())
                    .field("pwm11_slp_en", &self.pwm11_slp_en())
                    .field("qmspi_slp_en", &self.qmspi_slp_en())
                    .field("rc_id0_slp_en", &self.rc_id0_slp_en())
                    .field("rc_id1_slp_en", &self.rc_id1_slp_en())
                    .field("rc_id2_slp_en", &self.rc_id2_slp_en())
                    .field("gpspi_1_slp_en", &self.gpspi_1_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn4 {{ pwm10_slp_en: {=bool:?}, pwm11_slp_en: {=bool:?}, qmspi_slp_en: {=bool:?}, rc_id0_slp_en: {=bool:?}, rc_id1_slp_en: {=bool:?}, rc_id2_slp_en: {=bool:?}, gpspi_1_slp_en: {=bool:?} }}" , self . pwm10_slp_en () , self . pwm11_slp_en () , self . qmspi_slp_en () , self . rc_id0_slp_en () , self . rc_id1_slp_en () , self . rc_id2_slp_en () , self . gpspi_1_slp_en ())
            }
        }
        #[doc = "System Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SysRst(pub u32);
        impl SysRst {
            #[doc = "A write of a 1 forces an assertion of the RESET_SYS reset signal, resetting the device. A write of 0 has no effect."]
            #[inline(always)]
            pub const fn soft_sys_rst(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 forces an assertion of the RESET_SYS reset signal, resetting the device. A write of 0 has no effect."]
            #[inline(always)]
            pub fn set_soft_sys_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for SysRst {
            #[inline(always)]
            fn default() -> SysRst {
                SysRst(0)
            }
        }
        impl core::fmt::Debug for SysRst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SysRst")
                    .field("soft_sys_rst", &self.soft_sys_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SysRst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SysRst {{ soft_sys_rst: {=bool:?} }}", self.soft_sys_rst())
            }
        }
        #[doc = "System Sleep Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SysSlpCtrl(pub u32);
        impl SysSlpCtrl {
            #[doc = "Selects the System Sleep mode"]
            #[inline(always)]
            pub const fn sl_mod(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects the System Sleep mode"]
            #[inline(always)]
            pub fn set_sl_mod(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Regulator Standby Enable"]
            #[inline(always)]
            pub const fn reg_stndby_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Regulator Standby Enable"]
            #[inline(always)]
            pub fn set_reg_stndby_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Initiates the System Sleep mode"]
            #[inline(always)]
            pub const fn slp_all(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Initiates the System Sleep mode"]
            #[inline(always)]
            pub fn set_slp_all(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for SysSlpCtrl {
            #[inline(always)]
            fn default() -> SysSlpCtrl {
                SysSlpCtrl(0)
            }
        }
        impl core::fmt::Debug for SysSlpCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SysSlpCtrl")
                    .field("sl_mod", &self.sl_mod())
                    .field("reg_stndby_en", &self.reg_stndby_en())
                    .field("slp_all", &self.slp_all())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SysSlpCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SysSlpCtrl {{ sl_mod: {=bool:?}, reg_stndby_en: {=bool:?}, slp_all: {=bool:?} }}",
                    self.sl_mod(),
                    self.reg_stndby_en(),
                    self.slp_all()
                )
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Div(u8);
        impl Div {
            #[doc = "1: divide 48 MHz Ring Oscillator by 1"]
            pub const DIVIDE_BY_1: Self = Self(0x01);
            #[doc = "3: divide 48 MHz Ring Oscillator by 3"]
            pub const DIVIDE_BY_3: Self = Self(0x03);
            #[doc = "4: divide 48 MHz Ring Oscillator by 4"]
            pub const DIVIDE_BY_4: Self = Self(0x04);
            #[doc = "16: divide 48 MHz Ring Oscillator by 16"]
            pub const DIVIDE_BY_16: Self = Self(0x10);
            #[doc = "48: divide 48 MHz Ring Oscillator by 48"]
            pub const DIVIDE_BY_48: Self = Self(0x30);
        }
        impl Div {
            pub const fn from_bits(val: u8) -> Div {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Div {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x01 => f.write_str("DIVIDE_BY_1"),
                    0x03 => f.write_str("DIVIDE_BY_3"),
                    0x04 => f.write_str("DIVIDE_BY_4"),
                    0x10 => f.write_str("DIVIDE_BY_16"),
                    0x30 => f.write_str("DIVIDE_BY_48"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Div {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x01 => defmt::write!(f, "DIVIDE_BY_1"),
                    0x03 => defmt::write!(f, "DIVIDE_BY_3"),
                    0x04 => defmt::write!(f, "DIVIDE_BY_4"),
                    0x10 => defmt::write!(f, "DIVIDE_BY_16"),
                    0x30 => defmt::write!(f, "DIVIDE_BY_48"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Div {
            #[inline(always)]
            fn from(val: u8) -> Div {
                Div::from_bits(val)
            }
        }
        impl From<Div> for u8 {
            #[inline(always)]
            fn from(val: Div) -> u8 {
                Div::to_bits(val)
            }
        }
    }
}
pub mod peci {
    #[doc = "The PECI Interface allows the EC to retrieve temperature readings from PECI-compliant devices."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Peci {
        ptr: *mut u8,
    }
    unsafe impl Send for Peci {}
    unsafe impl Sync for Peci {}
    impl Peci {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The Write Data Register provides access to a 32-byte Transmit FIFO."]
        #[inline(always)]
        pub const fn wdata(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "The Read Data Register provides access to a 32-byte Receive FIFO."]
        #[inline(always)]
        pub const fn rdata(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Status Register 1"]
        #[inline(always)]
        pub const fn sts1(self) -> crate::common::Reg<regs::Sts1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Status Register 2"]
        #[inline(always)]
        pub const fn sts2(self) -> crate::common::Reg<regs::Sts2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Error Register"]
        #[inline(always)]
        pub const fn error(self) -> crate::common::Reg<regs::Error, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Interrupt Enable 1 Register"]
        #[inline(always)]
        pub const fn ien1(self) -> crate::common::Reg<regs::Ien1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Interrupt Enable 2 Register"]
        #[inline(always)]
        pub const fn ien2(self) -> crate::common::Reg<regs::Ien2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Optimal Bit Time Register (Low Byte)"]
        #[inline(always)]
        pub const fn optbtlo(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Optimal Bit Time Register (High Byte)"]
        #[inline(always)]
        pub const fn optbthi(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Baud Control Register. The baud div value divides down the sytem clock frequency to create the peci CORE_CLK frequency."]
        #[inline(always)]
        pub const fn bdctrl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Block ID Register"]
        #[inline(always)]
        pub const fn blkid(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Revision Register"]
        #[inline(always)]
        pub const fn blkrev(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u8);
        impl Ctrl {
            #[doc = "PD (Power Down) along with RST controls the Power Management Interface"]
            #[inline(always)]
            pub const fn pd(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PD (Power Down) along with RST controls the Power Management Interface"]
            #[inline(always)]
            pub fn set_pd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "RST indicates that the PECI Core should be reset."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "RST indicates that the PECI Core should be reset."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "FRST is the FIFO Reset bit."]
            #[inline(always)]
            pub const fn frst(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "FRST is the FIFO Reset bit."]
            #[inline(always)]
            pub fn set_frst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "TXEN is the Transmit Enable bit."]
            #[inline(always)]
            pub const fn txen(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "TXEN is the Transmit Enable bit."]
            #[inline(always)]
            pub fn set_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "MIEN is the Master Interrupt Enable"]
            #[inline(always)]
            pub const fn mien(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "MIEN is the Master Interrupt Enable"]
            #[inline(always)]
            pub fn set_mien(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("pd", &self.pd())
                    .field("rst", &self.rst())
                    .field("frst", &self.frst())
                    .field("txen", &self.txen())
                    .field("mien", &self.mien())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl {{ pd: {=bool:?}, rst: {=bool:?}, frst: {=bool:?}, txen: {=bool:?}, mien: {=bool:?} }}",
                    self.pd(),
                    self.rst(),
                    self.frst(),
                    self.txen(),
                    self.mien()
                )
            }
        }
        #[doc = "Error Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Error(pub u8);
        impl Error {
            #[doc = "FERR (Frame Check Sequence Error). (R/WC)"]
            #[inline(always)]
            pub const fn ferr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "FERR (Frame Check Sequence Error). (R/WC)"]
            #[inline(always)]
            pub fn set_ferr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "BERR (Bus Error). Bus contention has been detected. BERR is asserted when the PECI Module reads a value that is different from what it has driven (R/WC)"]
            #[inline(always)]
            pub const fn berr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "BERR (Bus Error). Bus contention has been detected. BERR is asserted when the PECI Module reads a value that is different from what it has driven (R/WC)"]
            #[inline(always)]
            pub fn set_berr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "REQERR is asserted if PEC_AVAILABLE (READY) input is not asserted when the counts down to zero as shown in. When asserted, REQERR can generate interrupt. (R/WC)"]
            #[inline(always)]
            pub const fn reqerr(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "REQERR is asserted if PEC_AVAILABLE (READY) input is not asserted when the counts down to zero as shown in. When asserted, REQERR can generate interrupt. (R/WC)"]
            #[inline(always)]
            pub fn set_reqerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "WROV (Write Overrun). (R/WC)"]
            #[inline(always)]
            pub const fn wrov(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "WROV (Write Overrun). (R/WC)"]
            #[inline(always)]
            pub fn set_wrov(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "WRUN (Write Underrun). (R/WC)"]
            #[inline(always)]
            pub const fn wrun(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "WRUN (Write Underrun). (R/WC)"]
            #[inline(always)]
            pub fn set_wrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "RDOV (Read Overrun). RDOV indicates that the internal read buffer has overflowed (R/WC)"]
            #[inline(always)]
            pub const fn rdov(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "RDOV (Read Overrun). RDOV indicates that the internal read buffer has overflowed (R/WC)"]
            #[inline(always)]
            pub fn set_rdov(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "CLKERR indicates that the READY signal function in the Hardware Interface was de-asserted in the middle of a transaction (R/WC)"]
            #[inline(always)]
            pub const fn clkerr(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "CLKERR indicates that the READY signal function in the Hardware Interface was de-asserted in the middle of a transaction (R/WC)"]
            #[inline(always)]
            pub fn set_clkerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Error {
            #[inline(always)]
            fn default() -> Error {
                Error(0)
            }
        }
        impl core::fmt::Debug for Error {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Error")
                    .field("ferr", &self.ferr())
                    .field("berr", &self.berr())
                    .field("reqerr", &self.reqerr())
                    .field("wrov", &self.wrov())
                    .field("wrun", &self.wrun())
                    .field("rdov", &self.rdov())
                    .field("clkerr", &self.clkerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Error {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Error {{ ferr: {=bool:?}, berr: {=bool:?}, reqerr: {=bool:?}, wrov: {=bool:?}, wrun: {=bool:?}, rdov: {=bool:?}, clkerr: {=bool:?} }}" , self . ferr () , self . berr () , self . reqerr () , self . wrov () , self . wrun () , self . rdov () , self . clkerr ())
            }
        }
        #[doc = "Interrupt Enable 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien1(pub u8);
        impl Ien1 {
            #[doc = "When the BIEN bit is asserted '1' the BOF interrupt is enabled."]
            #[inline(always)]
            pub const fn bien(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When the BIEN bit is asserted '1' the BOF interrupt is enabled."]
            #[inline(always)]
            pub fn set_bien(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "When the EIEN bit is asserted '1' the EOF interrupt is enabled."]
            #[inline(always)]
            pub const fn eien(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When the EIEN bit is asserted '1' the EOF interrupt is enabled."]
            #[inline(always)]
            pub fn set_eien(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "When the EREN bit is asserted '1' the ERR interrupt is enabled."]
            #[inline(always)]
            pub const fn eren(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "When the EREN bit is asserted '1' the ERR interrupt is enabled."]
            #[inline(always)]
            pub fn set_eren(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "When the RLEN bit is asserted '1' the RDYLO interrupt is enabled."]
            #[inline(always)]
            pub const fn rlen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When the RLEN bit is asserted '1' the RDYLO interrupt is enabled."]
            #[inline(always)]
            pub fn set_rlen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "When the RHEN bit is asserted '1' the RDYHI interrupt is enabled."]
            #[inline(always)]
            pub const fn rhen(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When the RHEN bit is asserted '1' the RDYHI interrupt is enabled."]
            #[inline(always)]
            pub fn set_rhen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Ien1 {
            #[inline(always)]
            fn default() -> Ien1 {
                Ien1(0)
            }
        }
        impl core::fmt::Debug for Ien1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien1")
                    .field("bien", &self.bien())
                    .field("eien", &self.eien())
                    .field("eren", &self.eren())
                    .field("rlen", &self.rlen())
                    .field("rhen", &self.rhen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien1 {{ bien: {=bool:?}, eien: {=bool:?}, eren: {=bool:?}, rlen: {=bool:?}, rhen: {=bool:?} }}",
                    self.bien(),
                    self.eien(),
                    self.eren(),
                    self.rlen(),
                    self.rhen()
                )
            }
        }
        #[doc = "Interrupt Enable 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien2(pub u8);
        impl Ien2 {
            #[doc = "When the ENWFE bit is asserted '1' the WFE interrupt is enabled."]
            #[inline(always)]
            pub const fn enwfe(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When the ENWFE bit is asserted '1' the WFE interrupt is enabled."]
            #[inline(always)]
            pub fn set_enwfe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "When the ENRFF bit is asserted '1' the RFF interrupt is enabled."]
            #[inline(always)]
            pub const fn enrff(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "When the ENRFF bit is asserted '1' the RFF interrupt is enabled."]
            #[inline(always)]
            pub fn set_enrff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ien2 {
            #[inline(always)]
            fn default() -> Ien2 {
                Ien2(0)
            }
        }
        impl core::fmt::Debug for Ien2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien2")
                    .field("enwfe", &self.enwfe())
                    .field("enrff", &self.enrff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien2 {{ enwfe: {=bool:?}, enrff: {=bool:?} }}",
                    self.enwfe(),
                    self.enrff()
                )
            }
        }
        #[doc = "Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts1(pub u8);
        impl Sts1 {
            #[doc = "BOF (Beginning of Frame) is asserted when the PECI Core begins Address Timing Negotiation. (R/WC)"]
            #[inline(always)]
            pub const fn bof(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "BOF (Beginning of Frame) is asserted when the PECI Core begins Address Timing Negotiation. (R/WC)"]
            #[inline(always)]
            pub fn set_bof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "EOF (End of Frame) is asserted following Message Stop (tSTOP). (R/WC)"]
            #[inline(always)]
            pub const fn eof(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "EOF (End of Frame) is asserted following Message Stop (tSTOP). (R/WC)"]
            #[inline(always)]
            pub fn set_eof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "ERR Indicates that an error for the current transaction has been detected."]
            #[inline(always)]
            pub const fn err(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "ERR Indicates that an error for the current transaction has been detected."]
            #[inline(always)]
            pub fn set_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "RDY represents the state of the READY signal function"]
            #[inline(always)]
            pub const fn rdy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "RDY represents the state of the READY signal function"]
            #[inline(always)]
            pub fn set_rdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "RDYLO is asserted '1' on the falling edge of the READY signal function (R/WC)"]
            #[inline(always)]
            pub const fn rdylo(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "RDYLO is asserted '1' on the falling edge of the READY signal function (R/WC)"]
            #[inline(always)]
            pub fn set_rdylo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "RDYHI is asserted '1' on the rising edge of the READY signal function (R/WC)"]
            #[inline(always)]
            pub const fn rdyhi(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "RDYHI is asserted '1' on the rising edge of the READY signal function (R/WC)"]
            #[inline(always)]
            pub fn set_rdyhi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "MINT is the Master Interrupt Status bit and is asserted when any interrupt status bit in the Interrupt Interface is asserted."]
            #[inline(always)]
            pub const fn mint(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "MINT is the Master Interrupt Status bit and is asserted when any interrupt status bit in the Interrupt Interface is asserted."]
            #[inline(always)]
            pub fn set_mint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Sts1 {
            #[inline(always)]
            fn default() -> Sts1 {
                Sts1(0)
            }
        }
        impl core::fmt::Debug for Sts1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts1")
                    .field("bof", &self.bof())
                    .field("eof", &self.eof())
                    .field("err", &self.err())
                    .field("rdy", &self.rdy())
                    .field("rdylo", &self.rdylo())
                    .field("rdyhi", &self.rdyhi())
                    .field("mint", &self.mint())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sts1 {{ bof: {=bool:?}, eof: {=bool:?}, err: {=bool:?}, rdy: {=bool:?}, rdylo: {=bool:?}, rdyhi: {=bool:?}, mint: {=bool:?} }}" , self . bof () , self . eof () , self . err () , self . rdy () , self . rdylo () , self . rdyhi () , self . mint ())
            }
        }
        #[doc = "Status Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts2(pub u8);
        impl Sts2 {
            #[doc = "WFF indicates that the Write Data Register FIFO is full. WFF does not generate an interrupt."]
            #[inline(always)]
            pub const fn wff(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "WFF indicates that the Write Data Register FIFO is full. WFF does not generate an interrupt."]
            #[inline(always)]
            pub fn set_wff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "WFE indicates that the Write Data Register FIFO is empty."]
            #[inline(always)]
            pub const fn wfe(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "WFE indicates that the Write Data Register FIFO is empty."]
            #[inline(always)]
            pub fn set_wfe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "RFF indicates that the Read Data Register FIFO is full."]
            #[inline(always)]
            pub const fn rff(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RFF indicates that the Read Data Register FIFO is full."]
            #[inline(always)]
            pub fn set_rff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "RFE indicates that the Read Data Register FIFO is empty. RFE does not generate an interrupt."]
            #[inline(always)]
            pub const fn rfe(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "RFE indicates that the Read Data Register FIFO is empty. RFE does not generate an interrupt."]
            #[inline(always)]
            pub fn set_rfe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "The IDLE status bit indicates when the SST/PECI bus is idle and a new transaction may begin."]
            #[inline(always)]
            pub const fn idle(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The IDLE status bit indicates when the SST/PECI bus is idle and a new transaction may begin."]
            #[inline(always)]
            pub fn set_idle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Sts2 {
            #[inline(always)]
            fn default() -> Sts2 {
                Sts2(0)
            }
        }
        impl core::fmt::Debug for Sts2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts2")
                    .field("wff", &self.wff())
                    .field("wfe", &self.wfe())
                    .field("rff", &self.rff())
                    .field("rfe", &self.rfe())
                    .field("idle", &self.idle())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sts2 {{ wff: {=bool:?}, wfe: {=bool:?}, rff: {=bool:?}, rfe: {=bool:?}, idle: {=bool:?} }}",
                    self.wff(),
                    self.wfe(),
                    self.rff(),
                    self.rfe(),
                    self.idle()
                )
            }
        }
    }
}
pub mod phot {
    #[doc = "This block monitors the PROCHOT# signal and designed to detect single assertions and monitor cumulative PROCHOT active time."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Phot {
        ptr: *mut u8,
    }
    unsafe impl Send for Phot {}
    unsafe impl Sync for Phot {}
    impl Phot {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "PROCHOT Cumulative Count Register"]
        #[inline(always)]
        pub const fn cucnt(self) -> crate::common::Reg<regs::Cucnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "PROCHOT Duty Cycle Count Register"]
        #[inline(always)]
        pub const fn dc_cnt(self) -> crate::common::Reg<regs::DcCnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "PROCHOT Duty Cycle Period Register"]
        #[inline(always)]
        pub const fn dc_per(self) -> crate::common::Reg<regs::DcPer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "PROCHOT Status/Control Register"]
        #[inline(always)]
        pub const fn ctrl_sts(self) -> crate::common::Reg<regs::CtrlSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "PROCHOT Assertion Counter Register"]
        #[inline(always)]
        pub const fn ascnt(self) -> crate::common::Reg<regs::Ascnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "PROCHOT Assertion Counter Register"]
        #[inline(always)]
        pub const fn asclim(self) -> crate::common::Reg<regs::Asclim, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "PROCHOT Assertion Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Asclim(pub u32);
        impl Asclim {
            #[doc = "The PROCHOT Assertion Counter Limit register is compared to the 16-bit PROCHOT Assertion Counter."]
            #[inline(always)]
            pub const fn clim(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "The PROCHOT Assertion Counter Limit register is compared to the 16-bit PROCHOT Assertion Counter."]
            #[inline(always)]
            pub fn set_clim(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Asclim {
            #[inline(always)]
            fn default() -> Asclim {
                Asclim(0)
            }
        }
        impl core::fmt::Debug for Asclim {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Asclim").field("clim", &self.clim()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Asclim {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Asclim {{ clim: {=u16:?} }}", self.clim())
            }
        }
        #[doc = "PROCHOT Assertion Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ascnt(pub u32);
        impl Ascnt {
            #[doc = "The PROCHOT Assertion Counter is a 16-bit up-counter that is clocked by the 100KHz and is gated and reset by the PROCHOT# input signal. This counter is used to measure a single PROCHOT assertion."]
            #[inline(always)]
            pub const fn cnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "The PROCHOT Assertion Counter is a 16-bit up-counter that is clocked by the 100KHz and is gated and reset by the PROCHOT# input signal. This counter is used to measure a single PROCHOT assertion."]
            #[inline(always)]
            pub fn set_cnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Ascnt {
            #[inline(always)]
            fn default() -> Ascnt {
                Ascnt(0)
            }
        }
        impl core::fmt::Debug for Ascnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ascnt").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ascnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ascnt {{ cnt: {=u16:?} }}", self.cnt())
            }
        }
        #[doc = "PROCHOT Status/Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CtrlSts(pub u32);
        impl CtrlSts {
            #[doc = "This bit enables the PROCHOT Monitor logic."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the PROCHOT Monitor logic."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When PHOT_ENABLE is 1b, this bit reflects the state of the PROCHOT# Pin input."]
            #[inline(always)]
            pub const fn pin(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When PHOT_ENABLE is 1b, this bit reflects the state of the PROCHOT# Pin input."]
            #[inline(always)]
            pub fn set_pin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit determines whether or not an interrupt will be generated when the PHOT_ASSERT bit is set."]
            #[inline(always)]
            pub const fn assert_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit determines whether or not an interrupt will be generated when the PHOT_ASSERT bit is set."]
            #[inline(always)]
            pub fn set_assert_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit determines whether or not an interrupt will be generated when the PHOT_PERIOD bit is set."]
            #[inline(always)]
            pub const fn per_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit determines whether or not an interrupt will be generated when the PHOT_PERIOD bit is set."]
            #[inline(always)]
            pub fn set_per_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Writing this self-clearing bit to one resets all the registers and logic in the PROCHOT Monitor block to its defined initial state."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Writing this self-clearing bit to one resets all the registers and logic in the PROCHOT Monitor block to its defined initial state."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit determines whether a digital filter eliminates pulses on the PROCHOT# signal before PROCHOT# is sampled by the Assertion counter or the Active counter."]
            #[inline(always)]
            pub const fn filt_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit determines whether a digital filter eliminates pulses on the PROCHOT# signal before PROCHOT# is sampled by the Assertion counter or the Active counter."]
            #[inline(always)]
            pub fn set_filt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit is set when the PROCHOT Assertion Counter Register value is greater than or equal to the PROCHOT Assertion Counter Limit Register value. (R/WC)"]
            #[inline(always)]
            pub const fn assert(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the PROCHOT Assertion Counter Register value is greater than or equal to the PROCHOT Assertion Counter Limit Register value. (R/WC)"]
            #[inline(always)]
            pub fn set_assert(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This sticky status bit is set to '1b' when the PROCHOT Period Counter transitions from '1b' to '0b.' (R/WC)"]
            #[inline(always)]
            pub const fn per(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "This sticky status bit is set to '1b' when the PROCHOT Period Counter transitions from '1b' to '0b.' (R/WC)"]
            #[inline(always)]
            pub fn set_per(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for CtrlSts {
            #[inline(always)]
            fn default() -> CtrlSts {
                CtrlSts(0)
            }
        }
        impl core::fmt::Debug for CtrlSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CtrlSts")
                    .field("en", &self.en())
                    .field("pin", &self.pin())
                    .field("assert_en", &self.assert_en())
                    .field("per_en", &self.per_en())
                    .field("rst", &self.rst())
                    .field("filt_en", &self.filt_en())
                    .field("assert", &self.assert())
                    .field("per", &self.per())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CtrlSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CtrlSts {{ en: {=bool:?}, pin: {=bool:?}, assert_en: {=bool:?}, per_en: {=bool:?}, rst: {=bool:?}, filt_en: {=bool:?}, assert: {=bool:?}, per: {=bool:?} }}" , self . en () , self . pin () , self . assert_en () , self . per_en () , self . rst () , self . filt_en () , self . assert () , self . per ())
            }
        }
        #[doc = "PROCHOT Cumulative Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cucnt(pub u32);
        impl Cucnt {
            #[doc = "This register contains the current filtered PROCHOT Active Counter value."]
            #[inline(always)]
            pub const fn active(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "This register contains the current filtered PROCHOT Active Counter value."]
            #[inline(always)]
            pub fn set_active(&mut self, val: u32) {
                self.0 = (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Cucnt {
            #[inline(always)]
            fn default() -> Cucnt {
                Cucnt(0)
            }
        }
        impl core::fmt::Debug for Cucnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cucnt").field("active", &self.active()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cucnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cucnt {{ active: {=u32:?} }}", self.active())
            }
        }
        #[doc = "PROCHOT Duty Cycle Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DcCnt(pub u32);
        impl DcCnt {
            #[doc = "The contents of the PROCHOT Cumulative Count Register is copied into this register when the PROCHOT Duty Cycle Period Register transitions from 1 to 0."]
            #[inline(always)]
            pub const fn cnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "The contents of the PROCHOT Cumulative Count Register is copied into this register when the PROCHOT Duty Cycle Period Register transitions from 1 to 0."]
            #[inline(always)]
            pub fn set_cnt(&mut self, val: u32) {
                self.0 = (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for DcCnt {
            #[inline(always)]
            fn default() -> DcCnt {
                DcCnt(0)
            }
        }
        impl core::fmt::Debug for DcCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DcCnt").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DcCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DcCnt {{ cnt: {=u32:?} }}", self.cnt())
            }
        }
        #[doc = "PROCHOT Duty Cycle Period Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DcPer(pub u32);
        impl DcPer {
            #[doc = "This register defines the number of 100KHz periods required for a duty cycle measurement."]
            #[inline(always)]
            pub const fn per(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "This register defines the number of 100KHz periods required for a duty cycle measurement."]
            #[inline(always)]
            pub fn set_per(&mut self, val: u32) {
                self.0 = (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for DcPer {
            #[inline(always)]
            fn default() -> DcPer {
                DcPer(0)
            }
        }
        impl core::fmt::Debug for DcPer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DcPer").field("per", &self.per()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DcPer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DcPer {{ per: {=u32:?} }}", self.per())
            }
        }
    }
}
pub mod pm1 {
    #[doc = "These features comply with the ACPI Specification through a combination of hardware and EC software."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pm1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Pm1 {}
    unsafe impl Sync for Pm1 {}
    impl Pm1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "PM1 Status 2"]
        #[inline(always)]
        pub const fn h_pm1_sts2(self) -> crate::common::Reg<regs::Hpm1sts2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "PM1 Enable 2"]
        #[inline(always)]
        pub const fn h_pm1_en2(self) -> crate::common::Reg<regs::Hpm1en2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "PM1 Control 2"]
        #[inline(always)]
        pub const fn h_pm1_ctrl2(self) -> crate::common::Reg<regs::Hpm1ctrl2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "PM1 Status 2"]
        #[inline(always)]
        pub const fn ec_pm1_sts2(self) -> crate::common::Reg<regs::EcPm1sts2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0101usize) as _) }
        }
        #[doc = "PM1 Enable 2"]
        #[inline(always)]
        pub const fn ec_pm1_en2(self) -> crate::common::Reg<regs::EcPm1en2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0103usize) as _) }
        }
        #[doc = "PM1 Control 2"]
        #[inline(always)]
        pub const fn ec_pm1_ctrl2(self) -> crate::common::Reg<regs::EcPm1ctrl2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0105usize) as _) }
        }
        #[doc = "PM1 EC PM Status"]
        #[inline(always)]
        pub const fn ec_pm_sts(self) -> crate::common::Reg<regs::EcPmSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "PM1 Control 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcPm1ctrl2(pub u8);
        impl EcPm1ctrl2 {
            #[doc = "This bit can be set or cleared by the Host, read by the EC."]
            #[inline(always)]
            pub const fn pwrbtnor_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the Host, read by the EC."]
            #[inline(always)]
            pub fn set_pwrbtnor_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits can be set or cleared by the Host, read by the EC."]
            #[inline(always)]
            pub const fn slp_typ(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x07;
                val as u8
            }
            #[doc = "These bits can be set or cleared by the Host, read by the EC."]
            #[inline(always)]
            pub fn set_slp_typ(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val as u8) & 0x07) << 2usize);
            }
            #[doc = "SLP_EN"]
            #[inline(always)]
            pub const fn slp_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "SLP_EN"]
            #[inline(always)]
            pub fn set_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
        }
        impl Default for EcPm1ctrl2 {
            #[inline(always)]
            fn default() -> EcPm1ctrl2 {
                EcPm1ctrl2(0)
            }
        }
        impl core::fmt::Debug for EcPm1ctrl2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcPm1ctrl2")
                    .field("pwrbtnor_en", &self.pwrbtnor_en())
                    .field("slp_typ", &self.slp_typ())
                    .field("slp_en", &self.slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcPm1ctrl2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcPm1ctrl2 {{ pwrbtnor_en: {=bool:?}, slp_typ: {=u8:?}, slp_en: {=bool:?} }}",
                    self.pwrbtnor_en(),
                    self.slp_typ(),
                    self.slp_en()
                )
            }
        }
        #[doc = "PM1 Enable 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcPm1en2(pub u8);
        impl EcPm1en2 {
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub const fn pwrbtn_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub fn set_pwrbtn_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub const fn slpbtn_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub fn set_slpbtn_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub const fn rtc_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub fn set_rtc_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for EcPm1en2 {
            #[inline(always)]
            fn default() -> EcPm1en2 {
                EcPm1en2(0)
            }
        }
        impl core::fmt::Debug for EcPm1en2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcPm1en2")
                    .field("pwrbtn_en", &self.pwrbtn_en())
                    .field("slpbtn_en", &self.slpbtn_en())
                    .field("rtc_en", &self.rtc_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcPm1en2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcPm1en2 {{ pwrbtn_en: {=bool:?}, slpbtn_en: {=bool:?}, rtc_en: {=bool:?} }}",
                    self.pwrbtn_en(),
                    self.slpbtn_en(),
                    self.rtc_en()
                )
            }
        }
        #[doc = "PM1 Status 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcPm1sts2(pub u8);
        impl EcPm1sts2 {
            #[doc = "This bit can be set or cleared by the EC to simulate a Power button status if the power is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)"]
            #[inline(always)]
            pub const fn pwrbtn_sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a Power button status if the power is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)"]
            #[inline(always)]
            pub fn set_pwrbtn_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a Sleep button status if the sleep state is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control.(R/WC)"]
            #[inline(always)]
            pub const fn slpbtn_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a Sleep button status if the sleep state is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control.(R/WC)"]
            #[inline(always)]
            pub fn set_slpbtn_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a RTC status. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)"]
            #[inline(always)]
            pub const fn rtc_sts(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a RTC status. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)"]
            #[inline(always)]
            pub fn set_rtc_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a Power button override event status if the power is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated hardware event under software control.(R/WC)"]
            #[inline(always)]
            pub const fn pwrbtnor_sts(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a Power button override event status if the power is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated hardware event under software control.(R/WC)"]
            #[inline(always)]
            pub fn set_pwrbtnor_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "This bit can be set or cleared by the EC. The Host writing a one to this bit can also clear this bit. (R/WC)"]
            #[inline(always)]
            pub const fn wak_sts(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the EC. The Host writing a one to this bit can also clear this bit. (R/WC)"]
            #[inline(always)]
            pub fn set_wak_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for EcPm1sts2 {
            #[inline(always)]
            fn default() -> EcPm1sts2 {
                EcPm1sts2(0)
            }
        }
        impl core::fmt::Debug for EcPm1sts2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcPm1sts2")
                    .field("pwrbtn_sts", &self.pwrbtn_sts())
                    .field("slpbtn_sts", &self.slpbtn_sts())
                    .field("rtc_sts", &self.rtc_sts())
                    .field("pwrbtnor_sts", &self.pwrbtnor_sts())
                    .field("wak_sts", &self.wak_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcPm1sts2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcPm1sts2 {{ pwrbtn_sts: {=bool:?}, slpbtn_sts: {=bool:?}, rtc_sts: {=bool:?}, pwrbtnor_sts: {=bool:?}, wak_sts: {=bool:?} }}" , self . pwrbtn_sts () , self . slpbtn_sts () , self . rtc_sts () , self . pwrbtnor_sts () , self . wak_sts ())
            }
        }
        #[doc = "PM1 EC PM Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcPmSts(pub u8);
        impl EcPmSts {
            #[doc = "If the EC_SCI_STS bit is '1', an interrupt is generated on the EC_SCI# pin."]
            #[inline(always)]
            pub const fn ec_sci_sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "If the EC_SCI_STS bit is '1', an interrupt is generated on the EC_SCI# pin."]
            #[inline(always)]
            pub fn set_ec_sci_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "User Defined"]
            #[inline(always)]
            pub const fn ud(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "User Defined"]
            #[inline(always)]
            pub fn set_ud(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for EcPmSts {
            #[inline(always)]
            fn default() -> EcPmSts {
                EcPmSts(0)
            }
        }
        impl core::fmt::Debug for EcPmSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcPmSts")
                    .field("ec_sci_sts", &self.ec_sci_sts())
                    .field("ud", &self.ud())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcPmSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcPmSts {{ ec_sci_sts: {=bool:?}, ud: {=u8:?} }}",
                    self.ec_sci_sts(),
                    self.ud()
                )
            }
        }
        #[doc = "PM1 Control 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hpm1ctrl2(pub u8);
        impl Hpm1ctrl2 {
            #[doc = "This bit can be set or cleared by the Host, read by the EC."]
            #[inline(always)]
            pub const fn pwrbtnor_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the Host, read by the EC."]
            #[inline(always)]
            pub fn set_pwrbtnor_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "These bits can be set or cleared by the Host, read by the EC."]
            #[inline(always)]
            pub const fn slp_typ(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x07;
                val as u8
            }
            #[doc = "These bits can be set or cleared by the Host, read by the EC."]
            #[inline(always)]
            pub fn set_slp_typ(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val as u8) & 0x07) << 2usize);
            }
            #[doc = "SLP_EN"]
            #[inline(always)]
            pub const fn slp_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "SLP_EN"]
            #[inline(always)]
            pub fn set_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Hpm1ctrl2 {
            #[inline(always)]
            fn default() -> Hpm1ctrl2 {
                Hpm1ctrl2(0)
            }
        }
        impl core::fmt::Debug for Hpm1ctrl2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hpm1ctrl2")
                    .field("pwrbtnor_en", &self.pwrbtnor_en())
                    .field("slp_typ", &self.slp_typ())
                    .field("slp_en", &self.slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hpm1ctrl2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Hpm1ctrl2 {{ pwrbtnor_en: {=bool:?}, slp_typ: {=u8:?}, slp_en: {=bool:?} }}",
                    self.pwrbtnor_en(),
                    self.slp_typ(),
                    self.slp_en()
                )
            }
        }
        #[doc = "PM1 Enable 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hpm1en2(pub u8);
        impl Hpm1en2 {
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub const fn pwrbtn_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub fn set_pwrbtn_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub const fn slpbtn_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub fn set_slpbtn_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub const fn rtc_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be read or written by the Host. It can be read by the EC."]
            #[inline(always)]
            pub fn set_rtc_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Hpm1en2 {
            #[inline(always)]
            fn default() -> Hpm1en2 {
                Hpm1en2(0)
            }
        }
        impl core::fmt::Debug for Hpm1en2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hpm1en2")
                    .field("pwrbtn_en", &self.pwrbtn_en())
                    .field("slpbtn_en", &self.slpbtn_en())
                    .field("rtc_en", &self.rtc_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hpm1en2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Hpm1en2 {{ pwrbtn_en: {=bool:?}, slpbtn_en: {=bool:?}, rtc_en: {=bool:?} }}",
                    self.pwrbtn_en(),
                    self.slpbtn_en(),
                    self.rtc_en()
                )
            }
        }
        #[doc = "PM1 Status 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hpm1sts2(pub u8);
        impl Hpm1sts2 {
            #[doc = "This bit can be set or cleared by the EC to simulate a Power button status if the power is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)"]
            #[inline(always)]
            pub const fn pwrbtn_sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a Power button status if the power is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)"]
            #[inline(always)]
            pub fn set_pwrbtn_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a Sleep button status if the sleep state is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control.(R/WC)"]
            #[inline(always)]
            pub const fn slpbtn_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a Sleep button status if the sleep state is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control.(R/WC)"]
            #[inline(always)]
            pub fn set_slpbtn_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a RTC status. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)"]
            #[inline(always)]
            pub const fn rtc_sts(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a RTC status. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)"]
            #[inline(always)]
            pub fn set_rtc_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a Power button override event status if the power is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated hardware event under software control.(R/WC)"]
            #[inline(always)]
            pub const fn pwrbtnor_sts(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the EC to simulate a Power button override event status if the power is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated hardware event under software control.(R/WC)"]
            #[inline(always)]
            pub fn set_pwrbtnor_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "This bit can be set or cleared by the EC. The Host writing a one to this bit can also clear this bit. (R/WC)"]
            #[inline(always)]
            pub const fn wak_sts(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can be set or cleared by the EC. The Host writing a one to this bit can also clear this bit. (R/WC)"]
            #[inline(always)]
            pub fn set_wak_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Hpm1sts2 {
            #[inline(always)]
            fn default() -> Hpm1sts2 {
                Hpm1sts2(0)
            }
        }
        impl core::fmt::Debug for Hpm1sts2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hpm1sts2")
                    .field("pwrbtn_sts", &self.pwrbtn_sts())
                    .field("slpbtn_sts", &self.slpbtn_sts())
                    .field("rtc_sts", &self.rtc_sts())
                    .field("pwrbtnor_sts", &self.pwrbtnor_sts())
                    .field("wak_sts", &self.wak_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hpm1sts2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Hpm1sts2 {{ pwrbtn_sts: {=bool:?}, slpbtn_sts: {=bool:?}, rtc_sts: {=bool:?}, pwrbtnor_sts: {=bool:?}, wak_sts: {=bool:?} }}" , self . pwrbtn_sts () , self . slpbtn_sts () , self . rtc_sts () , self . pwrbtnor_sts () , self . wak_sts ())
            }
        }
    }
}
pub mod port92 {
    #[doc = "The registers listed in the Configuration Register Summary table are for a single instance of the Legacy Port92/GATEA20 logic."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port92 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port92 {}
    unsafe impl Sync for Port92 {}
    impl Port92 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "PORT92 Register: The registers listed in the Runtime Register Summary table are for a single instance of the Legacy Port92/GATEA20 logic."]
        #[inline(always)]
        pub const fn rt_port92(self) -> crate::common::Reg<regs::RtPort92, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "GATEA20 Control Register"]
        #[inline(always)]
        pub const fn gatea20(self) -> crate::common::Reg<regs::Gatea20, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "SETGA20L Register. A write to this register sets GATEA20 in the GATEA20 Control Register."]
        #[inline(always)]
        pub const fn setga20l(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "RSTGA20L Register. A write to this register sets GATEA20 in the GATEA20 Control Register."]
        #[inline(always)]
        pub const fn rstga20l(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "PORT92 Enable Register"]
        #[inline(always)]
        pub const fn en(self) -> crate::common::Reg<regs::En, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "PORT92 Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct En(pub u8);
        impl En {
            #[doc = "When this bit is '1', the Port92h Register is enabled. When this bit is '0', the Port92h Register is disabled, and Host writes to Host address 92h are ignored."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is '1', the Port92h Register is enabled. When this bit is '0', the Port92h Register is disabled, and Host writes to Host address 92h are ignored."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for En {
            #[inline(always)]
            fn default() -> En {
                En(0)
            }
        }
        impl core::fmt::Debug for En {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("En").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for En {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "En {{ en: {=bool:?} }}", self.en())
            }
        }
        #[doc = "GATEA20 Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gatea20(pub u8);
        impl Gatea20 {
            #[doc = "0=The GATEA20 output is driven low, 1=The GATEA20 output is driven high."]
            #[inline(always)]
            pub const fn gatea20(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "0=The GATEA20 output is driven low, 1=The GATEA20 output is driven high."]
            #[inline(always)]
            pub fn set_gatea20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Gatea20 {
            #[inline(always)]
            fn default() -> Gatea20 {
                Gatea20(0)
            }
        }
        impl core::fmt::Debug for Gatea20 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gatea20").field("gatea20", &self.gatea20()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gatea20 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gatea20 {{ gatea20: {=bool:?} }}", self.gatea20())
            }
        }
        #[doc = "PORT92 Register: The registers listed in the Runtime Register Summary table are for a single instance of the Legacy Port92/GATEA20 logic."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtPort92(pub u8);
        impl RtPort92 {
            #[doc = "This bit provides an alternate means to generate a CPU_RESET pulse."]
            #[inline(always)]
            pub const fn alt_cpu_rst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit provides an alternate means to generate a CPU_RESET pulse."]
            #[inline(always)]
            pub fn set_alt_cpu_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This bit provides an alternate means for system control of the GATEA20 pin. ALT_A20 low drives GATEA20 low, if A20 from the keyboard controller is also low. When Port 92 is enabled, writing a 1 to this bit forces ALT_A20 high. ALT_A20 high drives GATEA20 high regardless of the state of A20 from the keyboard controller. 0=ALT_A20 is driven low; 1=ALT_A20 is driven high"]
            #[inline(always)]
            pub const fn alt_gate_a20(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit provides an alternate means for system control of the GATEA20 pin. ALT_A20 low drives GATEA20 low, if A20 from the keyboard controller is also low. When Port 92 is enabled, writing a 1 to this bit forces ALT_A20 high. ALT_A20 high drives GATEA20 high regardless of the state of A20 from the keyboard controller. 0=ALT_A20 is driven low; 1=ALT_A20 is driven high"]
            #[inline(always)]
            pub fn set_alt_gate_a20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
        }
        impl Default for RtPort92 {
            #[inline(always)]
            fn default() -> RtPort92 {
                RtPort92(0)
            }
        }
        impl core::fmt::Debug for RtPort92 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtPort92")
                    .field("alt_cpu_rst", &self.alt_cpu_rst())
                    .field("alt_gate_a20", &self.alt_gate_a20())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtPort92 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RtPort92 {{ alt_cpu_rst: {=bool:?}, alt_gate_a20: {=bool:?} }}",
                    self.alt_cpu_rst(),
                    self.alt_gate_a20()
                )
            }
        }
    }
}
pub mod port_80_debug {
    #[doc = "Diagnostic data is written by the Host Interface to the Port 80 BIOS Debug Port."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port80debug {
        ptr: *mut u8,
    }
    unsafe impl Send for Port80debug {}
    unsafe impl Sync for Port80debug {}
    impl Port80debug {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Host Data Register"]
        #[inline(always)]
        pub const fn host_data32(self) -> crate::common::Reg<regs::HostData32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "EC Data Register."]
        #[inline(always)]
        pub const fn ec_data(self) -> crate::common::Reg<regs::EcData, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "EC Attribute Register."]
        #[inline(always)]
        pub const fn ec_attr(self) -> crate::common::Reg<regs::EcAttr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0101usize) as _) }
        }
        #[doc = "Configuration Register."]
        #[inline(always)]
        pub const fn cfg(self) -> crate::common::Reg<regs::Cfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Status Register"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Interrupt Enable Register"]
        #[inline(always)]
        pub const fn int_en(self) -> crate::common::Reg<regs::IntEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0109usize) as _) }
        }
        #[doc = "Snapshot Register"]
        #[inline(always)]
        pub const fn snapshot(self) -> crate::common::Reg<regs::Snapshot, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Capture Register"]
        #[inline(always)]
        pub const fn capture(self) -> crate::common::Reg<regs::Capture, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Test Mode Register"]
        #[inline(always)]
        pub const fn test_modes(self) -> crate::common::Reg<regs::TestModes, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Activate Register"]
        #[inline(always)]
        pub const fn activate32(self) -> crate::common::Reg<regs::Activate32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "Host Data Register"]
        #[inline(always)]
        pub const fn host_data8(self) -> crate::common::Reg<regs::HostData8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Activate Register"]
        #[inline(always)]
        pub const fn activate8(self) -> crate::common::Reg<regs::Activate8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0730usize) as _) }
        }
        #[doc = "Host Alias Data Register"]
        #[inline(always)]
        pub const fn hst_alis_data(self) -> crate::common::Reg<regs::HstAlisData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07f0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Activate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate32(pub u32);
        impl Activate32 {
            #[doc = "When this bit is asserted 1, the block is enabled. When this bit is 0, writes by the Host interface to the Host Data Register are not claimed, the FIFO is flushed."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is asserted 1, the block is enabled. When this bit is 0, writes by the Host interface to the Host Data Register are not claimed, the FIFO is flushed."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Activate32 {
            #[inline(always)]
            fn default() -> Activate32 {
                Activate32(0)
            }
        }
        impl core::fmt::Debug for Activate32 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate32").field("act", &self.act()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate32 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate32 {{ act: {=bool:?} }}", self.act())
            }
        }
        #[doc = "Activate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate8(pub u8);
        impl Activate8 {
            #[doc = "When this bit is asserted 1, the block is enabled. When this bit is 0, writes by the Host interface to the Host Data Register are not claimed, the FIFO is flushed."]
            #[inline(always)]
            pub const fn activate(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is asserted 1, the block is enabled. When this bit is 0, writes by the Host interface to the Host Data Register are not claimed, the FIFO is flushed."]
            #[inline(always)]
            pub fn set_activate(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate8 {
            #[inline(always)]
            fn default() -> Activate8 {
                Activate8(0)
            }
        }
        impl core::fmt::Debug for Activate8 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate8").field("activate", &self.activate()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate8 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate8 {{ activate: {=bool:?} }}", self.activate())
            }
        }
        #[doc = "Capture Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Capture(pub u32);
        impl Capture {
            #[doc = "Current image of the 4-byte Port 80 value capture register."]
            #[inline(always)]
            pub const fn capture(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Current image of the 4-byte Port 80 value capture register."]
            #[inline(always)]
            pub fn set_capture(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Capture {
            #[inline(always)]
            fn default() -> Capture {
                Capture(0)
            }
        }
        impl core::fmt::Debug for Capture {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Capture").field("capture", &self.capture()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Capture {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Capture {{ capture: {=u32:?} }}", self.capture())
            }
        }
        #[doc = "Configuration Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfg(pub u32);
        impl Cfg {
            #[doc = "Flush FIFO (also clears the OVERRUN bit) Self Clearing bit. This bit does not affect the Snapshot Register."]
            #[inline(always)]
            pub const fn flush(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Flush FIFO (also clears the OVERRUN bit) Self Clearing bit. This bit does not affect the Snapshot Register."]
            #[inline(always)]
            pub fn set_flush(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Writing this bit clears the Snapshot Register as well as the Capture Register (Buffer)."]
            #[inline(always)]
            pub const fn snpsht_clr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Writing this bit clears the Snapshot Register as well as the Capture Register (Buffer)."]
            #[inline(always)]
            pub fn set_snpsht_clr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This field determines the threshold for the Port 80 32-Bit BIOS Debug Port Interrupts. 7=30 entry threshold 6=28 entry threshold 5=24 entry threshold 4=20 entry threshold 3=16 entry threshold 2=8 entry threshold 1=4 entry threshold 0=1 entry threshold"]
            #[inline(always)]
            pub const fn fifo_threshold(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "This field determines the threshold for the Port 80 32-Bit BIOS Debug Port Interrupts. 7=30 entry threshold 6=28 entry threshold 5=24 entry threshold 4=20 entry threshold 3=16 entry threshold 2=8 entry threshold 1=4 entry threshold 0=1 entry threshold"]
            #[inline(always)]
            pub fn set_fifo_threshold(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
            }
            #[doc = "Soft Reset, When a 1 is written to this bit a one clock wide pulse resets the entire block"]
            #[inline(always)]
            pub const fn soft_rst(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Soft Reset, When a 1 is written to this bit a one clock wide pulse resets the entire block"]
            #[inline(always)]
            pub fn set_soft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Cfg {
            #[inline(always)]
            fn default() -> Cfg {
                Cfg(0)
            }
        }
        impl core::fmt::Debug for Cfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfg")
                    .field("flush", &self.flush())
                    .field("snpsht_clr", &self.snpsht_clr())
                    .field("fifo_threshold", &self.fifo_threshold())
                    .field("soft_rst", &self.soft_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cfg {{ flush: {=bool:?}, snpsht_clr: {=bool:?}, fifo_threshold: {=u8:?}, soft_rst: {=bool:?} }}",
                    self.flush(),
                    self.snpsht_clr(),
                    self.fifo_threshold(),
                    self.soft_rst()
                )
            }
        }
        #[doc = "EC Attribute Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcAttr(pub u8);
        impl EcAttr {
            #[doc = "The byte address to which this byte was written 00 = Byte Lane 0 01 = Byte Lane 1 10 = Byte Lane 2 11 = Byte Lane 3"]
            #[inline(always)]
            pub const fn ec_lane(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "The byte address to which this byte was written 00 = Byte Lane 0 01 = Byte Lane 1 10 = Byte Lane 2 11 = Byte Lane 3"]
            #[inline(always)]
            pub fn set_ec_lane(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "Length 00 = One byte, or a continuation of a multi-byte value. 01 = The first byte (LSB) of a two-byte value. 10 = The first byte (LSB) of a 4-byte value. 11 = Invalid"]
            #[inline(always)]
            pub const fn ec_len(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "Length 00 = One byte, or a continuation of a multi-byte value. 01 = The first byte (LSB) of a two-byte value. 10 = The first byte (LSB) of a 4-byte value. 11 = Invalid"]
            #[inline(always)]
            pub fn set_ec_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "FIFO Not Empty Status"]
            #[inline(always)]
            pub const fn fifo_nempty(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO Not Empty Status"]
            #[inline(always)]
            pub fn set_fifo_nempty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "FIFO Overflow 1 = One or more bytes have been lost from the FIFO before this byte. 0 = No loss of information has occurred immediately before this byte."]
            #[inline(always)]
            pub const fn ec_ovr(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO Overflow 1 = One or more bytes have been lost from the FIFO before this byte. 0 = No loss of information has occurred immediately before this byte."]
            #[inline(always)]
            pub fn set_ec_ovr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Threshold Status"]
            #[inline(always)]
            pub const fn thres_stat(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Threshold Status"]
            #[inline(always)]
            pub fn set_thres_stat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
        }
        impl Default for EcAttr {
            #[inline(always)]
            fn default() -> EcAttr {
                EcAttr(0)
            }
        }
        impl core::fmt::Debug for EcAttr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcAttr")
                    .field("ec_lane", &self.ec_lane())
                    .field("ec_len", &self.ec_len())
                    .field("fifo_nempty", &self.fifo_nempty())
                    .field("ec_ovr", &self.ec_ovr())
                    .field("thres_stat", &self.thres_stat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcAttr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcAttr {{ ec_lane: {=u8:?}, ec_len: {=u8:?}, fifo_nempty: {=bool:?}, ec_ovr: {=bool:?}, thres_stat: {=bool:?} }}" , self . ec_lane () , self . ec_len () , self . fifo_nempty () , self . ec_ovr () , self . thres_stat ())
            }
        }
        #[doc = "EC Data Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcData(pub u8);
        impl EcData {
            #[doc = "This is the Oldest FIFO byte from the Host."]
            #[inline(always)]
            pub const fn ec_data(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This is the Oldest FIFO byte from the Host."]
            #[inline(always)]
            pub fn set_ec_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for EcData {
            #[inline(always)]
            fn default() -> EcData {
                EcData(0)
            }
        }
        impl core::fmt::Debug for EcData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcData").field("ec_data", &self.ec_data()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcData {{ ec_data: {=u8:?} }}", self.ec_data())
            }
        }
        #[doc = "Host Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostData32(pub u32);
        impl HostData32 {
            #[doc = "This is the host data."]
            #[inline(always)]
            pub const fn h_dat(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the host data."]
            #[inline(always)]
            pub fn set_h_dat(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for HostData32 {
            #[inline(always)]
            fn default() -> HostData32 {
                HostData32(0)
            }
        }
        impl core::fmt::Debug for HostData32 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostData32").field("h_dat", &self.h_dat()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostData32 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HostData32 {{ h_dat: {=u32:?} }}", self.h_dat())
            }
        }
        #[doc = "Host Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostData8(pub u8);
        impl HostData8 {
            #[doc = "This is the host data."]
            #[inline(always)]
            pub const fn host_data(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This is the host data."]
            #[inline(always)]
            pub fn set_host_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for HostData8 {
            #[inline(always)]
            fn default() -> HostData8 {
                HostData8(0)
            }
        }
        impl core::fmt::Debug for HostData8 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostData8")
                    .field("host_data", &self.host_data())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostData8 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HostData8 {{ host_data: {=u8:?} }}", self.host_data())
            }
        }
        #[doc = "Host Alias Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HstAlisData(pub u8);
        impl HstAlisData {
            #[doc = "Byte from Alias LDN Port80 mapped location in Snapshot Register b00 = Byte 0 b01 = Byte 1 b10 = Byte 2 b11 = Byte 3"]
            #[inline(always)]
            pub const fn alis_blane(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "Byte from Alias LDN Port80 mapped location in Snapshot Register b00 = Byte 0 b01 = Byte 1 b10 = Byte 2 b11 = Byte 3"]
            #[inline(always)]
            pub fn set_alis_blane(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
        }
        impl Default for HstAlisData {
            #[inline(always)]
            fn default() -> HstAlisData {
                HstAlisData(0)
            }
        }
        impl core::fmt::Debug for HstAlisData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HstAlisData")
                    .field("alis_blane", &self.alis_blane())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HstAlisData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HstAlisData {{ alis_blane: {=u8:?} }}", self.alis_blane())
            }
        }
        #[doc = "Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntEn(pub u8);
        impl IntEn {
            #[doc = "Enable Threshold interrupt. When set threshold interrupt is enabled"]
            #[inline(always)]
            pub const fn thres_ien(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Threshold interrupt. When set threshold interrupt is enabled"]
            #[inline(always)]
            pub fn set_thres_ien(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for IntEn {
            #[inline(always)]
            fn default() -> IntEn {
                IntEn(0)
            }
        }
        impl core::fmt::Debug for IntEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntEn").field("thres_ien", &self.thres_ien()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IntEn {{ thres_ien: {=bool:?} }}", self.thres_ien())
            }
        }
        #[doc = "Snapshot Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snapshot(pub u32);
        impl Snapshot {
            #[doc = "Current image of the 4-byte Port 80 value, captured immediately from the Host CPU."]
            #[inline(always)]
            pub const fn snapshot(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Current image of the 4-byte Port 80 value, captured immediately from the Host CPU."]
            #[inline(always)]
            pub fn set_snapshot(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Snapshot {
            #[inline(always)]
            fn default() -> Snapshot {
                Snapshot(0)
            }
        }
        impl core::fmt::Debug for Snapshot {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snapshot").field("snapshot", &self.snapshot()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snapshot {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Snapshot {{ snapshot: {=u32:?} }}", self.snapshot())
            }
        }
        #[doc = "Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u8);
        impl Sts {
            #[doc = "The NOT EMPTY bit is 1 when there is data in the FIFO. The NOT EMPTY bit is 0 when the FIFO is empty."]
            #[inline(always)]
            pub const fn not_empty(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The NOT EMPTY bit is 1 when there is data in the FIFO. The NOT EMPTY bit is 0 when the FIFO is empty."]
            #[inline(always)]
            pub fn set_not_empty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "The OVERRUN bit is 1 when the host writes the Host Data Register when the FIFO is full."]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The OVERRUN bit is 1 when the host writes the Host Data Register when the FIFO is full."]
            #[inline(always)]
            pub fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Threshold Status is set when the number of threshold entries are above the selected threshold"]
            #[inline(always)]
            pub const fn thres_stat(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Threshold Status is set when the number of threshold entries are above the selected threshold"]
            #[inline(always)]
            pub fn set_thres_stat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("not_empty", &self.not_empty())
                    .field("overrun", &self.overrun())
                    .field("thres_stat", &self.thres_stat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sts {{ not_empty: {=bool:?}, overrun: {=bool:?}, thres_stat: {=bool:?} }}",
                    self.not_empty(),
                    self.overrun(),
                    self.thres_stat()
                )
            }
        }
        #[doc = "Test Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TestModes(pub u32);
        impl TestModes {
            #[doc = "Enable other masters (JTAG, EC etc) to be able to write to Port80 FIFO with size selection."]
            #[inline(always)]
            pub const fn en_omastr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable other masters (JTAG, EC etc) to be able to write to Port80 FIFO with size selection."]
            #[inline(always)]
            pub fn set_en_omastr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Size from other master 00 = Byte 01 = Word 10 = Double Word 11 = Invalid"]
            #[inline(always)]
            pub const fn sz4m_omastr(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x03;
                val as u8
            }
            #[doc = "Size from other master 00 = Byte 01 = Word 10 = Double Word 11 = Invalid"]
            #[inline(always)]
            pub fn set_sz4m_omastr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val as u32) & 0x03) << 1usize);
            }
        }
        impl Default for TestModes {
            #[inline(always)]
            fn default() -> TestModes {
                TestModes(0)
            }
        }
        impl core::fmt::Debug for TestModes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TestModes")
                    .field("en_omastr", &self.en_omastr())
                    .field("sz4m_omastr", &self.sz4m_omastr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TestModes {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TestModes {{ en_omastr: {=bool:?}, sz4m_omastr: {=u8:?} }}",
                    self.en_omastr(),
                    self.sz4m_omastr()
                )
            }
        }
    }
}
pub mod powerguard_0 {
    #[doc = "This block monitors PowerGuard output signals (or locked rotor signals) from various types of fans, and determines their speed."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Powerguard0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Powerguard0 {}
    unsafe impl Sync for Powerguard0 {}
    impl Powerguard0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "LPF1 Frequency Cut-off Rate Register"]
        #[inline(always)]
        pub const fn lpf1_freq_cutoff_rate(self) -> crate::common::Reg<regs::Lpf1freqCutoffRate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "LPF2 Frequency Cut-off Rate Register"]
        #[inline(always)]
        pub const fn lpf2_freq_cutoff_rate(self) -> crate::common::Reg<regs::Lpf2freqCutoffRate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Data Register"]
        #[inline(always)]
        pub const fn data_reg(self) -> crate::common::Reg<regs::DataReg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Threshold Limit Register."]
        #[inline(always)]
        pub const fn threshold_limit(self) -> crate::common::Reg<regs::ThresholdLimit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Low Timer Register"]
        #[inline(always)]
        pub const fn low_timer(self) -> crate::common::Reg<regs::LowTimer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "High Timer Register"]
        #[inline(always)]
        pub const fn high_timer(self) -> crate::common::Reg<regs::HighTimer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Control and Status Register."]
        #[inline(always)]
        pub const fn ctrl_sts(self) -> crate::common::Reg<regs::CtrlSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "PowerGuard Interrupt Status Register"]
        #[inline(always)]
        pub const fn int_status(self) -> crate::common::Reg<regs::IntStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "PowerGuard Interrupt Enable Register"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Control and Status Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CtrlSts(pub u32);
        impl CtrlSts {
            #[doc = "The high-side timer output enable bit."]
            #[inline(always)]
            pub const fn ctmer_out_hi_enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The high-side timer output enable bit."]
            #[inline(always)]
            pub fn set_ctmer_out_hi_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The low-side timer output enable bit."]
            #[inline(always)]
            pub const fn ctmer_out_lo_enable(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The low-side timer output enable bit."]
            #[inline(always)]
            pub fn set_ctmer_out_lo_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "FORCE_PROCHOT Enable bit"]
            #[inline(always)]
            pub const fn force_prochot_enable(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "FORCE_PROCHOT Enable bit"]
            #[inline(always)]
            pub fn set_force_prochot_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is set to '1b' if either high-side timer or the low-side timer is configured for Manual Recovery Mode and the timer times out and asserts."]
            #[inline(always)]
            pub const fn manual_recovery(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if either high-side timer or the low-side timer is configured for Manual Recovery Mode and the timer times out and asserts."]
            #[inline(always)]
            pub fn set_manual_recovery(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "The field controls the read data accessible of the SELECTED_- BYTE0 field of the Data Register."]
            #[inline(always)]
            pub const fn data_mux_select(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "The field controls the read data accessible of the SELECTED_- BYTE0 field of the Data Register."]
            #[inline(always)]
            pub fn set_data_mux_select(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
            }
            #[doc = "This bit controls the effect of the VCI_OVRD_IN pin on the PROCHOT_IO# Output."]
            #[inline(always)]
            pub const fn prochot_gate(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls the effect of the VCI_OVRD_IN pin on the PROCHOT_IO# Output."]
            #[inline(always)]
            pub fn set_prochot_gate(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This bit controls the source of the ADC sample data to the Second Order LPF."]
            #[inline(always)]
            pub const fn test_data_mux_select(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls the source of the ADC sample data to the Second Order LPF."]
            #[inline(always)]
            pub fn set_test_data_mux_select(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This field controls the source of the Prochot Data Mux."]
            #[inline(always)]
            pub const fn prochot_data_mux_select(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x03;
                val as u8
            }
            #[doc = "This field controls the source of the Prochot Data Mux."]
            #[inline(always)]
            pub fn set_prochot_data_mux_select(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 9usize)) | (((val as u32) & 0x03) << 9usize);
            }
            #[doc = "This bit selects Hysteresis Mode for the low-side comparator."]
            #[inline(always)]
            pub const fn low_comparator_hysteresis_mode(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects Hysteresis Mode for the low-side comparator."]
            #[inline(always)]
            pub fn set_low_comparator_hysteresis_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "This bit selects Hysteresis Mode for the high-side comparator."]
            #[inline(always)]
            pub const fn high_comparator_hysteresis_mode(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects Hysteresis Mode for the high-side comparator."]
            #[inline(always)]
            pub fn set_high_comparator_hysteresis_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub const fn test1(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub fn set_test1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub const fn test2(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub fn set_test2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub const fn test3(&self) -> u8 {
                let val = (self.0 >> 18usize) & 0x03;
                val as u8
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub fn set_test3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 18usize)) | (((val as u32) & 0x03) << 18usize);
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub const fn test4(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x03;
                val as u8
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub fn set_test4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 20usize)) | (((val as u32) & 0x03) << 20usize);
            }
            #[doc = "When this bit is set to '1b' the PowerGuard block is disabled and placed in a low power state."]
            #[inline(always)]
            pub const fn block_disable(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is set to '1b' the PowerGuard block is disabled and placed in a low power state."]
            #[inline(always)]
            pub fn set_block_disable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "When this bit is set to '1b' the entire block is reset."]
            #[inline(always)]
            pub const fn block_reset(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is set to '1b' the entire block is reset."]
            #[inline(always)]
            pub fn set_block_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Status bit of the low-side timer."]
            #[inline(always)]
            pub const fn ctmr_out_lo(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Status bit of the low-side timer."]
            #[inline(always)]
            pub fn set_ctmr_out_lo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Status bit of the high-side timer."]
            #[inline(always)]
            pub const fn ctmr_out_hi(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Status bit of the high-side timer."]
            #[inline(always)]
            pub fn set_ctmr_out_hi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "If both the high-side timer and the low-side timer are configured for Manual Recovery Mode, this bit reports the status of the timer contribution to the ORing Logic."]
            #[inline(always)]
            pub const fn man_recovery_out(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "If both the high-side timer and the low-side timer are configured for Manual Recovery Mode, this bit reports the status of the timer contribution to the ORing Logic."]
            #[inline(always)]
            pub fn set_man_recovery_out(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Inverted copy of the current state of the input signal FORCE_PROCHOT# from the PROCHOT PWM."]
            #[inline(always)]
            pub const fn force_prochot(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Inverted copy of the current state of the input signal FORCE_PROCHOT# from the PROCHOT PWM."]
            #[inline(always)]
            pub fn set_force_prochot(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Current output of the low-side comparator."]
            #[inline(always)]
            pub const fn cout_lo(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Current output of the low-side comparator."]
            #[inline(always)]
            pub fn set_cout_lo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Current output of the high-side comparator."]
            #[inline(always)]
            pub const fn cout_hi(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Current output of the high-side comparator."]
            #[inline(always)]
            pub fn set_cout_hi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Current output of the ORing Logic."]
            #[inline(always)]
            pub const fn prochot_out(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Current output of the ORing Logic."]
            #[inline(always)]
            pub fn set_prochot_out(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for CtrlSts {
            #[inline(always)]
            fn default() -> CtrlSts {
                CtrlSts(0)
            }
        }
        impl core::fmt::Debug for CtrlSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CtrlSts")
                    .field("ctmer_out_hi_enable", &self.ctmer_out_hi_enable())
                    .field("ctmer_out_lo_enable", &self.ctmer_out_lo_enable())
                    .field("force_prochot_enable", &self.force_prochot_enable())
                    .field("manual_recovery", &self.manual_recovery())
                    .field("data_mux_select", &self.data_mux_select())
                    .field("prochot_gate", &self.prochot_gate())
                    .field("test_data_mux_select", &self.test_data_mux_select())
                    .field("prochot_data_mux_select", &self.prochot_data_mux_select())
                    .field("low_comparator_hysteresis_mode", &self.low_comparator_hysteresis_mode())
                    .field(
                        "high_comparator_hysteresis_mode",
                        &self.high_comparator_hysteresis_mode(),
                    )
                    .field("test1", &self.test1())
                    .field("test2", &self.test2())
                    .field("test3", &self.test3())
                    .field("test4", &self.test4())
                    .field("block_disable", &self.block_disable())
                    .field("block_reset", &self.block_reset())
                    .field("ctmr_out_lo", &self.ctmr_out_lo())
                    .field("ctmr_out_hi", &self.ctmr_out_hi())
                    .field("man_recovery_out", &self.man_recovery_out())
                    .field("force_prochot", &self.force_prochot())
                    .field("cout_lo", &self.cout_lo())
                    .field("cout_hi", &self.cout_hi())
                    .field("prochot_out", &self.prochot_out())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CtrlSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CtrlSts {{ ctmer_out_hi_enable: {=bool:?}, ctmer_out_lo_enable: {=bool:?}, force_prochot_enable: {=bool:?}, manual_recovery: {=bool:?}, data_mux_select: {=u8:?}, prochot_gate: {=bool:?}, test_data_mux_select: {=bool:?}, prochot_data_mux_select: {=u8:?}, low_comparator_hysteresis_mode: {=bool:?}, high_comparator_hysteresis_mode: {=bool:?}, test1: {=bool:?}, test2: {=bool:?}, test3: {=u8:?}, test4: {=u8:?}, block_disable: {=bool:?}, block_reset: {=bool:?}, ctmr_out_lo: {=bool:?}, ctmr_out_hi: {=bool:?}, man_recovery_out: {=bool:?}, force_prochot: {=bool:?}, cout_lo: {=bool:?}, cout_hi: {=bool:?}, prochot_out: {=bool:?} }}" , self . ctmer_out_hi_enable () , self . ctmer_out_lo_enable () , self . force_prochot_enable () , self . manual_recovery () , self . data_mux_select () , self . prochot_gate () , self . test_data_mux_select () , self . prochot_data_mux_select () , self . low_comparator_hysteresis_mode () , self . high_comparator_hysteresis_mode () , self . test1 () , self . test2 () , self . test3 () , self . test4 () , self . block_disable () , self . block_reset () , self . ctmr_out_lo () , self . ctmr_out_hi () , self . man_recovery_out () , self . force_prochot () , self . cout_lo () , self . cout_hi () , self . prochot_out ())
            }
        }
        #[doc = "Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataReg(pub u32);
        impl DataReg {
            #[doc = "The contents of this read-only field is controlled by the value written into the DATA_MUX_SELECT field in the Control And Status Register."]
            #[inline(always)]
            pub const fn selected_byte0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The contents of this read-only field is controlled by the value written into the DATA_MUX_SELECT field in the Control And Status Register."]
            #[inline(always)]
            pub fn set_selected_byte0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Data output of 1st Order LPF."]
            #[inline(always)]
            pub const fn lpf1_output_dat(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Data output of 1st Order LPF."]
            #[inline(always)]
            pub fn set_lpf1_output_dat(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Data output of 2nd Order LPF."]
            #[inline(always)]
            pub const fn lpf2_output_data(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Data output of 2nd Order LPF."]
            #[inline(always)]
            pub fn set_lpf2_output_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "When the TEST_DATA_MUX_SELECT bit in the Control And Status Register is a 1, writes to this register are used as the ADC sample data."]
            #[inline(always)]
            pub const fn test_write_data(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "When the TEST_DATA_MUX_SELECT bit in the Control And Status Register is a 1, writes to this register are used as the ADC sample data."]
            #[inline(always)]
            pub fn set_test_write_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for DataReg {
            #[inline(always)]
            fn default() -> DataReg {
                DataReg(0)
            }
        }
        impl core::fmt::Debug for DataReg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataReg")
                    .field("selected_byte0", &self.selected_byte0())
                    .field("lpf1_output_dat", &self.lpf1_output_dat())
                    .field("lpf2_output_data", &self.lpf2_output_data())
                    .field("test_write_data", &self.test_write_data())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataReg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataReg {{ selected_byte0: {=u8:?}, lpf1_output_dat: {=u8:?}, lpf2_output_data: {=u8:?}, test_write_data: {=u8:?} }}" , self . selected_byte0 () , self . lpf1_output_dat () , self . lpf2_output_data () , self . test_write_data ())
            }
        }
        #[doc = "High Timer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HighTimer(pub u32);
        impl HighTimer {
            #[doc = "Reads of this field provides the current count of the high-side timer."]
            #[inline(always)]
            pub const fn high_timer_counter(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Reads of this field provides the current count of the high-side timer."]
            #[inline(always)]
            pub fn set_high_timer_counter(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "The value written into this field is the Load Count value for the HIGH_TIMER_COUNTER."]
            #[inline(always)]
            pub const fn high_timer_load(&self) -> u16 {
                let val = (self.0 >> 12usize) & 0x0fff;
                val as u16
            }
            #[doc = "The value written into this field is the Load Count value for the HIGH_TIMER_COUNTER."]
            #[inline(always)]
            pub fn set_high_timer_load(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 12usize)) | (((val as u32) & 0x0fff) << 12usize);
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub const fn test_bit(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub fn set_test_bit(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Recovery mode for the high-side timer."]
            #[inline(always)]
            pub const fn high_timer_recovery_options(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Recovery mode for the high-side timer."]
            #[inline(always)]
            pub fn set_high_timer_recovery_options(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for HighTimer {
            #[inline(always)]
            fn default() -> HighTimer {
                HighTimer(0)
            }
        }
        impl core::fmt::Debug for HighTimer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HighTimer")
                    .field("high_timer_counter", &self.high_timer_counter())
                    .field("high_timer_load", &self.high_timer_load())
                    .field("test_bit", &self.test_bit())
                    .field("high_timer_recovery_options", &self.high_timer_recovery_options())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HighTimer {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "HighTimer {{ high_timer_counter: {=u16:?}, high_timer_load: {=u16:?}, test_bit: {=bool:?}, high_timer_recovery_options: {=bool:?} }}" , self . high_timer_counter () , self . high_timer_load () , self . test_bit () , self . high_timer_recovery_options ())
            }
        }
        #[doc = "PowerGuard Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u32);
        impl Ien {
            #[doc = "This bit is used to enable/disable the CTMR_OUT_HI interrupt."]
            #[inline(always)]
            pub const fn ct_hi_h2l_enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to enable/disable the CTMR_OUT_HI interrupt."]
            #[inline(always)]
            pub fn set_ct_hi_h2l_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is used to enable/disable the CTMR_OUT_LO interrupt."]
            #[inline(always)]
            pub const fn ct_lo_h2l_enable(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to enable/disable the CTMR_OUT_LO interrupt."]
            #[inline(always)]
            pub fn set_ct_lo_h2l_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is used to enable/disable the CTMR_OUT_HI interrupt."]
            #[inline(always)]
            pub const fn ct_hi_l2h_enable(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to enable/disable the CTMR_OUT_HI interrupt."]
            #[inline(always)]
            pub fn set_ct_hi_l2h_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is used to enable/disable the CTMR_OUT_LO interrupt."]
            #[inline(always)]
            pub const fn ct_lo_l2h_enable(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to enable/disable the CTMR_OUT_LO interrupt."]
            #[inline(always)]
            pub fn set_ct_lo_l2h_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit is used to enable/disable the FORCE_PROCHOT# interrupt."]
            #[inline(always)]
            pub const fn force_prochot_enable(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to enable/disable the FORCE_PROCHOT# interrupt."]
            #[inline(always)]
            pub fn set_force_prochot_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("ct_hi_h2l_enable", &self.ct_hi_h2l_enable())
                    .field("ct_lo_h2l_enable", &self.ct_lo_h2l_enable())
                    .field("ct_hi_l2h_enable", &self.ct_hi_l2h_enable())
                    .field("ct_lo_l2h_enable", &self.ct_lo_l2h_enable())
                    .field("force_prochot_enable", &self.force_prochot_enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ien {{ ct_hi_h2l_enable: {=bool:?}, ct_lo_h2l_enable: {=bool:?}, ct_hi_l2h_enable: {=bool:?}, ct_lo_l2h_enable: {=bool:?}, force_prochot_enable: {=bool:?} }}" , self . ct_hi_h2l_enable () , self . ct_lo_h2l_enable () , self . ct_hi_l2h_enable () , self . ct_lo_l2h_enable () , self . force_prochot_enable ())
            }
        }
        #[doc = "PowerGuard Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntStatus(pub u32);
        impl IntStatus {
            #[doc = "This bit is set to 1b when the CTMR_OUT_HI in the Control And Status Register transitions from '1b' to '0b'. (R/WC)"]
            #[inline(always)]
            pub const fn ct_hi_h2l(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1b when the CTMR_OUT_HI in the Control And Status Register transitions from '1b' to '0b'. (R/WC)"]
            #[inline(always)]
            pub fn set_ct_hi_h2l(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to 1b when the CTMR_OUT_LO in the Control And Status Register transitions from '1b' to '0b'. (R/WC)"]
            #[inline(always)]
            pub const fn ct_lo_h2l(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1b when the CTMR_OUT_LO in the Control And Status Register transitions from '1b' to '0b'. (R/WC)"]
            #[inline(always)]
            pub fn set_ct_lo_h2l(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is set to 1b when the CTMR_OUT_HI in the Control And Status Register transitions from '0b' to '1b'. (R/WC)"]
            #[inline(always)]
            pub const fn ct_hi_l2h(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1b when the CTMR_OUT_HI in the Control And Status Register transitions from '0b' to '1b'. (R/WC)"]
            #[inline(always)]
            pub fn set_ct_hi_l2h(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is set to 1b when the CTMR_OUT_LO in the Control And Status Register transitions from '0b' to '1b'. (R/WC)"]
            #[inline(always)]
            pub const fn ct_lo_l2h(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1b when the CTMR_OUT_LO in the Control And Status Register transitions from '0b' to '1b'. (R/WC)"]
            #[inline(always)]
            pub fn set_ct_lo_l2h(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit is set to '1b' if the FORCE_PROCHOT# input from the PROCHOT PWM is low (asserted). (R/WC)"]
            #[inline(always)]
            pub const fn force_prochot(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if the FORCE_PROCHOT# input from the PROCHOT PWM is low (asserted). (R/WC)"]
            #[inline(always)]
            pub fn set_force_prochot(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for IntStatus {
            #[inline(always)]
            fn default() -> IntStatus {
                IntStatus(0)
            }
        }
        impl core::fmt::Debug for IntStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntStatus")
                    .field("ct_hi_h2l", &self.ct_hi_h2l())
                    .field("ct_lo_h2l", &self.ct_lo_h2l())
                    .field("ct_hi_l2h", &self.ct_hi_l2h())
                    .field("ct_lo_l2h", &self.ct_lo_l2h())
                    .field("force_prochot", &self.force_prochot())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "IntStatus {{ ct_hi_h2l: {=bool:?}, ct_lo_h2l: {=bool:?}, ct_hi_l2h: {=bool:?}, ct_lo_l2h: {=bool:?}, force_prochot: {=bool:?} }}" , self . ct_hi_h2l () , self . ct_lo_h2l () , self . ct_hi_l2h () , self . ct_lo_l2h () , self . force_prochot ())
            }
        }
        #[doc = "Low Timer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LowTimer(pub u32);
        impl LowTimer {
            #[doc = "Reads of this field provides the current count of the low-side timer."]
            #[inline(always)]
            pub const fn low_timer_counter(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Reads of this field provides the current count of the low-side timer."]
            #[inline(always)]
            pub fn set_low_timer_counter(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "The value written into this field is the Load Count value for the LOW_TIMER_COUNTER."]
            #[inline(always)]
            pub const fn low_timer_load(&self) -> u16 {
                let val = (self.0 >> 12usize) & 0x0fff;
                val as u16
            }
            #[doc = "The value written into this field is the Load Count value for the LOW_TIMER_COUNTER."]
            #[inline(always)]
            pub fn set_low_timer_load(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 12usize)) | (((val as u32) & 0x0fff) << 12usize);
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub const fn test_bit(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "All writes to this register should clear this test bit to 0."]
            #[inline(always)]
            pub fn set_test_bit(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Recovery mode for the low-side timer."]
            #[inline(always)]
            pub const fn low_timer_recovery_options(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Recovery mode for the low-side timer."]
            #[inline(always)]
            pub fn set_low_timer_recovery_options(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for LowTimer {
            #[inline(always)]
            fn default() -> LowTimer {
                LowTimer(0)
            }
        }
        impl core::fmt::Debug for LowTimer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LowTimer")
                    .field("low_timer_counter", &self.low_timer_counter())
                    .field("low_timer_load", &self.low_timer_load())
                    .field("test_bit", &self.test_bit())
                    .field("low_timer_recovery_options", &self.low_timer_recovery_options())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LowTimer {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "LowTimer {{ low_timer_counter: {=u16:?}, low_timer_load: {=u16:?}, test_bit: {=bool:?}, low_timer_recovery_options: {=bool:?} }}" , self . low_timer_counter () , self . low_timer_load () , self . test_bit () , self . low_timer_recovery_options ())
            }
        }
        #[doc = "LPF1 Frequency Cut-off Rate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lpf1freqCutoffRate(pub u32);
        impl Lpf1freqCutoffRate {
            #[doc = "The cutoff frequency for the Linear Predictive Filter 1."]
            #[inline(always)]
            pub const fn lpf1_cutoff_freq(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "The cutoff frequency for the Linear Predictive Filter 1."]
            #[inline(always)]
            pub fn set_lpf1_cutoff_freq(&mut self, val: u32) {
                self.0 = (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
            #[doc = "This bit controls the weight parameter W in the First Order Average Equation and the weight parameter W2 in the Second Order Average Equation for Linear Predictive Filter 1."]
            #[inline(always)]
            pub const fn weight(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls the weight parameter W in the First Order Average Equation and the weight parameter W2 in the Second Order Average Equation for Linear Predictive Filter 1."]
            #[inline(always)]
            pub fn set_weight(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "FILTER_ENABLE This bit controls the LPF1 sampling rate."]
            #[inline(always)]
            pub const fn lpf1_sample_eq_adc(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "FILTER_ENABLE This bit controls the LPF1 sampling rate."]
            #[inline(always)]
            pub fn set_lpf1_sample_eq_adc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
        }
        impl Default for Lpf1freqCutoffRate {
            #[inline(always)]
            fn default() -> Lpf1freqCutoffRate {
                Lpf1freqCutoffRate(0)
            }
        }
        impl core::fmt::Debug for Lpf1freqCutoffRate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lpf1freqCutoffRate")
                    .field("lpf1_cutoff_freq", &self.lpf1_cutoff_freq())
                    .field("weight", &self.weight())
                    .field("lpf1_sample_eq_adc", &self.lpf1_sample_eq_adc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lpf1freqCutoffRate {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Lpf1freqCutoffRate {{ lpf1_cutoff_freq: {=u32:?}, weight: {=bool:?}, lpf1_sample_eq_adc: {=bool:?} }}" , self . lpf1_cutoff_freq () , self . weight () , self . lpf1_sample_eq_adc ())
            }
        }
        #[doc = "LPF2 Frequency Cut-off Rate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lpf2freqCutoffRate(pub u32);
        impl Lpf2freqCutoffRate {
            #[doc = "The cutoff frequency for the Linear Predictive Filter 2."]
            #[inline(always)]
            pub const fn lpf2_cutoff_freq(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "The cutoff frequency for the Linear Predictive Filter 2."]
            #[inline(always)]
            pub fn set_lpf2_cutoff_freq(&mut self, val: u32) {
                self.0 = (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
            #[doc = "This bit controls the weight parameter W in the First Order Average Equation and the weight parameter W2 in the Second Order Average Equation for Linear Predictive Filter 1."]
            #[inline(always)]
            pub const fn weight(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls the weight parameter W in the First Order Average Equation and the weight parameter W2 in the Second Order Average Equation for Linear Predictive Filter 1."]
            #[inline(always)]
            pub fn set_weight(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "FILTER_ENABLE This bit controls the LPF1 sampling rate."]
            #[inline(always)]
            pub const fn lpf1_sample_eq_adc(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "FILTER_ENABLE This bit controls the LPF1 sampling rate."]
            #[inline(always)]
            pub fn set_lpf1_sample_eq_adc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
        }
        impl Default for Lpf2freqCutoffRate {
            #[inline(always)]
            fn default() -> Lpf2freqCutoffRate {
                Lpf2freqCutoffRate(0)
            }
        }
        impl core::fmt::Debug for Lpf2freqCutoffRate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lpf2freqCutoffRate")
                    .field("lpf2_cutoff_freq", &self.lpf2_cutoff_freq())
                    .field("weight", &self.weight())
                    .field("lpf1_sample_eq_adc", &self.lpf1_sample_eq_adc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lpf2freqCutoffRate {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Lpf2freqCutoffRate {{ lpf2_cutoff_freq: {=u32:?}, weight: {=bool:?}, lpf1_sample_eq_adc: {=bool:?} }}" , self . lpf2_cutoff_freq () , self . weight () , self . lpf1_sample_eq_adc ())
            }
        }
        #[doc = "Threshold Limit Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ThresholdLimit(pub u32);
        impl ThresholdLimit {
            #[doc = "The contents of this field are added to both THRESHOLD_HIGH and THRESHOLD_LOW when generating the comparison thresholds for the high-side and low-side comparators, respectively."]
            #[inline(always)]
            pub const fn bias(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The contents of this field are added to both THRESHOLD_HIGH and THRESHOLD_LOW when generating the comparison thresholds for the high-side and low-side comparators, respectively."]
            #[inline(always)]
            pub fn set_bias(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "The contents of this field is added or subtracted both comparator thresholds, based on the hysteresis settings for the comparators."]
            #[inline(always)]
            pub const fn hysteresis(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x1f;
                val as u8
            }
            #[doc = "The contents of this field is added or subtracted both comparator thresholds, based on the hysteresis settings for the comparators."]
            #[inline(always)]
            pub fn set_hysteresis(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 11usize)) | (((val as u32) & 0x1f) << 11usize);
            }
            #[doc = "This field contains the base value for setting the comparison threshold for the low-side comparator."]
            #[inline(always)]
            pub const fn threshold_low(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the base value for setting the comparison threshold for the low-side comparator."]
            #[inline(always)]
            pub fn set_threshold_low(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field contains the base value for setting the comparison threshold for the high-side comparator."]
            #[inline(always)]
            pub const fn threshold_high(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the base value for setting the comparison threshold for the high-side comparator."]
            #[inline(always)]
            pub fn set_threshold_high(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for ThresholdLimit {
            #[inline(always)]
            fn default() -> ThresholdLimit {
                ThresholdLimit(0)
            }
        }
        impl core::fmt::Debug for ThresholdLimit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ThresholdLimit")
                    .field("bias", &self.bias())
                    .field("hysteresis", &self.hysteresis())
                    .field("threshold_low", &self.threshold_low())
                    .field("threshold_high", &self.threshold_high())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ThresholdLimit {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ThresholdLimit {{ bias: {=u8:?}, hysteresis: {=u8:?}, threshold_low: {=u8:?}, threshold_high: {=u8:?} }}" , self . bias () , self . hysteresis () , self . threshold_low () , self . threshold_high ())
            }
        }
    }
}
pub mod ps2_0 {
    #[doc = "The four PS/2 Ports implementation eliminates the need to bit bang I/O ports to generate PS/2 traffic."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ps20 {
        ptr: *mut u8,
    }
    unsafe impl Send for Ps20 {}
    unsafe impl Sync for Ps20 {}
    impl Ps20 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data received from a peripheral are recorded in this register in bits 7:0."]
        #[inline(always)]
        pub const fn rx_data(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Writes to bits 7:0 of this register start a transmission of the data in this register to the peripheral"]
        #[inline(always)]
        pub const fn tx_data(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "PS2 Control Register"]
        #[inline(always)]
        pub const fn control(self) -> crate::common::Reg<regs::Control, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "PS2 Status Register"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "PS2 Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Control(pub u32);
        impl Control {
            #[doc = "PS/2 Transmit/Receive 0=The P2/2 channel is enabled to receive data. 1=The PS2 channel is enabled to transmit data."]
            #[inline(always)]
            pub const fn tr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PS/2 Transmit/Receive 0=The P2/2 channel is enabled to receive data. 1=The PS2 channel is enabled to transmit data."]
            #[inline(always)]
            pub fn set_tr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PS/2 Enable. 0=The PS/2 state machine is disabled. 1=The PS/2 state machine is enabled."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PS/2 Enable. 0=The PS/2 state machine is disabled. 1=The PS/2 state machine is enabled."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "00b=Receiver expects Odd Parity (default). 01b=Receiver expects Even Parity. 10b=Receiver ignores level of the parity bit (10th bit is not interpreted as a parity bit). 11b=Reserved"]
            #[inline(always)]
            pub const fn parity(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "00b=Receiver expects Odd Parity (default). 01b=Receiver expects Even Parity. 10b=Receiver ignores level of the parity bit (10th bit is not interpreted as a parity bit). 11b=Reserved"]
            #[inline(always)]
            pub fn set_parity(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "00b=Receiver expects an active high stop bit. 01b=Receiver expects an active low stop bit. 10b=Receiver ignores the level of the Stop bit (11th bit is not interpreted as a stop bit). 11b=Reserved."]
            #[inline(always)]
            pub const fn stop(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "00b=Receiver expects an active high stop bit. 01b=Receiver expects an active low stop bit. 10b=Receiver ignores the level of the Stop bit (11th bit is not interpreted as a stop bit). 11b=Reserved."]
            #[inline(always)]
            pub fn set_stop(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
        }
        impl Default for Control {
            #[inline(always)]
            fn default() -> Control {
                Control(0)
            }
        }
        impl core::fmt::Debug for Control {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Control")
                    .field("tr", &self.tr())
                    .field("en", &self.en())
                    .field("parity", &self.parity())
                    .field("stop", &self.stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Control {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Control {{ tr: {=bool:?}, en: {=bool:?}, parity: {=u8:?}, stop: {=u8:?} }}",
                    self.tr(),
                    self.en(),
                    self.parity(),
                    self.stop()
                )
            }
        }
        #[doc = "PS2 Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "Receive Data Ready. Reading the Receive Register clears this bit. A low to high transition on this bit generates a PS2 Activity interrupt."]
            #[inline(always)]
            pub const fn rdata_rdy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Receive Data Ready. Reading the Receive Register clears this bit. A low to high transition on this bit generates a PS2 Activity interrupt."]
            #[inline(always)]
            pub fn set_rdata_rdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Receive Timeout. The REC_TIMEOUT bit is cleared when the Status Register is read. A low to high transition on this bit generates a PS2 Activity interrupt. (R/WC)"]
            #[inline(always)]
            pub const fn rec_timeout(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Receive Timeout. The REC_TIMEOUT bit is cleared when the Status Register is read. A low to high transition on this bit generates a PS2 Activity interrupt. (R/WC)"]
            #[inline(always)]
            pub fn set_rec_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Parity Error"]
            #[inline(always)]
            pub const fn pe(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Parity Error"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Framing Error"]
            #[inline(always)]
            pub const fn fe(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Framing Error"]
            #[inline(always)]
            pub fn set_fe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Transmitter Idle. 0=The channel is actively transmitting PS/2 data. 1=The channel is not transmitting. A low to high transition on this bit generates a PS2 Activity interrupt."]
            #[inline(always)]
            pub const fn xmit_idle(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Transmitter Idle. 0=The channel is actively transmitting PS/2 data. 1=The channel is not transmitting. A low to high transition on this bit generates a PS2 Activity interrupt."]
            #[inline(always)]
            pub fn set_xmit_idle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Transmitter Time-out. When the XMIT_TIMEOUT bit is set, the PS2_T/R bit is held clear, the PS/2 channel's CLK line is pulled low for a minimum of 300us until the PS/2 Status register is read."]
            #[inline(always)]
            pub const fn xmit_time_out(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Transmitter Time-out. When the XMIT_TIMEOUT bit is set, the PS2_T/R bit is held clear, the PS/2 channel's CLK line is pulled low for a minimum of 300us until the PS/2 Status register is read."]
            #[inline(always)]
            pub fn set_xmit_time_out(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Receive Channel Busy. 0=The channel is idle 1=The channel is actively receiving PS/2 data"]
            #[inline(always)]
            pub const fn rx_busy(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Receive Channel Busy. 0=The channel is idle 1=The channel is actively receiving PS/2 data"]
            #[inline(always)]
            pub fn set_rx_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit Start Timeout. 0=No transmit start timeout detected 1=A start bit was not received within 25 ms following the transmit start event. The transmit start bit time-out condition is also indicated by the XMIT_TIMEOUT bit."]
            #[inline(always)]
            pub const fn xmit_start_timeout(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit Start Timeout. 0=No transmit start timeout detected 1=A start bit was not received within 25 ms following the transmit start event. The transmit start bit time-out condition is also indicated by the XMIT_TIMEOUT bit."]
            #[inline(always)]
            pub fn set_xmit_start_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("rdata_rdy", &self.rdata_rdy())
                    .field("rec_timeout", &self.rec_timeout())
                    .field("pe", &self.pe())
                    .field("fe", &self.fe())
                    .field("xmit_idle", &self.xmit_idle())
                    .field("xmit_time_out", &self.xmit_time_out())
                    .field("rx_busy", &self.rx_busy())
                    .field("xmit_start_timeout", &self.xmit_start_timeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Status {{ rdata_rdy: {=bool:?}, rec_timeout: {=bool:?}, pe: {=bool:?}, fe: {=bool:?}, xmit_idle: {=bool:?}, xmit_time_out: {=bool:?}, rx_busy: {=bool:?}, xmit_start_timeout: {=bool:?} }}" , self . rdata_rdy () , self . rec_timeout () , self . pe () , self . fe () , self . xmit_idle () , self . xmit_time_out () , self . rx_busy () , self . xmit_start_timeout ())
            }
        }
    }
}
pub mod pwm0 {
    #[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwm0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Pwm0 {}
    unsafe impl Sync for Pwm0 {}
    impl Pwm0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This field determines both the frequency and duty cycle of the PWM signal. Setting this field to a value of n will cause the On time of the PWM to be n+1 cycles of the PWM Clock Source. When this field is set to zero and the PWMX_COUNTER_OFF_TIME is not set to zero, the PWM_OUTPUT is held low (Full Off)."]
        #[inline(always)]
        pub const fn cnt_on(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This field determine both the frequency and duty cycle of the PWM signal. Setting this field to a value of n will cause the Off time of the PWM to be n+1 cycles of the PWM Clock Source. When this field is set to zero, the PWM_OUTPUT is held high (Full On)."]
        #[inline(always)]
        pub const fn cnt_off(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "PWMx CONFIGURATION REGISTER"]
        #[inline(always)]
        pub const fn cfg(self) -> crate::common::Reg<regs::Cfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "PWMx CONFIGURATION REGISTER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfg(pub u32);
        impl Cfg {
            #[doc = "When the PWM_ENABLE is set to 0 the internal counters are reset and the internal state machine is set to the OFF state. In addition, the PWM_OUTPUT signal is set to the inactive state as determined by the Invert bit. The PWMx Counter ON Time Register and PWMx Counter OFF Time Register are not affected by the PWM_ENABLE bit and may be read and written while the PWM enable bit is 0. 1=Enabled (default); 0=Disabled (gates clocks to save power)."]
            #[inline(always)]
            pub const fn pwm_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When the PWM_ENABLE is set to 0 the internal counters are reset and the internal state machine is set to the OFF state. In addition, the PWM_OUTPUT signal is set to the inactive state as determined by the Invert bit. The PWMx Counter ON Time Register and PWMx Counter OFF Time Register are not affected by the PWM_ENABLE bit and may be read and written while the PWM enable bit is 0. 1=Enabled (default); 0=Disabled (gates clocks to save power)."]
            #[inline(always)]
            pub fn set_pwm_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit determines the clock source used by the PWM duty cycle and frequency control logic. 1=CLOCK_LOW 0=CLOCK_HIGH"]
            #[inline(always)]
            pub const fn clk_sel(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit determines the clock source used by the PWM duty cycle and frequency control logic. 1=CLOCK_LOW 0=CLOCK_HIGH"]
            #[inline(always)]
            pub fn set_clk_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1= PWM_OUTPUT ON State is active low; 0=PWM_OUTPUT ON State is active high."]
            #[inline(always)]
            pub const fn inv(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1= PWM_OUTPUT ON State is active low; 0=PWM_OUTPUT ON State is active high."]
            #[inline(always)]
            pub fn set_inv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "The Clock source for the 16-bit down counter (see PWMx Counter ON Time Register and PWMx Counter OFF Time Register) is determined by bit D1 of this register. The Clock source is then divided by the value of Pre-Divider+1 and the resulting signal determines the rate at which the down counter will be decremented. For example, a Pre-Divider value of 1 divides the input clock by 2 and a value of 2 divides the input clock by 3. A Pre-Divider of 0 will disable the Pre-Divider option."]
            #[inline(always)]
            pub const fn clk_pre_div(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x0f;
                val as u8
            }
            #[doc = "The Clock source for the 16-bit down counter (see PWMx Counter ON Time Register and PWMx Counter OFF Time Register) is determined by bit D1 of this register. The Clock source is then divided by the value of Pre-Divider+1 and the resulting signal determines the rate at which the down counter will be decremented. For example, a Pre-Divider value of 1 divides the input clock by 2 and a value of 2 divides the input clock by 3. A Pre-Divider of 0 will disable the Pre-Divider option."]
            #[inline(always)]
            pub fn set_clk_pre_div(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 3usize)) | (((val as u32) & 0x0f) << 3usize);
            }
        }
        impl Default for Cfg {
            #[inline(always)]
            fn default() -> Cfg {
                Cfg(0)
            }
        }
        impl core::fmt::Debug for Cfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfg")
                    .field("pwm_en", &self.pwm_en())
                    .field("clk_sel", &self.clk_sel())
                    .field("inv", &self.inv())
                    .field("clk_pre_div", &self.clk_pre_div())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cfg {{ pwm_en: {=bool:?}, clk_sel: {=bool:?}, inv: {=bool:?}, clk_pre_div: {=u8:?} }}",
                    self.pwm_en(),
                    self.clk_sel(),
                    self.inv(),
                    self.clk_pre_div()
                )
            }
        }
    }
}
pub mod qmspi {
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct LdmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for LdmaRx {}
    unsafe impl Sync for LdmaRx {}
    impl LdmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "QMSPI RX Control Register"]
        #[inline(always)]
        pub const fn ldma_rxctrl(self) -> crate::common::Reg<regs::LdmaRxctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "QMSPI Local DMA Rx Start Address Register"]
        #[inline(always)]
        pub const fn ldma_rxstrt_addr(self) -> crate::common::Reg<regs::LdmaRxstrtAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "QMSPI Local DMA Rx Length Register"]
        #[inline(always)]
        pub const fn ldma_rx_len(self) -> crate::common::Reg<regs::LdmaRxLen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Reserved Register"]
        #[inline(always)]
        pub const fn rsvd(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct LdmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for LdmaTx {}
    unsafe impl Sync for LdmaTx {}
    impl LdmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "QMSPI TX Control Register"]
        #[inline(always)]
        pub const fn ldma_txctrl(self) -> crate::common::Reg<regs::LdmaTxctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "QMSPI Local DMA Tx Start Address Register"]
        #[inline(always)]
        pub const fn ldma_txstrt_addr(self) -> crate::common::Reg<regs::LdmaTxstrtAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "QMSPI Local DMA Tx Length Register"]
        #[inline(always)]
        pub const fn ldma_tx_len(self) -> crate::common::Reg<regs::LdmaTxLen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Reserved Register"]
        #[inline(always)]
        pub const fn rsvd(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Qmspi {
        ptr: *mut u8,
    }
    unsafe impl Send for Qmspi {}
    unsafe impl Sync for Qmspi {}
    impl Qmspi {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "QMSPI Mode Register"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "QMSPI SPI Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "QMSPI Execute Register"]
        #[inline(always)]
        pub const fn exe(self) -> crate::common::Reg<regs::Exe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "QMSPI Interface Control Register"]
        #[inline(always)]
        pub const fn ifctrl(self) -> crate::common::Reg<regs::Ifctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "QMSPI Status Register"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "QMSPI Buffer Count Status Register"]
        #[inline(always)]
        pub const fn buf_cnt_sts(self) -> crate::common::Reg<regs::BufCntSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "QMSPI Interrupt Enable Register"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "QMSPI Buffer Count Trigger Register"]
        #[inline(always)]
        pub const fn buf_cnt_trig(self) -> crate::common::Reg<regs::BufCntTrig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "QMSPI Transmit Buffer Register"]
        #[inline(always)]
        pub const fn tx_fifo(self) -> crate::common::Reg<regs::TxFifo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "QMSPI Receive Buffer Register"]
        #[inline(always)]
        pub const fn rx_fifo(self) -> crate::common::Reg<regs::RxFifo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "QMSPI Chip Select Timing Register"]
        #[inline(always)]
        pub const fn cstm(self) -> crate::common::Reg<regs::Cstm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "QMSPI Description Buffer 0 Register"]
        #[inline(always)]
        pub const fn descr(self, n: usize) -> crate::common::Reg<regs::Descr, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize + n * 4usize) as _) }
        }
        #[doc = "QMSPI Alias Control Register"]
        #[inline(always)]
        pub const fn alias_ctrl(self) -> crate::common::Reg<regs::AliasCtrl, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb0usize) as _) }
        }
        #[doc = "QMSPI Mode Alternate 1 Register"]
        #[inline(always)]
        pub const fn mode_alt1(self) -> crate::common::Reg<regs::ModeAlt1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "QMSPI TAPs Register"]
        #[inline(always)]
        pub const fn taps(self) -> crate::common::Reg<regs::Taps, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd0usize) as _) }
        }
        #[doc = "QMSPI TAP Control Register"]
        #[inline(always)]
        pub const fn tap_adj(self) -> crate::common::Reg<regs::TapAdj, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd4usize) as _) }
        }
        #[doc = "QMSPI TAP Adjustment Register"]
        #[inline(always)]
        pub const fn tap_ctrl(self) -> crate::common::Reg<regs::TapCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd8usize) as _) }
        }
        #[doc = "QMSPI Descriptor Local DMA Rx Enable Register"]
        #[inline(always)]
        pub const fn desc_ldma_rxen(self) -> crate::common::Reg<regs::DescLdmaRxen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "QMSPI Descriptor Local DMA Tx Enable Register"]
        #[inline(always)]
        pub const fn desc_ldma_txen(self) -> crate::common::Reg<regs::DescLdmaTxen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[inline(always)]
        pub const fn ldma_rx(self, n: usize) -> LdmaRx {
            assert!(n < 3usize);
            unsafe { LdmaRx::from_ptr(self.ptr.add(0x0110usize + n * 16usize) as _) }
        }
        #[inline(always)]
        pub const fn ldma_tx(self, n: usize) -> LdmaTx {
            assert!(n < 3usize);
            unsafe { LdmaTx::from_ptr(self.ptr.add(0x0140usize + n * 16usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "QMSPI Alias Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AliasCtrl(pub u32);
        impl AliasCtrl {
            #[doc = "Alias for the QMSPI Execution:Start field."]
            #[inline(always)]
            pub const fn als_exec_strt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Alias for the QMSPI Execution:Start field."]
            #[inline(always)]
            pub fn set_als_exec_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable the CS1 Clock Divide to be active if CS1 is the interface in use."]
            #[inline(always)]
            pub const fn cls_altmode_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the CS1 Clock Divide to be active if CS1 is the interface in use."]
            #[inline(always)]
            pub fn set_cls_altmode_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Alias that triggers a write to the Tx Buffer of 1 Byte using data from Alias Tx Buffer Data in this register."]
            #[inline(always)]
            pub const fn als_wr_txbuf(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Alias that triggers a write to the Tx Buffer of 1 Byte using data from Alias Tx Buffer Data in this register."]
            #[inline(always)]
            pub fn set_als_wr_txbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Alias that triggers a write to the Description Buffer pointed to by Alias Description Buffer Select in this register to modify the Transfer Length field with the value of Alias Description Buffer Transfer Length in this register."]
            #[inline(always)]
            pub const fn als_wrdbuf_xfrlen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Alias that triggers a write to the Description Buffer pointed to by Alias Description Buffer Select in this register to modify the Transfer Length field with the value of Alias Description Buffer Transfer Length in this register."]
            #[inline(always)]
            pub fn set_als_wrdbuf_xfrlen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Alias for the QMSPI Mode:Chip Select field."]
            #[inline(always)]
            pub const fn als_mod_cs(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "Alias for the QMSPI Mode:Chip Select field."]
            #[inline(always)]
            pub fn set_als_mod_cs(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "Alias that overrides the value in all QMSPI Local DMA * \\[Tx/Rx\\] Control:Increment Address Enable fields w/ this value."]
            #[inline(always)]
            pub const fn als_ldma_incr_add(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Alias that overrides the value in all QMSPI Local DMA * \\[Tx/Rx\\] Control:Increment Address Enable fields w/ this value."]
            #[inline(always)]
            pub fn set_als_ldma_incr_add(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Alias for the QMSPI Control:Description Buffer Pointer field."]
            #[inline(always)]
            pub const fn als_ctrl_dbuf_ptr(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Alias for the QMSPI Control:Description Buffer Pointer field."]
            #[inline(always)]
            pub fn set_als_ctrl_dbuf_ptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Which Description Buffer will be modified by a write if Alias Write Description Buffer Transfer Length is set."]
            #[inline(always)]
            pub const fn als_dbuf_sel(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Which Description Buffer will be modified by a write if Alias Write Description Buffer Transfer Length is set."]
            #[inline(always)]
            pub fn set_als_dbuf_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "The value of the data written to the Description Buffers Transfer Length field, if the write is enabled."]
            #[inline(always)]
            pub const fn als_dbuf_xfr_len(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "The value of the data written to the Description Buffers Transfer Length field, if the write is enabled."]
            #[inline(always)]
            pub fn set_als_dbuf_xfr_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "The Byte of data written into the Tx Buffer if the write is enabled."]
            #[inline(always)]
            pub const fn als_txdbuf_data(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "The Byte of data written into the Tx Buffer if the write is enabled."]
            #[inline(always)]
            pub fn set_als_txdbuf_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for AliasCtrl {
            #[inline(always)]
            fn default() -> AliasCtrl {
                AliasCtrl(0)
            }
        }
        impl core::fmt::Debug for AliasCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AliasCtrl")
                    .field("als_exec_strt", &self.als_exec_strt())
                    .field("cls_altmode_en", &self.cls_altmode_en())
                    .field("als_wr_txbuf", &self.als_wr_txbuf())
                    .field("als_wrdbuf_xfrlen", &self.als_wrdbuf_xfrlen())
                    .field("als_mod_cs", &self.als_mod_cs())
                    .field("als_ldma_incr_add", &self.als_ldma_incr_add())
                    .field("als_ctrl_dbuf_ptr", &self.als_ctrl_dbuf_ptr())
                    .field("als_dbuf_sel", &self.als_dbuf_sel())
                    .field("als_dbuf_xfr_len", &self.als_dbuf_xfr_len())
                    .field("als_txdbuf_data", &self.als_txdbuf_data())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AliasCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "AliasCtrl {{ als_exec_strt: {=bool:?}, cls_altmode_en: {=bool:?}, als_wr_txbuf: {=bool:?}, als_wrdbuf_xfrlen: {=bool:?}, als_mod_cs: {=u8:?}, als_ldma_incr_add: {=bool:?}, als_ctrl_dbuf_ptr: {=u8:?}, als_dbuf_sel: {=u8:?}, als_dbuf_xfr_len: {=u8:?}, als_txdbuf_data: {=u8:?} }}" , self . als_exec_strt () , self . cls_altmode_en () , self . als_wr_txbuf () , self . als_wrdbuf_xfrlen () , self . als_mod_cs () , self . als_ldma_incr_add () , self . als_ctrl_dbuf_ptr () , self . als_dbuf_sel () , self . als_dbuf_xfr_len () , self . als_txdbuf_data ())
            }
        }
        #[doc = "QMSPI Buffer Count Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BufCntSts(pub u32);
        impl BufCntSts {
            #[doc = "This is a count of the number of bytes currently valid in the Transmit Buffer."]
            #[inline(always)]
            pub const fn tx_buff_cnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is a count of the number of bytes currently valid in the Transmit Buffer."]
            #[inline(always)]
            pub fn set_tx_buff_cnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "This is a count of the number of bytes currently valid in the Receive Buffer."]
            #[inline(always)]
            pub const fn rx_buff_cnt(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This is a count of the number of bytes currently valid in the Receive Buffer."]
            #[inline(always)]
            pub fn set_rx_buff_cnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for BufCntSts {
            #[inline(always)]
            fn default() -> BufCntSts {
                BufCntSts(0)
            }
        }
        impl core::fmt::Debug for BufCntSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BufCntSts")
                    .field("tx_buff_cnt", &self.tx_buff_cnt())
                    .field("rx_buff_cnt", &self.rx_buff_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BufCntSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BufCntSts {{ tx_buff_cnt: {=u16:?}, rx_buff_cnt: {=u16:?} }}",
                    self.tx_buff_cnt(),
                    self.rx_buff_cnt()
                )
            }
        }
        #[doc = "QMSPI Buffer Count Trigger Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BufCntTrig(pub u32);
        impl BufCntTrig {
            #[doc = "An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_trig(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_trig(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_trig(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_trig(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for BufCntTrig {
            #[inline(always)]
            fn default() -> BufCntTrig {
                BufCntTrig(0)
            }
        }
        impl core::fmt::Debug for BufCntTrig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BufCntTrig")
                    .field("tx_buf_trig", &self.tx_buf_trig())
                    .field("rx_buf_trig", &self.rx_buf_trig())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BufCntTrig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BufCntTrig {{ tx_buf_trig: {=u16:?}, rx_buf_trig: {=u16:?} }}",
                    self.tx_buf_trig(),
                    self.rx_buf_trig()
                )
            }
        }
        #[doc = "QMSPI Chip Select Timing Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cstm(pub u32);
        impl Cstm {
            #[doc = "This selects the number of system clock cycles between CS assertion to the start of the SPI Clock."]
            #[inline(always)]
            pub const fn dly_cs_on_clk_strt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This selects the number of system clock cycles between CS assertion to the start of the SPI Clock."]
            #[inline(always)]
            pub fn set_dly_cs_on_clk_strt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "This selects the number of system clock cycles between the last clock edge and the deassertion of CS."]
            #[inline(always)]
            pub const fn dly_clk_stop_cs_off(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "This selects the number of system clock cycles between the last clock edge and the deassertion of CS."]
            #[inline(always)]
            pub fn set_dly_clk_stop_cs_off(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD switching from input to output."]
            #[inline(always)]
            pub const fn dly_last_dat_hld(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD switching from input to output."]
            #[inline(always)]
            pub fn set_dly_last_dat_hld(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum pulse width of CS deassertion."]
            #[inline(always)]
            pub const fn dly_off_to_on(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum pulse width of CS deassertion."]
            #[inline(always)]
            pub fn set_dly_off_to_on(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cstm {
            #[inline(always)]
            fn default() -> Cstm {
                Cstm(0)
            }
        }
        impl core::fmt::Debug for Cstm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cstm")
                    .field("dly_cs_on_clk_strt", &self.dly_cs_on_clk_strt())
                    .field("dly_clk_stop_cs_off", &self.dly_clk_stop_cs_off())
                    .field("dly_last_dat_hld", &self.dly_last_dat_hld())
                    .field("dly_off_to_on", &self.dly_off_to_on())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cstm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cstm {{ dly_cs_on_clk_strt: {=u8:?}, dly_clk_stop_cs_off: {=u8:?}, dly_last_dat_hld: {=u8:?}, dly_off_to_on: {=u8:?} }}" , self . dly_cs_on_clk_strt () , self . dly_clk_stop_cs_off () , self . dly_last_dat_hld () , self . dly_off_to_on ())
            }
        }
        #[doc = "QMSPI SPI Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub const fn tx_mode(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub fn set_tx_mode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used. 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub const fn tx_trans_en(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used. 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub fn set_tx_trans_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes. 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware"]
            #[inline(always)]
            pub const fn tx_dma_en(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes. 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware"]
            #[inline(always)]
            pub fn set_tx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer 0=Receive is disabled"]
            #[inline(always)]
            pub const fn rx_trans_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer 0=Receive is disabled"]
            #[inline(always)]
            pub fn set_rx_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware"]
            #[inline(always)]
            pub const fn rx_dma_en(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware"]
            #[inline(always)]
            pub fn set_rx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 7usize)) | (((val as u32) & 0x03) << 7usize);
            }
            #[doc = "This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer. 1=The transaction is terminated 0=The transaction is not terminated"]
            #[inline(always)]
            pub const fn close_trans_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer. 1=The transaction is terminated 0=The transaction is not terminated"]
            #[inline(always)]
            pub fn set_close_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "3=TRANSFER_LENGTH defined in units of 16-byte segments 2=TRANSFER_LENGTH defined in units of 4-byte segments 1=TRANSFER_LENGTH defined in units of bytes 0=TRANSFER_LENGTH defined in units of bits."]
            #[inline(always)]
            pub const fn trans_units(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x03;
                val as u8
            }
            #[doc = "3=TRANSFER_LENGTH defined in units of 16-byte segments 2=TRANSFER_LENGTH defined in units of 4-byte segments 1=TRANSFER_LENGTH defined in units of bytes 0=TRANSFER_LENGTH defined in units of bits."]
            #[inline(always)]
            pub fn set_trans_units(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize);
            }
            #[doc = "This field selects the first buffer used if Description Buffers are enabled."]
            #[inline(always)]
            pub const fn descr_buff_ptr(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "This field selects the first buffer used if Description Buffers are enabled."]
            #[inline(always)]
            pub fn set_descr_buff_ptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This enables the Description Buffers to be used. 1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER 0=Description Buffers disabled."]
            #[inline(always)]
            pub const fn descr_buff_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the Description Buffers to be used. 1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER 0=Description Buffers disabled."]
            #[inline(always)]
            pub fn set_descr_buff_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub const fn trans_len(&self) -> u16 {
                let val = (self.0 >> 17usize) & 0x7fff;
                val as u16
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub fn set_trans_len(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 17usize)) | (((val as u32) & 0x7fff) << 17usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("tx_mode", &self.tx_mode())
                    .field("tx_trans_en", &self.tx_trans_en())
                    .field("tx_dma_en", &self.tx_dma_en())
                    .field("rx_trans_en", &self.rx_trans_en())
                    .field("rx_dma_en", &self.rx_dma_en())
                    .field("close_trans_en", &self.close_trans_en())
                    .field("trans_units", &self.trans_units())
                    .field("descr_buff_ptr", &self.descr_buff_ptr())
                    .field("descr_buff_en", &self.descr_buff_en())
                    .field("trans_len", &self.trans_len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ tx_mode: {=u8:?}, tx_trans_en: {=u8:?}, tx_dma_en: {=u8:?}, rx_trans_en: {=bool:?}, rx_dma_en: {=u8:?}, close_trans_en: {=bool:?}, trans_units: {=u8:?}, descr_buff_ptr: {=u8:?}, descr_buff_en: {=bool:?}, trans_len: {=u16:?} }}" , self . tx_mode () , self . tx_trans_en () , self . tx_dma_en () , self . rx_trans_en () , self . rx_dma_en () , self . close_trans_en () , self . trans_units () , self . descr_buff_ptr () , self . descr_buff_en () , self . trans_len ())
            }
        }
        #[doc = "QMSPI Descriptor Local DMA Rx Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DescLdmaRxen(pub u32);
        impl DescLdmaRxen {
            #[doc = "This enables the Local RX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."]
            #[inline(always)]
            pub const fn desc_ldma_rxen(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This enables the Local RX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."]
            #[inline(always)]
            pub fn set_desc_ldma_rxen(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for DescLdmaRxen {
            #[inline(always)]
            fn default() -> DescLdmaRxen {
                DescLdmaRxen(0)
            }
        }
        impl core::fmt::Debug for DescLdmaRxen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DescLdmaRxen")
                    .field("desc_ldma_rxen", &self.desc_ldma_rxen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DescLdmaRxen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DescLdmaRxen {{ desc_ldma_rxen: {=u16:?} }}", self.desc_ldma_rxen())
            }
        }
        #[doc = "QMSPI Descriptor Local DMA Tx Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DescLdmaTxen(pub u32);
        impl DescLdmaTxen {
            #[doc = "This enables the Local TX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."]
            #[inline(always)]
            pub const fn desc_ldma_txen(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This enables the Local TX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."]
            #[inline(always)]
            pub fn set_desc_ldma_txen(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for DescLdmaTxen {
            #[inline(always)]
            fn default() -> DescLdmaTxen {
                DescLdmaTxen(0)
            }
        }
        impl core::fmt::Debug for DescLdmaTxen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DescLdmaTxen")
                    .field("desc_ldma_txen", &self.desc_ldma_txen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DescLdmaTxen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DescLdmaTxen {{ desc_ldma_txen: {=u16:?} }}", self.desc_ldma_txen())
            }
        }
        #[doc = "QMSPI Description Buffer 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Descr(pub u32);
        impl Descr {
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub const fn inface_mod(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub fn set_inface_mod(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub const fn tx_trans_en(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub fn set_tx_trans_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."]
            #[inline(always)]
            pub const fn tx_dma_en(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."]
            #[inline(always)]
            pub fn set_tx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."]
            #[inline(always)]
            pub const fn rx_trans_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."]
            #[inline(always)]
            pub fn set_rx_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."]
            #[inline(always)]
            pub const fn rx_dma_en(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."]
            #[inline(always)]
            pub fn set_rx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 7usize)) | (((val as u32) & 0x03) << 7usize);
            }
            #[doc = "This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer. 1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer. 0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"]
            #[inline(always)]
            pub const fn close_trans_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer. 1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer. 0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"]
            #[inline(always)]
            pub fn set_close_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "3=TRANSFER_LENGTH defined in units of 16-byte segments, 2=TRANSFER_LENGTH defined in units of 4-byte segments, 1=TRANSFER_LENGTH defined in units of bytes 0=TRANSFER_LENGTH defined in units of bits"]
            #[inline(always)]
            pub const fn trans_len_bits(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x03;
                val as u8
            }
            #[doc = "3=TRANSFER_LENGTH defined in units of 16-byte segments, 2=TRANSFER_LENGTH defined in units of 4-byte segments, 1=TRANSFER_LENGTH defined in units of bytes 0=TRANSFER_LENGTH defined in units of bits"]
            #[inline(always)]
            pub fn set_trans_len_bits(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize);
            }
            #[doc = "This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."]
            #[inline(always)]
            pub const fn descr_buf_nxt_ptr(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."]
            #[inline(always)]
            pub fn set_descr_buf_nxt_ptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."]
            #[inline(always)]
            pub const fn descr_buf_last(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."]
            #[inline(always)]
            pub fn set_descr_buf_last(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub const fn tx_len(&self) -> u16 {
                let val = (self.0 >> 17usize) & 0x7fff;
                val as u16
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub fn set_tx_len(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 17usize)) | (((val as u32) & 0x7fff) << 17usize);
            }
        }
        impl Default for Descr {
            #[inline(always)]
            fn default() -> Descr {
                Descr(0)
            }
        }
        impl core::fmt::Debug for Descr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Descr")
                    .field("inface_mod", &self.inface_mod())
                    .field("tx_trans_en", &self.tx_trans_en())
                    .field("tx_dma_en", &self.tx_dma_en())
                    .field("rx_trans_en", &self.rx_trans_en())
                    .field("rx_dma_en", &self.rx_dma_en())
                    .field("close_trans_en", &self.close_trans_en())
                    .field("trans_len_bits", &self.trans_len_bits())
                    .field("descr_buf_nxt_ptr", &self.descr_buf_nxt_ptr())
                    .field("descr_buf_last", &self.descr_buf_last())
                    .field("tx_len", &self.tx_len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Descr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Descr {{ inface_mod: {=u8:?}, tx_trans_en: {=u8:?}, tx_dma_en: {=u8:?}, rx_trans_en: {=bool:?}, rx_dma_en: {=u8:?}, close_trans_en: {=bool:?}, trans_len_bits: {=u8:?}, descr_buf_nxt_ptr: {=u8:?}, descr_buf_last: {=bool:?}, tx_len: {=u16:?} }}" , self . inface_mod () , self . tx_trans_en () , self . tx_dma_en () , self . rx_trans_en () , self . rx_dma_en () , self . close_trans_en () , self . trans_len_bits () , self . descr_buf_nxt_ptr () , self . descr_buf_last () , self . tx_len ())
            }
        }
        #[doc = "QMSPI Execute Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Exe(pub u32);
        impl Exe {
            #[doc = "Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing. This bit must not be set to 1 if the field STOP in this register is set to 1."]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing. This bit must not be set to 1 if the field STOP in this register is set to 1."]
            #[inline(always)]
            pub fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect. This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1."]
            #[inline(always)]
            pub const fn stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect. This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1."]
            #[inline(always)]
            pub fn set_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset. Writing a 0 to this bit has no effect. This bit is self clearing."]
            #[inline(always)]
            pub const fn clr_dat_buff(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset. Writing a 0 to this bit has no effect. This bit is self clearing."]
            #[inline(always)]
            pub fn set_clr_dat_buff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Exe {
            #[inline(always)]
            fn default() -> Exe {
                Exe(0)
            }
        }
        impl core::fmt::Debug for Exe {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Exe")
                    .field("start", &self.start())
                    .field("stop", &self.stop())
                    .field("clr_dat_buff", &self.clr_dat_buff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Exe {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Exe {{ start: {=bool:?}, stop: {=bool:?}, clr_dat_buff: {=bool:?} }}",
                    self.start(),
                    self.stop(),
                    self.clr_dat_buff()
                )
            }
        }
        #[doc = "QMSPI Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u32);
        impl Ien {
            #[doc = "1=Enable an interrupt if TRANSFER_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn trans_compl_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSFER_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_trans_compl_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=Enable an interrupt if DMA_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn dma_compl_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if DMA_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_dma_compl_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_err_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_err_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_err_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_err_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "1=Enable an interrupt if PROGRAMMING_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn prgm_err_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if PROGRAMMING_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_prgm_err_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "1=Enable an interrupt if Local DMA RX Error is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn ldma_rxerrie(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if Local DMA RX Error is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_ldma_rxerrie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "1=Enable an interrupt if Local DMA TX Error is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn ldma_txerrie(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if Local DMA TX Error is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_ldma_txerrie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_full_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_full_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_empty_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_empty_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_req_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_req_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_ful_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_ful_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_empty_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_empty_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_req_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_req_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("trans_compl_en", &self.trans_compl_en())
                    .field("dma_compl_en", &self.dma_compl_en())
                    .field("tx_buf_err_en", &self.tx_buf_err_en())
                    .field("rx_buf_err_en", &self.rx_buf_err_en())
                    .field("prgm_err_en", &self.prgm_err_en())
                    .field("ldma_rxerrie", &self.ldma_rxerrie())
                    .field("ldma_txerrie", &self.ldma_txerrie())
                    .field("tx_buf_full_en", &self.tx_buf_full_en())
                    .field("tx_buf_empty_en", &self.tx_buf_empty_en())
                    .field("tx_buf_req_en", &self.tx_buf_req_en())
                    .field("rx_buf_ful_en", &self.rx_buf_ful_en())
                    .field("rx_buf_empty_en", &self.rx_buf_empty_en())
                    .field("rx_buf_req_en", &self.rx_buf_req_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ien {{ trans_compl_en: {=bool:?}, dma_compl_en: {=bool:?}, tx_buf_err_en: {=bool:?}, rx_buf_err_en: {=bool:?}, prgm_err_en: {=bool:?}, ldma_rxerrie: {=bool:?}, ldma_txerrie: {=bool:?}, tx_buf_full_en: {=bool:?}, tx_buf_empty_en: {=bool:?}, tx_buf_req_en: {=bool:?}, rx_buf_ful_en: {=bool:?}, rx_buf_empty_en: {=bool:?}, rx_buf_req_en: {=bool:?} }}" , self . trans_compl_en () , self . dma_compl_en () , self . tx_buf_err_en () , self . rx_buf_err_en () , self . prgm_err_en () , self . ldma_rxerrie () , self . ldma_txerrie () , self . tx_buf_full_en () , self . tx_buf_empty_en () , self . tx_buf_req_en () , self . rx_buf_ful_en () , self . rx_buf_empty_en () , self . rx_buf_req_en ())
            }
        }
        #[doc = "QMSPI Interface Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ifctrl(pub u32);
        impl Ifctrl {
            #[doc = "This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven. 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0"]
            #[inline(always)]
            pub const fn wr_prct_out_val(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven. 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0"]
            #[inline(always)]
            pub fn set_wr_prct_out_val(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=WRITE PROTECT SPI Output Port is driven 0=WRITE PROTECT SPI Output Port is not driven"]
            #[inline(always)]
            pub const fn wr_prct_out_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=WRITE PROTECT SPI Output Port is driven 0=WRITE PROTECT SPI Output Port is not driven"]
            #[inline(always)]
            pub fn set_wr_prct_out_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit sets the value on the HOLD SPI Output Port if it is driven. 1=HOLD is driven to 1; 0=HOLD is driven to 0."]
            #[inline(always)]
            pub const fn hld_out_val(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit sets the value on the HOLD SPI Output Port if it is driven. 1=HOLD is driven to 1; 0=HOLD is driven to 0."]
            #[inline(always)]
            pub fn set_hld_out_val(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=HOLD SPI Output Port is driven 0=HOLD SPI Output Port is not driven."]
            #[inline(always)]
            pub const fn hld_out_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=HOLD SPI Output Port is driven 0=HOLD SPI Output Port is not driven."]
            #[inline(always)]
            pub fn set_hld_out_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-down resistors enabled on Receive pins"]
            #[inline(always)]
            pub const fn pd_on_not_sel(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-down resistors enabled on Receive pins"]
            #[inline(always)]
            pub fn set_pd_on_not_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-up resistors enabled on Receive pins."]
            #[inline(always)]
            pub const fn pu_on_notsel(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-up resistors enabled on Receive pins."]
            #[inline(always)]
            pub fn set_pu_on_notsel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "1=Enable pull-down resistors on Transmit pins while the pins are not driven 0=No pull-down resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub const fn pd_on_notdriven(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-down resistors on Transmit pins while the pins are not driven 0=No pull-down resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub fn set_pd_on_notdriven(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "1=Enable pull-up resistors on Transmit pins while the pins are not driven 0=No pull-up resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub const fn pu_on_notdriven(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-up resistors on Transmit pins while the pins are not driven 0=No pull-up resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub fn set_pu_on_notdriven(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Ifctrl {
            #[inline(always)]
            fn default() -> Ifctrl {
                Ifctrl(0)
            }
        }
        impl core::fmt::Debug for Ifctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ifctrl")
                    .field("wr_prct_out_val", &self.wr_prct_out_val())
                    .field("wr_prct_out_en", &self.wr_prct_out_en())
                    .field("hld_out_val", &self.hld_out_val())
                    .field("hld_out_en", &self.hld_out_en())
                    .field("pd_on_not_sel", &self.pd_on_not_sel())
                    .field("pu_on_notsel", &self.pu_on_notsel())
                    .field("pd_on_notdriven", &self.pd_on_notdriven())
                    .field("pu_on_notdriven", &self.pu_on_notdriven())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ifctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ifctrl {{ wr_prct_out_val: {=bool:?}, wr_prct_out_en: {=bool:?}, hld_out_val: {=bool:?}, hld_out_en: {=bool:?}, pd_on_not_sel: {=bool:?}, pu_on_notsel: {=bool:?}, pd_on_notdriven: {=bool:?}, pu_on_notdriven: {=bool:?} }}" , self . wr_prct_out_val () , self . wr_prct_out_en () , self . hld_out_val () , self . hld_out_en () , self . pd_on_not_sel () , self . pu_on_notsel () , self . pd_on_notdriven () , self . pu_on_notdriven ())
            }
        }
        #[doc = "QMSPI Local DMA Rx Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaRxLen(pub u32);
        impl LdmaRxLen {
            #[doc = "This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."]
            #[inline(always)]
            pub const fn rx_len(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."]
            #[inline(always)]
            pub fn set_rx_len(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LdmaRxLen {
            #[inline(always)]
            fn default() -> LdmaRxLen {
                LdmaRxLen(0)
            }
        }
        impl core::fmt::Debug for LdmaRxLen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaRxLen").field("rx_len", &self.rx_len()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaRxLen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LdmaRxLen {{ rx_len: {=u32:?} }}", self.rx_len())
            }
        }
        #[doc = "QMSPI RX Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaRxctrl(pub u32);
        impl LdmaRxctrl {
            #[doc = "This enables the Local RX DMA Channel."]
            #[inline(always)]
            pub const fn ch_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the Local RX DMA Channel."]
            #[inline(always)]
            pub fn set_ch_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit automatically re-enables the Local DMA Channel after completion of previous transfer."]
            #[inline(always)]
            pub const fn rstrt_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit automatically re-enables the Local DMA Channel after completion of previous transfer."]
            #[inline(always)]
            pub fn set_rstrt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Address re-enable will automatically re-enables the same address upon completion previous transfer."]
            #[inline(always)]
            pub const fn buf_addr_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Address re-enable will automatically re-enables the same address upon completion previous transfer."]
            #[inline(always)]
            pub fn set_buf_addr_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."]
            #[inline(always)]
            pub const fn ovrd_len(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."]
            #[inline(always)]
            pub fn set_ovrd_len(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Access Size selects the AHB Access Size."]
            #[inline(always)]
            pub const fn acs_sz(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "Access Size selects the AHB Access Size."]
            #[inline(always)]
            pub fn set_acs_sz(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."]
            #[inline(always)]
            pub const fn inc_addr_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."]
            #[inline(always)]
            pub fn set_inc_addr_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for LdmaRxctrl {
            #[inline(always)]
            fn default() -> LdmaRxctrl {
                LdmaRxctrl(0)
            }
        }
        impl core::fmt::Debug for LdmaRxctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaRxctrl")
                    .field("ch_en", &self.ch_en())
                    .field("rstrt_en", &self.rstrt_en())
                    .field("buf_addr_en", &self.buf_addr_en())
                    .field("ovrd_len", &self.ovrd_len())
                    .field("acs_sz", &self.acs_sz())
                    .field("inc_addr_en", &self.inc_addr_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaRxctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "LdmaRxctrl {{ ch_en: {=bool:?}, rstrt_en: {=bool:?}, buf_addr_en: {=bool:?}, ovrd_len: {=bool:?}, acs_sz: {=u8:?}, inc_addr_en: {=bool:?} }}" , self . ch_en () , self . rstrt_en () , self . buf_addr_en () , self . ovrd_len () , self . acs_sz () , self . inc_addr_en ())
            }
        }
        #[doc = "QMSPI Local DMA Rx Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaRxstrtAddr(pub u32);
        impl LdmaRxstrtAddr {
            #[doc = "This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access."]
            #[inline(always)]
            pub const fn strt_addr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access."]
            #[inline(always)]
            pub fn set_strt_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LdmaRxstrtAddr {
            #[inline(always)]
            fn default() -> LdmaRxstrtAddr {
                LdmaRxstrtAddr(0)
            }
        }
        impl core::fmt::Debug for LdmaRxstrtAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaRxstrtAddr")
                    .field("strt_addr", &self.strt_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaRxstrtAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LdmaRxstrtAddr {{ strt_addr: {=u32:?} }}", self.strt_addr())
            }
        }
        #[doc = "QMSPI Local DMA Tx Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaTxLen(pub u32);
        impl LdmaTxLen {
            #[doc = "This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."]
            #[inline(always)]
            pub const fn tx_len(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."]
            #[inline(always)]
            pub fn set_tx_len(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LdmaTxLen {
            #[inline(always)]
            fn default() -> LdmaTxLen {
                LdmaTxLen(0)
            }
        }
        impl core::fmt::Debug for LdmaTxLen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaTxLen").field("tx_len", &self.tx_len()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaTxLen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LdmaTxLen {{ tx_len: {=u32:?} }}", self.tx_len())
            }
        }
        #[doc = "QMSPI TX Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaTxctrl(pub u32);
        impl LdmaTxctrl {
            #[doc = "This enables the Local TX DMA Channel."]
            #[inline(always)]
            pub const fn ch_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the Local TX DMA Channel."]
            #[inline(always)]
            pub fn set_ch_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit automatically re-enables the Local DMA Channel after completion of previous transfer."]
            #[inline(always)]
            pub const fn rstrt_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit automatically re-enables the Local DMA Channel after completion of previous transfer."]
            #[inline(always)]
            pub fn set_rstrt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Address re-enable will automatically re-enables the same address upon completion previous transfer."]
            #[inline(always)]
            pub const fn buf_addr_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Address re-enable will automatically re-enables the same address upon completion previous transfer."]
            #[inline(always)]
            pub fn set_buf_addr_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."]
            #[inline(always)]
            pub const fn ovrd_len(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."]
            #[inline(always)]
            pub fn set_ovrd_len(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Access Size selects the AHB Access Size."]
            #[inline(always)]
            pub const fn acs_sz(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "Access Size selects the AHB Access Size."]
            #[inline(always)]
            pub fn set_acs_sz(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."]
            #[inline(always)]
            pub const fn inc_addr_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."]
            #[inline(always)]
            pub fn set_inc_addr_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for LdmaTxctrl {
            #[inline(always)]
            fn default() -> LdmaTxctrl {
                LdmaTxctrl(0)
            }
        }
        impl core::fmt::Debug for LdmaTxctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaTxctrl")
                    .field("ch_en", &self.ch_en())
                    .field("rstrt_en", &self.rstrt_en())
                    .field("buf_addr_en", &self.buf_addr_en())
                    .field("ovrd_len", &self.ovrd_len())
                    .field("acs_sz", &self.acs_sz())
                    .field("inc_addr_en", &self.inc_addr_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaTxctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "LdmaTxctrl {{ ch_en: {=bool:?}, rstrt_en: {=bool:?}, buf_addr_en: {=bool:?}, ovrd_len: {=bool:?}, acs_sz: {=u8:?}, inc_addr_en: {=bool:?} }}" , self . ch_en () , self . rstrt_en () , self . buf_addr_en () , self . ovrd_len () , self . acs_sz () , self . inc_addr_en ())
            }
        }
        #[doc = "QMSPI Local DMA Tx Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaTxstrtAddr(pub u32);
        impl LdmaTxstrtAddr {
            #[doc = "This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access."]
            #[inline(always)]
            pub const fn strt_addr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access."]
            #[inline(always)]
            pub fn set_strt_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LdmaTxstrtAddr {
            #[inline(always)]
            fn default() -> LdmaTxstrtAddr {
                LdmaTxstrtAddr(0)
            }
        }
        impl core::fmt::Debug for LdmaTxstrtAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaTxstrtAddr")
                    .field("strt_addr", &self.strt_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaTxstrtAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LdmaTxstrtAddr {{ strt_addr: {=u32:?} }}", self.strt_addr())
            }
        }
        #[doc = "QMSPI Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "This bit is used to activate the QMSPI block. 1=Enabled. The block is fully operational 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to activate the QMSPI block. 1=Enabled. The block is fully operational 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing."]
            #[inline(always)]
            pub const fn soft_reset(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing."]
            #[inline(always)]
            pub fn set_soft_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "When enabled the DMA is allowed to operate w/ unaligned transfer lengths."]
            #[inline(always)]
            pub const fn dma_unlgnd_mod(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "When enabled the DMA is allowed to operate w/ unaligned transfer lengths."]
            #[inline(always)]
            pub fn set_dma_unlgnd_mod(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This enables the Local DMA RX usage (instead of the Central DMA) when the Control register enables the DMA."]
            #[inline(always)]
            pub const fn ldma_rxen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the Local DMA RX usage (instead of the Central DMA) when the Control register enables the DMA."]
            #[inline(always)]
            pub fn set_ldma_rxen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This enables the Local DMA TX usage (instead of the Central DMA) when the Control register enables the DMA."]
            #[inline(always)]
            pub const fn ldma_txen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the Local DMA TX usage (instead of the Central DMA) when the Control register enables the DMA."]
            #[inline(always)]
            pub fn set_ldma_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low."]
            #[inline(always)]
            pub const fn cpol(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low."]
            #[inline(always)]
            pub fn set_cpol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock"]
            #[inline(always)]
            pub const fn chpa_mosi(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock"]
            #[inline(always)]
            pub fn set_chpa_mosi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock"]
            #[inline(always)]
            pub const fn chpa_miso(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock"]
            #[inline(always)]
            pub fn set_chpa_miso(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This defines which Chip Select will be used by the H/W when doing a transfer."]
            #[inline(always)]
            pub const fn cs(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x03;
                val as u8
            }
            #[doc = "This defines which Chip Select will be used by the H/W when doing a transfer."]
            #[inline(always)]
            pub fn set_cs(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize);
            }
            #[doc = "The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256."]
            #[inline(always)]
            pub const fn clk_div(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256."]
            #[inline(always)]
            pub fn set_clk_div(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("act", &self.act())
                    .field("soft_reset", &self.soft_reset())
                    .field("dma_unlgnd_mod", &self.dma_unlgnd_mod())
                    .field("ldma_rxen", &self.ldma_rxen())
                    .field("ldma_txen", &self.ldma_txen())
                    .field("cpol", &self.cpol())
                    .field("chpa_mosi", &self.chpa_mosi())
                    .field("chpa_miso", &self.chpa_miso())
                    .field("cs", &self.cs())
                    .field("clk_div", &self.clk_div())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mode {{ act: {=bool:?}, soft_reset: {=bool:?}, dma_unlgnd_mod: {=bool:?}, ldma_rxen: {=bool:?}, ldma_txen: {=bool:?}, cpol: {=bool:?}, chpa_mosi: {=bool:?}, chpa_miso: {=bool:?}, cs: {=u8:?}, clk_div: {=u16:?} }}" , self . act () , self . soft_reset () , self . dma_unlgnd_mod () , self . ldma_rxen () , self . ldma_txen () , self . cpol () , self . chpa_mosi () , self . chpa_miso () , self . cs () , self . clk_div ())
            }
        }
        #[doc = "QMSPI Mode Alternate 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ModeAlt1(pub u32);
        impl ModeAlt1 {
            #[doc = "Enable the CS1 Clock Divide to be active if CS1 is the interface in use."]
            #[inline(always)]
            pub const fn cs1_altmod_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the CS1 Clock Divide to be active if CS1 is the interface in use."]
            #[inline(always)]
            pub fn set_cs1_altmod_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The SPI clock divide in number of system clocks when CS1 is in use and CS1 Alt Mode Enable is set."]
            #[inline(always)]
            pub const fn cs1_altclk_div(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "The SPI clock divide in number of system clocks when CS1 is in use and CS1 Alt Mode Enable is set."]
            #[inline(always)]
            pub fn set_cs1_altclk_div(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for ModeAlt1 {
            #[inline(always)]
            fn default() -> ModeAlt1 {
                ModeAlt1(0)
            }
        }
        impl core::fmt::Debug for ModeAlt1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ModeAlt1")
                    .field("cs1_altmod_en", &self.cs1_altmod_en())
                    .field("cs1_altclk_div", &self.cs1_altclk_div())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ModeAlt1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "ModeAlt1 {{ cs1_altmod_en: {=bool:?}, cs1_altclk_div: {=u16:?} }}",
                    self.cs1_altmod_en(),
                    self.cs1_altclk_div()
                )
            }
        }
        #[doc = "QMSPI Receive Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxFifo(pub u32);
        impl RxFifo {
            #[doc = "Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO. Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits \\[7:0\\] and a Word read will have data on bits \\[15:0\\]. It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error). Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."]
            #[inline(always)]
            pub const fn rx_buf(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO. Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits \\[7:0\\] and a Word read will have data on bits \\[15:0\\]. It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error). Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."]
            #[inline(always)]
            pub fn set_rx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for RxFifo {
            #[inline(always)]
            fn default() -> RxFifo {
                RxFifo(0)
            }
        }
        impl core::fmt::Debug for RxFifo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxFifo").field("rx_buf", &self.rx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxFifo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxFifo {{ rx_buf: {=u32:?} }}", self.rx_buf())
            }
        }
        #[doc = "QMSPI Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH. If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer. In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied. 1=Transfer completed; 0=Transfer not complete."]
            #[inline(always)]
            pub const fn trans_compl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH. If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer. In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied. 1=Transfer completed; 0=Transfer not complete."]
            #[inline(always)]
            pub fn set_trans_compl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller. This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously. This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode. 1=DMA completed; 0=DMA not completed."]
            #[inline(always)]
            pub const fn dma_compl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller. This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously. This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode. 1=DMA completed; 0=DMA not completed."]
            #[inline(always)]
            pub fn set_dma_compl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1=Overflow error occurred (attempt to write to a full Transmit Buffer) 0=No overflow occurred."]
            #[inline(always)]
            pub const fn tx_buff_err(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=Overflow error occurred (attempt to write to a full Transmit Buffer) 0=No overflow occurred."]
            #[inline(always)]
            pub fn set_tx_buff_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=Underflow error occurred (attempt to read from an empty Receive Buffer) 0=No underflow occurred."]
            #[inline(always)]
            pub const fn rx_buff_err(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=Underflow error occurred (attempt to read from an empty Receive Buffer) 0=No underflow occurred."]
            #[inline(always)]
            pub fn set_rx_buff_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit if a programming error is detected. 1=Programming Error detected; 0=No programming error detected."]
            #[inline(always)]
            pub const fn prgm_err(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit if a programming error is detected. 1=Programming Error detected; 0=No programming error detected."]
            #[inline(always)]
            pub fn set_prgm_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit is set if Local DMA Receive error is detected. 1=Local DMA RX Error detected; 0=No Local DMA RX detected."]
            #[inline(always)]
            pub const fn ldma_rxerr(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if Local DMA Receive error is detected. 1=Local DMA RX Error detected; 0=No Local DMA RX detected."]
            #[inline(always)]
            pub fn set_ldma_rxerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit is set if Local DMA Transmit error is detected. 1=Local DMA TX Error detected; 0=No Local DMA TX detected."]
            #[inline(always)]
            pub const fn ldma_txerr(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if Local DMA Transmit error is detected. 1=Local DMA TX Error detected; 0=No Local DMA TX detected."]
            #[inline(always)]
            pub fn set_ldma_txerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "1=The Transmit Buffer is full 0=The Transmit Buffer is not full."]
            #[inline(always)]
            pub const fn tx_buff_full(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Transmit Buffer is full 0=The Transmit Buffer is not full."]
            #[inline(always)]
            pub fn set_tx_buff_full(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "1=The Transmit Buffer is empty 0=The Transmit Buffer is not empty."]
            #[inline(always)]
            pub const fn tx_buff_emp(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Transmit Buffer is empty 0=The Transmit Buffer is not empty."]
            #[inline(always)]
            pub fn set_tx_buff_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field. 1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER."]
            #[inline(always)]
            pub const fn tx_buff_req(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field. 1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER."]
            #[inline(always)]
            pub fn set_tx_buff_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub const fn tx_buff_stall(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub fn set_tx_buff_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "1=The Receive Buffer is full 0=The Receive Buffer is not full."]
            #[inline(always)]
            pub const fn rx_buff_full(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Receive Buffer is full 0=The Receive Buffer is not full."]
            #[inline(always)]
            pub fn set_rx_buff_full(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "1=The Receive Buffer is empty 0=The Receive Buffer is not empty."]
            #[inline(always)]
            pub const fn rx_buff_emp(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Receive Buffer is empty 0=The Receive Buffer is not empty."]
            #[inline(always)]
            pub fn set_rx_buff_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field. 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER."]
            #[inline(always)]
            pub const fn rx_buff_req(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field. 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER."]
            #[inline(always)]
            pub fn set_rx_buff_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub const fn rx_buff_stall(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub fn set_rx_buff_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "1=A transfer is currently executing 0=No transfer currently in progress."]
            #[inline(always)]
            pub const fn trans_activ(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=A transfer is currently executing 0=No transfer currently in progress."]
            #[inline(always)]
            pub fn set_trans_activ(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled."]
            #[inline(always)]
            pub const fn cur_descr_buf(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled."]
            #[inline(always)]
            pub fn set_cur_descr_buf(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("trans_compl", &self.trans_compl())
                    .field("dma_compl", &self.dma_compl())
                    .field("tx_buff_err", &self.tx_buff_err())
                    .field("rx_buff_err", &self.rx_buff_err())
                    .field("prgm_err", &self.prgm_err())
                    .field("ldma_rxerr", &self.ldma_rxerr())
                    .field("ldma_txerr", &self.ldma_txerr())
                    .field("tx_buff_full", &self.tx_buff_full())
                    .field("tx_buff_emp", &self.tx_buff_emp())
                    .field("tx_buff_req", &self.tx_buff_req())
                    .field("tx_buff_stall", &self.tx_buff_stall())
                    .field("rx_buff_full", &self.rx_buff_full())
                    .field("rx_buff_emp", &self.rx_buff_emp())
                    .field("rx_buff_req", &self.rx_buff_req())
                    .field("rx_buff_stall", &self.rx_buff_stall())
                    .field("trans_activ", &self.trans_activ())
                    .field("cur_descr_buf", &self.cur_descr_buf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sts {{ trans_compl: {=bool:?}, dma_compl: {=bool:?}, tx_buff_err: {=bool:?}, rx_buff_err: {=bool:?}, prgm_err: {=bool:?}, ldma_rxerr: {=bool:?}, ldma_txerr: {=bool:?}, tx_buff_full: {=bool:?}, tx_buff_emp: {=bool:?}, tx_buff_req: {=bool:?}, tx_buff_stall: {=bool:?}, rx_buff_full: {=bool:?}, rx_buff_emp: {=bool:?}, rx_buff_req: {=bool:?}, rx_buff_stall: {=bool:?}, trans_activ: {=bool:?}, cur_descr_buf: {=u8:?} }}" , self . trans_compl () , self . dma_compl () , self . tx_buff_err () , self . rx_buff_err () , self . prgm_err () , self . ldma_rxerr () , self . ldma_txerr () , self . tx_buff_full () , self . tx_buff_emp () , self . tx_buff_req () , self . tx_buff_stall () , self . rx_buff_full () , self . rx_buff_emp () , self . rx_buff_req () , self . rx_buff_stall () , self . trans_activ () , self . cur_descr_buf ())
            }
        }
        #[doc = "QMSPI TAP Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TapAdj(pub u32);
        impl TapAdj {
            #[doc = "This is a signed value that will be added to the Select SCK Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub const fn sck_adj(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This is a signed value that will be added to the Select SCK Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub fn set_sck_adj(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub const fn ctrl_adj(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub fn set_ctrl_adj(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for TapAdj {
            #[inline(always)]
            fn default() -> TapAdj {
                TapAdj(0)
            }
        }
        impl core::fmt::Debug for TapAdj {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TapAdj")
                    .field("sck_adj", &self.sck_adj())
                    .field("ctrl_adj", &self.ctrl_adj())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TapAdj {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TapAdj {{ sck_adj: {=u8:?}, ctrl_adj: {=u8:?} }}",
                    self.sck_adj(),
                    self.ctrl_adj()
                )
            }
        }
        #[doc = "QMSPI TAP Adjustment Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TapCtrl(pub u32);
        impl TapCtrl {
            #[doc = "This enables the automatic H/W trim of the Tap."]
            #[inline(always)]
            pub const fn auto_mod(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This enables the automatic H/W trim of the Tap."]
            #[inline(always)]
            pub fn set_auto_mod(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub const fn ctrl(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub fn set_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This will force the auto-trim H/W to run and find a new trim value."]
            #[inline(always)]
            pub const fn fw_go(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This will force the auto-trim H/W to run and find a new trim value."]
            #[inline(always)]
            pub fn set_fw_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This will multiply the target delay value the Auto-trim H/W will search for."]
            #[inline(always)]
            pub const fn auto_mult(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "This will multiply the target delay value the Auto-trim H/W will search for."]
            #[inline(always)]
            pub fn set_auto_mult(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
        }
        impl Default for TapCtrl {
            #[inline(always)]
            fn default() -> TapCtrl {
                TapCtrl(0)
            }
        }
        impl core::fmt::Debug for TapCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TapCtrl")
                    .field("auto_mod", &self.auto_mod())
                    .field("ctrl", &self.ctrl())
                    .field("fw_go", &self.fw_go())
                    .field("auto_mult", &self.auto_mult())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TapCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TapCtrl {{ auto_mod: {=u8:?}, ctrl: {=bool:?}, fw_go: {=bool:?}, auto_mult: {=u8:?} }}",
                    self.auto_mod(),
                    self.ctrl(),
                    self.fw_go(),
                    self.auto_mult()
                )
            }
        }
        #[doc = "QMSPI TAPs Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Taps(pub u32);
        impl Taps {
            #[doc = "This will select the tap point for the feed-back SCK."]
            #[inline(always)]
            pub const fn sck_tap(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This will select the tap point for the feed-back SCK."]
            #[inline(always)]
            pub fn set_sck_tap(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This will select the tap point for signals that go from the System Domain."]
            #[inline(always)]
            pub const fn ctrl_tap(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This will select the tap point for signals that go from the System Domain."]
            #[inline(always)]
            pub fn set_ctrl_tap(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Taps {
            #[inline(always)]
            fn default() -> Taps {
                Taps(0)
            }
        }
        impl core::fmt::Debug for Taps {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Taps")
                    .field("sck_tap", &self.sck_tap())
                    .field("ctrl_tap", &self.ctrl_tap())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Taps {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Taps {{ sck_tap: {=u8:?}, ctrl_tap: {=u8:?} }}",
                    self.sck_tap(),
                    self.ctrl_tap()
                )
            }
        }
        #[doc = "QMSPI Transmit Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxFifo(pub u32);
        impl TxFifo {
            #[doc = "Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave. Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes. The data must always be aligned to the bottom most byte (so 1 byte write is on bits \\[7:0\\] and Word write is on \\[15:0\\]). An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."]
            #[inline(always)]
            pub const fn tx_buf(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave. Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes. The data must always be aligned to the bottom most byte (so 1 byte write is on bits \\[7:0\\] and Word write is on \\[15:0\\]). An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."]
            #[inline(always)]
            pub fn set_tx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for TxFifo {
            #[inline(always)]
            fn default() -> TxFifo {
                TxFifo(0)
            }
        }
        impl core::fmt::Debug for TxFifo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxFifo").field("tx_buf", &self.tx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxFifo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxFifo {{ tx_buf: {=u32:?} }}", self.tx_buf())
            }
        }
    }
}
pub mod rc_id0 {
    #[doc = "This interface provides a single pin interface which can discriminate a number of quantized RC constants."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct RcId0 {
        ptr: *mut u8,
    }
    unsafe impl Send for RcId0 {}
    unsafe impl Sync for RcId0 {}
    impl RcId0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RC_ID Control Register"]
        #[inline(always)]
        pub const fn control(self) -> crate::common::Reg<regs::Control, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Reads of this register provide the result of an RC_ID measurement."]
        #[inline(always)]
        pub const fn data(self) -> crate::common::Reg<regs::Data, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "RC_ID Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Control(pub u32);
        impl Control {
            #[doc = "This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes an RC_ID measurement."]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes an RC_ID measurement."]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes the Discharged phase of an RC_ID measurement."]
            #[inline(always)]
            pub const fn tc(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes the Discharged phase of an RC_ID measurement."]
            #[inline(always)]
            pub fn set_tc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is 1 if an RC_ID measurement encountered an error and the reading in the RC_ID Data Register is invalid. This bit is cleared to 0 when the RC_ID interface is in the Reset phase."]
            #[inline(always)]
            pub const fn cy_er(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is 1 if an RC_ID measurement encountered an error and the reading in the RC_ID Data Register is invalid. This bit is cleared to 0 when the RC_ID interface is in the Reset phase."]
            #[inline(always)]
            pub fn set_cy_er(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Setting this bit to 1 initiates the Discharged phase of an RC_ID measurement."]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Setting this bit to 1 initiates the Discharged phase of an RC_ID measurement."]
            #[inline(always)]
            pub fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Clearing the bit to 0 causes the RC_ID interface to enter the Reset state, gating its clocks, clearing the status bits in this register and entering into its lowest power state. Setting this bit to 1 causes the RC_ID interface to enter the Armed phase of an RC_ID measurement."]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Clearing the bit to 0 causes the RC_ID interface to enter the Reset state, gating its clocks, clearing the status bits in this register and entering into its lowest power state. Setting this bit to 1 causes the RC_ID interface to enter the Armed phase of an RC_ID measurement."]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This field selects the frequency of the Counter circuit clock. This field must retain the same value as long as the ENABLE bit in this register is 1."]
            #[inline(always)]
            pub const fn clock_set(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the frequency of the Counter circuit clock. This field must retain the same value as long as the ENABLE bit in this register is 1."]
            #[inline(always)]
            pub fn set_clock_set(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
        }
        impl Default for Control {
            #[inline(always)]
            fn default() -> Control {
                Control(0)
            }
        }
        impl core::fmt::Debug for Control {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Control")
                    .field("done", &self.done())
                    .field("tc", &self.tc())
                    .field("cy_er", &self.cy_er())
                    .field("start", &self.start())
                    .field("enable", &self.enable())
                    .field("clock_set", &self.clock_set())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Control {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Control {{ done: {=bool:?}, tc: {=bool:?}, cy_er: {=bool:?}, start: {=bool:?}, enable: {=bool:?}, clock_set: {=u8:?} }}" , self . done () , self . tc () , self . cy_er () , self . start () , self . enable () , self . clock_set ())
            }
        }
        #[doc = "Reads of this register provide the result of an RC_ID measurement."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Data(pub u32);
        impl Data {
            #[doc = "Reads of this register provide the result of an RC_ID measurement."]
            #[inline(always)]
            pub const fn rcid_data(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Reads of this register provide the result of an RC_ID measurement."]
            #[inline(always)]
            pub fn set_rcid_data(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Data {
            #[inline(always)]
            fn default() -> Data {
                Data(0)
            }
        }
        impl core::fmt::Debug for Data {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Data").field("rcid_data", &self.rcid_data()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Data {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Data {{ rcid_data: {=u16:?} }}", self.rcid_data())
            }
        }
    }
}
pub mod rtc {
    #[doc = "This is the set of registers that are automatically counted by hardware every 1 second while the block is enabled."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtc {}
    unsafe impl Sync for Rtc {}
    impl Rtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Seconds Register"]
        #[inline(always)]
        pub const fn sec(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Seconds Alarm Register"]
        #[inline(always)]
        pub const fn sec_alarm(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Minutes Register"]
        #[inline(always)]
        pub const fn min(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Minutes Alarm Register"]
        #[inline(always)]
        pub const fn min_alarm(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Hours Register"]
        #[inline(always)]
        pub const fn hr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Hours Alarm Register"]
        #[inline(always)]
        pub const fn hr_alarm(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "Day of Week Register"]
        #[inline(always)]
        pub const fn day_of_wk(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Day of Month Register"]
        #[inline(always)]
        pub const fn day_of_mon(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "Month Register"]
        #[inline(always)]
        pub const fn month(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Year Register"]
        #[inline(always)]
        pub const fn year(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "Register A"]
        #[inline(always)]
        pub const fn rega(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Register B"]
        #[inline(always)]
        pub const fn regb(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "Register C"]
        #[inline(always)]
        pub const fn regc(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Register D"]
        #[inline(always)]
        pub const fn regd(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "RTC Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Week Alarm Register\\[7:0\\] - ALARM_DAY_OF_WEEK This register, if written to a value in the range 1- -7, will inhibit the Alarm interrupt unless this field matches the contents of the Day of Week Register also."]
        #[inline(always)]
        pub const fn wk_alarm(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Daylight Savings Forward Register"]
        #[inline(always)]
        pub const fn daylt_savf(self) -> crate::common::Reg<regs::DayltSavf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Daylight Savings Backward Register"]
        #[inline(always)]
        pub const fn daylt_savb(self) -> crate::common::Reg<regs::DayltSavb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "RTC Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "BLOCK_ENABLE This bit must be 1 in order for the block to function internally. Registers may be initialized first, before setting this bit to '1' to start operation."]
            #[inline(always)]
            pub const fn blk_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "BLOCK_ENABLE This bit must be 1 in order for the block to function internally. Registers may be initialized first, before setting this bit to '1' to start operation."]
            #[inline(always)]
            pub fn set_blk_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SOFT_RESET A 1 written to this bit position will trigger the RTC_RST reset, resetting the block and all registers except this one and the Test Register. This bit is self-clearing at the end of the reset, one cycle of Host Bus Clock later, and so requires no waiting."]
            #[inline(always)]
            pub const fn soft_rst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "SOFT_RESET A 1 written to this bit position will trigger the RTC_RST reset, resetting the block and all registers except this one and the Test Register. This bit is self-clearing at the end of the reset, one cycle of Host Bus Clock later, and so requires no waiting."]
            #[inline(always)]
            pub fn set_soft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "VCI Enable 1= RTC Alarm to VCI Circuitry, 0= No RTC alarm to VCI circuitry"]
            #[inline(always)]
            pub const fn vci_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "VCI Enable 1= RTC Alarm to VCI Circuitry, 0= No RTC alarm to VCI circuitry"]
            #[inline(always)]
            pub fn set_vci_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "ALARM_ENABLE 1=Enables the Alarm features, 0=Disables the Alarm features"]
            #[inline(always)]
            pub const fn alm_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ALARM_ENABLE 1=Enables the Alarm features, 0=Disables the Alarm features"]
            #[inline(always)]
            pub fn set_alm_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("blk_en", &self.blk_en())
                    .field("soft_rst", &self.soft_rst())
                    .field("vci_en", &self.vci_en())
                    .field("alm_en", &self.alm_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl {{ blk_en: {=bool:?}, soft_rst: {=bool:?}, vci_en: {=bool:?}, alm_en: {=bool:?} }}",
                    self.blk_en(),
                    self.soft_rst(),
                    self.vci_en(),
                    self.alm_en()
                )
            }
        }
        #[doc = "Daylight Savings Backward Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DayltSavb(pub u32);
        impl DayltSavb {
            #[doc = "This field matches the Month Register."]
            #[inline(always)]
            pub const fn dst_mon(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field matches the Month Register."]
            #[inline(always)]
            pub fn set_dst_mon(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field matches the Day of Week Register bits\\[2:0\\]."]
            #[inline(always)]
            pub const fn dst_day_of_wk(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "This field matches the Day of Week Register bits\\[2:0\\]."]
            #[inline(always)]
            pub fn set_dst_day_of_wk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize);
            }
            #[doc = "5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month"]
            #[inline(always)]
            pub const fn dst_wk(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month"]
            #[inline(always)]
            pub fn set_dst_wk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
            #[doc = "This field holds the matching value for bits\\[6:0\\] of the Hours register. The written value will be interpreted according to the 24/12 Hour mode and DM mode settings at the time of writing."]
            #[inline(always)]
            pub const fn dst_hr(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x7f;
                val as u8
            }
            #[doc = "This field holds the matching value for bits\\[6:0\\] of the Hours register. The written value will be interpreted according to the 24/12 Hour mode and DM mode settings at the time of writing."]
            #[inline(always)]
            pub fn set_dst_hr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 24usize)) | (((val as u32) & 0x7f) << 24usize);
            }
            #[doc = "This bit selects AM vs. PM, to match bit\\[7\\] of the Hours Register if 12-Hour mode is selected in Register B at the time of writing."]
            #[inline(always)]
            pub const fn dst_am_pm(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects AM vs. PM, to match bit\\[7\\] of the Hours Register if 12-Hour mode is selected in Register B at the time of writing."]
            #[inline(always)]
            pub fn set_dst_am_pm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for DayltSavb {
            #[inline(always)]
            fn default() -> DayltSavb {
                DayltSavb(0)
            }
        }
        impl core::fmt::Debug for DayltSavb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DayltSavb")
                    .field("dst_mon", &self.dst_mon())
                    .field("dst_day_of_wk", &self.dst_day_of_wk())
                    .field("dst_wk", &self.dst_wk())
                    .field("dst_hr", &self.dst_hr())
                    .field("dst_am_pm", &self.dst_am_pm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DayltSavb {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DayltSavb {{ dst_mon: {=u8:?}, dst_day_of_wk: {=u8:?}, dst_wk: {=u8:?}, dst_hr: {=u8:?}, dst_am_pm: {=bool:?} }}" , self . dst_mon () , self . dst_day_of_wk () , self . dst_wk () , self . dst_hr () , self . dst_am_pm ())
            }
        }
        #[doc = "Daylight Savings Forward Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DayltSavf(pub u32);
        impl DayltSavf {
            #[doc = "This field matches the Month Register."]
            #[inline(always)]
            pub const fn dst_mon(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field matches the Month Register."]
            #[inline(always)]
            pub fn set_dst_mon(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field matches the Day of Week Register bits\\[2:0\\]."]
            #[inline(always)]
            pub const fn dst_day_of_wk(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "This field matches the Day of Week Register bits\\[2:0\\]."]
            #[inline(always)]
            pub fn set_dst_day_of_wk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize);
            }
            #[doc = "5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month"]
            #[inline(always)]
            pub const fn dst_wk(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month"]
            #[inline(always)]
            pub fn set_dst_wk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
            #[doc = "This field holds the matching value for bits\\[6:0\\] of the Hours register. The written value will be interpreted according to the 24/12 Hour mode and DM mode settings at the time of writing."]
            #[inline(always)]
            pub const fn dst_hr(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x7f;
                val as u8
            }
            #[doc = "This field holds the matching value for bits\\[6:0\\] of the Hours register. The written value will be interpreted according to the 24/12 Hour mode and DM mode settings at the time of writing."]
            #[inline(always)]
            pub fn set_dst_hr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 24usize)) | (((val as u32) & 0x7f) << 24usize);
            }
            #[doc = "This bit selects AM vs. PM, to match bit\\[7\\] of the Hours Register if 12-Hour mode is selected in Register B at the time of writing."]
            #[inline(always)]
            pub const fn dst_am_pm(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects AM vs. PM, to match bit\\[7\\] of the Hours Register if 12-Hour mode is selected in Register B at the time of writing."]
            #[inline(always)]
            pub fn set_dst_am_pm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for DayltSavf {
            #[inline(always)]
            fn default() -> DayltSavf {
                DayltSavf(0)
            }
        }
        impl core::fmt::Debug for DayltSavf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DayltSavf")
                    .field("dst_mon", &self.dst_mon())
                    .field("dst_day_of_wk", &self.dst_day_of_wk())
                    .field("dst_wk", &self.dst_wk())
                    .field("dst_hr", &self.dst_hr())
                    .field("dst_am_pm", &self.dst_am_pm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DayltSavf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DayltSavf {{ dst_mon: {=u8:?}, dst_day_of_wk: {=u8:?}, dst_wk: {=u8:?}, dst_hr: {=u8:?}, dst_am_pm: {=bool:?} }}" , self . dst_mon () , self . dst_day_of_wk () , self . dst_wk () , self . dst_hr () , self . dst_am_pm ())
            }
        }
    }
}
pub mod rtos {
    #[doc = "RTOS is a 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtos {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtos {}
    unsafe impl Sync for Rtos {}
    impl Rtos {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RTOS Timer Count Register."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<regs::Cnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "RTOS Timer Preload Register"]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<regs::Prld, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "RTOS Timer Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Soft Interrupt Register"]
        #[inline(always)]
        pub const fn softirq(self) -> crate::common::Reg<regs::Softirq, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "RTOS Timer Count Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cnt(pub u32);
        impl Cnt {
            #[doc = "This register contains the current value of the RTOS Timer counter. This register should be read as a DWORD. There is no latching mechanism of the upper bytes implemented if the register is accessed as a byte or word. Reading the register with byte or word operations may give incorrect results."]
            #[inline(always)]
            pub const fn cntr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register contains the current value of the RTOS Timer counter. This register should be read as a DWORD. There is no latching mechanism of the upper bytes implemented if the register is accessed as a byte or word. Reading the register with byte or word operations may give incorrect results."]
            #[inline(always)]
            pub fn set_cntr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cnt {
            #[inline(always)]
            fn default() -> Cnt {
                Cnt(0)
            }
        }
        impl core::fmt::Debug for Cnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cnt").field("cntr", &self.cntr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cnt {{ cntr: {=u32:?} }}", self.cntr())
            }
        }
        #[doc = "RTOS Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "1=RTOS timer counter is enabled 0=RTOS timer disabled. All register bits are reset to their default state"]
            #[inline(always)]
            pub const fn blk_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=RTOS timer counter is enabled 0=RTOS timer disabled. All register bits are reset to their default state"]
            #[inline(always)]
            pub fn set_blk_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=The the RTOS Timer Preload Register is loaded into the timer counter and the counter is restarted when the counter transitions from 1 to 0 0=The timer counter halts when it transitions from 1 to 0 and will not restart."]
            #[inline(always)]
            pub const fn au_reload(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=The the RTOS Timer Preload Register is loaded into the timer counter and the counter is restarted when the counter transitions from 1 to 0 0=The timer counter halts when it transitions from 1 to 0 and will not restart."]
            #[inline(always)]
            pub fn set_au_reload(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Writing a 1 to this bit will load the timer counter with the RTOS Timer Preload Register and start counting. If the Preload Register is 0, counting will not start and this bit will be cleared to 0. Writing a 0 to this bit will halt the counter and clear its contents to 0. The RTOS timer interrupt will not be generated. This bit is automatically cleared if the AUTO_RELOAD bit is 0 and the timer counter transitions from 1 to 0."]
            #[inline(always)]
            pub const fn tmr_strt(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will load the timer counter with the RTOS Timer Preload Register and start counting. If the Preload Register is 0, counting will not start and this bit will be cleared to 0. Writing a 0 to this bit will halt the counter and clear its contents to 0. The RTOS timer interrupt will not be generated. This bit is automatically cleared if the AUTO_RELOAD bit is 0 and the timer counter transitions from 1 to 0."]
            #[inline(always)]
            pub fn set_tmr_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=The timer counter is halted when the external HALT signal is asserted. Counting is always enabled if HALT is de-asserted. 0=The HALT signal does not affect the RTOS Timer"]
            #[inline(always)]
            pub const fn ext_hw_halt_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=The timer counter is halted when the external HALT signal is asserted. Counting is always enabled if HALT is de-asserted. 0=The HALT signal does not affect the RTOS Timer"]
            #[inline(always)]
            pub fn set_ext_hw_halt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "1=The timer counter is halted. If the counter was running, clearing this bit will restart the counter from the value at which it halted 0=The timer counter, if enabled, will continue to run"]
            #[inline(always)]
            pub const fn fw_tmr_halt(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "1=The timer counter is halted. If the counter was running, clearing this bit will restart the counter from the value at which it halted 0=The timer counter, if enabled, will continue to run"]
            #[inline(always)]
            pub fn set_fw_tmr_halt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("blk_en", &self.blk_en())
                    .field("au_reload", &self.au_reload())
                    .field("tmr_strt", &self.tmr_strt())
                    .field("ext_hw_halt_en", &self.ext_hw_halt_en())
                    .field("fw_tmr_halt", &self.fw_tmr_halt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ blk_en: {=bool:?}, au_reload: {=bool:?}, tmr_strt: {=bool:?}, ext_hw_halt_en: {=bool:?}, fw_tmr_halt: {=bool:?} }}" , self . blk_en () , self . au_reload () , self . tmr_strt () , self . ext_hw_halt_en () , self . fw_tmr_halt ())
            }
        }
        #[doc = "RTOS Timer Preload Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prld(pub u32);
        impl Prld {
            #[doc = "The this register is loaded into the RTOS Timer counter either when the TIMER_START bit is written with a 1, or when the timer counter counts down to 0 and the AUTO_RELOAD bit is 1. This register must be programmed with a new count value before the TIMER_START bit is set to 1. If this register is updated while the counter is operating, the new count value will only take effect if the counter transitions form 1 to 0 while the AUTO_RELOAD bit is set."]
            #[inline(always)]
            pub const fn preload(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "The this register is loaded into the RTOS Timer counter either when the TIMER_START bit is written with a 1, or when the timer counter counts down to 0 and the AUTO_RELOAD bit is 1. This register must be programmed with a new count value before the TIMER_START bit is set to 1. If this register is updated while the counter is operating, the new count value will only take effect if the counter transitions form 1 to 0 while the AUTO_RELOAD bit is set."]
            #[inline(always)]
            pub fn set_preload(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Prld {
            #[inline(always)]
            fn default() -> Prld {
                Prld(0)
            }
        }
        impl core::fmt::Debug for Prld {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prld").field("preload", &self.preload()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prld {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prld {{ preload: {=u32:?} }}", self.preload())
            }
        }
        #[doc = "Soft Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Softirq(pub u32);
        impl Softirq {
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Softirq {
            #[inline(always)]
            fn default() -> Softirq {
                Softirq(0)
            }
        }
        impl core::fmt::Debug for Softirq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Softirq")
                    .field("swi0", &self.swi0())
                    .field("swi1", &self.swi1())
                    .field("swi2", &self.swi2())
                    .field("swi3", &self.swi3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Softirq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Softirq {{ swi0: {=bool:?}, swi1: {=bool:?}, swi2: {=bool:?}, swi3: {=bool:?} }}",
                    self.swi0(),
                    self.swi1(),
                    self.swi2(),
                    self.swi3()
                )
            }
        }
    }
}
pub mod safbc_cache {
    #[doc = "SAF BRIDGE CACHE INTERFACE"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SafbcCache {
        ptr: *mut u8,
    }
    unsafe impl Send for SafbcCache {}
    unsafe impl Sync for SafbcCache {}
    impl SafbcCache {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This register defines the command type and length of transfers requested by EC firmware"]
        #[inline(always)]
        pub const fn ec_len_tag_cmd(self) -> crate::common::Reg<regs::EcLenTagCmd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "This register hold the Flash Space address to be accessed by the current command from EC firmware."]
        #[inline(always)]
        pub const fn ec_flash_add(self) -> crate::common::Reg<regs::EcFlashAdd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "This register contains the Start control for a Flash access requested in the rest of the EC Portal registers. It triggers the requested transfer."]
        #[inline(always)]
        pub const fn ec_start(self) -> crate::common::Reg<regs::EcStart, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "This register holds a location in the EC's own address space that is to be used as the SRAM buffer for an EC Flash access."]
        #[inline(always)]
        pub const fn ec_ahb_add(self) -> crate::common::Reg<regs::EcAhbAdd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "This register holds the DONE status bit."]
        #[inline(always)]
        pub const fn ec_done_status(self) -> crate::common::Reg<regs::EcDoneStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "This register contains the one bit DONE_EN in bit position\\[0\\]. This bit enables the DONE bit in the status register to trigger an interrupt."]
        #[inline(always)]
        pub const fn ec_en(self) -> crate::common::Reg<regs::EcEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This register holds a location in the EC's own address space that is to be used as the SRAM buffer for an EC Flash access."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcAhbAdd(pub u32);
        impl EcAhbAdd {
            #[doc = "This bit controls whether the saf bridge increases the address in saf2_ahb_address."]
            #[inline(always)]
            pub const fn addr_inc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls whether the saf bridge increases the address in saf2_ahb_address."]
            #[inline(always)]
            pub fn set_addr_inc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This field holds bits \\[31:2\\] of the SRAM buffer address. Bits\\[1:0\\] of the address are fixed at 00."]
            #[inline(always)]
            pub const fn buf_addr(&self) -> u32 {
                let val = (self.0 >> 2usize) & 0x3fff_ffff;
                val as u32
            }
            #[doc = "This field holds bits \\[31:2\\] of the SRAM buffer address. Bits\\[1:0\\] of the address are fixed at 00."]
            #[inline(always)]
            pub fn set_buf_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0x3fff_ffff << 2usize)) | (((val as u32) & 0x3fff_ffff) << 2usize);
            }
        }
        impl Default for EcAhbAdd {
            #[inline(always)]
            fn default() -> EcAhbAdd {
                EcAhbAdd(0)
            }
        }
        impl core::fmt::Debug for EcAhbAdd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcAhbAdd")
                    .field("addr_inc", &self.addr_inc())
                    .field("buf_addr", &self.buf_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcAhbAdd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcAhbAdd {{ addr_inc: {=bool:?}, buf_addr: {=u32:?} }}",
                    self.addr_inc(),
                    self.buf_addr()
                )
            }
        }
        #[doc = "This register holds the DONE status bit."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcDoneStatus(pub u32);
        impl EcDoneStatus {
            #[doc = "When this bit is set the f/w initiated transaction is complete. This field is auto cleared by hardware. This is R/WC."]
            #[inline(always)]
            pub const fn saf2_rdy_nxt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is set the f/w initiated transaction is complete. This field is auto cleared by hardware. This is R/WC."]
            #[inline(always)]
            pub fn set_saf2_rdy_nxt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit will always return 1 for f/w. This field is auto cleared by hardware. This is R/WC."]
            #[inline(always)]
            pub const fn saf2_ak_nkn(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit will always return 1 for f/w. This field is auto cleared by hardware. This is R/WC."]
            #[inline(always)]
            pub fn set_saf2_ak_nkn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit indicates that an Erase or Write request from the EC has failed because the Flash has timed out. This is R/WC."]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an Erase or Write request from the EC has failed because the Flash has timed out. This is R/WC."]
            #[inline(always)]
            pub fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit indicates that a request has been rejected because it is beyond the physical limits of the attached Flash devices. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn outofrng(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a request has been rejected because it is beyond the physical limits of the attached Flash devices. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_outofrng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit indicates that a request from the EC has been rejected because it violates the Protection Register settings. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn access_violation(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a request from the EC has been rejected because it violates the Protection Register settings. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_access_violation(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit indicates that a Read request from the EC has been rejected because it has attempted to cross a 4K Flash address boundary. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn boundary_4k(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a Read request from the EC has been rejected because it has attempted to cross a 4K Flash address boundary. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_boundary_4k(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit indicates that an invalid Erase Block Size has been specified in an Erase request. This is R/WC."]
            #[inline(always)]
            pub const fn erase_siz_err(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an invalid Erase Block Size has been specified in an Erase request. This is R/WC."]
            #[inline(always)]
            pub fn set_erase_siz_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit indicates that an access was already in progress when a new access was requested by writing '1' to the START bit. This is R/WC."]
            #[inline(always)]
            pub const fn start_overflow(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an access was already in progress when a new access was requested by writing '1' to the START bit. This is R/WC."]
            #[inline(always)]
            pub fn set_start_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This bit indicates that an invalid Request code has been specified in the Portal Command Register at the time the START bit was set to trigger it. This is R/WC."]
            #[inline(always)]
            pub const fn bad_request(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an invalid Request code has been specified in the Portal Command Register at the time the START bit was set to trigger it. This is R/WC."]
            #[inline(always)]
            pub fn set_bad_request(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This bit indicates that a lenght greater that 49 is set for RPMC OP2 command. This is R/WC."]
            #[inline(always)]
            pub const fn rpmc_op2len(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a lenght greater that 49 is set for RPMC OP2 command. This is R/WC."]
            #[inline(always)]
            pub fn set_rpmc_op2len(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for EcDoneStatus {
            #[inline(always)]
            fn default() -> EcDoneStatus {
                EcDoneStatus(0)
            }
        }
        impl core::fmt::Debug for EcDoneStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcDoneStatus")
                    .field("saf2_rdy_nxt", &self.saf2_rdy_nxt())
                    .field("saf2_ak_nkn", &self.saf2_ak_nkn())
                    .field("timeout", &self.timeout())
                    .field("outofrng", &self.outofrng())
                    .field("access_violation", &self.access_violation())
                    .field("boundary_4k", &self.boundary_4k())
                    .field("erase_siz_err", &self.erase_siz_err())
                    .field("start_overflow", &self.start_overflow())
                    .field("bad_request", &self.bad_request())
                    .field("rpmc_op2len", &self.rpmc_op2len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcDoneStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcDoneStatus {{ saf2_rdy_nxt: {=bool:?}, saf2_ak_nkn: {=bool:?}, timeout: {=bool:?}, outofrng: {=bool:?}, access_violation: {=bool:?}, boundary_4k: {=bool:?}, erase_siz_err: {=bool:?}, start_overflow: {=bool:?}, bad_request: {=bool:?}, rpmc_op2len: {=bool:?} }}" , self . saf2_rdy_nxt () , self . saf2_ak_nkn () , self . timeout () , self . outofrng () , self . access_violation () , self . boundary_4k () , self . erase_siz_err () , self . start_overflow () , self . bad_request () , self . rpmc_op2len ())
            }
        }
        #[doc = "This register contains the one bit DONE_EN in bit position\\[0\\]. This bit enables the DONE bit in the status register to trigger an interrupt."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcEn(pub u32);
        impl EcEn {
            #[doc = "This bit controls whether an interrupt is fired when Ready_Next is asserted."]
            #[inline(always)]
            pub const fn rdy_nxt_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls whether an interrupt is fired when Ready_Next is asserted."]
            #[inline(always)]
            pub fn set_rdy_nxt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This controls whether an interrupt is fired when Timeout is asserted."]
            #[inline(always)]
            pub const fn timeout_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Timeout is asserted."]
            #[inline(always)]
            pub fn set_timeout_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This controls whether an interrupt is fired when Out Of Range is asserted."]
            #[inline(always)]
            pub const fn outofrng_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Out Of Range is asserted."]
            #[inline(always)]
            pub fn set_outofrng_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This controls whether an interrupt is fired when Access Violation is asserted."]
            #[inline(always)]
            pub const fn access_violation_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Access Violation is asserted."]
            #[inline(always)]
            pub fn set_access_violation_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This controls whether an interrupt is fired when 4K Boundary is asserted."]
            #[inline(always)]
            pub const fn boundary_4k_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when 4K Boundary is asserted."]
            #[inline(always)]
            pub fn set_boundary_4k_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This controls whether an interrupt is fired when Erase Size Error is asserted."]
            #[inline(always)]
            pub const fn erase_siz_err_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Erase Size Error is asserted."]
            #[inline(always)]
            pub fn set_erase_siz_err_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This controls whether an interrupt is fired when Start Overflow is asserted."]
            #[inline(always)]
            pub const fn start_overflow_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Start Overflow is asserted."]
            #[inline(always)]
            pub fn set_start_overflow_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This controls whether an interrupt is fired when Bad Request is asserted."]
            #[inline(always)]
            pub const fn bad_request_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Bad Request is asserted."]
            #[inline(always)]
            pub fn set_bad_request_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This controls whether an interrupt is fired when RPMC OP2 Lenght is asserted."]
            #[inline(always)]
            pub const fn rpmc_op2len_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when RPMC OP2 Lenght is asserted."]
            #[inline(always)]
            pub fn set_rpmc_op2len_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for EcEn {
            #[inline(always)]
            fn default() -> EcEn {
                EcEn(0)
            }
        }
        impl core::fmt::Debug for EcEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcEn")
                    .field("rdy_nxt_en", &self.rdy_nxt_en())
                    .field("timeout_en", &self.timeout_en())
                    .field("outofrng_en", &self.outofrng_en())
                    .field("access_violation_en", &self.access_violation_en())
                    .field("boundary_4k_en", &self.boundary_4k_en())
                    .field("erase_siz_err_en", &self.erase_siz_err_en())
                    .field("start_overflow_en", &self.start_overflow_en())
                    .field("bad_request_en", &self.bad_request_en())
                    .field("rpmc_op2len_en", &self.rpmc_op2len_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcEn {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcEn {{ rdy_nxt_en: {=bool:?}, timeout_en: {=bool:?}, outofrng_en: {=bool:?}, access_violation_en: {=bool:?}, boundary_4k_en: {=bool:?}, erase_siz_err_en: {=bool:?}, start_overflow_en: {=bool:?}, bad_request_en: {=bool:?}, rpmc_op2len_en: {=bool:?} }}" , self . rdy_nxt_en () , self . timeout_en () , self . outofrng_en () , self . access_violation_en () , self . boundary_4k_en () , self . erase_siz_err_en () , self . start_overflow_en () , self . bad_request_en () , self . rpmc_op2len_en ())
            }
        }
        #[doc = "This register hold the Flash Space address to be accessed by the current command from EC firmware."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcFlashAdd(pub u32);
        impl EcFlashAdd {
            #[doc = "FLASH_ADDR: This field holds the Flash address to be accessed."]
            #[inline(always)]
            pub const fn flash_addr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "FLASH_ADDR: This field holds the Flash address to be accessed."]
            #[inline(always)]
            pub fn set_flash_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for EcFlashAdd {
            #[inline(always)]
            fn default() -> EcFlashAdd {
                EcFlashAdd(0)
            }
        }
        impl core::fmt::Debug for EcFlashAdd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcFlashAdd")
                    .field("flash_addr", &self.flash_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcFlashAdd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcFlashAdd {{ flash_addr: {=u32:?} }}", self.flash_addr())
            }
        }
        #[doc = "This register defines the command type and length of transfers requested by EC firmware"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcLenTagCmd(pub u32);
        impl EcLenTagCmd {
            #[doc = "This field must contain the value 0Ah; that is, the eSPI command PUT_FLASH_NP."]
            #[inline(always)]
            pub const fn ec_put_cmd(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field must contain the value 0Ah; that is, the eSPI command PUT_FLASH_NP."]
            #[inline(always)]
            pub fn set_ec_put_cmd(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field encodes the operation requested: 00h = Read 01h = Write (Page Program) 02h = Erase Other encodings are undefined"]
            #[inline(always)]
            pub const fn ec_ctype_cmd(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field encodes the operation requested: 00h = Read 01h = Write (Page Program) 02h = Erase Other encodings are undefined"]
            #[inline(always)]
            pub fn set_ec_ctype_cmd(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field contains the Length field for all requests. Read or Write: The length in bytes of the data transfer, to or from the SRAM buffer. Must be in the range 1 -- 64 (01h -- 40h). Erase: Must encode an eSPI-defined Erase Block Size: 00h = 4K 01h = 32K 02h = 64K Other encodings are undefined."]
            #[inline(always)]
            pub const fn ec_length(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the Length field for all requests. Read or Write: The length in bytes of the data transfer, to or from the SRAM buffer. Must be in the range 1 -- 64 (01h -- 40h). Erase: Must encode an eSPI-defined Erase Block Size: 00h = 4K 01h = 32K 02h = 64K Other encodings are undefined."]
            #[inline(always)]
            pub fn set_ec_length(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for EcLenTagCmd {
            #[inline(always)]
            fn default() -> EcLenTagCmd {
                EcLenTagCmd(0)
            }
        }
        impl core::fmt::Debug for EcLenTagCmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcLenTagCmd")
                    .field("ec_put_cmd", &self.ec_put_cmd())
                    .field("ec_ctype_cmd", &self.ec_ctype_cmd())
                    .field("ec_length", &self.ec_length())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcLenTagCmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcLenTagCmd {{ ec_put_cmd: {=u8:?}, ec_ctype_cmd: {=u8:?}, ec_length: {=u8:?} }}",
                    self.ec_put_cmd(),
                    self.ec_ctype_cmd(),
                    self.ec_length()
                )
            }
        }
        #[doc = "This register contains the Start control for a Flash access requested in the rest of the EC Portal registers. It triggers the requested transfer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcStart(pub u32);
        impl EcStart {
            #[doc = "This bit is written with '1' to start a new request, but always appears 0 when being read."]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is written with '1' to start a new request, but always appears 0 when being read."]
            #[inline(always)]
            pub fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EcStart {
            #[inline(always)]
            fn default() -> EcStart {
                EcStart(0)
            }
        }
        impl core::fmt::Debug for EcStart {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcStart").field("start", &self.start()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcStart {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcStart {{ start: {=bool:?} }}", self.start())
            }
        }
    }
}
pub mod safbc_ec {
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SafProt {
        ptr: *mut u8,
    }
    unsafe impl Send for SafProt {}
    unsafe impl Sync for SafProt {}
    impl SafProt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This is Start00 register. Unless the Start register is less than or equal to the Limit register, the associated register set \\[RR\\] is Disabled, and has no effect on permissions. The default state of these registers, in all of the register sets, is this Disabled state. While all register sets remain Disabled, no Protection Master except Master #0 (PCH HW) will be able to perform any Flash access anywhere through SAFS operations, and this restriction includes the EC firmware (as Master #5)."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<regs::Start, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is Limit00 register. Unless the Start register is less than or equal to the Limit register, the associated register set \\[RR\\] is Disabled, and has no effect on permissions. The default state of these registers, in all of the register sets, is this Disabled state. While all register sets remain Disabled, no Protection Master except Master #0 (PCH HW) will be able to perform any Flash access anywhere through SAFS operations, and this restriction includes the EC firmware (as Master #5)."]
        #[inline(always)]
        pub const fn limit(self) -> crate::common::Reg<regs::Limit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is Write00 register. It applies to the region defined by the associated \\[RR\\] Start and Limit registers. Bits at positions \\[0\\]--\\[7\\] grant Write/Erase permission to Permission Masters numbered 0--7 respectively."]
        #[inline(always)]
        pub const fn write(self) -> crate::common::Reg<regs::Write, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is Read00 register. Bits at positions \\[0\\]--\\[7\\] grant Read permission to Permission Masters numbered 0--7 respectively."]
        #[inline(always)]
        pub const fn read(self) -> crate::common::Reg<regs::Read, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "SAF BRIDGE COMPONENT"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SafbcEc {
        ptr: *mut u8,
    }
    unsafe impl Send for SafbcEc {}
    unsafe impl Sync for SafbcEc {}
    impl SafbcEc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This register defines the command type and length of transfers requested by EC firmware"]
        #[inline(always)]
        pub const fn ecp_cmd(self) -> crate::common::Reg<regs::EcpCmd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "This register hold the Flash Space address to be accessed by the current command from EC firmware."]
        #[inline(always)]
        pub const fn ecp_flash_addr(self) -> crate::common::Reg<regs::EcpFlashAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "This register contains the Start control for a Flash access requested in the rest of the EC Portal registers. It triggers the requested transfer."]
        #[inline(always)]
        pub const fn ecp_start(self) -> crate::common::Reg<regs::EcpStart, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "This register holds a location in the EC's own address space that is to be used as the SRAM buffer for an EC Flash access."]
        #[inline(always)]
        pub const fn ecp_buf_addr(self) -> crate::common::Reg<regs::EcpBufAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "This register holds the DONE status bit."]
        #[inline(always)]
        pub const fn ecp_sts(self) -> crate::common::Reg<regs::EcpSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "This register contains the one bit DONE_EN in bit position\\[0\\]. This bit enables the DONE bit in the status register to trigger an interrupt."]
        #[inline(always)]
        pub const fn ecp_ien(self) -> crate::common::Reg<regs::EcpIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "This register declares the address of the final byte of the Flash space implemented in the physically present Flash device or devices."]
        #[inline(always)]
        pub const fn flash_size_lim(self) -> crate::common::Reg<regs::FlashSizeLim, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "This register declares whether there are two Flash devices, and if so, where the boundary is between the devices."]
        #[inline(always)]
        pub const fn flash_thr(self) -> crate::common::Reg<regs::FlashThr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Bits\\[7:6\\] (PREFIX) declare the need for some Flash devices (notably Micron) to be given an explicit command to enter Continuous Mode, as opposed to requiring only Mode bits in the first Read access."]
        #[inline(always)]
        pub const fn flash_misc_cfg(self) -> crate::common::Reg<regs::FlashMiscCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "These bits may be individually enabled to trigger interrupts using the corresponding Interrupt Enable register."]
        #[inline(always)]
        pub const fn espi_errintr_stat(self) -> crate::common::Reg<regs::EspiErrintrStat, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "This is the eSPI Error interrupt Enable Register."]
        #[inline(always)]
        pub const fn espi_err_ien(self) -> crate::common::Reg<regs::EspiErrIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "This register holds the EC_BUSY status bit, which indicates when the EC Portal is busy performing an access."]
        #[inline(always)]
        pub const fn ec_busy(self) -> crate::common::Reg<regs::EcBusy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "There are two Opcode A registers, one associated with each of the Flashes. If the CS1 Flash does not exist, its register can be left in its default state. The four fields in each register represent the 8-bit Flash opcodes for Write Enable, Suspend, Resume and Read Status Register. The Status Register referred to is the register inside the Flash which contains the (BUSY) or (IN PROGRESS) status bit in position 0."]
        #[inline(always)]
        pub const fn cs0_opa(self) -> crate::common::Reg<regs::Cs0opa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "There are two Opcode B registers, one associated with each of the Flashes. If the CS1 Flash does not exist, its register can be left in its default state. The OP_PROGRAM field is mandatory, and must hold the Page Program opcode for the respective Flash. The Erase size of 4K is mandatory, and so the OP_ERASE0 field must be initialized to the appropriate opcode for the Flash device. There is only one bit declaring each Erase size up to the Host System (instead of one per Flash device, see eSPI Configuration Register 44h), so if there are two Flash devices, each Erase size over 4K must be declared here only if BOTH Flash devices support it."]
        #[inline(always)]
        pub const fn cs0_opb(self) -> crate::common::Reg<regs::Cs0opb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "There are two Opcode C registers, one associated with each of the Flashes. If the CS1 Flash does not exist, its register can be left in its default state. Two fields (OP) define opcodes, and two fields (MODE) represent the Mode code values. Mode codes are provided immediately after the Address in Continuous Read traffic, and are used to keep the Flash device in Continuous Read Mode. Depending on the Flash device manufacturer, this mode may be documented in their datasheet as either a Mode byte, or as certain bits of a first Dummy byte or first Dummy clock. The recommended Mode values given below are selected to be appropriate for any Flash device."]
        #[inline(always)]
        pub const fn cs0_opc(self) -> crate::common::Reg<regs::Cs0opc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "There are two Per-Flash Descriptors registers, one associated with each of the Flash devices."]
        #[inline(always)]
        pub const fn cs0_pfd(self) -> crate::common::Reg<regs::Cs0pfd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "This is the CS1 Opcode A register. If the CS1 Flash does not exist, its register can be left in its default state. The four fields in each register represent the 8-bit Flash opcodes for Write Enable, Suspend, Resume and Read Status Register. The Status Register referred to is the register inside the Flash which contains the BUSY or IN PROGRESS status bit in position 0."]
        #[inline(always)]
        pub const fn cs1_opa(self) -> crate::common::Reg<regs::Cs1opa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "This is the CS1 Flash Opcode B register. If the CS1 Flash does not exist, its register can be left in its default state. The OP_PROGRAM field is mandatory, and must hold the Page Program opcode for the respective Flash. The Erase size of 4K is mandatory, and so the OP_ERASE0 field must be initialized to the appropriate opcode for the Flash device. There is only one bit declaring each Erase size up to the Host System (instead of one per Flash device, see eSPI Configuration Register 44h), so if there are two Flash devices, each Erase size over 4K must be declared here only if BOTH Flash devices support it."]
        #[inline(always)]
        pub const fn cs1_opb(self) -> crate::common::Reg<regs::Cs1opb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "This is the CS1 Flash device Opcode C register. If the CS1 Flash does not exist, its register can be left in its default state. Two fields (OP) define opcodes, and two fields (MODE) represent the Mode code values. Mode codes are provided immediately after the Address in Continuous Read traffic, and are used to keep the Flash device in Continuous Read Mode. Depending on the Flash device manufacturer, this mode may be documented in their datasheet as either a Mode byte, or as certain bits of a first Dummy byte or first Dummy clock. The recommended Mode values given below are selected to be appropriate for any Flash device."]
        #[inline(always)]
        pub const fn cs1_opc(self) -> crate::common::Reg<regs::Cs1opc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "This is the Per-Flash Descriptors register for CS1 Flash."]
        #[inline(always)]
        pub const fn cs1_pfd(self) -> crate::common::Reg<regs::Cs1pfd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize) as _) }
        }
        #[doc = "This is a single register, which accompanies the two Per-Flash Descriptors registers, and provides Descriptor pointers that are shared by both CS0 and CS1 devices uniformly. Each 4-bit field is a pointer which identifies a Timing Descriptor location in the Captive QMSPI block's memory. The EXIT_CONT field (Exit Continuous Mode) points to the single chain invoked to exit the Flash from Continuous Mode, allowing an Erase or Program command to be entered. This chain is identical for either Flash device, regardless of its manufacturer, and simply directs a universal Exit symbol to the appropriate CS0/CS1 device. The POLL1 and POLL2 fields should both point to the same chain. This chain will issue the appropriate opcode for the operation (Poll1 or Poll2) supplied by the SAF Bridge from the Opcode registers, and will read back 16 bits of information for use by the SAF Bridge."]
        #[inline(always)]
        pub const fn gend(self) -> crate::common::Reg<regs::Gend, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6cusize) as _) }
        }
        #[doc = "There is a bit in this register for each of the 17 Protection Region Register sets. Writing '1' to a bit locks the associated 4-Register set to Read-Only access, and also locks this bit itself to a Read-Only '1'."]
        #[inline(always)]
        pub const fn prlock(self) -> crate::common::Reg<regs::Prlock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "There is a bit in this register for each of the 12 Flash Regions that can be allocated from the Region Table in the Intel Descriptor structure. Register sets 12 through 16 do not represent allocated Flash regions, and so they do not have bits in this register."]
        #[inline(always)]
        pub const fn prdirty(self) -> crate::common::Reg<regs::Prdirty, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "The default values in this register match hard-wired assignments made in the Chipset for eSPI Tag values 0h through 7h. A default value of 7 indicates a non-existent map entry, for a Tag value which should never happen."]
        #[inline(always)]
        pub const fn tag_map0(self) -> crate::common::Reg<regs::TagMap0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "The default values in this register match hard-wired assignments made in the Chipset for eSPI Tag values 8h through Fh. A default value of 7 indicates a non-existent map entry, for a Tag value which should never happen."]
        #[inline(always)]
        pub const fn tag_map1(self) -> crate::common::Reg<regs::TagMap1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "The default value in bits \\[2:0\\] of this register matches the hard-wired assignment made in the Chipset for accesses made by an EC. After ensuring that all three Tag Map Registers \\[2:0\\] contain valid mappings, the STM_LK bit should be set to '1' to lock them, preventing firmware from re-assigning them later."]
        #[inline(always)]
        pub const fn tag_map2(self) -> crate::common::Reg<regs::TagMap2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[inline(always)]
        pub const fn saf_prot(self, n: usize) -> SafProt {
            assert!(n < 17usize);
            unsafe { SafProt::from_ptr(self.ptr.add(0x84usize + n * 16usize) as _) }
        }
        #[doc = "This is an error timeout value imposed on any consecutive series of Poll-1 commands to a Flash. The timeout counter starts whenever any new Poll-1 sequence starts, and stops when a Poll-1 detects Not-BUSY status from the Flash."]
        #[inline(always)]
        pub const fn poll_tmout(self) -> crate::common::Reg<regs::PollTmout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "This register should be kept zero except for diagnostic purposes. Where needed, it can be set to provide spacing between consecutive Poll-1 operations to limit the amount of traffic."]
        #[inline(always)]
        pub const fn poll_intrvl(self) -> crate::common::Reg<regs::PollIntrvl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0198usize) as _) }
        }
        #[doc = "The value placed in this register provides necessary programmable support to a Flash that is performing an Erase or a Program operation. When an Erase or Program is started or Resumed, a Suspend is held off until this time expires. While an Erase or Program is in process but Suspended, a Resume is forced when this time expires, even if Read requests are still pending, causing the Erase or Program operation to continue, and again inhibiting the next Suspend until it expires again."]
        #[inline(always)]
        pub const fn susp_res_intrvl(self) -> crate::common::Reg<regs::SuspResIntrvl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x019cusize) as _) }
        }
        #[doc = "This register is used to detect when a series of Read transfers has finished. When this time expires without any new Read request, any suspended Erase or Program operation is given the Resume command to continue."]
        #[inline(always)]
        pub const fn consec_rd_tmout(self) -> crate::common::Reg<regs::ConsecRdTmout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a0usize) as _) }
        }
        #[doc = "Upon issuing a Suspend command, a Poll-1 operation is repeated until the Flash is no longer BUSY, then a Poll-2 operation to determine whether the Flash device is in a Suspended state."]
        #[inline(always)]
        pub const fn fc_poll2_mask(self) -> crate::common::Reg<regs::FcPoll2mask, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a4usize) as _) }
        }
        #[doc = "This register provides special mode control."]
        #[inline(always)]
        pub const fn fc_spec_mode(self) -> crate::common::Reg<regs::FcSpecMode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a8usize) as _) }
        }
        #[doc = "This register provides a time delay for support of some Flash devices. It holds off the first Poll-1 check after a Suspend command has been given to the Flash."]
        #[inline(always)]
        pub const fn susp_check_dly(self) -> crate::common::Reg<regs::SuspCheckDly, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01acusize) as _) }
        }
        #[doc = "Micron requires a prefix consisting of two command frames (in separate CS# assertions) to be sent before Mode information will be recognized to enter Continuous Read mode. This technique is called (Micron XIP) in their datasheets. The support for these chips requires setting up this register and setting the corresponding Prefix Enable bit(s) to enable this handling. The first command frame of the Prefix sequence will be a single byte consisting of the Write Enable opcode, taken from the OP_WE opcode field of the appropriate Opcode A register (Section 7.3.5, on page 113). The second command frame of the Prefix sequence comes from this register, consisting of first the PREFIX_OP byte for the corresponding Flash device (CS0/CS1), and then its PREFIX_DAT byte. The PREFIX_OP byte will be 81h always, which is documented as the Micron opcode (WRITE VOLATILE CONFIGURATION REGISTER) The PREFIX_DAT byte contains the data written to the Micron Flash device's Volatile Configuration Register. It has potential side-effects beyond just enabling Micron XIP Mode, so it must be constructed very carefully."]
        #[inline(always)]
        pub const fn fc_spec_mode2(self) -> crate::common::Reg<regs::FcSpecMode2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b0usize) as _) }
        }
        #[doc = "DnX DnX Protection Bypass Register."]
        #[inline(always)]
        pub const fn dnx_pro_bypas(self) -> crate::common::Reg<regs::DnxProBypas, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b4usize) as _) }
        }
        #[doc = "Timeout Activity Counter."]
        #[inline(always)]
        pub const fn actv_cnt(self) -> crate::common::Reg<regs::ActvCnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b8usize) as _) }
        }
        #[doc = "SAF Low Power Control Register."]
        #[inline(always)]
        pub const fn flp_ctrl(self) -> crate::common::Reg<regs::FlpCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01bcusize) as _) }
        }
        #[doc = "SAF Low Power Status Register."]
        #[inline(always)]
        pub const fn flp_stat(self) -> crate::common::Reg<regs::FlpStat, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize) as _) }
        }
        #[doc = "SAF Low Power CS0 OPCODE Register."]
        #[inline(always)]
        pub const fn flp_cs0_opcd(self) -> crate::common::Reg<regs::FlpCs0opcd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c4usize) as _) }
        }
        #[doc = "SAF Low Power CS0 OPCODE Register."]
        #[inline(always)]
        pub const fn flp_cs1_opcd(self) -> crate::common::Reg<regs::FlpCs1opcd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c8usize) as _) }
        }
        #[doc = "Flash Timeout Power Down Up."]
        #[inline(always)]
        pub const fn fpd_tout_pdup(self) -> crate::common::Reg<regs::FpdToutPdup, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Clock Divider for CS0."]
        #[inline(always)]
        pub const fn cs0clkdiv(self) -> crate::common::Reg<regs::Cs0clkdiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Clock Divider for CS1."]
        #[inline(always)]
        pub const fn cs1clkdiv(self) -> crate::common::Reg<regs::Cs1clkdiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize) as _) }
        }
        #[doc = "eSPI RPMC OP2 Result Address."]
        #[inline(always)]
        pub const fn espirpmcop2_resadd(self) -> crate::common::Reg<regs::Espirpmcop2resadd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize) as _) }
        }
        #[doc = "EC0 RPMC OP2 Result Address."]
        #[inline(always)]
        pub const fn ec0rpmcop2_resadd(self) -> crate::common::Reg<regs::Ec0rpmcop2resadd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x020cusize) as _) }
        }
        #[doc = "EC1 RPMC OP2 Result Address."]
        #[inline(always)]
        pub const fn ec1rpmcop2_resadd(self) -> crate::common::Reg<regs::Ec1rpmcop2resadd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0210usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Timeout Activity Counter."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ActvCnt(pub u16);
        impl ActvCnt {
            #[doc = "This is the Flash Avtivity Timeout Counter."]
            #[inline(always)]
            pub const fn ft_actv_cnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is the Flash Avtivity Timeout Counter."]
            #[inline(always)]
            pub fn set_ft_actv_cnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for ActvCnt {
            #[inline(always)]
            fn default() -> ActvCnt {
                ActvCnt(0)
            }
        }
        impl core::fmt::Debug for ActvCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ActvCnt")
                    .field("ft_actv_cnt", &self.ft_actv_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ActvCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ActvCnt {{ ft_actv_cnt: {=u16:?} }}", self.ft_actv_cnt())
            }
        }
        #[doc = "This register is used to detect when a series of Read transfers has finished. When this time expires without any new Read request, any suspended Erase or Program operation is given the Resume command to continue."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ConsecRdTmout(pub u32);
        impl ConsecRdTmout {
            #[doc = "This field provides a timeout value in units of the EC internal clock MCLK. This value is tunable for system performance, but a value at or below 20us is suggested."]
            #[inline(always)]
            pub const fn rd_tout(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "This field provides a timeout value in units of the EC internal clock MCLK. This value is tunable for system performance, but a value at or below 20us is suggested."]
            #[inline(always)]
            pub fn set_rd_tout(&mut self, val: u32) {
                self.0 = (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
        }
        impl Default for ConsecRdTmout {
            #[inline(always)]
            fn default() -> ConsecRdTmout {
                ConsecRdTmout(0)
            }
        }
        impl core::fmt::Debug for ConsecRdTmout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ConsecRdTmout")
                    .field("rd_tout", &self.rd_tout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ConsecRdTmout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ConsecRdTmout {{ rd_tout: {=u32:?} }}", self.rd_tout())
            }
        }
        #[doc = "Clock Divider for CS0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cs0clkdiv(pub u32);
        impl Cs0clkdiv {
            #[doc = "Read clock divider for CS0."]
            #[inline(always)]
            pub const fn cs0rdclkdiv(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Read clock divider for CS0."]
            #[inline(always)]
            pub fn set_cs0rdclkdiv(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Read clock divider for CS0."]
            #[inline(always)]
            pub const fn cs0restclkdiv(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Read clock divider for CS0."]
            #[inline(always)]
            pub fn set_cs0restclkdiv(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Cs0clkdiv {
            #[inline(always)]
            fn default() -> Cs0clkdiv {
                Cs0clkdiv(0)
            }
        }
        impl core::fmt::Debug for Cs0clkdiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cs0clkdiv")
                    .field("cs0rdclkdiv", &self.cs0rdclkdiv())
                    .field("cs0restclkdiv", &self.cs0restclkdiv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cs0clkdiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cs0clkdiv {{ cs0rdclkdiv: {=u16:?}, cs0restclkdiv: {=u16:?} }}",
                    self.cs0rdclkdiv(),
                    self.cs0restclkdiv()
                )
            }
        }
        #[doc = "There are two Opcode A registers, one associated with each of the Flashes. If the CS1 Flash does not exist, its register can be left in its default state. The four fields in each register represent the 8-bit Flash opcodes for Write Enable, Suspend, Resume and Read Status Register. The Status Register referred to is the register inside the Flash which contains the (BUSY) or (IN PROGRESS) status bit in position 0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cs0opa(pub u32);
        impl Cs0opa {
            #[doc = "This field contains the 8-bit Opcode for Write Enable in the respective Flash device."]
            #[inline(always)]
            pub const fn op_we(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for Write Enable in the respective Flash device."]
            #[inline(always)]
            pub fn set_op_we(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field contains the 8-bit Opcode for Suspend in the respective Flash device."]
            #[inline(always)]
            pub const fn op_sus(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for Suspend in the respective Flash device."]
            #[inline(always)]
            pub fn set_op_sus(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field contains the 8-bit Opcode for Resume in the respective Flash device."]
            #[inline(always)]
            pub const fn op_rsm(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for Resume in the respective Flash device."]
            #[inline(always)]
            pub fn set_op_rsm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field contains the 8-bit Opcode for Read Status Register in the respective Flash device."]
            #[inline(always)]
            pub const fn op_poll1(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for Read Status Register in the respective Flash device."]
            #[inline(always)]
            pub fn set_op_poll1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cs0opa {
            #[inline(always)]
            fn default() -> Cs0opa {
                Cs0opa(0)
            }
        }
        impl core::fmt::Debug for Cs0opa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cs0opa")
                    .field("op_we", &self.op_we())
                    .field("op_sus", &self.op_sus())
                    .field("op_rsm", &self.op_rsm())
                    .field("op_poll1", &self.op_poll1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cs0opa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cs0opa {{ op_we: {=u8:?}, op_sus: {=u8:?}, op_rsm: {=u8:?}, op_poll1: {=u8:?} }}",
                    self.op_we(),
                    self.op_sus(),
                    self.op_rsm(),
                    self.op_poll1()
                )
            }
        }
        #[doc = "There are two Opcode B registers, one associated with each of the Flashes. If the CS1 Flash does not exist, its register can be left in its default state. The OP_PROGRAM field is mandatory, and must hold the Page Program opcode for the respective Flash. The Erase size of 4K is mandatory, and so the OP_ERASE0 field must be initialized to the appropriate opcode for the Flash device. There is only one bit declaring each Erase size up to the Host System (instead of one per Flash device, see eSPI Configuration Register 44h), so if there are two Flash devices, each Erase size over 4K must be declared here only if BOTH Flash devices support it."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cs0opb(pub u32);
        impl Cs0opb {
            #[doc = "This field contains the 8-bit Opcode for 4K Erase in the respective Flash device. This Erase size is mandatory."]
            #[inline(always)]
            pub const fn op_erase0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for 4K Erase in the respective Flash device. This Erase size is mandatory."]
            #[inline(always)]
            pub fn set_op_erase0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field contains the 8-bit Opcode for 32K Erase in the respective Flash device. If there are two Flash devices present, and 32K Erase is not supported by both Flash devices, then this field must be left as 00h in both the CS0 and CS1 registers."]
            #[inline(always)]
            pub const fn op_erase1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for 32K Erase in the respective Flash device. If there are two Flash devices present, and 32K Erase is not supported by both Flash devices, then this field must be left as 00h in both the CS0 and CS1 registers."]
            #[inline(always)]
            pub fn set_op_erase1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field contains the 8-bit Opcode for 64K Erase in the respective Flash device. If there are two Flash devices present, and 64K Erase is not supported by both Flash devices, then this field must be left as 00h in both the CS0 and CS1 registers."]
            #[inline(always)]
            pub const fn op_erase2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for 64K Erase in the respective Flash device. If there are two Flash devices present, and 64K Erase is not supported by both Flash devices, then this field must be left as 00h in both the CS0 and CS1 registers."]
            #[inline(always)]
            pub fn set_op_erase2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field contains the 8-bit Opcode for Page Program in the respective Flash device."]
            #[inline(always)]
            pub const fn op_prg(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for Page Program in the respective Flash device."]
            #[inline(always)]
            pub fn set_op_prg(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cs0opb {
            #[inline(always)]
            fn default() -> Cs0opb {
                Cs0opb(0)
            }
        }
        impl core::fmt::Debug for Cs0opb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cs0opb")
                    .field("op_erase0", &self.op_erase0())
                    .field("op_erase1", &self.op_erase1())
                    .field("op_erase2", &self.op_erase2())
                    .field("op_prg", &self.op_prg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cs0opb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cs0opb {{ op_erase0: {=u8:?}, op_erase1: {=u8:?}, op_erase2: {=u8:?}, op_prg: {=u8:?} }}",
                    self.op_erase0(),
                    self.op_erase1(),
                    self.op_erase2(),
                    self.op_prg()
                )
            }
        }
        #[doc = "There are two Opcode C registers, one associated with each of the Flashes. If the CS1 Flash does not exist, its register can be left in its default state. Two fields (OP) define opcodes, and two fields (MODE) represent the Mode code values. Mode codes are provided immediately after the Address in Continuous Read traffic, and are used to keep the Flash device in Continuous Read Mode. Depending on the Flash device manufacturer, this mode may be documented in their datasheet as either a Mode byte, or as certain bits of a first Dummy byte or first Dummy clock. The recommended Mode values given below are selected to be appropriate for any Flash device."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cs0opc(pub u32);
        impl Cs0opc {
            #[doc = "This field must contain the 8-bit Opcode for Fast Read Quad or Fast Read Dual in the respective Flash device. This code is used in entering Continuous Read mode, and does not appear afterward."]
            #[inline(always)]
            pub const fn op_read(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field must contain the 8-bit Opcode for Fast Read Quad or Fast Read Dual in the respective Flash device. This code is used in entering Continuous Read mode, and does not appear afterward."]
            #[inline(always)]
            pub fn set_op_read(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field is currently a placeholder and is not used. The recommended value for this field, for future compatibility, is FFh."]
            #[inline(always)]
            pub const fn mode_nonc(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field is currently a placeholder and is not used. The recommended value for this field, for future compatibility, is FFh."]
            #[inline(always)]
            pub fn set_mode_nonc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field contains the 8-bit Mode code used to place (or keep) the Flash device in Continuous Read mode. It is strongly recommended that this value be set to A5h, as a universally-acceptable value among Flash devices."]
            #[inline(always)]
            pub const fn mode_cont(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Mode code used to place (or keep) the Flash device in Continuous Read mode. It is strongly recommended that this value be set to A5h, as a universally-acceptable value among Flash devices."]
            #[inline(always)]
            pub fn set_mode_cont(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field contains the 8-bit Opcode used to confirm Suspended status in the Flash device. It is issued using a designated Timing Descriptor chain Poll which is used to read a 16-bit value. This value is evaluated using the Mask values in the Poll2 Mask register"]
            #[inline(always)]
            pub const fn op_poll2(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode used to confirm Suspended status in the Flash device. It is issued using a designated Timing Descriptor chain Poll which is used to read a 16-bit value. This value is evaluated using the Mask values in the Poll2 Mask register"]
            #[inline(always)]
            pub fn set_op_poll2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cs0opc {
            #[inline(always)]
            fn default() -> Cs0opc {
                Cs0opc(0)
            }
        }
        impl core::fmt::Debug for Cs0opc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cs0opc")
                    .field("op_read", &self.op_read())
                    .field("mode_nonc", &self.mode_nonc())
                    .field("mode_cont", &self.mode_cont())
                    .field("op_poll2", &self.op_poll2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cs0opc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cs0opc {{ op_read: {=u8:?}, mode_nonc: {=u8:?}, mode_cont: {=u8:?}, op_poll2: {=u8:?} }}",
                    self.op_read(),
                    self.mode_nonc(),
                    self.mode_cont(),
                    self.op_poll2()
                )
            }
        }
        #[doc = "There are two Per-Flash Descriptors registers, one associated with each of the Flash devices."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cs0pfd(pub u32);
        impl Cs0pfd {
            #[doc = "This field points to the first Descriptor element of the Enter Continuous Mode chain."]
            #[inline(always)]
            pub const fn enter_cont(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This field points to the first Descriptor element of the Enter Continuous Mode chain."]
            #[inline(always)]
            pub fn set_enter_cont(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "This field points to the first Descriptor element of the Continuous Read chain."]
            #[inline(always)]
            pub const fn read_cont(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "This field points to the first Descriptor element of the Continuous Read chain."]
            #[inline(always)]
            pub fn set_read_cont(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "This field points to the Descriptor element within the READ_CONT chain that contains the Length field for data."]
            #[inline(always)]
            pub const fn size_cont(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "This field points to the Descriptor element within the READ_CONT chain that contains the Length field for data."]
            #[inline(always)]
            pub fn set_size_cont(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Cs0pfd {
            #[inline(always)]
            fn default() -> Cs0pfd {
                Cs0pfd(0)
            }
        }
        impl core::fmt::Debug for Cs0pfd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cs0pfd")
                    .field("enter_cont", &self.enter_cont())
                    .field("read_cont", &self.read_cont())
                    .field("size_cont", &self.size_cont())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cs0pfd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cs0pfd {{ enter_cont: {=u8:?}, read_cont: {=u8:?}, size_cont: {=u8:?} }}",
                    self.enter_cont(),
                    self.read_cont(),
                    self.size_cont()
                )
            }
        }
        #[doc = "Clock Divider for CS1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cs1clkdiv(pub u32);
        impl Cs1clkdiv {
            #[doc = "Read clock divider for CS1."]
            #[inline(always)]
            pub const fn cs1rdclkdiv(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Read clock divider for CS1."]
            #[inline(always)]
            pub fn set_cs1rdclkdiv(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Read clock divider for CS1."]
            #[inline(always)]
            pub const fn cs1restclkdiv(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Read clock divider for CS1."]
            #[inline(always)]
            pub fn set_cs1restclkdiv(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Cs1clkdiv {
            #[inline(always)]
            fn default() -> Cs1clkdiv {
                Cs1clkdiv(0)
            }
        }
        impl core::fmt::Debug for Cs1clkdiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cs1clkdiv")
                    .field("cs1rdclkdiv", &self.cs1rdclkdiv())
                    .field("cs1restclkdiv", &self.cs1restclkdiv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cs1clkdiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cs1clkdiv {{ cs1rdclkdiv: {=u16:?}, cs1restclkdiv: {=u16:?} }}",
                    self.cs1rdclkdiv(),
                    self.cs1restclkdiv()
                )
            }
        }
        #[doc = "This is the CS1 Opcode A register. If the CS1 Flash does not exist, its register can be left in its default state. The four fields in each register represent the 8-bit Flash opcodes for Write Enable, Suspend, Resume and Read Status Register. The Status Register referred to is the register inside the Flash which contains the BUSY or IN PROGRESS status bit in position 0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cs1opa(pub u32);
        impl Cs1opa {
            #[doc = "This field contains the 8-bit Opcode for Write Enable in the respective Flash device."]
            #[inline(always)]
            pub const fn op_we(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for Write Enable in the respective Flash device."]
            #[inline(always)]
            pub fn set_op_we(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field contains the 8-bit Opcode for Suspend in the respective Flash device."]
            #[inline(always)]
            pub const fn op_sus(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for Suspend in the respective Flash device."]
            #[inline(always)]
            pub fn set_op_sus(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field contains the 8-bit Opcode for Resume in the respective Flash device."]
            #[inline(always)]
            pub const fn op_rsm(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for Resume in the respective Flash device."]
            #[inline(always)]
            pub fn set_op_rsm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field contains the 8-bit Opcode for Read Status Register in the respective Flash device."]
            #[inline(always)]
            pub const fn op_poll1(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for Read Status Register in the respective Flash device."]
            #[inline(always)]
            pub fn set_op_poll1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cs1opa {
            #[inline(always)]
            fn default() -> Cs1opa {
                Cs1opa(0)
            }
        }
        impl core::fmt::Debug for Cs1opa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cs1opa")
                    .field("op_we", &self.op_we())
                    .field("op_sus", &self.op_sus())
                    .field("op_rsm", &self.op_rsm())
                    .field("op_poll1", &self.op_poll1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cs1opa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cs1opa {{ op_we: {=u8:?}, op_sus: {=u8:?}, op_rsm: {=u8:?}, op_poll1: {=u8:?} }}",
                    self.op_we(),
                    self.op_sus(),
                    self.op_rsm(),
                    self.op_poll1()
                )
            }
        }
        #[doc = "This is the CS1 Flash Opcode B register. If the CS1 Flash does not exist, its register can be left in its default state. The OP_PROGRAM field is mandatory, and must hold the Page Program opcode for the respective Flash. The Erase size of 4K is mandatory, and so the OP_ERASE0 field must be initialized to the appropriate opcode for the Flash device. There is only one bit declaring each Erase size up to the Host System (instead of one per Flash device, see eSPI Configuration Register 44h), so if there are two Flash devices, each Erase size over 4K must be declared here only if BOTH Flash devices support it."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cs1opb(pub u32);
        impl Cs1opb {
            #[doc = "This field contains the 8-bit Opcode for 4K Erase in the respective Flash device. This Erase size is mandatory."]
            #[inline(always)]
            pub const fn op_erase0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for 4K Erase in the respective Flash device. This Erase size is mandatory."]
            #[inline(always)]
            pub fn set_op_erase0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field contains the 8-bit Opcode for 32K Erase in the respective Flash device. If there are two Flash devices present, and 32K Erase is not supported by both Flash devices, then this field must be left as 00h in both the CS0 and CS1 registers."]
            #[inline(always)]
            pub const fn op_erase1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for 32K Erase in the respective Flash device. If there are two Flash devices present, and 32K Erase is not supported by both Flash devices, then this field must be left as 00h in both the CS0 and CS1 registers."]
            #[inline(always)]
            pub fn set_op_erase1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field contains the 8-bit Opcode for 64K Erase in the respective Flash device. If there are two Flash devices present, and 64K Erase is not supported by both Flash devices, then this field must be left as 00h in both the CS0 and CS1 registers."]
            #[inline(always)]
            pub const fn op_erase2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for 64K Erase in the respective Flash device. If there are two Flash devices present, and 64K Erase is not supported by both Flash devices, then this field must be left as 00h in both the CS0 and CS1 registers."]
            #[inline(always)]
            pub fn set_op_erase2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field contains the 8-bit Opcode for Page Program in the respective Flash device."]
            #[inline(always)]
            pub const fn op_program(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode for Page Program in the respective Flash device."]
            #[inline(always)]
            pub fn set_op_program(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cs1opb {
            #[inline(always)]
            fn default() -> Cs1opb {
                Cs1opb(0)
            }
        }
        impl core::fmt::Debug for Cs1opb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cs1opb")
                    .field("op_erase0", &self.op_erase0())
                    .field("op_erase1", &self.op_erase1())
                    .field("op_erase2", &self.op_erase2())
                    .field("op_program", &self.op_program())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cs1opb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cs1opb {{ op_erase0: {=u8:?}, op_erase1: {=u8:?}, op_erase2: {=u8:?}, op_program: {=u8:?} }}",
                    self.op_erase0(),
                    self.op_erase1(),
                    self.op_erase2(),
                    self.op_program()
                )
            }
        }
        #[doc = "This is the CS1 Flash device Opcode C register. If the CS1 Flash does not exist, its register can be left in its default state. Two fields (OP) define opcodes, and two fields (MODE) represent the Mode code values. Mode codes are provided immediately after the Address in Continuous Read traffic, and are used to keep the Flash device in Continuous Read Mode. Depending on the Flash device manufacturer, this mode may be documented in their datasheet as either a Mode byte, or as certain bits of a first Dummy byte or first Dummy clock. The recommended Mode values given below are selected to be appropriate for any Flash device."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cs1opc(pub u32);
        impl Cs1opc {
            #[doc = "This field must contain the 8-bit Opcode for Fast Read Quad or Fast Read Dual in the respective Flash device. This code is used in entering Continuous Read mode, and does not appear afterward."]
            #[inline(always)]
            pub const fn op_read(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field must contain the 8-bit Opcode for Fast Read Quad or Fast Read Dual in the respective Flash device. This code is used in entering Continuous Read mode, and does not appear afterward."]
            #[inline(always)]
            pub fn set_op_read(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field is currently a placeholder and is not used. The recommended value for this field, for future compatibility, is FFh."]
            #[inline(always)]
            pub const fn mode_nonc(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field is currently a placeholder and is not used. The recommended value for this field, for future compatibility, is FFh."]
            #[inline(always)]
            pub fn set_mode_nonc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field contains the 8-bit Mode code used to place (or keep) the Flash device in Continuous Read mode. It is strongly recommended that this value be set to A5h, as a universally-acceptable value among Flash devices."]
            #[inline(always)]
            pub const fn mode_cont(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Mode code used to place (or keep) the Flash device in Continuous Read mode. It is strongly recommended that this value be set to A5h, as a universally-acceptable value among Flash devices."]
            #[inline(always)]
            pub fn set_mode_cont(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field contains the 8-bit Opcode used to confirm Suspended status in the Flash device. It is issued using a designated Timing Descriptor chain Poll which is used to read a 16-bit value. This value is evaluated using the Mask values in the Poll2 Mask register"]
            #[inline(always)]
            pub const fn op_poll2(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the 8-bit Opcode used to confirm Suspended status in the Flash device. It is issued using a designated Timing Descriptor chain Poll which is used to read a 16-bit value. This value is evaluated using the Mask values in the Poll2 Mask register"]
            #[inline(always)]
            pub fn set_op_poll2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cs1opc {
            #[inline(always)]
            fn default() -> Cs1opc {
                Cs1opc(0)
            }
        }
        impl core::fmt::Debug for Cs1opc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cs1opc")
                    .field("op_read", &self.op_read())
                    .field("mode_nonc", &self.mode_nonc())
                    .field("mode_cont", &self.mode_cont())
                    .field("op_poll2", &self.op_poll2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cs1opc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cs1opc {{ op_read: {=u8:?}, mode_nonc: {=u8:?}, mode_cont: {=u8:?}, op_poll2: {=u8:?} }}",
                    self.op_read(),
                    self.mode_nonc(),
                    self.mode_cont(),
                    self.op_poll2()
                )
            }
        }
        #[doc = "This is the Per-Flash Descriptors register for CS1 Flash."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cs1pfd(pub u32);
        impl Cs1pfd {
            #[doc = "This field points to the first Descriptor element of the Enter Continuous Mode chain."]
            #[inline(always)]
            pub const fn enter_cont(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This field points to the first Descriptor element of the Enter Continuous Mode chain."]
            #[inline(always)]
            pub fn set_enter_cont(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "This field points to the first Descriptor element of the Continuous Read chain."]
            #[inline(always)]
            pub const fn read_cont(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "This field points to the first Descriptor element of the Continuous Read chain."]
            #[inline(always)]
            pub fn set_read_cont(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "This field points to the Descriptor element within the READ_CONT chain that contains the Length field for data."]
            #[inline(always)]
            pub const fn size_cont(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "This field points to the Descriptor element within the READ_CONT chain that contains the Length field for data."]
            #[inline(always)]
            pub fn set_size_cont(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Cs1pfd {
            #[inline(always)]
            fn default() -> Cs1pfd {
                Cs1pfd(0)
            }
        }
        impl core::fmt::Debug for Cs1pfd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cs1pfd")
                    .field("enter_cont", &self.enter_cont())
                    .field("read_cont", &self.read_cont())
                    .field("size_cont", &self.size_cont())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cs1pfd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cs1pfd {{ enter_cont: {=u8:?}, read_cont: {=u8:?}, size_cont: {=u8:?} }}",
                    self.enter_cont(),
                    self.read_cont(),
                    self.size_cont()
                )
            }
        }
        #[doc = "DnX DnX Protection Bypass Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DnxProBypas(pub u32);
        impl DnxProBypas {
            #[doc = "Lock bit for this register: 0= All Read/Write bits in this register are unlocked and writable. 1= All Read/Write bits in this register are locked to Read-Only (including this bit)."]
            #[inline(always)]
            pub const fn dnx_lk(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Lock bit for this register: 0= All Read/Write bits in this register are unlocked and writable. 1= All Read/Write bits in this register are locked to Read-Only (including this bit)."]
            #[inline(always)]
            pub fn set_dnx_lk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for DnxProBypas {
            #[inline(always)]
            fn default() -> DnxProBypas {
                DnxProBypas(0)
            }
        }
        impl core::fmt::Debug for DnxProBypas {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DnxProBypas").field("dnx_lk", &self.dnx_lk()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DnxProBypas {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DnxProBypas {{ dnx_lk: {=bool:?} }}", self.dnx_lk())
            }
        }
        #[doc = "EC0 RPMC OP2 Result Address."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ec0rpmcop2resadd(pub u32);
        impl Ec0rpmcop2resadd {
            #[doc = "eSPI RPMC OP2 Result Address for EC0."]
            #[inline(always)]
            pub const fn ec0rpmcop2_resadd(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "eSPI RPMC OP2 Result Address for EC0."]
            #[inline(always)]
            pub fn set_ec0rpmcop2_resadd(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Ec0rpmcop2resadd {
            #[inline(always)]
            fn default() -> Ec0rpmcop2resadd {
                Ec0rpmcop2resadd(0)
            }
        }
        impl core::fmt::Debug for Ec0rpmcop2resadd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ec0rpmcop2resadd")
                    .field("ec0rpmcop2_resadd", &self.ec0rpmcop2_resadd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ec0rpmcop2resadd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ec0rpmcop2resadd {{ ec0rpmcop2_resadd: {=u32:?} }}",
                    self.ec0rpmcop2_resadd()
                )
            }
        }
        #[doc = "EC1 RPMC OP2 Result Address."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ec1rpmcop2resadd(pub u32);
        impl Ec1rpmcop2resadd {
            #[doc = "eSPI RPMC OP2 Result Address for EC1."]
            #[inline(always)]
            pub const fn ec1rpmcop2_resadd(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "eSPI RPMC OP2 Result Address for EC1."]
            #[inline(always)]
            pub fn set_ec1rpmcop2_resadd(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Ec1rpmcop2resadd {
            #[inline(always)]
            fn default() -> Ec1rpmcop2resadd {
                Ec1rpmcop2resadd(0)
            }
        }
        impl core::fmt::Debug for Ec1rpmcop2resadd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ec1rpmcop2resadd")
                    .field("ec1rpmcop2_resadd", &self.ec1rpmcop2_resadd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ec1rpmcop2resadd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ec1rpmcop2resadd {{ ec1rpmcop2_resadd: {=u32:?} }}",
                    self.ec1rpmcop2_resadd()
                )
            }
        }
        #[doc = "This register holds the EC_BUSY status bit, which indicates when the EC Portal is busy performing an access."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcBusy(pub u32);
        impl EcBusy {
            #[doc = "This Read-Only bit is set to '1' by hardware when the START bit is written with '1' to start a new request. It is cleared to '0' when request completes, and its falling edge sets the DONE bit. While this bit is '1', the EC Portal Command, Flash Address and Buffer Address registers are locked Read-Only, and the START bit is disabled, causing it only to set the START_OVERFLOW error status bit to '1'."]
            #[inline(always)]
            pub const fn ec_busy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This Read-Only bit is set to '1' by hardware when the START bit is written with '1' to start a new request. It is cleared to '0' when request completes, and its falling edge sets the DONE bit. While this bit is '1', the EC Portal Command, Flash Address and Buffer Address registers are locked Read-Only, and the START bit is disabled, causing it only to set the START_OVERFLOW error status bit to '1'."]
            #[inline(always)]
            pub fn set_ec_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EcBusy {
            #[inline(always)]
            fn default() -> EcBusy {
                EcBusy(0)
            }
        }
        impl core::fmt::Debug for EcBusy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcBusy").field("ec_busy", &self.ec_busy()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcBusy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcBusy {{ ec_busy: {=bool:?} }}", self.ec_busy())
            }
        }
        #[doc = "This register holds a location in the EC's own address space that is to be used as the SRAM buffer for an EC Flash access."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcpBufAddr(pub u32);
        impl EcpBufAddr {
            #[doc = "This field holds bits \\[31:2\\] of the SRAM buffer address. Bits\\[1:0\\] of the address are fixed at 00."]
            #[inline(always)]
            pub const fn adr(&self) -> u32 {
                let val = (self.0 >> 2usize) & 0x3fff_ffff;
                val as u32
            }
            #[doc = "This field holds bits \\[31:2\\] of the SRAM buffer address. Bits\\[1:0\\] of the address are fixed at 00."]
            #[inline(always)]
            pub fn set_adr(&mut self, val: u32) {
                self.0 = (self.0 & !(0x3fff_ffff << 2usize)) | (((val as u32) & 0x3fff_ffff) << 2usize);
            }
        }
        impl Default for EcpBufAddr {
            #[inline(always)]
            fn default() -> EcpBufAddr {
                EcpBufAddr(0)
            }
        }
        impl core::fmt::Debug for EcpBufAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcpBufAddr").field("adr", &self.adr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcpBufAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcpBufAddr {{ adr: {=u32:?} }}", self.adr())
            }
        }
        #[doc = "This register defines the command type and length of transfers requested by EC firmware"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcpCmd(pub u32);
        impl EcpCmd {
            #[doc = "This field must contain the value 0Ah; that is, the eSPI command PUT_FLASH_NP."]
            #[inline(always)]
            pub const fn ec_put_cmd(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field must contain the value 0Ah; that is, the eSPI command PUT_FLASH_NP."]
            #[inline(always)]
            pub fn set_ec_put_cmd(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field encodes the operation requested: 00h = Read 01h = Write (Page Program) 02h = Erase 03h = RPMC OP1 directed to Flash CS0# 04h = RPMC OP2 directed to Flash CS0# 83h = RPMC OP1 directed to Flash CS1# 84h = RPMC OP2 directed to Flash CS1# Other encodings are undefined"]
            #[inline(always)]
            pub const fn ec_ctype_cmd(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field encodes the operation requested: 00h = Read 01h = Write (Page Program) 02h = Erase 03h = RPMC OP1 directed to Flash CS0# 04h = RPMC OP2 directed to Flash CS0# 83h = RPMC OP1 directed to Flash CS1# 84h = RPMC OP2 directed to Flash CS1# Other encodings are undefined"]
            #[inline(always)]
            pub fn set_ec_ctype_cmd(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field contains the Length field for all requests. Read or Write or RPMC OP1 or OP2: The length in bytes of the data transfer, to or from the SRAM buffer. Must be in the range 1 -- 64 (01h -- 40h). Erase: Must encode an eSPI-defined Erase Block Size: 00h = 4K 01h = 32K 02h = 64K Other encodings are undefined."]
            #[inline(always)]
            pub const fn ec_len(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field contains the Length field for all requests. Read or Write or RPMC OP1 or OP2: The length in bytes of the data transfer, to or from the SRAM buffer. Must be in the range 1 -- 64 (01h -- 40h). Erase: Must encode an eSPI-defined Erase Block Size: 00h = 4K 01h = 32K 02h = 64K Other encodings are undefined."]
            #[inline(always)]
            pub fn set_ec_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for EcpCmd {
            #[inline(always)]
            fn default() -> EcpCmd {
                EcpCmd(0)
            }
        }
        impl core::fmt::Debug for EcpCmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcpCmd")
                    .field("ec_put_cmd", &self.ec_put_cmd())
                    .field("ec_ctype_cmd", &self.ec_ctype_cmd())
                    .field("ec_len", &self.ec_len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcpCmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EcpCmd {{ ec_put_cmd: {=u8:?}, ec_ctype_cmd: {=u8:?}, ec_len: {=u8:?} }}",
                    self.ec_put_cmd(),
                    self.ec_ctype_cmd(),
                    self.ec_len()
                )
            }
        }
        #[doc = "This register hold the Flash Space address to be accessed by the current command from EC firmware."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcpFlashAddr(pub u32);
        impl EcpFlashAddr {
            #[doc = "FLASH_ADDR: This field holds the Flash address to be accessed."]
            #[inline(always)]
            pub const fn addr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "FLASH_ADDR: This field holds the Flash address to be accessed."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for EcpFlashAddr {
            #[inline(always)]
            fn default() -> EcpFlashAddr {
                EcpFlashAddr(0)
            }
        }
        impl core::fmt::Debug for EcpFlashAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcpFlashAddr").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcpFlashAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcpFlashAddr {{ addr: {=u32:?} }}", self.addr())
            }
        }
        #[doc = "This register contains the one bit DONE_EN in bit position\\[0\\]. This bit enables the DONE bit in the status register to trigger an interrupt."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcpIen(pub u32);
        impl EcpIen {
            #[doc = "This bit enables interrupts from the DONE bit in the Status register. 1 = Enabled 0 = Disabled"]
            #[inline(always)]
            pub const fn done_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables interrupts from the DONE bit in the Status register. 1 = Enabled 0 = Disabled"]
            #[inline(always)]
            pub fn set_done_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This controls whether an interrupt is fired when Timeout is asserted."]
            #[inline(always)]
            pub const fn timeout_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Timeout is asserted."]
            #[inline(always)]
            pub fn set_timeout_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This controls whether an interrupt is fired when Out Of Range is asserted."]
            #[inline(always)]
            pub const fn outofrng_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Out Of Range is asserted."]
            #[inline(always)]
            pub fn set_outofrng_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This controls whether an interrupt is fired when Access Violation is asserted."]
            #[inline(always)]
            pub const fn access_violat_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Access Violation is asserted."]
            #[inline(always)]
            pub fn set_access_violat_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This controls whether an interrupt is fired when 4K Boundary is asserted."]
            #[inline(always)]
            pub const fn bound_4k_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when 4K Boundary is asserted."]
            #[inline(always)]
            pub fn set_bound_4k_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This controls whether an interrupt is fired when Erase Size Error is asserted."]
            #[inline(always)]
            pub const fn erase_siz_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Erase Size Error is asserted."]
            #[inline(always)]
            pub fn set_erase_siz_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This controls whether an interrupt is fired when Start Overflow is asserted."]
            #[inline(always)]
            pub const fn strt_ovrfl_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Start Overflow is asserted."]
            #[inline(always)]
            pub fn set_strt_ovrfl_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This controls whether an interrupt is fired when Bad Request is asserted."]
            #[inline(always)]
            pub const fn bad_req_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when Bad Request is asserted."]
            #[inline(always)]
            pub fn set_bad_req_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This controls whether an interrupt is fired when RPMC OP2 Lenght is asserted."]
            #[inline(always)]
            pub const fn rpmc_op2len_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This controls whether an interrupt is fired when RPMC OP2 Lenght is asserted."]
            #[inline(always)]
            pub fn set_rpmc_op2len_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for EcpIen {
            #[inline(always)]
            fn default() -> EcpIen {
                EcpIen(0)
            }
        }
        impl core::fmt::Debug for EcpIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcpIen")
                    .field("done_en", &self.done_en())
                    .field("timeout_en", &self.timeout_en())
                    .field("outofrng_en", &self.outofrng_en())
                    .field("access_violat_en", &self.access_violat_en())
                    .field("bound_4k_en", &self.bound_4k_en())
                    .field("erase_siz_en", &self.erase_siz_en())
                    .field("strt_ovrfl_en", &self.strt_ovrfl_en())
                    .field("bad_req_en", &self.bad_req_en())
                    .field("rpmc_op2len_en", &self.rpmc_op2len_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcpIen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcpIen {{ done_en: {=bool:?}, timeout_en: {=bool:?}, outofrng_en: {=bool:?}, access_violat_en: {=bool:?}, bound_4k_en: {=bool:?}, erase_siz_en: {=bool:?}, strt_ovrfl_en: {=bool:?}, bad_req_en: {=bool:?}, rpmc_op2len_en: {=bool:?} }}" , self . done_en () , self . timeout_en () , self . outofrng_en () , self . access_violat_en () , self . bound_4k_en () , self . erase_siz_en () , self . strt_ovrfl_en () , self . bad_req_en () , self . rpmc_op2len_en ())
            }
        }
        #[doc = "This register contains the Start control for a Flash access requested in the rest of the EC Portal registers. It triggers the requested transfer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcpStart(pub u32);
        impl EcpStart {
            #[doc = "This bit is written with '1' to start a new request, but always appears '0' when being read. Writing '1' to this bit immediately sets the EC_BUSY bit to '1' as an acknowledgement that the request is being serviced. Writing '1' to the START bit again, while the EC_BUSY bit is already '1' will do nothing except to set the START_OVERFLOW error status bit to '1' and the request already in service will complete normally except for the START_OVERFLOW=1 status indication."]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is written with '1' to start a new request, but always appears '0' when being read. Writing '1' to this bit immediately sets the EC_BUSY bit to '1' as an acknowledgement that the request is being serviced. Writing '1' to the START bit again, while the EC_BUSY bit is already '1' will do nothing except to set the START_OVERFLOW error status bit to '1' and the request already in service will complete normally except for the START_OVERFLOW=1 status indication."]
            #[inline(always)]
            pub fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EcpStart {
            #[inline(always)]
            fn default() -> EcpStart {
                EcpStart(0)
            }
        }
        impl core::fmt::Debug for EcpStart {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcpStart").field("start", &self.start()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcpStart {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EcpStart {{ start: {=bool:?} }}", self.start())
            }
        }
        #[doc = "This register holds the DONE status bit."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcpSts(pub u32);
        impl EcpSts {
            #[doc = "This bit is set to '1' by hardware to indicate the end of a requested access by the EC. It can be enabled to trigger an interrupt when '1'. Writing a '1' clears this bit and the interrupt source. This is R/WC."]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' by hardware to indicate the end of a requested access by the EC. It can be enabled to trigger an interrupt when '1'. Writing a '1' clears this bit and the interrupt source. This is R/WC."]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to '1' by hardware during a requested access by the EC. It has no usage except for possible diagnostic purposes, but should be cleared (with the rest of this register) by writing '1' before starting any new access. This is R/WC."]
            #[inline(always)]
            pub const fn done_tst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' by hardware during a requested access by the EC. It has no usage except for possible diagnostic purposes, but should be cleared (with the rest of this register) by writing '1' before starting any new access. This is R/WC."]
            #[inline(always)]
            pub fn set_done_tst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit indicates that an Erase or Write or RPMC OP1 request from the EC has failed because the Flash has timed out. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an Erase or Write or RPMC OP1 request from the EC has failed because the Flash has timed out. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit indicates that a request from the EC has been rejected because it is beyond the physical limits of the attached Flash devices, as declared in the Size Limit and Threshold Registers. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn out_of_range(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a request from the EC has been rejected because it is beyond the physical limits of the attached Flash devices, as declared in the Size Limit and Threshold Registers. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_out_of_range(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit indicates that a request from the EC has been rejected because it violates the Protection Register settings. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn access_violat(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a request from the EC has been rejected because it violates the Protection Register settings. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_access_violat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit indicates that a Read request from the EC has been rejected because it has attempted to cross a 4K Flash address boundary. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn bound_4k(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a Read request from the EC has been rejected because it has attempted to cross a 4K Flash address boundary. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_bound_4k(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit indicates that an invalid Erase Block Size has been specified in an Erase request from the EC. This error is detected by seeing 00h in the specific Erase Size opcode field. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn erase_size(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an invalid Erase Block Size has been specified in an Erase request from the EC. This error is detected by seeing 00h in the specific Erase Size opcode field. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_erase_size(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit indicates that an access was already in progress when a new access was requested by writing '1' to the START bit. Such a request is ignored except to set this bit. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn strt_ovrflw(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an access was already in progress when a new access was requested by writing '1' to the START bit. Such a request is ignored except to set this bit. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_strt_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This bit indicates that an invalid Request code has been specified in the Portal Command Register at the time the START bit was set to trigger it. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn bad_req(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an invalid Request code has been specified in the Portal Command Register at the time the START bit was set to trigger it. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_bad_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This bit indicates that a lenght greater that 49 is set for RPMC OP2 command. This is R/WC."]
            #[inline(always)]
            pub const fn rpmc_op2len(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a lenght greater that 49 is set for RPMC OP2 command. This is R/WC."]
            #[inline(always)]
            pub fn set_rpmc_op2len(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for EcpSts {
            #[inline(always)]
            fn default() -> EcpSts {
                EcpSts(0)
            }
        }
        impl core::fmt::Debug for EcpSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcpSts")
                    .field("done", &self.done())
                    .field("done_tst", &self.done_tst())
                    .field("timeout", &self.timeout())
                    .field("out_of_range", &self.out_of_range())
                    .field("access_violat", &self.access_violat())
                    .field("bound_4k", &self.bound_4k())
                    .field("erase_size", &self.erase_size())
                    .field("strt_ovrflw", &self.strt_ovrflw())
                    .field("bad_req", &self.bad_req())
                    .field("rpmc_op2len", &self.rpmc_op2len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcpSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcpSts {{ done: {=bool:?}, done_tst: {=bool:?}, timeout: {=bool:?}, out_of_range: {=bool:?}, access_violat: {=bool:?}, bound_4k: {=bool:?}, erase_size: {=bool:?}, strt_ovrflw: {=bool:?}, bad_req: {=bool:?}, rpmc_op2len: {=bool:?} }}" , self . done () , self . done_tst () , self . timeout () , self . out_of_range () , self . access_violat () , self . bound_4k () , self . erase_size () , self . strt_ovrflw () , self . bad_req () , self . rpmc_op2len ())
            }
        }
        #[doc = "This is the eSPI Error interrupt Enable Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EspiErrIen(pub u32);
        impl EspiErrIen {
            #[doc = "This bit enables the TIMEOUT status bit as an interrupt."]
            #[inline(always)]
            pub const fn timeout_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the TIMEOUT status bit as an interrupt."]
            #[inline(always)]
            pub fn set_timeout_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit enables the OUT_OF_RANGE status bit as an interrupt."]
            #[inline(always)]
            pub const fn out_of_range_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the OUT_OF_RANGE status bit as an interrupt."]
            #[inline(always)]
            pub fn set_out_of_range_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit enables the ACCESS_VIOLATION status bit as an interrupt."]
            #[inline(always)]
            pub const fn access_violat_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the ACCESS_VIOLATION status bit as an interrupt."]
            #[inline(always)]
            pub fn set_access_violat_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit enables the 4K_BOUNDARY status bit as an interrupt."]
            #[inline(always)]
            pub const fn bound_4k_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the 4K_BOUNDARY status bit as an interrupt."]
            #[inline(always)]
            pub fn set_bound_4k_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit enables the ERASE_SIZE status bit as an interrupt."]
            #[inline(always)]
            pub const fn erase_size_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the ERASE_SIZE status bit as an interrupt."]
            #[inline(always)]
            pub fn set_erase_size_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit enables the RPMC OP2 Length Error status bit as an interrupt."]
            #[inline(always)]
            pub const fn rpmc_op2len_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the RPMC OP2 Length Error status bit as an interrupt."]
            #[inline(always)]
            pub fn set_rpmc_op2len_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for EspiErrIen {
            #[inline(always)]
            fn default() -> EspiErrIen {
                EspiErrIen(0)
            }
        }
        impl core::fmt::Debug for EspiErrIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EspiErrIen")
                    .field("timeout_en", &self.timeout_en())
                    .field("out_of_range_en", &self.out_of_range_en())
                    .field("access_violat_en", &self.access_violat_en())
                    .field("bound_4k_en", &self.bound_4k_en())
                    .field("erase_size_en", &self.erase_size_en())
                    .field("rpmc_op2len_en", &self.rpmc_op2len_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EspiErrIen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EspiErrIen {{ timeout_en: {=bool:?}, out_of_range_en: {=bool:?}, access_violat_en: {=bool:?}, bound_4k_en: {=bool:?}, erase_size_en: {=bool:?}, rpmc_op2len_en: {=bool:?} }}" , self . timeout_en () , self . out_of_range_en () , self . access_violat_en () , self . bound_4k_en () , self . erase_size_en () , self . rpmc_op2len_en ())
            }
        }
        #[doc = "These bits may be individually enabled to trigger interrupts using the corresponding Interrupt Enable register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EspiErrintrStat(pub u32);
        impl EspiErrintrStat {
            #[doc = "This bit indicates that an Erase or Write request from the Host Chipset has failed because the Flash has timed out. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an Erase or Write request from the Host Chipset has failed because the Flash has timed out. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit indicates that a request from the Host Chipset has been rejected because it is beyond the physical limits of the attached Flash devices. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn out_of_range(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a request from the Host Chipset has been rejected because it is beyond the physical limits of the attached Flash devices. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_out_of_range(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit indicates that a request from the Host Chipset has been rejected because it violates the Protection Register settings. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn access_violat(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a request from the Host Chipset has been rejected because it violates the Protection Register settings. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_access_violat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit indicates that a Read request from the Host Chipset has been rejected because it has attempted to cross a 4K Flash address boundary. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn bound_4k(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a Read request from the Host Chipset has been rejected because it has attempted to cross a 4K Flash address boundary. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_bound_4k(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit indicates that an invalid Erase Block Size has been specified in an Erase request from the Host Chipset. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub const fn erase_size(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an invalid Erase Block Size has been specified in an Erase request from the Host Chipset. This bit is cleared by writing '1' to its position. This is R/WC."]
            #[inline(always)]
            pub fn set_erase_size(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for EspiErrintrStat {
            #[inline(always)]
            fn default() -> EspiErrintrStat {
                EspiErrintrStat(0)
            }
        }
        impl core::fmt::Debug for EspiErrintrStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EspiErrintrStat")
                    .field("timeout", &self.timeout())
                    .field("out_of_range", &self.out_of_range())
                    .field("access_violat", &self.access_violat())
                    .field("bound_4k", &self.bound_4k())
                    .field("erase_size", &self.erase_size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EspiErrintrStat {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EspiErrintrStat {{ timeout: {=bool:?}, out_of_range: {=bool:?}, access_violat: {=bool:?}, bound_4k: {=bool:?}, erase_size: {=bool:?} }}" , self . timeout () , self . out_of_range () , self . access_violat () , self . bound_4k () , self . erase_size ())
            }
        }
        #[doc = "eSPI RPMC OP2 Result Address."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Espirpmcop2resadd(pub u32);
        impl Espirpmcop2resadd {
            #[doc = "eSPI RPMC OP2 Result Address for EC0."]
            #[inline(always)]
            pub const fn ec0rpmcop2_resadd(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "eSPI RPMC OP2 Result Address for EC0."]
            #[inline(always)]
            pub fn set_ec0rpmcop2_resadd(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Espirpmcop2resadd {
            #[inline(always)]
            fn default() -> Espirpmcop2resadd {
                Espirpmcop2resadd(0)
            }
        }
        impl core::fmt::Debug for Espirpmcop2resadd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Espirpmcop2resadd")
                    .field("ec0rpmcop2_resadd", &self.ec0rpmcop2_resadd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Espirpmcop2resadd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Espirpmcop2resadd {{ ec0rpmcop2_resadd: {=u32:?} }}",
                    self.ec0rpmcop2_resadd()
                )
            }
        }
        #[doc = "Upon issuing a Suspend command, a Poll-1 operation is repeated until the Flash is no longer BUSY, then a Poll-2 operation to determine whether the Flash device is in a Suspended state."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcPoll2mask(pub u32);
        impl FcPoll2mask {
            #[doc = "A '1' in this field masks out (ignores) the corresponding bit returned in Poll-2 status for the CS0 Flash."]
            #[inline(always)]
            pub const fn cs0_poll2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "A '1' in this field masks out (ignores) the corresponding bit returned in Poll-2 status for the CS0 Flash."]
            #[inline(always)]
            pub fn set_cs0_poll2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "A '1' in this field masks out (ignores) the corresponding bit returned in Poll-2 status for the CS1 Flash."]
            #[inline(always)]
            pub const fn cs1_poll2(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "A '1' in this field masks out (ignores) the corresponding bit returned in Poll-2 status for the CS1 Flash."]
            #[inline(always)]
            pub fn set_cs1_poll2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for FcPoll2mask {
            #[inline(always)]
            fn default() -> FcPoll2mask {
                FcPoll2mask(0)
            }
        }
        impl core::fmt::Debug for FcPoll2mask {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcPoll2mask")
                    .field("cs0_poll2", &self.cs0_poll2())
                    .field("cs1_poll2", &self.cs1_poll2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcPoll2mask {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FcPoll2mask {{ cs0_poll2: {=u16:?}, cs1_poll2: {=u16:?} }}",
                    self.cs0_poll2(),
                    self.cs1_poll2()
                )
            }
        }
        #[doc = "This register provides special mode control."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcSpecMode(pub u32);
        impl FcSpecMode {
            #[doc = "A '1' in this field enters DISABLE_SUSPEND mode, which prevents suspending an Erase or Write in progress. In this mode, Read operations will be held waiting until the Erase or Write finishes."]
            #[inline(always)]
            pub const fn dis_suspend(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "A '1' in this field enters DISABLE_SUSPEND mode, which prevents suspending an Erase or Write in progress. In this mode, Read operations will be held waiting until the Erase or Write finishes."]
            #[inline(always)]
            pub fn set_dis_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for FcSpecMode {
            #[inline(always)]
            fn default() -> FcSpecMode {
                FcSpecMode(0)
            }
        }
        impl core::fmt::Debug for FcSpecMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcSpecMode")
                    .field("dis_suspend", &self.dis_suspend())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcSpecMode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FcSpecMode {{ dis_suspend: {=bool:?} }}", self.dis_suspend())
            }
        }
        #[doc = "Micron requires a prefix consisting of two command frames (in separate CS# assertions) to be sent before Mode information will be recognized to enter Continuous Read mode. This technique is called (Micron XIP) in their datasheets. The support for these chips requires setting up this register and setting the corresponding Prefix Enable bit(s) to enable this handling. The first command frame of the Prefix sequence will be a single byte consisting of the Write Enable opcode, taken from the OP_WE opcode field of the appropriate Opcode A register (Section 7.3.5, on page 113). The second command frame of the Prefix sequence comes from this register, consisting of first the PREFIX_OP byte for the corresponding Flash device (CS0/CS1), and then its PREFIX_DAT byte. The PREFIX_OP byte will be 81h always, which is documented as the Micron opcode (WRITE VOLATILE CONFIGURATION REGISTER) The PREFIX_DAT byte contains the data written to the Micron Flash device's Volatile Configuration Register. It has potential side-effects beyond just enabling Micron XIP Mode, so it must be constructed very carefully."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FcSpecMode2(pub u32);
        impl FcSpecMode2 {
            #[doc = "This field is the Prefix Opcode for Micron XIP mode on CS0. It should be set to 81h, for Micron parts."]
            #[inline(always)]
            pub const fn cs0_pre_op(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field is the Prefix Opcode for Micron XIP mode on CS0. It should be set to 81h, for Micron parts."]
            #[inline(always)]
            pub fn set_cs0_pre_op(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field is the data sent with the CS0_PREFIX_OP command."]
            #[inline(always)]
            pub const fn cs0_pre_dat(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field is the data sent with the CS0_PREFIX_OP command."]
            #[inline(always)]
            pub fn set_cs0_pre_dat(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field is the Prefix Opcode for Micron XIP mode on CS1. It should be set to 81h, for Micron parts."]
            #[inline(always)]
            pub const fn cs1_pre_op(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field is the Prefix Opcode for Micron XIP mode on CS1. It should be set to 81h, for Micron parts."]
            #[inline(always)]
            pub fn set_cs1_pre_op(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field is the data sent with the CS1_PREFIX_OP command."]
            #[inline(always)]
            pub const fn cs1_pre_dat(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field is the data sent with the CS1_PREFIX_OP command."]
            #[inline(always)]
            pub fn set_cs1_pre_dat(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for FcSpecMode2 {
            #[inline(always)]
            fn default() -> FcSpecMode2 {
                FcSpecMode2(0)
            }
        }
        impl core::fmt::Debug for FcSpecMode2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FcSpecMode2")
                    .field("cs0_pre_op", &self.cs0_pre_op())
                    .field("cs0_pre_dat", &self.cs0_pre_dat())
                    .field("cs1_pre_op", &self.cs1_pre_op())
                    .field("cs1_pre_dat", &self.cs1_pre_dat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FcSpecMode2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "FcSpecMode2 {{ cs0_pre_op: {=u8:?}, cs0_pre_dat: {=u8:?}, cs1_pre_op: {=u8:?}, cs1_pre_dat: {=u8:?} }}" , self . cs0_pre_op () , self . cs0_pre_dat () , self . cs1_pre_op () , self . cs1_pre_dat ())
            }
        }
        #[doc = "Bits\\[7:6\\] (PREFIX) declare the need for some Flash devices (notably Micron) to be given an explicit command to enter Continuous Mode, as opposed to requiring only Mode bits in the first Read access."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlashMiscCfg(pub u32);
        impl FlashMiscCfg {
            #[doc = "Selects optimized data prefetching from the Flash devices to the eSPI Master. This field has no effect unless the PREFETCH_EN bit is also '1' 00= Prefetched data from Flash is delivered using canonical eSPI methods. (Default) 11= Prefetched data from Flash is delivered using expedited eSPI methods. 01,10= (Reserved)"]
            #[inline(always)]
            pub const fn prefetch_opt_en(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "Selects optimized data prefetching from the Flash devices to the eSPI Master. This field has no effect unless the PREFETCH_EN bit is also '1' 00= Prefetched data from Flash is delivered using canonical eSPI methods. (Default) 11= Prefetched data from Flash is delivered using expedited eSPI methods. 01,10= (Reserved)"]
            #[inline(always)]
            pub fn set_prefetch_opt_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "Declares whether the Flash device on CS0# uses a 32-bit address. Set this bit to '1' if the Flash device is 32Mbytes (256MBits) or greater. This bit does not cause the Flash device itself to be placed into 4-byte address mode; that must be done by EC firmware before enabling SAFS operation. 0=Issue 3-byte addresses to the CS0# Flash device. 1=Issue 4-byte addresses to the CS0# Flash device."]
            #[inline(always)]
            pub const fn cs0_4byte_addr_mode(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Declares whether the Flash device on CS0# uses a 32-bit address. Set this bit to '1' if the Flash device is 32Mbytes (256MBits) or greater. This bit does not cause the Flash device itself to be placed into 4-byte address mode; that must be done by EC firmware before enabling SAFS operation. 0=Issue 3-byte addresses to the CS0# Flash device. 1=Issue 4-byte addresses to the CS0# Flash device."]
            #[inline(always)]
            pub fn set_cs0_4byte_addr_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Declares whether the Flash device on CS1# uses a 32-bit address. Set this bit to '1' if the Flash device is 32Mbytes (256MBits) or greater. This bit does not cause the Flash device itself to be placed into 4-byte address mode; that must be done by EC firmware before enabling SAFS operation. 0=Issue 3-byte addresses to the CS1# Flash device. 1=Issue 4-byte addresses to the CS1# Flash device."]
            #[inline(always)]
            pub const fn cs1_4byte_addr_mode(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Declares whether the Flash device on CS1# uses a 32-bit address. Set this bit to '1' if the Flash device is 32Mbytes (256MBits) or greater. This bit does not cause the Flash device itself to be placed into 4-byte address mode; that must be done by EC firmware before enabling SAFS operation. 0=Issue 3-byte addresses to the CS1# Flash device. 1=Issue 4-byte addresses to the CS1# Flash device."]
            #[inline(always)]
            pub fn set_cs1_4byte_addr_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Declares whether the Flash device on CS0# requires a prefix command to enter Continuous Mode. 0=No prefix command is required by the Flash device on CS0#. 1=A Prefix command will be issued from the CS0 fields of the SAF Flash Configuration Special Mode Register to the Flash device on CS0# before entry into Continuous Mode."]
            #[inline(always)]
            pub const fn cs0_cont_prefix_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Declares whether the Flash device on CS0# requires a prefix command to enter Continuous Mode. 0=No prefix command is required by the Flash device on CS0#. 1=A Prefix command will be issued from the CS0 fields of the SAF Flash Configuration Special Mode Register to the Flash device on CS0# before entry into Continuous Mode."]
            #[inline(always)]
            pub fn set_cs0_cont_prefix_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Declares whether the Flash device on CS1# (if any) requires a prefix command to enter Continuous Mode. 0=No prefix command is required by the Flash device on CS1#. 1=A Prefix command will be issued from the CS1 fields of the SAF Flash Configuration Special Mode Register to the Flash device on CS1# before entry into Continuous Mode."]
            #[inline(always)]
            pub const fn cs1_cont_prefix_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Declares whether the Flash device on CS1# (if any) requires a prefix command to enter Continuous Mode. 0=No prefix command is required by the Flash device on CS1#. 1=A Prefix command will be issued from the CS1 fields of the SAF Flash Configuration Special Mode Register to the Flash device on CS1# before entry into Continuous Mode."]
            #[inline(always)]
            pub fn set_cs1_cont_prefix_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "0=SAFS Mode operation is globally disabled. 1=SAFS Mode operation is globally enabled. The Captive QMSPI Block register set and the SAF Communication register set also become inaccessible to EC firmware."]
            #[inline(always)]
            pub const fn saf_mode_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "0=SAFS Mode operation is globally disabled. 1=SAFS Mode operation is globally enabled. The Captive QMSPI Block register set and the SAF Communication register set also become inaccessible to EC firmware."]
            #[inline(always)]
            pub fn set_saf_mode_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "0=The SAF Bridge register sets are unlocked and available R/W to EC firmware. 1=The SAF Bridge register sets Device Configuration and Device Timing, including this register, are locked read-only to EC firmware."]
            #[inline(always)]
            pub const fn saf_mode_lock(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "0=The SAF Bridge register sets are unlocked and available R/W to EC firmware. 1=The SAF Bridge register sets Device Configuration and Device Timing, including this register, are locked read-only to EC firmware."]
            #[inline(always)]
            pub fn set_saf_mode_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enables the SAF block to sleep the flash on Light Sleep Enable"]
            #[inline(always)]
            pub const fn fpwrdn_lght_slpen(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the SAF block to sleep the flash on Light Sleep Enable"]
            #[inline(always)]
            pub fn set_fpwrdn_lght_slpen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Enables the SAF block to sleep the flash on Heavy Sleep Enable"]
            #[inline(always)]
            pub const fn fpwrdn_hvy_slpen(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the SAF block to sleep the flash on Heavy Sleep Enable"]
            #[inline(always)]
            pub fn set_fpwrdn_hvy_slpen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Enables the saf block to sleep on the Activity Counter reaching zero."]
            #[inline(always)]
            pub const fn factv_cnt_en(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the saf block to sleep on the Activity Counter reaching zero."]
            #[inline(always)]
            pub fn set_factv_cnt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enables the Activity Counter to Reload On SPI Enable"]
            #[inline(always)]
            pub const fn rld_actv_cnt_espi_en(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the Activity Counter to Reload On SPI Enable"]
            #[inline(always)]
            pub fn set_rld_actv_cnt_espi_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enables the activity counter to reload on EC0 Activity Counter Reload"]
            #[inline(always)]
            pub const fn rld_actv_cnt_ec0_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the activity counter to reload on EC0 Activity Counter Reload"]
            #[inline(always)]
            pub fn set_rld_actv_cnt_ec0_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enables the activity counter to reload on EC1 Activity"]
            #[inline(always)]
            pub const fn rld_actv_cnt_ec1_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the activity counter to reload on EC1 Activity"]
            #[inline(always)]
            pub fn set_rld_actv_cnt_ec1_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Force RPMC Success. 1=Forces all RPMC OP1 operations to be reported as successful."]
            #[inline(always)]
            pub const fn f_rpmc_scss(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Force RPMC Success. 1=Forces all RPMC OP1 operations to be reported as successful."]
            #[inline(always)]
            pub fn set_f_rpmc_scss(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for FlashMiscCfg {
            #[inline(always)]
            fn default() -> FlashMiscCfg {
                FlashMiscCfg(0)
            }
        }
        impl core::fmt::Debug for FlashMiscCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlashMiscCfg")
                    .field("prefetch_opt_en", &self.prefetch_opt_en())
                    .field("cs0_4byte_addr_mode", &self.cs0_4byte_addr_mode())
                    .field("cs1_4byte_addr_mode", &self.cs1_4byte_addr_mode())
                    .field("cs0_cont_prefix_en", &self.cs0_cont_prefix_en())
                    .field("cs1_cont_prefix_en", &self.cs1_cont_prefix_en())
                    .field("saf_mode_en", &self.saf_mode_en())
                    .field("saf_mode_lock", &self.saf_mode_lock())
                    .field("fpwrdn_lght_slpen", &self.fpwrdn_lght_slpen())
                    .field("fpwrdn_hvy_slpen", &self.fpwrdn_hvy_slpen())
                    .field("factv_cnt_en", &self.factv_cnt_en())
                    .field("rld_actv_cnt_espi_en", &self.rld_actv_cnt_espi_en())
                    .field("rld_actv_cnt_ec0_en", &self.rld_actv_cnt_ec0_en())
                    .field("rld_actv_cnt_ec1_en", &self.rld_actv_cnt_ec1_en())
                    .field("f_rpmc_scss", &self.f_rpmc_scss())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlashMiscCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "FlashMiscCfg {{ prefetch_opt_en: {=u8:?}, cs0_4byte_addr_mode: {=bool:?}, cs1_4byte_addr_mode: {=bool:?}, cs0_cont_prefix_en: {=bool:?}, cs1_cont_prefix_en: {=bool:?}, saf_mode_en: {=bool:?}, saf_mode_lock: {=bool:?}, fpwrdn_lght_slpen: {=bool:?}, fpwrdn_hvy_slpen: {=bool:?}, factv_cnt_en: {=bool:?}, rld_actv_cnt_espi_en: {=bool:?}, rld_actv_cnt_ec0_en: {=bool:?}, rld_actv_cnt_ec1_en: {=bool:?}, f_rpmc_scss: {=bool:?} }}" , self . prefetch_opt_en () , self . cs0_4byte_addr_mode () , self . cs1_4byte_addr_mode () , self . cs0_cont_prefix_en () , self . cs1_cont_prefix_en () , self . saf_mode_en () , self . saf_mode_lock () , self . fpwrdn_lght_slpen () , self . fpwrdn_hvy_slpen () , self . factv_cnt_en () , self . rld_actv_cnt_espi_en () , self . rld_actv_cnt_ec0_en () , self . rld_actv_cnt_ec1_en () , self . f_rpmc_scss ())
            }
        }
        #[doc = "This register declares the address of the final byte of the Flash space implemented in the physically present Flash device or devices."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlashSizeLim(pub u32);
        impl FlashSizeLim {
            #[doc = "This register declares the address of the final byte of the Flash space implemented in the physically present Flash device or devices."]
            #[inline(always)]
            pub const fn limit(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register declares the address of the final byte of the Flash space implemented in the physically present Flash device or devices."]
            #[inline(always)]
            pub fn set_limit(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FlashSizeLim {
            #[inline(always)]
            fn default() -> FlashSizeLim {
                FlashSizeLim(0)
            }
        }
        impl core::fmt::Debug for FlashSizeLim {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlashSizeLim").field("limit", &self.limit()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlashSizeLim {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FlashSizeLim {{ limit: {=u32:?} }}", self.limit())
            }
        }
        #[doc = "This register declares whether there are two Flash devices, and if so, where the boundary is between the devices."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlashThr(pub u32);
        impl FlashThr {
            #[doc = "The address placed in this register is the address of the first byte of the second Flash device. If there is only one Flash device, then this register must contain a value greater than the Size Limit register above."]
            #[inline(always)]
            pub const fn thres(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "The address placed in this register is the address of the first byte of the second Flash device. If there is only one Flash device, then this register must contain a value greater than the Size Limit register above."]
            #[inline(always)]
            pub fn set_thres(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FlashThr {
            #[inline(always)]
            fn default() -> FlashThr {
                FlashThr(0)
            }
        }
        impl core::fmt::Debug for FlashThr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlashThr").field("thres", &self.thres()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlashThr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FlashThr {{ thres: {=u32:?} }}", self.thres())
            }
        }
        #[doc = "SAF Low Power CS0 OPCODE Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlpCs0opcd(pub u32);
        impl FlpCs0opcd {
            #[doc = "CS0 Low Power Opcode for low power entry."]
            #[inline(always)]
            pub const fn cs0opcd_ntry(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "CS0 Low Power Opcode for low power entry."]
            #[inline(always)]
            pub fn set_cs0opcd_ntry(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "CS0 Low Power Opcode for low power exit."]
            #[inline(always)]
            pub const fn cs0opcd_xit(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "CS0 Low Power Opcode for low power exit."]
            #[inline(always)]
            pub fn set_cs0opcd_xit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "CS0 Opcode for rpmc op2."]
            #[inline(always)]
            pub const fn cs0_rpmc_op2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "CS0 Opcode for rpmc op2."]
            #[inline(always)]
            pub fn set_cs0_rpmc_op2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for FlpCs0opcd {
            #[inline(always)]
            fn default() -> FlpCs0opcd {
                FlpCs0opcd(0)
            }
        }
        impl core::fmt::Debug for FlpCs0opcd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlpCs0opcd")
                    .field("cs0opcd_ntry", &self.cs0opcd_ntry())
                    .field("cs0opcd_xit", &self.cs0opcd_xit())
                    .field("cs0_rpmc_op2", &self.cs0_rpmc_op2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlpCs0opcd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FlpCs0opcd {{ cs0opcd_ntry: {=u8:?}, cs0opcd_xit: {=u8:?}, cs0_rpmc_op2: {=u8:?} }}",
                    self.cs0opcd_ntry(),
                    self.cs0opcd_xit(),
                    self.cs0_rpmc_op2()
                )
            }
        }
        #[doc = "SAF Low Power CS0 OPCODE Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlpCs1opcd(pub u32);
        impl FlpCs1opcd {
            #[doc = "CS1 Low Power Opcode for low power entry."]
            #[inline(always)]
            pub const fn cs1opcd_ntry(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "CS1 Low Power Opcode for low power entry."]
            #[inline(always)]
            pub fn set_cs1opcd_ntry(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "CS1 Low Power Opcode for low power exit."]
            #[inline(always)]
            pub const fn cs1opcd_xit(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "CS1 Low Power Opcode for low power exit."]
            #[inline(always)]
            pub fn set_cs1opcd_xit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "CS1 Opcode for rpmc op2."]
            #[inline(always)]
            pub const fn cs1_rpmc_op2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "CS1 Opcode for rpmc op2."]
            #[inline(always)]
            pub fn set_cs1_rpmc_op2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for FlpCs1opcd {
            #[inline(always)]
            fn default() -> FlpCs1opcd {
                FlpCs1opcd(0)
            }
        }
        impl core::fmt::Debug for FlpCs1opcd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlpCs1opcd")
                    .field("cs1opcd_ntry", &self.cs1opcd_ntry())
                    .field("cs1opcd_xit", &self.cs1opcd_xit())
                    .field("cs1_rpmc_op2", &self.cs1_rpmc_op2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlpCs1opcd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FlpCs1opcd {{ cs1opcd_ntry: {=u8:?}, cs1opcd_xit: {=u8:?}, cs1_rpmc_op2: {=u8:?} }}",
                    self.cs1opcd_ntry(),
                    self.cs1opcd_xit(),
                    self.cs1_rpmc_op2()
                )
            }
        }
        #[doc = "SAF Low Power Control Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlpCtrl(pub u8);
        impl FlpCtrl {
            #[doc = "CS0 Low Power Enable."]
            #[inline(always)]
            pub const fn cs0lp_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CS0 Low Power Enable."]
            #[inline(always)]
            pub fn set_cs0lp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "CS1 Low Power Enable."]
            #[inline(always)]
            pub const fn cs1lp_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "CS1 Low Power Enable."]
            #[inline(always)]
            pub fn set_cs1lp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Enable wake SPI Flash CS0 when processor wakes."]
            #[inline(always)]
            pub const fn cs0wakon_processor_acti_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable wake SPI Flash CS0 when processor wakes."]
            #[inline(always)]
            pub fn set_cs0wakon_processor_acti_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Enable wake SPI Flash CS1 when processor wakes."]
            #[inline(always)]
            pub const fn cs1wakon_processor_acti_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable wake SPI Flash CS1 when processor wakes."]
            #[inline(always)]
            pub fn set_cs1wakon_processor_acti_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
        }
        impl Default for FlpCtrl {
            #[inline(always)]
            fn default() -> FlpCtrl {
                FlpCtrl(0)
            }
        }
        impl core::fmt::Debug for FlpCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlpCtrl")
                    .field("cs0lp_en", &self.cs0lp_en())
                    .field("cs1lp_en", &self.cs1lp_en())
                    .field("cs0wakon_processor_acti_en", &self.cs0wakon_processor_acti_en())
                    .field("cs1wakon_processor_acti_en", &self.cs1wakon_processor_acti_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlpCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "FlpCtrl {{ cs0lp_en: {=bool:?}, cs1lp_en: {=bool:?}, cs0wakon_processor_acti_en: {=bool:?}, cs1wakon_processor_acti_en: {=bool:?} }}" , self . cs0lp_en () , self . cs1lp_en () , self . cs0wakon_processor_acti_en () , self . cs1wakon_processor_acti_en ())
            }
        }
        #[doc = "SAF Low Power Status Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlpStat(pub u8);
        impl FlpStat {
            #[doc = "CS0 Low Power Status."]
            #[inline(always)]
            pub const fn cs0lp_stat(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CS0 Low Power Status."]
            #[inline(always)]
            pub fn set_cs0lp_stat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "CS1 Low Power Enable."]
            #[inline(always)]
            pub const fn cs1lp_stat(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "CS1 Low Power Enable."]
            #[inline(always)]
            pub fn set_cs1lp_stat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
        }
        impl Default for FlpStat {
            #[inline(always)]
            fn default() -> FlpStat {
                FlpStat(0)
            }
        }
        impl core::fmt::Debug for FlpStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlpStat")
                    .field("cs0lp_stat", &self.cs0lp_stat())
                    .field("cs1lp_stat", &self.cs1lp_stat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlpStat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FlpStat {{ cs0lp_stat: {=bool:?}, cs1lp_stat: {=bool:?} }}",
                    self.cs0lp_stat(),
                    self.cs1lp_stat()
                )
            }
        }
        #[doc = "Flash Timeout Power Down Up."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FpdToutPdup(pub u16);
        impl FpdToutPdup {
            #[doc = "This is the Flash Timeout Power Down Up."]
            #[inline(always)]
            pub const fn fpd_tout_cnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is the Flash Timeout Power Down Up."]
            #[inline(always)]
            pub fn set_fpd_tout_cnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for FpdToutPdup {
            #[inline(always)]
            fn default() -> FpdToutPdup {
                FpdToutPdup(0)
            }
        }
        impl core::fmt::Debug for FpdToutPdup {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FpdToutPdup")
                    .field("fpd_tout_cnt", &self.fpd_tout_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FpdToutPdup {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FpdToutPdup {{ fpd_tout_cnt: {=u16:?} }}", self.fpd_tout_cnt())
            }
        }
        #[doc = "This is a single register, which accompanies the two Per-Flash Descriptors registers, and provides Descriptor pointers that are shared by both CS0 and CS1 devices uniformly. Each 4-bit field is a pointer which identifies a Timing Descriptor location in the Captive QMSPI block's memory. The EXIT_CONT field (Exit Continuous Mode) points to the single chain invoked to exit the Flash from Continuous Mode, allowing an Erase or Program command to be entered. This chain is identical for either Flash device, regardless of its manufacturer, and simply directs a universal Exit symbol to the appropriate CS0/CS1 device. The POLL1 and POLL2 fields should both point to the same chain. This chain will issue the appropriate opcode for the operation (Poll1 or Poll2) supplied by the SAF Bridge from the Opcode registers, and will read back 16 bits of information for use by the SAF Bridge."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gend(pub u32);
        impl Gend {
            #[doc = "This field points to the first Descriptor element of the Exit Continuous Mode chain."]
            #[inline(always)]
            pub const fn exit_cont(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This field points to the first Descriptor element of the Exit Continuous Mode chain."]
            #[inline(always)]
            pub fn set_exit_cont(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "This field points to the first Descriptor element of the Poll chain, used when polling for Busy status."]
            #[inline(always)]
            pub const fn poll1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "This field points to the first Descriptor element of the Poll chain, used when polling for Busy status."]
            #[inline(always)]
            pub fn set_poll1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "This field points to the first Descriptor element of the Poll chain, used when polling for Suspended status."]
            #[inline(always)]
            pub const fn poll2(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "This field points to the first Descriptor element of the Poll chain, used when polling for Suspended status."]
            #[inline(always)]
            pub fn set_poll2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Gend {
            #[inline(always)]
            fn default() -> Gend {
                Gend(0)
            }
        }
        impl core::fmt::Debug for Gend {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gend")
                    .field("exit_cont", &self.exit_cont())
                    .field("poll1", &self.poll1())
                    .field("poll2", &self.poll2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gend {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gend {{ exit_cont: {=u8:?}, poll1: {=u8:?}, poll2: {=u8:?} }}",
                    self.exit_cont(),
                    self.poll1(),
                    self.poll2()
                )
            }
        }
        #[doc = "This is Limit00 register. Unless the Start register is less than or equal to the Limit register, the associated register set \\[RR\\] is Disabled, and has no effect on permissions. The default state of these registers, in all of the register sets, is this Disabled state. While all register sets remain Disabled, no Protection Master except Master #0 (PCH HW) will be able to perform any Flash access anywhere through SAFS operations, and this restriction includes the EC firmware (as Master #5)."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Limit(pub u32);
        impl Limit {
            #[doc = "This field contains the limit address of this Region, in units of 4K bytes. The entire 4K block identified is within the Region: that is, the final byte address is determined by appending FFFh to this field."]
            #[inline(always)]
            pub const fn saf_prot(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "This field contains the limit address of this Region, in units of 4K bytes. The entire 4K block identified is within the Region: that is, the final byte address is determined by appending FFFh to this field."]
            #[inline(always)]
            pub fn set_saf_prot(&mut self, val: u32) {
                self.0 = (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
        }
        impl Default for Limit {
            #[inline(always)]
            fn default() -> Limit {
                Limit(0)
            }
        }
        impl core::fmt::Debug for Limit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Limit").field("saf_prot", &self.saf_prot()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Limit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Limit {{ saf_prot: {=u32:?} }}", self.saf_prot())
            }
        }
        #[doc = "This register should be kept zero except for diagnostic purposes. Where needed, it can be set to provide spacing between consecutive Poll-1 operations to limit the amount of traffic."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PollIntrvl(pub u32);
        impl PollIntrvl {
            #[doc = "This field provides an interval in units of the EC internal clock MCLK."]
            #[inline(always)]
            pub const fn intrvl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This field provides an interval in units of the EC internal clock MCLK."]
            #[inline(always)]
            pub fn set_intrvl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for PollIntrvl {
            #[inline(always)]
            fn default() -> PollIntrvl {
                PollIntrvl(0)
            }
        }
        impl core::fmt::Debug for PollIntrvl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PollIntrvl").field("intrvl", &self.intrvl()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PollIntrvl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PollIntrvl {{ intrvl: {=u16:?} }}", self.intrvl())
            }
        }
        #[doc = "This is an error timeout value imposed on any consecutive series of Poll-1 commands to a Flash. The timeout counter starts whenever any new Poll-1 sequence starts, and stops when a Poll-1 detects Not-BUSY status from the Flash."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PollTmout(pub u32);
        impl PollTmout {
            #[doc = "This field provides a polling timeout value in units of the 32KHz clock. Recommended value is 5 seconds, expressed as 28000h (163,840 decimal) in this field."]
            #[inline(always)]
            pub const fn tout(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0003_ffff;
                val as u32
            }
            #[doc = "This field provides a polling timeout value in units of the 32KHz clock. Recommended value is 5 seconds, expressed as 28000h (163,840 decimal) in this field."]
            #[inline(always)]
            pub fn set_tout(&mut self, val: u32) {
                self.0 = (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
            }
        }
        impl Default for PollTmout {
            #[inline(always)]
            fn default() -> PollTmout {
                PollTmout(0)
            }
        }
        impl core::fmt::Debug for PollTmout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PollTmout").field("tout", &self.tout()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PollTmout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PollTmout {{ tout: {=u32:?} }}", self.tout())
            }
        }
        #[doc = "There is a bit in this register for each of the 12 Flash Regions that can be allocated from the Region Table in the Intel Descriptor structure. Register sets 12 through 16 do not represent allocated Flash regions, and so they do not have bits in this register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prdirty(pub u32);
        impl Prdirty {
            #[doc = "Indicates whether contents of Region 0 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 0 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether contents of Region 1 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 1 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether contents of Region 2 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 2 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether contents of Region 3 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 3 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether contents of Region 4 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 4 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Indicates whether contents of Region 5 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 5 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Indicates whether contents of Region 6 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 6 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Indicates whether contents of Region 7 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 7 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates whether contents of Region 8 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 8 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates whether contents of Region 9 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 9 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates whether contents of Region 10 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 10 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Indicates whether contents of Region 11 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub const fn saf_11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether contents of Region 11 have been changed. 0=There has been no Write or Erase performed in this region since this bit was last cleared. 1=A Write or Erase has been performed in this region since this bit was last cleared."]
            #[inline(always)]
            pub fn set_saf_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for Prdirty {
            #[inline(always)]
            fn default() -> Prdirty {
                Prdirty(0)
            }
        }
        impl core::fmt::Debug for Prdirty {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prdirty")
                    .field("saf_0", &self.saf_0())
                    .field("saf_1", &self.saf_1())
                    .field("saf_2", &self.saf_2())
                    .field("saf_3", &self.saf_3())
                    .field("saf_4", &self.saf_4())
                    .field("saf_5", &self.saf_5())
                    .field("saf_6", &self.saf_6())
                    .field("saf_7", &self.saf_7())
                    .field("saf_8", &self.saf_8())
                    .field("saf_9", &self.saf_9())
                    .field("saf_10", &self.saf_10())
                    .field("saf_11", &self.saf_11())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prdirty {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Prdirty {{ saf_0: {=bool:?}, saf_1: {=bool:?}, saf_2: {=bool:?}, saf_3: {=bool:?}, saf_4: {=bool:?}, saf_5: {=bool:?}, saf_6: {=bool:?}, saf_7: {=bool:?}, saf_8: {=bool:?}, saf_9: {=bool:?}, saf_10: {=bool:?}, saf_11: {=bool:?} }}" , self . saf_0 () , self . saf_1 () , self . saf_2 () , self . saf_3 () , self . saf_4 () , self . saf_5 () , self . saf_6 () , self . saf_7 () , self . saf_8 () , self . saf_9 () , self . saf_10 () , self . saf_11 ())
            }
        }
        #[doc = "There is a bit in this register for each of the 17 Protection Region Register sets. Writing '1' to a bit locks the associated 4-Register set to Read-Only access, and also locks this bit itself to a Read-Only '1'."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prlock(pub u32);
        impl Prlock {
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 0: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 0: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 1: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 1: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 2: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 2: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 3: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 3: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 4: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 4: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 5: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 5: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 6: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 6: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 7: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 7: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 8: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 8: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 9: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 9: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 10: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 10: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 11: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 11: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 12: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 12: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 13: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 13: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 14: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 14: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 15: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 15: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 16: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub const fn saf_16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "In its initial 0 state, this bit allows Read and Write access to the corresponding Region Register set RR = 16: Start, Limit, Write and Read. When written to 1, this bit locks those four registers as read-only, and also locks this bit itself against being cleared."]
            #[inline(always)]
            pub fn set_saf_16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Prlock {
            #[inline(always)]
            fn default() -> Prlock {
                Prlock(0)
            }
        }
        impl core::fmt::Debug for Prlock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prlock")
                    .field("saf_0", &self.saf_0())
                    .field("saf_1", &self.saf_1())
                    .field("saf_2", &self.saf_2())
                    .field("saf_3", &self.saf_3())
                    .field("saf_4", &self.saf_4())
                    .field("saf_5", &self.saf_5())
                    .field("saf_6", &self.saf_6())
                    .field("saf_7", &self.saf_7())
                    .field("saf_8", &self.saf_8())
                    .field("saf_9", &self.saf_9())
                    .field("saf_10", &self.saf_10())
                    .field("saf_11", &self.saf_11())
                    .field("saf_12", &self.saf_12())
                    .field("saf_13", &self.saf_13())
                    .field("saf_14", &self.saf_14())
                    .field("saf_15", &self.saf_15())
                    .field("saf_16", &self.saf_16())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prlock {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Prlock {{ saf_0: {=bool:?}, saf_1: {=bool:?}, saf_2: {=bool:?}, saf_3: {=bool:?}, saf_4: {=bool:?}, saf_5: {=bool:?}, saf_6: {=bool:?}, saf_7: {=bool:?}, saf_8: {=bool:?}, saf_9: {=bool:?}, saf_10: {=bool:?}, saf_11: {=bool:?}, saf_12: {=bool:?}, saf_13: {=bool:?}, saf_14: {=bool:?}, saf_15: {=bool:?}, saf_16: {=bool:?} }}" , self . saf_0 () , self . saf_1 () , self . saf_2 () , self . saf_3 () , self . saf_4 () , self . saf_5 () , self . saf_6 () , self . saf_7 () , self . saf_8 () , self . saf_9 () , self . saf_10 () , self . saf_11 () , self . saf_12 () , self . saf_13 () , self . saf_14 () , self . saf_15 () , self . saf_16 ())
            }
        }
        #[doc = "This is Read00 register. Bits at positions \\[0\\]--\\[7\\] grant Read permission to Permission Masters numbered 0--7 respectively."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Read(pub u32);
        impl Read {
            #[doc = "This bit contains the permission for Read access by Protection Master 0 to this Region. It is a read-only placeholder because Protection Master 0 has full access to all Flash locations. 1=Protection Master 0 may always Read in this region."]
            #[inline(always)]
            pub const fn saf_prot_rd0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 0 to this Region. It is a read-only placeholder because Protection Master 0 has full access to all Flash locations. 1=Protection Master 0 may always Read in this region."]
            #[inline(always)]
            pub fn set_saf_prot_rd0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 1 to this Region. 0=Protection Master 1 may not Read in this region. 1=Protection Master 1 may Read in this region."]
            #[inline(always)]
            pub const fn saf_prot_rd1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 1 to this Region. 0=Protection Master 1 may not Read in this region. 1=Protection Master 1 may Read in this region."]
            #[inline(always)]
            pub fn set_saf_prot_rd1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 2 to this Region. 0=Protection Master 2 may not Read in this region. 1=Protection Master 2 may Read in this region."]
            #[inline(always)]
            pub const fn saf_prot_rd2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 2 to this Region. 0=Protection Master 2 may not Read in this region. 1=Protection Master 2 may Read in this region."]
            #[inline(always)]
            pub fn set_saf_prot_rd2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 3 to this Region. 0=Protection Master 3 may not Read in this region. 1=Protection Master 3 may Read in this region."]
            #[inline(always)]
            pub const fn saf_prot_rd3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 3 to this Region. 0=Protection Master 3 may not Read in this region. 1=Protection Master 3 may Read in this region."]
            #[inline(always)]
            pub fn set_saf_prot_rd3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 4 to this Region. 0=Protection Master 4 may not Read in this region. 1=Protection Master 4 may Read in this region."]
            #[inline(always)]
            pub const fn saf_prot_rd4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 4 to this Region. 0=Protection Master 4 may not Read in this region. 1=Protection Master 4 may Read in this region."]
            #[inline(always)]
            pub fn set_saf_prot_rd4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 5 to this Region. 0=Protection Master 5 may not Read in this region. 1=Protection Master 5 may Read in this region."]
            #[inline(always)]
            pub const fn saf_prot_rd5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 5 to this Region. 0=Protection Master 5 may not Read in this region. 1=Protection Master 5 may Read in this region."]
            #[inline(always)]
            pub fn set_saf_prot_rd5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 6 to this Region. 0=Protection Master 6 may not Read in this region. 1=Protection Master 6 may Read in this region."]
            #[inline(always)]
            pub const fn saf_prot_rd6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 6 to this Region. 0=Protection Master 6 may not Read in this region. 1=Protection Master 6 may Read in this region."]
            #[inline(always)]
            pub fn set_saf_prot_rd6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 7 to this Region. 0=Protection Master 7 may not Read in this region. 1=Protection Master 7 may Read in this region."]
            #[inline(always)]
            pub const fn saf_prot_rd7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Read access by Protection Master 7 to this Region. 0=Protection Master 7 may not Read in this region. 1=Protection Master 7 may Read in this region."]
            #[inline(always)]
            pub fn set_saf_prot_rd7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Read {
            #[inline(always)]
            fn default() -> Read {
                Read(0)
            }
        }
        impl core::fmt::Debug for Read {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Read")
                    .field("saf_prot_rd0", &self.saf_prot_rd0())
                    .field("saf_prot_rd1", &self.saf_prot_rd1())
                    .field("saf_prot_rd2", &self.saf_prot_rd2())
                    .field("saf_prot_rd3", &self.saf_prot_rd3())
                    .field("saf_prot_rd4", &self.saf_prot_rd4())
                    .field("saf_prot_rd5", &self.saf_prot_rd5())
                    .field("saf_prot_rd6", &self.saf_prot_rd6())
                    .field("saf_prot_rd7", &self.saf_prot_rd7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Read {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Read {{ saf_prot_rd0: {=bool:?}, saf_prot_rd1: {=bool:?}, saf_prot_rd2: {=bool:?}, saf_prot_rd3: {=bool:?}, saf_prot_rd4: {=bool:?}, saf_prot_rd5: {=bool:?}, saf_prot_rd6: {=bool:?}, saf_prot_rd7: {=bool:?} }}" , self . saf_prot_rd0 () , self . saf_prot_rd1 () , self . saf_prot_rd2 () , self . saf_prot_rd3 () , self . saf_prot_rd4 () , self . saf_prot_rd5 () , self . saf_prot_rd6 () , self . saf_prot_rd7 ())
            }
        }
        #[doc = "This is Start00 register. Unless the Start register is less than or equal to the Limit register, the associated register set \\[RR\\] is Disabled, and has no effect on permissions. The default state of these registers, in all of the register sets, is this Disabled state. While all register sets remain Disabled, no Protection Master except Master #0 (PCH HW) will be able to perform any Flash access anywhere through SAFS operations, and this restriction includes the EC firmware (as Master #5)."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Start(pub u32);
        impl Start {
            #[doc = "This field contains the start address of this Region, in units of 4K bytes."]
            #[inline(always)]
            pub const fn saf_prot(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "This field contains the start address of this Region, in units of 4K bytes."]
            #[inline(always)]
            pub fn set_saf_prot(&mut self, val: u32) {
                self.0 = (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
        }
        impl Default for Start {
            #[inline(always)]
            fn default() -> Start {
                Start(0)
            }
        }
        impl core::fmt::Debug for Start {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Start").field("saf_prot", &self.saf_prot()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Start {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Start {{ saf_prot: {=u32:?} }}", self.saf_prot())
            }
        }
        #[doc = "This register provides a time delay for support of some Flash devices. It holds off the first Poll-1 check after a Suspend command has been given to the Flash."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SuspCheckDly(pub u32);
        impl SuspCheckDly {
            #[doc = "This field provides a delay value in units of the EC internal clock MCLK. This value should be set to 20us."]
            #[inline(always)]
            pub const fn dly(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "This field provides a delay value in units of the EC internal clock MCLK. This value should be set to 20us."]
            #[inline(always)]
            pub fn set_dly(&mut self, val: u32) {
                self.0 = (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
        }
        impl Default for SuspCheckDly {
            #[inline(always)]
            fn default() -> SuspCheckDly {
                SuspCheckDly(0)
            }
        }
        impl core::fmt::Debug for SuspCheckDly {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SuspCheckDly").field("dly", &self.dly()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SuspCheckDly {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SuspCheckDly {{ dly: {=u32:?} }}", self.dly())
            }
        }
        #[doc = "The value placed in this register provides necessary programmable support to a Flash that is performing an Erase or a Program operation. When an Erase or Program is started or Resumed, a Suspend is held off until this time expires. While an Erase or Program is in process but Suspended, a Resume is forced when this time expires, even if Read requests are still pending, causing the Erase or Program operation to continue, and again inhibiting the next Suspend until it expires again."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SuspResIntrvl(pub u32);
        impl SuspResIntrvl {
            #[doc = "This field provides an interval value in units of the 32KHz RTC clock. Its value should be taken from the Flash datasheet parameter that specifies minimum time for an Erase or Program step to make progress."]
            #[inline(always)]
            pub const fn intrvl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This field provides an interval value in units of the 32KHz RTC clock. Its value should be taken from the Flash datasheet parameter that specifies minimum time for an Erase or Program step to make progress."]
            #[inline(always)]
            pub fn set_intrvl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for SuspResIntrvl {
            #[inline(always)]
            fn default() -> SuspResIntrvl {
                SuspResIntrvl(0)
            }
        }
        impl core::fmt::Debug for SuspResIntrvl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SuspResIntrvl").field("intrvl", &self.intrvl()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SuspResIntrvl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SuspResIntrvl {{ intrvl: {=u16:?} }}", self.intrvl())
            }
        }
        #[doc = "The default values in this register match hard-wired assignments made in the Chipset for eSPI Tag values 0h through 7h. A default value of 7 indicates a non-existent map entry, for a Tag value which should never happen."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TagMap0(pub u32);
        impl TagMap0 {
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 0h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 0h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 1h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_1(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 1h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 2h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 2h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 3h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_3(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 3h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 12usize)) | (((val as u32) & 0x07) << 12usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 4h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_4(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 4h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 5h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_5(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 5h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 6h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_6(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 6h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 24usize)) | (((val as u32) & 0x07) << 24usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 7h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_7(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 7h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 28usize)) | (((val as u32) & 0x07) << 28usize);
            }
        }
        impl Default for TagMap0 {
            #[inline(always)]
            fn default() -> TagMap0 {
                TagMap0(0)
            }
        }
        impl core::fmt::Debug for TagMap0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TagMap0")
                    .field("stm_0", &self.stm_0())
                    .field("stm_1", &self.stm_1())
                    .field("stm_2", &self.stm_2())
                    .field("stm_3", &self.stm_3())
                    .field("stm_4", &self.stm_4())
                    .field("stm_5", &self.stm_5())
                    .field("stm_6", &self.stm_6())
                    .field("stm_7", &self.stm_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TagMap0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "TagMap0 {{ stm_0: {=u8:?}, stm_1: {=u8:?}, stm_2: {=u8:?}, stm_3: {=u8:?}, stm_4: {=u8:?}, stm_5: {=u8:?}, stm_6: {=u8:?}, stm_7: {=u8:?} }}" , self . stm_0 () , self . stm_1 () , self . stm_2 () , self . stm_3 () , self . stm_4 () , self . stm_5 () , self . stm_6 () , self . stm_7 ())
            }
        }
        #[doc = "The default values in this register match hard-wired assignments made in the Chipset for eSPI Tag values 8h through Fh. A default value of 7 indicates a non-existent map entry, for a Tag value which should never happen."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TagMap1(pub u32);
        impl TagMap1 {
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 8h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_8(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 8h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_8(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 9h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_9(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value 9h to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_9(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Ah to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_a(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Ah to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_a(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Bh to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_b(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Bh to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_b(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 12usize)) | (((val as u32) & 0x07) << 12usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Ch to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_c(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Ch to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_c(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Dh to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_d(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Dh to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_d(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Eh to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_e(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Eh to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_e(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 24usize)) | (((val as u32) & 0x07) << 24usize);
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Fh to its 3-bit Protection Master number."]
            #[inline(always)]
            pub const fn stm_f(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x07;
                val as u8
            }
            #[doc = "This bit contains the mapping of the 4-bit eSPI Tag value Fh to its 3-bit Protection Master number."]
            #[inline(always)]
            pub fn set_stm_f(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 28usize)) | (((val as u32) & 0x07) << 28usize);
            }
        }
        impl Default for TagMap1 {
            #[inline(always)]
            fn default() -> TagMap1 {
                TagMap1(0)
            }
        }
        impl core::fmt::Debug for TagMap1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TagMap1")
                    .field("stm_8", &self.stm_8())
                    .field("stm_9", &self.stm_9())
                    .field("stm_a", &self.stm_a())
                    .field("stm_b", &self.stm_b())
                    .field("stm_c", &self.stm_c())
                    .field("stm_d", &self.stm_d())
                    .field("stm_e", &self.stm_e())
                    .field("stm_f", &self.stm_f())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TagMap1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "TagMap1 {{ stm_8: {=u8:?}, stm_9: {=u8:?}, stm_a: {=u8:?}, stm_b: {=u8:?}, stm_c: {=u8:?}, stm_d: {=u8:?}, stm_e: {=u8:?}, stm_f: {=u8:?} }}" , self . stm_8 () , self . stm_9 () , self . stm_a () , self . stm_b () , self . stm_c () , self . stm_d () , self . stm_e () , self . stm_f ())
            }
        }
        #[doc = "The default value in bits \\[2:0\\] of this register matches the hard-wired assignment made in the Chipset for accesses made by an EC. After ensuring that all three Tag Map Registers \\[2:0\\] contain valid mappings, the STM_LK bit should be set to '1' to lock them, preventing firmware from re-assigning them later."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TagMap2(pub u32);
        impl TagMap2 {
            #[doc = "This bit maps the 3-bit Protection Master number assigned to EC Firmware accesses."]
            #[inline(always)]
            pub const fn sm_ec(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "This bit maps the 3-bit Protection Master number assigned to EC Firmware accesses."]
            #[inline(always)]
            pub fn set_sm_ec(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "1 Locks all bits in the Tag Map Registers, including this bit. 0 (Default) keeps all Tag Map Register fields R/W."]
            #[inline(always)]
            pub const fn stm_lk(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "1 Locks all bits in the Tag Map Registers, including this bit. 0 (Default) keeps all Tag Map Register fields R/W."]
            #[inline(always)]
            pub fn set_stm_lk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for TagMap2 {
            #[inline(always)]
            fn default() -> TagMap2 {
                TagMap2(0)
            }
        }
        impl core::fmt::Debug for TagMap2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TagMap2")
                    .field("sm_ec", &self.sm_ec())
                    .field("stm_lk", &self.stm_lk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TagMap2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TagMap2 {{ sm_ec: {=u8:?}, stm_lk: {=bool:?} }}",
                    self.sm_ec(),
                    self.stm_lk()
                )
            }
        }
        #[doc = "This is Write00 register. It applies to the region defined by the associated \\[RR\\] Start and Limit registers. Bits at positions \\[0\\]--\\[7\\] grant Write/Erase permission to Permission Masters numbered 0--7 respectively."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Write(pub u32);
        impl Write {
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 0 to this Region. It is a read-only '1' placeholder because Protection Master 0 has full access to all Flash locations. 1=Protection Master 0 may always Write and Erase in this region."]
            #[inline(always)]
            pub const fn saf_prot_wr0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 0 to this Region. It is a read-only '1' placeholder because Protection Master 0 has full access to all Flash locations. 1=Protection Master 0 may always Write and Erase in this region."]
            #[inline(always)]
            pub fn set_saf_prot_wr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 1 to this Region. 0=Protection Master 1 may not Write or Erase in this region. 1=Protection Master 1 may Write and Erase in this region."]
            #[inline(always)]
            pub const fn saf_prot_wr1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 1 to this Region. 0=Protection Master 1 may not Write or Erase in this region. 1=Protection Master 1 may Write and Erase in this region."]
            #[inline(always)]
            pub fn set_saf_prot_wr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 2 to this Region. 0=Protection Master 2 may not Write or Erase in this region. 1=Protection Master 2 may Write and Erase in this region."]
            #[inline(always)]
            pub const fn saf_prot_wr2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 2 to this Region. 0=Protection Master 2 may not Write or Erase in this region. 1=Protection Master 2 may Write and Erase in this region."]
            #[inline(always)]
            pub fn set_saf_prot_wr2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 3 to this Region. 0=Protection Master 3 may not Write or Erase in this region. 1=Protection Master 3 may Write and Erase in this region."]
            #[inline(always)]
            pub const fn saf_prot_wr3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 3 to this Region. 0=Protection Master 3 may not Write or Erase in this region. 1=Protection Master 3 may Write and Erase in this region."]
            #[inline(always)]
            pub fn set_saf_prot_wr3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 4 to this Region. 0=Protection Master 4 may not Write or Erase in this region. 1=Protection Master 4 may Write and Erase in this region."]
            #[inline(always)]
            pub const fn saf_prot_wr4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 4 to this Region. 0=Protection Master 4 may not Write or Erase in this region. 1=Protection Master 4 may Write and Erase in this region."]
            #[inline(always)]
            pub fn set_saf_prot_wr4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 5 to this Region. 0=Protection Master 5 may not Write or Erase in this region. 1=Protection Master 5 may Write and Erase in this region."]
            #[inline(always)]
            pub const fn saf_prot_wr5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 5 to this Region. 0=Protection Master 5 may not Write or Erase in this region. 1=Protection Master 5 may Write and Erase in this region."]
            #[inline(always)]
            pub fn set_saf_prot_wr5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 6 to this Region. 0=Protection Master 6 may not Write or Erase in this region. 1=Protection Master 6 may Write and Erase in this region."]
            #[inline(always)]
            pub const fn saf_prot_wr6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 6 to this Region. 0=Protection Master 6 may not Write or Erase in this region. 1=Protection Master 6 may Write and Erase in this region."]
            #[inline(always)]
            pub fn set_saf_prot_wr6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 7 to this Region. 0=Protection Master 7 may not Write or Erase in this region. 1=Protection Master 7 may Write and Erase in this region."]
            #[inline(always)]
            pub const fn saf_prot_wr7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit contains the permission for Write or Erase access by Protection Master 7 to this Region. 0=Protection Master 7 may not Write or Erase in this region. 1=Protection Master 7 may Write and Erase in this region."]
            #[inline(always)]
            pub fn set_saf_prot_wr7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Write {
            #[inline(always)]
            fn default() -> Write {
                Write(0)
            }
        }
        impl core::fmt::Debug for Write {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Write")
                    .field("saf_prot_wr0", &self.saf_prot_wr0())
                    .field("saf_prot_wr1", &self.saf_prot_wr1())
                    .field("saf_prot_wr2", &self.saf_prot_wr2())
                    .field("saf_prot_wr3", &self.saf_prot_wr3())
                    .field("saf_prot_wr4", &self.saf_prot_wr4())
                    .field("saf_prot_wr5", &self.saf_prot_wr5())
                    .field("saf_prot_wr6", &self.saf_prot_wr6())
                    .field("saf_prot_wr7", &self.saf_prot_wr7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Write {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Write {{ saf_prot_wr0: {=bool:?}, saf_prot_wr1: {=bool:?}, saf_prot_wr2: {=bool:?}, saf_prot_wr3: {=bool:?}, saf_prot_wr4: {=bool:?}, saf_prot_wr5: {=bool:?}, saf_prot_wr6: {=bool:?}, saf_prot_wr7: {=bool:?} }}" , self . saf_prot_wr0 () , self . saf_prot_wr1 () , self . saf_prot_wr2 () , self . saf_prot_wr3 () , self . saf_prot_wr4 () , self . saf_prot_wr5 () , self . saf_prot_wr6 () , self . saf_prot_wr7 ())
            }
        }
    }
}
pub mod safcomm {
    #[doc = "This register contains one bit PREFETCH_EN that should be set to '1' during initialization, to enable Prefetch Mode operation in SAFS Mode. Prefetch Mode allows overlapped anticipatory reading of information from Flash during the eSPI delivery of previously-read data to the Host Chipset. If enabled, Prefetching is invoked during consecutive Reads that are 64 bytes in length and from consecutive 64-byte aligned Flash addresses. With roughly equal clock rates on eSPI and SPI, these features together can approximately double the effective bandwidth of consecutive Flash reads performed over eSPI. In SAFS operation (SAF_MODE_ENABLE bit = 1) attempted accesses by EC firmware to this register are blocked."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Safcomm {
        ptr: *mut u8,
    }
    unsafe impl Send for Safcomm {}
    unsafe impl Sync for Safcomm {}
    impl Safcomm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This register contains one bit PREFETCH_EN that should be set to '1' during initialization, to enable Prefetch Mode operation in SAFS Mode."]
        #[inline(always)]
        pub const fn saf_mode(self) -> crate::common::Reg<regs::SafMode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02b8usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This register contains one bit PREFETCH_EN that should be set to '1' during initialization, to enable Prefetch Mode operation in SAFS Mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SafMode(pub u32);
        impl SafMode {
            #[doc = "1= Allow Prefetching from Flash devices, and use the bits CS0_PREFETCH_OPT_EN and CS1_PREFETCH_OPT_EN to select any additional optimization. 0= Do not perform Prefetches from Flash devices"]
            #[inline(always)]
            pub const fn prefetch_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1= Allow Prefetching from Flash devices, and use the bits CS0_PREFETCH_OPT_EN and CS1_PREFETCH_OPT_EN to select any additional optimization. 0= Do not perform Prefetches from Flash devices"]
            #[inline(always)]
            pub fn set_prefetch_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SafMode {
            #[inline(always)]
            fn default() -> SafMode {
                SafMode(0)
            }
        }
        impl core::fmt::Debug for SafMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SafMode")
                    .field("prefetch_en", &self.prefetch_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SafMode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SafMode {{ prefetch_en: {=bool:?} }}", self.prefetch_en())
            }
        }
    }
}
pub mod smb0 {
    #[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Smb0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Smb0 {}
    unsafe impl Sync for Smb0 {}
    impl Smb0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Status Register"]
        #[inline(always)]
        pub const fn rsts(self) -> crate::common::Reg<regs::Rsts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Control Register"]
        #[inline(always)]
        pub const fn wctrl(self) -> crate::common::Reg<regs::Wctrl, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Own Address Register Note that the Data Register and Own Address fields are offset by one bit, so that programming Own Address 1 with a value of 55h will result in the value AAh being recognized as the SMB Controller Core slave address."]
        #[inline(always)]
        pub const fn own_addr(self) -> crate::common::Reg<regs::OwnAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This register holds the data that are either shifted out to or shifted in from the I2C port."]
        #[inline(always)]
        pub const fn i2cdata(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Reserved"]
        #[inline(always)]
        pub const fn rsvd1(self, n: usize) -> crate::common::Reg<u8, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize + n * 1usize) as _) }
        }
        #[doc = "SMBus Master Command Register"]
        #[inline(always)]
        pub const fn mcmd(self) -> crate::common::Reg<regs::Mcmd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SMBus Slave Command Register"]
        #[inline(always)]
        pub const fn scmd(self) -> crate::common::Reg<regs::Scmd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Packet Error Check (PEC) Register"]
        #[inline(always)]
        pub const fn pec(self) -> crate::common::Reg<regs::Pec, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Repeated Start Hold Time Register"]
        #[inline(always)]
        pub const fn rshtm(self) -> crate::common::Reg<regs::Rshtm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Extended Length Register"]
        #[inline(always)]
        pub const fn extnd_len(self) -> crate::common::Reg<regs::ExtndLen, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Completion Register"]
        #[inline(always)]
        pub const fn compl(self) -> crate::common::Reg<regs::Compl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Idle Scaling Register"]
        #[inline(always)]
        pub const fn idlsc(self) -> crate::common::Reg<regs::Idlsc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Configuration Register"]
        #[inline(always)]
        pub const fn cfg(self) -> crate::common::Reg<regs::Cfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Bus Clock Register"]
        #[inline(always)]
        pub const fn busclk(self) -> crate::common::Reg<regs::Busclk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Block ID Register"]
        #[inline(always)]
        pub const fn blkid(self) -> crate::common::Reg<regs::Blkid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Revision Register"]
        #[inline(always)]
        pub const fn blkrev(self) -> crate::common::Reg<regs::Blkrev, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Bit-Bang Control Register"]
        #[inline(always)]
        pub const fn bbctrl(self) -> crate::common::Reg<regs::Bbctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Test"]
        #[inline(always)]
        pub const fn test(self) -> crate::common::Reg<regs::Test, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Data Timing Register"]
        #[inline(always)]
        pub const fn datatm(self) -> crate::common::Reg<regs::Datatm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Time-Out Scaling Register"]
        #[inline(always)]
        pub const fn tmoutsc(self) -> crate::common::Reg<regs::Tmoutsc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "SMBus Slave Transmit Buffer Register"]
        #[inline(always)]
        pub const fn slv_txb(self) -> crate::common::Reg<regs::SlvTxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "SMBus Slave Receive Buffer Register"]
        #[inline(always)]
        pub const fn slv_rxb(self) -> crate::common::Reg<regs::SlvRxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "SMBus Master Transmit Buffer Register"]
        #[inline(always)]
        pub const fn mtr_txb(self) -> crate::common::Reg<regs::MtrTxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "SMBus Master Receive Buffer Register"]
        #[inline(always)]
        pub const fn mtr_rxb(self) -> crate::common::Reg<regs::MtrRxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "WAKE STATUS Register"]
        #[inline(always)]
        pub const fn wake_sts(self) -> crate::common::Reg<regs::WakeSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "WAKE ENABLE Register"]
        #[inline(always)]
        pub const fn wake_en(self) -> crate::common::Reg<regs::WakeEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "This is the Slave Address Register"]
        #[inline(always)]
        pub const fn slv_addr(self) -> crate::common::Reg<regs::SlvAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6cusize) as _) }
        }
        #[doc = "This is the Promiscuous Interrupt Register"]
        #[inline(always)]
        pub const fn prm_sts(self) -> crate::common::Reg<regs::PrmSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "This is the Promiscuous Interrupt Enable Register"]
        #[inline(always)]
        pub const fn prm_ien(self) -> crate::common::Reg<regs::PrmIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "This is the Promiscuous Control Register"]
        #[inline(always)]
        pub const fn prm_ctrl(self) -> crate::common::Reg<regs::PrmCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "This is the I2C Shadow Data Register"]
        #[inline(always)]
        pub const fn shdw_data(self) -> crate::common::Reg<regs::ShdwData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Bit-Bang Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bbctrl(pub u32);
        impl Bbctrl {
            #[doc = "Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled"]
            #[inline(always)]
            pub const fn bben(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled"]
            #[inline(always)]
            pub fn set_bben(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output"]
            #[inline(always)]
            pub const fn cldir(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output"]
            #[inline(always)]
            pub fn set_cldir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output"]
            #[inline(always)]
            pub const fn dadir(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output"]
            #[inline(always)]
            pub fn set_dadir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'"]
            #[inline(always)]
            pub const fn bbclk(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'"]
            #[inline(always)]
            pub fn set_bbclk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'"]
            #[inline(always)]
            pub const fn bbdat(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'"]
            #[inline(always)]
            pub fn set_bbdat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK."]
            #[inline(always)]
            pub const fn bbclki(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK."]
            #[inline(always)]
            pub fn set_bbclki(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Bit-Bang Data In. The BBDATI bit always returns the state of SDAT"]
            #[inline(always)]
            pub const fn bbdati(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Data In. The BBDATI bit always returns the state of SDAT"]
            #[inline(always)]
            pub fn set_bbdati(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Bbctrl {
            #[inline(always)]
            fn default() -> Bbctrl {
                Bbctrl(0)
            }
        }
        impl core::fmt::Debug for Bbctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bbctrl")
                    .field("bben", &self.bben())
                    .field("cldir", &self.cldir())
                    .field("dadir", &self.dadir())
                    .field("bbclk", &self.bbclk())
                    .field("bbdat", &self.bbdat())
                    .field("bbclki", &self.bbclki())
                    .field("bbdati", &self.bbdati())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bbctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bbctrl {{ bben: {=bool:?}, cldir: {=bool:?}, dadir: {=bool:?}, bbclk: {=bool:?}, bbdat: {=bool:?}, bbclki: {=bool:?}, bbdati: {=bool:?} }}" , self . bben () , self . cldir () , self . dadir () , self . bbclk () , self . bbdat () , self . bbclki () , self . bbdati ())
            }
        }
        #[doc = "Block ID Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Blkid(pub u8);
        impl Blkid {
            #[doc = "Block ID."]
            #[inline(always)]
            pub const fn id(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Block ID."]
            #[inline(always)]
            pub fn set_id(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Blkid {
            #[inline(always)]
            fn default() -> Blkid {
                Blkid(0)
            }
        }
        impl core::fmt::Debug for Blkid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Blkid").field("id", &self.id()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Blkid {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Blkid {{ id: {=u8:?} }}", self.id())
            }
        }
        #[doc = "Revision Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Blkrev(pub u8);
        impl Blkrev {
            #[doc = "Block Revision Number"]
            #[inline(always)]
            pub const fn rev(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Block Revision Number"]
            #[inline(always)]
            pub fn set_rev(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Blkrev {
            #[inline(always)]
            fn default() -> Blkrev {
                Blkrev(0)
            }
        }
        impl core::fmt::Debug for Blkrev {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Blkrev").field("rev", &self.rev()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Blkrev {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Blkrev {{ rev: {=u8:?} }}", self.rev())
            }
        }
        #[doc = "Bus Clock Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busclk(pub u32);
        impl Busclk {
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub const fn low_per(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub fn set_low_per(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub const fn high_per(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub fn set_high_per(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Busclk {
            #[inline(always)]
            fn default() -> Busclk {
                Busclk(0)
            }
        }
        impl core::fmt::Debug for Busclk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busclk")
                    .field("low_per", &self.low_per())
                    .field("high_per", &self.high_per())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busclk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Busclk {{ low_per: {=u8:?}, high_per: {=u8:?} }}",
                    self.low_per(),
                    self.high_per()
                )
            }
        }
        #[doc = "Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfg(pub u32);
        impl Cfg {
            #[doc = "The PORT SEL \\[3:0\\] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."]
            #[inline(always)]
            pub const fn port_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The PORT SEL \\[3:0\\] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."]
            #[inline(always)]
            pub fn set_port_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"]
            #[inline(always)]
            pub const fn tcen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"]
            #[inline(always)]
            pub fn set_tcen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."]
            #[inline(always)]
            pub const fn slow_clk(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."]
            #[inline(always)]
            pub fn set_slow_clk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"]
            #[inline(always)]
            pub const fn pecen(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"]
            #[inline(always)]
            pub fn set_pecen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available. 1=Input filtering is enabled; 0=Input filtering is disabled."]
            #[inline(always)]
            pub const fn fen(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available. 1=Input filtering is enabled; 0=Input filtering is disabled."]
            #[inline(always)]
            pub fn set_fen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State). The ENAB bit must be asserted ('1') for normal operation."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State). The ENAB bit must be asserted ('1') for normal operation."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"]
            #[inline(always)]
            pub const fn dsa(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"]
            #[inline(always)]
            pub fn set_dsa(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "If this bit is 1, the MCTP Fairness protocol is in effect."]
            #[inline(always)]
            pub const fn fair(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the MCTP Fairness protocol is in effect."]
            #[inline(always)]
            pub fn set_fair(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub const fn test0(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub fn set_test0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "This is the General Call Disable bit. 0: the response to the General Call address as a slave is enabled 1: the response to the General Call address as a slave is disabled."]
            #[inline(always)]
            pub const fn gc_dis(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "This is the General Call Disable bit. 0: the response to the General Call address as a slave is enabled 1: the response to the General Call address as a slave is disabled."]
            #[inline(always)]
            pub fn set_gc_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "This bit define the Mode of SM Bus Controler Mode of operation. 0= Normal Operation. 1= Promiscuous Mode Enable."]
            #[inline(always)]
            pub const fn cfg_promis(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "This bit define the Mode of SM Bus Controler Mode of operation. 0= Normal Operation. 1= Promiscuous Mode Enable."]
            #[inline(always)]
            pub fn set_cfg_promis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_sxbuf(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_sxbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_srbuf(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_srbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_mxbuf(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_mxbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_mrbuf(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_mrbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "0: Disable the AAS, 1: Enable the AAS Interrupt"]
            #[inline(always)]
            pub const fn en_aas(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "0: Disable the AAS, 1: Enable the AAS Interrupt"]
            #[inline(always)]
            pub fn set_en_aas(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."]
            #[inline(always)]
            pub const fn enidi(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."]
            #[inline(always)]
            pub fn set_enidi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."]
            #[inline(always)]
            pub const fn enmi(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."]
            #[inline(always)]
            pub fn set_enmi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"]
            #[inline(always)]
            pub const fn ensi(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"]
            #[inline(always)]
            pub fn set_ensi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Cfg {
            #[inline(always)]
            fn default() -> Cfg {
                Cfg(0)
            }
        }
        impl core::fmt::Debug for Cfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfg")
                    .field("port_sel", &self.port_sel())
                    .field("tcen", &self.tcen())
                    .field("slow_clk", &self.slow_clk())
                    .field("test", &self.test())
                    .field("pecen", &self.pecen())
                    .field("fen", &self.fen())
                    .field("rst", &self.rst())
                    .field("en", &self.en())
                    .field("dsa", &self.dsa())
                    .field("fair", &self.fair())
                    .field("test0", &self.test0())
                    .field("gc_dis", &self.gc_dis())
                    .field("cfg_promis", &self.cfg_promis())
                    .field("flush_sxbuf", &self.flush_sxbuf())
                    .field("flush_srbuf", &self.flush_srbuf())
                    .field("flush_mxbuf", &self.flush_mxbuf())
                    .field("flush_mrbuf", &self.flush_mrbuf())
                    .field("en_aas", &self.en_aas())
                    .field("enidi", &self.enidi())
                    .field("enmi", &self.enmi())
                    .field("ensi", &self.ensi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cfg {{ port_sel: {=u8:?}, tcen: {=bool:?}, slow_clk: {=bool:?}, test: {=bool:?}, pecen: {=bool:?}, fen: {=bool:?}, rst: {=bool:?}, en: {=bool:?}, dsa: {=bool:?}, fair: {=bool:?}, test0: {=bool:?}, gc_dis: {=bool:?}, cfg_promis: {=bool:?}, flush_sxbuf: {=bool:?}, flush_srbuf: {=bool:?}, flush_mxbuf: {=bool:?}, flush_mrbuf: {=bool:?}, en_aas: {=bool:?}, enidi: {=bool:?}, enmi: {=bool:?}, ensi: {=bool:?} }}" , self . port_sel () , self . tcen () , self . slow_clk () , self . test () , self . pecen () , self . fen () , self . rst () , self . en () , self . dsa () , self . fair () , self . test0 () , self . gc_dis () , self . cfg_promis () , self . flush_sxbuf () , self . flush_srbuf () , self . flush_mxbuf () , self . flush_mrbuf () , self . en_aas () , self . enidi () , self . enmi () , self . ensi ())
            }
        }
        #[doc = "Completion Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Compl(pub u32);
        impl Compl {
            #[doc = "When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."]
            #[inline(always)]
            pub const fn dten(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."]
            #[inline(always)]
            pub fn set_dten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn mcen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_mcen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn scen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_scen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn biden(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_biden(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."]
            #[inline(always)]
            pub const fn timerr(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."]
            #[inline(always)]
            pub fn set_timerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "DTO is the Device Time-out bit. (R/WC)"]
            #[inline(always)]
            pub const fn dto(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "DTO is the Device Time-out bit. (R/WC)"]
            #[inline(always)]
            pub fn set_dto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "MCTO is the Master Cumulative Time-out bit. (R/WC)"]
            #[inline(always)]
            pub const fn mcto(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "MCTO is the Master Cumulative Time-out bit. (R/WC)"]
            #[inline(always)]
            pub fn set_mcto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SCTO is the Slave Cumulative Time-out bit(R/WC)"]
            #[inline(always)]
            pub const fn scto(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SCTO is the Slave Cumulative Time-out bit(R/WC)"]
            #[inline(always)]
            pub fn set_scto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "CHDL is the clock high time-out detect bit(R/WC)"]
            #[inline(always)]
            pub const fn chdl(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "CHDL is the clock high time-out detect bit(R/WC)"]
            #[inline(always)]
            pub fn set_chdl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "CHDH is the bus idle time-out detect bit(R/WC)"]
            #[inline(always)]
            pub const fn chdh(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "CHDH is the bus idle time-out detect bit(R/WC)"]
            #[inline(always)]
            pub fn set_chdh(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub const fn ber(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub fn set_ber(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub const fn lab(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub fn set_lab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."]
            #[inline(always)]
            pub const fn snakr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."]
            #[inline(always)]
            pub fn set_snakr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "0: Slave has just finished the receive phase of a transaction. 1: Slave has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub const fn str(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "0: Slave has just finished the receive phase of a transaction. 1: Slave has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub fn set_str(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "If this bit is 1, the WriteCount\\[7:0\\] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."]
            #[inline(always)]
            pub const fn sprot(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the WriteCount\\[7:0\\] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."]
            #[inline(always)]
            pub fn set_sprot(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."]
            #[inline(always)]
            pub const fn rep_rd(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."]
            #[inline(always)]
            pub fn set_rep_rd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."]
            #[inline(always)]
            pub const fn rep_wr(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."]
            #[inline(always)]
            pub fn set_rep_wr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"]
            #[inline(always)]
            pub const fn mnakx(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"]
            #[inline(always)]
            pub fn set_mnakx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "0: Master has just finished the receive phase of a transaction. 1: Master has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub const fn mtr(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "0: Master has just finished the receive phase of a transaction. 1: Master has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub fn set_mtr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"]
            #[inline(always)]
            pub const fn idle(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"]
            #[inline(always)]
            pub fn set_idle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn mdone(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_mdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"]
            #[inline(always)]
            pub const fn sdone(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"]
            #[inline(always)]
            pub fn set_sdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Compl {
            #[inline(always)]
            fn default() -> Compl {
                Compl(0)
            }
        }
        impl core::fmt::Debug for Compl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Compl")
                    .field("dten", &self.dten())
                    .field("mcen", &self.mcen())
                    .field("scen", &self.scen())
                    .field("biden", &self.biden())
                    .field("timerr", &self.timerr())
                    .field("dto", &self.dto())
                    .field("mcto", &self.mcto())
                    .field("scto", &self.scto())
                    .field("chdl", &self.chdl())
                    .field("chdh", &self.chdh())
                    .field("ber", &self.ber())
                    .field("lab", &self.lab())
                    .field("snakr", &self.snakr())
                    .field("str", &self.str())
                    .field("sprot", &self.sprot())
                    .field("rep_rd", &self.rep_rd())
                    .field("rep_wr", &self.rep_wr())
                    .field("mnakx", &self.mnakx())
                    .field("mtr", &self.mtr())
                    .field("idle", &self.idle())
                    .field("mdone", &self.mdone())
                    .field("sdone", &self.sdone())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Compl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Compl {{ dten: {=bool:?}, mcen: {=bool:?}, scen: {=bool:?}, biden: {=bool:?}, timerr: {=bool:?}, dto: {=bool:?}, mcto: {=bool:?}, scto: {=bool:?}, chdl: {=bool:?}, chdh: {=bool:?}, ber: {=bool:?}, lab: {=bool:?}, snakr: {=bool:?}, str: {=bool:?}, sprot: {=bool:?}, rep_rd: {=bool:?}, rep_wr: {=bool:?}, mnakx: {=bool:?}, mtr: {=bool:?}, idle: {=bool:?}, mdone: {=bool:?}, sdone: {=bool:?} }}" , self . dten () , self . mcen () , self . scen () , self . biden () , self . timerr () , self . dto () , self . mcto () , self . scto () , self . chdl () , self . chdh () , self . ber () , self . lab () , self . snakr () , self . str () , self . sprot () , self . rep_rd () , self . rep_wr () , self . mnakx () , self . mtr () , self . idle () , self . mdone () , self . sdone ())
            }
        }
        #[doc = "Data Timing Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Datatm(pub u32);
        impl Datatm {
            #[doc = "The Data Hold \\[7:0\\] timer determines the SDAT hold time following SCLK driven low."]
            #[inline(always)]
            pub const fn data_hold(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Data Hold \\[7:0\\] timer determines the SDAT hold time following SCLK driven low."]
            #[inline(always)]
            pub fn set_data_hold(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "The Restart Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition."]
            #[inline(always)]
            pub const fn restart_setup(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "The Restart Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition."]
            #[inline(always)]
            pub fn set_restart_setup(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "The Stop Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition."]
            #[inline(always)]
            pub const fn stop_setup(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "The Stop Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition."]
            #[inline(always)]
            pub fn set_stop_setup(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register."]
            #[inline(always)]
            pub const fn first_start_hold(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register."]
            #[inline(always)]
            pub fn set_first_start_hold(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Datatm {
            #[inline(always)]
            fn default() -> Datatm {
                Datatm(0)
            }
        }
        impl core::fmt::Debug for Datatm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Datatm")
                    .field("data_hold", &self.data_hold())
                    .field("restart_setup", &self.restart_setup())
                    .field("stop_setup", &self.stop_setup())
                    .field("first_start_hold", &self.first_start_hold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Datatm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Datatm {{ data_hold: {=u8:?}, restart_setup: {=u8:?}, stop_setup: {=u8:?}, first_start_hold: {=u8:?} }}" , self . data_hold () , self . restart_setup () , self . stop_setup () , self . first_start_hold ())
            }
        }
        #[doc = "Extended Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ExtndLen(pub u32);
        impl ExtndLen {
            #[doc = "Extended Length Register adds 8 MSB bits to the SMBUS Master/Slave Tx/Rx Length fields."]
            #[inline(always)]
            pub const fn extnd_len(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Extended Length Register adds 8 MSB bits to the SMBUS Master/Slave Tx/Rx Length fields."]
            #[inline(always)]
            pub fn set_extnd_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for ExtndLen {
            #[inline(always)]
            fn default() -> ExtndLen {
                ExtndLen(0)
            }
        }
        impl core::fmt::Debug for ExtndLen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ExtndLen")
                    .field("extnd_len", &self.extnd_len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtndLen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ExtndLen {{ extnd_len: {=u8:?} }}", self.extnd_len())
            }
        }
        #[doc = "Idle Scaling Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Idlsc(pub u32);
        impl Idlsc {
            #[doc = "This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub const fn fair_bus_idl_min(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub fn set_fair_bus_idl_min(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub const fn fair_idl_dly(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x0fff;
                val as u16
            }
            #[doc = "This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub fn set_fair_idl_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 16usize)) | (((val as u32) & 0x0fff) << 16usize);
            }
        }
        impl Default for Idlsc {
            #[inline(always)]
            fn default() -> Idlsc {
                Idlsc(0)
            }
        }
        impl core::fmt::Debug for Idlsc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Idlsc")
                    .field("fair_bus_idl_min", &self.fair_bus_idl_min())
                    .field("fair_idl_dly", &self.fair_idl_dly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Idlsc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Idlsc {{ fair_bus_idl_min: {=u16:?}, fair_idl_dly: {=u16:?} }}",
                    self.fair_bus_idl_min(),
                    self.fair_idl_dly()
                )
            }
        }
        #[doc = "SMBus Master Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mcmd(pub u32);
        impl Mcmd {
            #[doc = "While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."]
            #[inline(always)]
            pub const fn mrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."]
            #[inline(always)]
            pub fn set_mrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."]
            #[inline(always)]
            pub const fn mproceed(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."]
            #[inline(always)]
            pub fn set_mproceed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub const fn start0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub fn set_start0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub const fn startn(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub fn set_startn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "If this bit is 1, send a Stop bit after the transaction completes."]
            #[inline(always)]
            pub const fn stop(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Stop bit after the transaction completes."]
            #[inline(always)]
            pub fn set_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."]
            #[inline(always)]
            pub const fn pec_term(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."]
            #[inline(always)]
            pub fn set_pec_term(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount\\[7:0\\] is 1. After ReadCount\\[7:0\\] is updated, this bit is cleared to 0."]
            #[inline(always)]
            pub const fn readm(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount\\[7:0\\] is 1. After ReadCount\\[7:0\\] is updated, this bit is cleared to 0."]
            #[inline(always)]
            pub fn set_readm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."]
            #[inline(always)]
            pub const fn rd_pec(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."]
            #[inline(always)]
            pub fn set_rd_pec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."]
            #[inline(always)]
            pub const fn wr_cnt(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."]
            #[inline(always)]
            pub fn set_wr_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."]
            #[inline(always)]
            pub const fn rd_cnt(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."]
            #[inline(always)]
            pub fn set_rd_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Mcmd {
            #[inline(always)]
            fn default() -> Mcmd {
                Mcmd(0)
            }
        }
        impl core::fmt::Debug for Mcmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mcmd")
                    .field("mrun", &self.mrun())
                    .field("mproceed", &self.mproceed())
                    .field("start0", &self.start0())
                    .field("startn", &self.startn())
                    .field("stop", &self.stop())
                    .field("pec_term", &self.pec_term())
                    .field("readm", &self.readm())
                    .field("rd_pec", &self.rd_pec())
                    .field("wr_cnt", &self.wr_cnt())
                    .field("rd_cnt", &self.rd_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mcmd {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mcmd {{ mrun: {=bool:?}, mproceed: {=bool:?}, start0: {=bool:?}, startn: {=bool:?}, stop: {=bool:?}, pec_term: {=bool:?}, readm: {=bool:?}, rd_pec: {=bool:?}, wr_cnt: {=u8:?}, rd_cnt: {=u8:?} }}" , self . mrun () , self . mproceed () , self . start0 () , self . startn () , self . stop () , self . pec_term () , self . readm () , self . rd_pec () , self . wr_cnt () , self . rd_cnt ())
            }
        }
        #[doc = "SMBus Master Receive Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtrRxb(pub u32);
        impl MtrRxb {
            #[doc = "MASTER_RECEIVE_BUFFER"]
            #[inline(always)]
            pub const fn mrxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MASTER_RECEIVE_BUFFER"]
            #[inline(always)]
            pub fn set_mrxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for MtrRxb {
            #[inline(always)]
            fn default() -> MtrRxb {
                MtrRxb(0)
            }
        }
        impl core::fmt::Debug for MtrRxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtrRxb").field("mrxb", &self.mrxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtrRxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MtrRxb {{ mrxb: {=u8:?} }}", self.mrxb())
            }
        }
        #[doc = "SMBus Master Transmit Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtrTxb(pub u32);
        impl MtrTxb {
            #[doc = "MASTER_TRANSMIT_BUFFER"]
            #[inline(always)]
            pub const fn mtxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MASTER_TRANSMIT_BUFFER"]
            #[inline(always)]
            pub fn set_mtxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for MtrTxb {
            #[inline(always)]
            fn default() -> MtrTxb {
                MtrTxb(0)
            }
        }
        impl core::fmt::Debug for MtrTxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtrTxb").field("mtxb", &self.mtxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtrTxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MtrTxb {{ mtxb: {=u8:?} }}", self.mtxb())
            }
        }
        #[doc = "Own Address Register Note that the Data Register and Own Address fields are offset by one bit, so that programming Own Address 1 with a value of 55h will result in the value AAh being recognized as the SMB Controller Core slave address."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OwnAddr(pub u32);
        impl OwnAddr {
            #[doc = "The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub const fn addr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub fn set_addr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub const fn addr2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x7f;
                val as u8
            }
            #[doc = "The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub fn set_addr2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 8usize)) | (((val as u32) & 0x7f) << 8usize);
            }
        }
        impl Default for OwnAddr {
            #[inline(always)]
            fn default() -> OwnAddr {
                OwnAddr(0)
            }
        }
        impl core::fmt::Debug for OwnAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OwnAddr")
                    .field("addr1", &self.addr1())
                    .field("addr2", &self.addr2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OwnAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "OwnAddr {{ addr1: {=u8:?}, addr2: {=u8:?} }}",
                    self.addr1(),
                    self.addr2()
                )
            }
        }
        #[doc = "Packet Error Check (PEC) Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pec(pub u32);
        impl Pec {
            #[doc = "The SMBus Packet Error Check (PEC) byte."]
            #[inline(always)]
            pub const fn pec(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The SMBus Packet Error Check (PEC) byte."]
            #[inline(always)]
            pub fn set_pec(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Pec {
            #[inline(always)]
            fn default() -> Pec {
                Pec(0)
            }
        }
        impl core::fmt::Debug for Pec {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pec").field("pec", &self.pec()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pec {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pec {{ pec: {=u8:?} }}", self.pec())
            }
        }
        #[doc = "This is the Promiscuous Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PrmCtrl(pub u8);
        impl PrmCtrl {
            #[doc = "This is the Promiscuous ACK / NAK response register. 1= ACK. 0= NAK."]
            #[inline(always)]
            pub const fn ack_nak(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the Promiscuous ACK / NAK response register. 1= ACK. 0= NAK."]
            #[inline(always)]
            pub fn set_ack_nak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for PrmCtrl {
            #[inline(always)]
            fn default() -> PrmCtrl {
                PrmCtrl(0)
            }
        }
        impl core::fmt::Debug for PrmCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PrmCtrl").field("ack_nak", &self.ack_nak()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PrmCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PrmCtrl {{ ack_nak: {=bool:?} }}", self.ack_nak())
            }
        }
        #[doc = "This is the Promiscuous Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PrmIen(pub u8);
        impl PrmIen {
            #[doc = "This is the Promiscuous interrupt enable register. 1= Interrupt Enable. 0= Interrupt Disabled."]
            #[inline(always)]
            pub const fn addr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the Promiscuous interrupt enable register. 1= Interrupt Enable. 0= Interrupt Disabled."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for PrmIen {
            #[inline(always)]
            fn default() -> PrmIen {
                PrmIen(0)
            }
        }
        impl core::fmt::Debug for PrmIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PrmIen").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PrmIen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PrmIen {{ addr: {=bool:?} }}", self.addr())
            }
        }
        #[doc = "This is the Promiscuous Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PrmSts(pub u8);
        impl PrmSts {
            #[doc = "This is the Promiscuous Address Status interrupt and is set on the 8th clock of the I2C Address. This bit will hold the Clock line low till this register bit is cleared. This is Write 1 to clear. R/W1C."]
            #[inline(always)]
            pub const fn addr_intr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the Promiscuous Address Status interrupt and is set on the 8th clock of the I2C Address. This bit will hold the Clock line low till this register bit is cleared. This is Write 1 to clear. R/W1C."]
            #[inline(always)]
            pub fn set_addr_intr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for PrmSts {
            #[inline(always)]
            fn default() -> PrmSts {
                PrmSts(0)
            }
        }
        impl core::fmt::Debug for PrmSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PrmSts").field("addr_intr", &self.addr_intr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PrmSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PrmSts {{ addr_intr: {=bool:?} }}", self.addr_intr())
            }
        }
        #[doc = "Repeated Start Hold Time Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rshtm(pub u32);
        impl Rshtm {
            #[doc = "This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold the clock until the Hold Time for the repeated Start Bit has been satisfied."]
            #[inline(always)]
            pub const fn rshtm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold the clock until the Hold Time for the repeated Start Bit has been satisfied."]
            #[inline(always)]
            pub fn set_rshtm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Rshtm {
            #[inline(always)]
            fn default() -> Rshtm {
                Rshtm(0)
            }
        }
        impl core::fmt::Debug for Rshtm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rshtm").field("rshtm", &self.rshtm()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rshtm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rshtm {{ rshtm: {=u8:?} }}", self.rshtm())
            }
        }
        #[doc = "Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rsts(pub u32);
        impl Rsts {
            #[doc = "The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible."]
            #[inline(always)]
            pub const fn nbb(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible."]
            #[inline(always)]
            pub fn set_nbb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus"]
            #[inline(always)]
            pub const fn lab(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus"]
            #[inline(always)]
            pub fn set_lab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received"]
            #[inline(always)]
            pub const fn aas(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received"]
            #[inline(always)]
            pub fn set_aas(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "The Last Received Bit or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0'). When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus. When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave."]
            #[inline(always)]
            pub const fn lrb_ad0(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "The Last Received Bit or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0'). When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus. When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave."]
            #[inline(always)]
            pub fn set_lrb_ad0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected."]
            #[inline(always)]
            pub const fn ber(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected."]
            #[inline(always)]
            pub fn set_ber(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode."]
            #[inline(always)]
            pub const fn sts(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode."]
            #[inline(always)]
            pub fn set_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "SMBus Address Decoded (SAD)"]
            #[inline(always)]
            pub const fn sad(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "SMBus Address Decoded (SAD)"]
            #[inline(always)]
            pub fn set_sad(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Pending Interrupt bit"]
            #[inline(always)]
            pub const fn pin(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Pending Interrupt bit"]
            #[inline(always)]
            pub fn set_pin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Rsts {
            #[inline(always)]
            fn default() -> Rsts {
                Rsts(0)
            }
        }
        impl core::fmt::Debug for Rsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rsts")
                    .field("nbb", &self.nbb())
                    .field("lab", &self.lab())
                    .field("aas", &self.aas())
                    .field("lrb_ad0", &self.lrb_ad0())
                    .field("ber", &self.ber())
                    .field("sts", &self.sts())
                    .field("sad", &self.sad())
                    .field("pin", &self.pin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rsts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rsts {{ nbb: {=bool:?}, lab: {=bool:?}, aas: {=bool:?}, lrb_ad0: {=bool:?}, ber: {=bool:?}, sts: {=bool:?}, sad: {=bool:?}, pin: {=bool:?} }}" , self . nbb () , self . lab () , self . aas () , self . lrb_ad0 () , self . ber () , self . sts () , self . sad () , self . pin ())
            }
        }
        #[doc = "SMBus Slave Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scmd(pub u32);
        impl Scmd {
            #[doc = "Setting this bit to 1 enables the Slave State Machine to operate."]
            #[inline(always)]
            pub const fn srun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting this bit to 1 enables the Slave State Machine to operate."]
            #[inline(always)]
            pub fn set_srun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."]
            #[inline(always)]
            pub const fn sproceed(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."]
            #[inline(always)]
            pub fn set_sproceed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."]
            #[inline(always)]
            pub const fn pec(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."]
            #[inline(always)]
            pub fn set_pec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This field is set to the number of bytes software expects to send to the Master."]
            #[inline(always)]
            pub const fn wr_cnt(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field is set to the number of bytes software expects to send to the Master."]
            #[inline(always)]
            pub fn set_wr_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."]
            #[inline(always)]
            pub const fn rd_cnt(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."]
            #[inline(always)]
            pub fn set_rd_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for Scmd {
            #[inline(always)]
            fn default() -> Scmd {
                Scmd(0)
            }
        }
        impl core::fmt::Debug for Scmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scmd")
                    .field("srun", &self.srun())
                    .field("sproceed", &self.sproceed())
                    .field("pec", &self.pec())
                    .field("wr_cnt", &self.wr_cnt())
                    .field("rd_cnt", &self.rd_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Scmd {{ srun: {=bool:?}, sproceed: {=bool:?}, pec: {=bool:?}, wr_cnt: {=u8:?}, rd_cnt: {=u8:?} }}",
                    self.srun(),
                    self.sproceed(),
                    self.pec(),
                    self.wr_cnt(),
                    self.rd_cnt()
                )
            }
        }
        #[doc = "This is the I2C Shadow Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ShdwData(pub u8);
        impl ShdwData {
            #[doc = "This is the I2C Shadow Data Register"]
            #[inline(always)]
            pub const fn shdw_data(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This is the I2C Shadow Data Register"]
            #[inline(always)]
            pub fn set_shdw_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ShdwData {
            #[inline(always)]
            fn default() -> ShdwData {
                ShdwData(0)
            }
        }
        impl core::fmt::Debug for ShdwData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ShdwData")
                    .field("shdw_data", &self.shdw_data())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ShdwData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ShdwData {{ shdw_data: {=u8:?} }}", self.shdw_data())
            }
        }
        #[doc = "This is the Slave Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlvAddr(pub u8);
        impl SlvAddr {
            #[doc = "This register stores value of address + LSB direction after the 8th clock of the Address Byte."]
            #[inline(always)]
            pub const fn saddr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This register stores value of address + LSB direction after the 8th clock of the Address Byte."]
            #[inline(always)]
            pub fn set_saddr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for SlvAddr {
            #[inline(always)]
            fn default() -> SlvAddr {
                SlvAddr(0)
            }
        }
        impl core::fmt::Debug for SlvAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlvAddr").field("saddr", &self.saddr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlvAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SlvAddr {{ saddr: {=u8:?} }}", self.saddr())
            }
        }
        #[doc = "SMBus Slave Receive Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlvRxb(pub u32);
        impl SlvRxb {
            #[doc = "SLAVE_RECEIVE_BUFFER"]
            #[inline(always)]
            pub const fn srxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "SLAVE_RECEIVE_BUFFER"]
            #[inline(always)]
            pub fn set_srxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for SlvRxb {
            #[inline(always)]
            fn default() -> SlvRxb {
                SlvRxb(0)
            }
        }
        impl core::fmt::Debug for SlvRxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlvRxb").field("srxb", &self.srxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlvRxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SlvRxb {{ srxb: {=u8:?} }}", self.srxb())
            }
        }
        #[doc = "SMBus Slave Transmit Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlvTxb(pub u32);
        impl SlvTxb {
            #[doc = "SLAVE_TRANSMIT_BUFFER"]
            #[inline(always)]
            pub const fn stxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "SLAVE_TRANSMIT_BUFFER"]
            #[inline(always)]
            pub fn set_stxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for SlvTxb {
            #[inline(always)]
            fn default() -> SlvTxb {
                SlvTxb(0)
            }
        }
        impl core::fmt::Debug for SlvTxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlvTxb").field("stxb", &self.stxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlvTxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SlvTxb {{ stxb: {=u8:?} }}", self.stxb())
            }
        }
        #[doc = "Test"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Test(pub u8);
        impl Test {
            #[doc = "This register must not be written, or undesirable results may occur."]
            #[inline(always)]
            pub const fn test(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This register must not be written, or undesirable results may occur."]
            #[inline(always)]
            pub fn set_test(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Test {
            #[inline(always)]
            fn default() -> Test {
                Test(0)
            }
        }
        impl core::fmt::Debug for Test {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Test").field("test", &self.test()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Test {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Test {{ test: {=u8:?} }}", self.test())
            }
        }
        #[doc = "Time-Out Scaling Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmoutsc(pub u32);
        impl Tmoutsc {
            #[doc = "Clock High time out period = Clock High Time-Out \\[7:0\\] x Baud_Clock_Period x 2"]
            #[inline(always)]
            pub const fn clk_high_tim_out(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Clock High time out period = Clock High Time-Out \\[7:0\\] x Baud_Clock_Period x 2"]
            #[inline(always)]
            pub fn set_clk_high_tim_out(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Slave Cumulative Time-Out duration = Slave Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 1024"]
            #[inline(always)]
            pub const fn slv_cum_tim_out(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Slave Cumulative Time-Out duration = Slave Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 1024"]
            #[inline(always)]
            pub fn set_slv_cum_tim_out(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Master Cumulative Time-Out duration = Master Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 512"]
            #[inline(always)]
            pub const fn mast_cum_tim_out(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Master Cumulative Time-Out duration = Master Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 512"]
            #[inline(always)]
            pub fn set_mast_cum_tim_out(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Bus Idle Minimum time = Bus Idle Min \\[7:0\\] x Baud_Clock_Period"]
            #[inline(always)]
            pub const fn bus_idle_min(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Bus Idle Minimum time = Bus Idle Min \\[7:0\\] x Baud_Clock_Period"]
            #[inline(always)]
            pub fn set_bus_idle_min(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tmoutsc {
            #[inline(always)]
            fn default() -> Tmoutsc {
                Tmoutsc(0)
            }
        }
        impl core::fmt::Debug for Tmoutsc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmoutsc")
                    .field("clk_high_tim_out", &self.clk_high_tim_out())
                    .field("slv_cum_tim_out", &self.slv_cum_tim_out())
                    .field("mast_cum_tim_out", &self.mast_cum_tim_out())
                    .field("bus_idle_min", &self.bus_idle_min())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmoutsc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tmoutsc {{ clk_high_tim_out: {=u8:?}, slv_cum_tim_out: {=u8:?}, mast_cum_tim_out: {=u8:?}, bus_idle_min: {=u8:?} }}" , self . clk_high_tim_out () , self . slv_cum_tim_out () , self . mast_cum_tim_out () , self . bus_idle_min ())
            }
        }
        #[doc = "WAKE ENABLE Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WakeEn(pub u32);
        impl WakeEn {
            #[doc = "Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable. 1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled"]
            #[inline(always)]
            pub const fn start_det_int_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable. 1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled"]
            #[inline(always)]
            pub fn set_start_det_int_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for WakeEn {
            #[inline(always)]
            fn default() -> WakeEn {
                WakeEn(0)
            }
        }
        impl core::fmt::Debug for WakeEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WakeEn")
                    .field("start_det_int_en", &self.start_det_int_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WakeEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WakeEn {{ start_det_int_en: {=bool:?} }}", self.start_det_int_en())
            }
        }
        #[doc = "WAKE STATUS Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WakeSts(pub u32);
        impl WakeSts {
            #[doc = "This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when written with a '1'. Writes of '0' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn start_bit_det(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when written with a '1'. Writes of '0' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_start_bit_det(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for WakeSts {
            #[inline(always)]
            fn default() -> WakeSts {
                WakeSts(0)
            }
        }
        impl core::fmt::Debug for WakeSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WakeSts")
                    .field("start_bit_det", &self.start_bit_det())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WakeSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WakeSts {{ start_bit_det: {=bool:?} }}", self.start_bit_det())
            }
        }
        #[doc = "Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wctrl(pub u32);
        impl Wctrl {
            #[doc = "The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device."]
            #[inline(always)]
            pub const fn ack(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device."]
            #[inline(always)]
            pub fn set_ack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "See STA description"]
            #[inline(always)]
            pub const fn sto(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "See STA description"]
            #[inline(always)]
            pub fn set_sto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition"]
            #[inline(always)]
            pub const fn sta(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition"]
            #[inline(always)]
            pub fn set_sta(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable Interrupt bit (ENI) controls the Interrupt Interface"]
            #[inline(always)]
            pub const fn eni(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Interrupt bit (ENI) controls the Interrupt Interface"]
            #[inline(always)]
            pub fn set_eni(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)"]
            #[inline(always)]
            pub const fn eso(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)"]
            #[inline(always)]
            pub fn set_eso(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect."]
            #[inline(always)]
            pub const fn pin(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect."]
            #[inline(always)]
            pub fn set_pin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Wctrl {
            #[inline(always)]
            fn default() -> Wctrl {
                Wctrl(0)
            }
        }
        impl core::fmt::Debug for Wctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wctrl")
                    .field("ack", &self.ack())
                    .field("sto", &self.sto())
                    .field("sta", &self.sta())
                    .field("eni", &self.eni())
                    .field("eso", &self.eso())
                    .field("pin", &self.pin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Wctrl {{ ack: {=bool:?}, sto: {=bool:?}, sta: {=bool:?}, eni: {=bool:?}, eso: {=bool:?}, pin: {=bool:?} }}" , self . ack () , self . sto () , self . sta () , self . eni () , self . eso () , self . pin ())
            }
        }
    }
}
pub mod spi_slave {
    #[doc = "SPI Slave Register."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SpiSlave {
        ptr: *mut u8,
    }
    unsafe impl Send for SpiSlave {}
    unsafe impl Sync for SpiSlave {}
    impl SpiSlave {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SPI Slave Communication Configuration Register."]
        #[inline(always)]
        pub const fn spi_cfg(self) -> crate::common::Reg<regs::SpiCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SPI Slave Status Register."]
        #[inline(always)]
        pub const fn spi_sts(self) -> crate::common::Reg<regs::SpiSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Slave EC Status Register."]
        #[inline(always)]
        pub const fn spi_ec_sts(self) -> crate::common::Reg<regs::SpiEcSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "SPI Slave Interrupt Enable Register."]
        #[inline(always)]
        pub const fn spi_ien(self) -> crate::common::Reg<regs::SpiIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SPI Slave EC Interrupt Enable Register."]
        #[inline(always)]
        pub const fn ec_ien(self) -> crate::common::Reg<regs::EcIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "SPI Slave Memory Configuration Register."]
        #[inline(always)]
        pub const fn mem_cfg(self) -> crate::common::Reg<regs::MemCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "SPI Slave Memory Base Address0 Register."]
        #[inline(always)]
        pub const fn mem_bar0(self) -> crate::common::Reg<regs::MemBar0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "SPI Slave Memory Write LIMIT 0 Register."]
        #[inline(always)]
        pub const fn mem_wr_lim0(self) -> crate::common::Reg<regs::MemWrLim0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "SPI Slave Memory Read LIMIT 0 Register."]
        #[inline(always)]
        pub const fn mem_rd_lim0(self) -> crate::common::Reg<regs::MemRdLim0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "SPI Slave Memory Base Address1 Register."]
        #[inline(always)]
        pub const fn mem_bar1(self) -> crate::common::Reg<regs::MemBar1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "SPI Slave Memory Write LIMIT 1 Register."]
        #[inline(always)]
        pub const fn mem_wr_lim1(self) -> crate::common::Reg<regs::MemWrLim1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "SPI Slave Memory Read LIMIT 1 Register."]
        #[inline(always)]
        pub const fn mem_rd_lim1(self) -> crate::common::Reg<regs::MemRdLim1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "SPI Slave RX FIFO Host Bar Register."]
        #[inline(always)]
        pub const fn rxf_host_bar(self) -> crate::common::Reg<regs::RxfHostBar, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "SPI Slave RX FIFO Byte Counter Register."]
        #[inline(always)]
        pub const fn rxf_byte_cnt(self) -> crate::common::Reg<regs::RxfByteCnt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "SPI Slave TX FIFO Host Bar Register."]
        #[inline(always)]
        pub const fn txf_host_bar(self) -> crate::common::Reg<regs::TxfHostBar, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "SPI Slave TX FIFO Byte Counter Register."]
        #[inline(always)]
        pub const fn txf_byte_cnt(self) -> crate::common::Reg<regs::TxfByteCnt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "SPI Slave System Configuration Register."]
        #[inline(always)]
        pub const fn sys_cfg(self) -> crate::common::Reg<regs::SysCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "SPI Slave Master to EC Mailbox Register."]
        #[inline(always)]
        pub const fn spim2ec_mbx(self) -> crate::common::Reg<regs::Spim2ecMbx, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "SPI Slave Master to EC Mailbox Register."]
        #[inline(always)]
        pub const fn ec2spim_mbx(self) -> crate::common::Reg<regs::Ec2spimMbx, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "SPI Slave Master to EC Mailbox Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ec2spimMbx(pub u32);
        impl Ec2spimMbx {
            #[doc = "Read only register for the Host. When data is written to this register the OBF Flag is set. Host can read the data and writes of 0xFFFF_FFFF will clear this register, also clearing the flag. Any form of read will clear the flag for this register"]
            #[inline(always)]
            pub const fn ec2m(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Read only register for the Host. When data is written to this register the OBF Flag is set. Host can read the data and writes of 0xFFFF_FFFF will clear this register, also clearing the flag. Any form of read will clear the flag for this register"]
            #[inline(always)]
            pub fn set_ec2m(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Ec2spimMbx {
            #[inline(always)]
            fn default() -> Ec2spimMbx {
                Ec2spimMbx(0)
            }
        }
        impl core::fmt::Debug for Ec2spimMbx {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ec2spimMbx").field("ec2m", &self.ec2m()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ec2spimMbx {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ec2spimMbx {{ ec2m: {=u32:?} }}", self.ec2m())
            }
        }
        #[doc = "SPI Slave EC Interrupt Enable Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcIen(pub u32);
        impl EcIen {
            #[doc = "Enable Memory Write Done Interrupt to EC."]
            #[inline(always)]
            pub const fn mem_wr_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Write Done Interrupt to EC."]
            #[inline(always)]
            pub fn set_mem_wr_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable Memory Read Done Interrupt to EC."]
            #[inline(always)]
            pub const fn mem_rd_done(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Read Done Interrupt to EC."]
            #[inline(always)]
            pub fn set_mem_rd_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable Memory Write Busy Interrupt to EC."]
            #[inline(always)]
            pub const fn mem_wr_busy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Write Busy Interrupt to EC."]
            #[inline(always)]
            pub fn set_mem_wr_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable Memory Read Busy Interrupt to EC."]
            #[inline(always)]
            pub const fn mem_rd_busy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Read Busy Interrupt to EC."]
            #[inline(always)]
            pub fn set_mem_rd_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable SREG Trans Busy Interrupt to EC."]
            #[inline(always)]
            pub const fn sreg_trans(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SREG Trans Busy Interrupt to EC."]
            #[inline(always)]
            pub fn set_sreg_trans(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable Poll High Request Interrupt to EC."]
            #[inline(always)]
            pub const fn poll_hi(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Poll High Request Interrupt to EC."]
            #[inline(always)]
            pub fn set_poll_hi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable SREG RX FIFO Empty Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_emp(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SREG RX FIFO Empty Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable RX FIFO Full Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_ful(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Full Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable TX FIFO Empty Interrupt to EC."]
            #[inline(always)]
            pub const fn txf_emp(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Empty Interrupt to EC."]
            #[inline(always)]
            pub fn set_txf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable TX FIFI FULL Interrupt to EC."]
            #[inline(always)]
            pub const fn txf_ful(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFI FULL Interrupt to EC."]
            #[inline(always)]
            pub fn set_txf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable Test Mode SPI Clock Count Error Interrupt to EC."]
            #[inline(always)]
            pub const fn tmclk_cnt_err(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Test Mode SPI Clock Count Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_tmclk_cnt_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable Input Buffer Signaling Interrupt to EC."]
            #[inline(always)]
            pub const fn ibf_flg(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Input Buffer Signaling Interrupt to EC."]
            #[inline(always)]
            pub fn set_ibf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable Output Buffer signaling Interrupt to EC."]
            #[inline(always)]
            pub const fn obf_flg(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Output Buffer signaling Interrupt to EC."]
            #[inline(always)]
            pub fn set_obf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Enable SPI Master Request Reset Interrupt to EC."]
            #[inline(always)]
            pub const fn spim_rst_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SPI Master Request Reset Interrupt to EC."]
            #[inline(always)]
            pub fn set_spim_rst_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Enable RX FIFO Reset Done Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_rst_dn(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Reset Done Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Enable TX FIFO Reset Done Interrupt to EC."]
            #[inline(always)]
            pub const fn txf_rst_dn(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Reset Done Interrupt to EC."]
            #[inline(always)]
            pub fn set_txf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enable Out Of Limit 0 Error Interrupt to EC."]
            #[inline(always)]
            pub const fn ool0_err(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Out Of Limit 0 Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_ool0_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable Out Of Limit 1 Error Interrupt to EC."]
            #[inline(always)]
            pub const fn ool1_err(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Out Of Limit 1 Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_ool1_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable AHB BUS Error Interrupt to EC."]
            #[inline(always)]
            pub const fn armbus_err(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable AHB BUS Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_armbus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable Undefined Command Error Interrupt to EC."]
            #[inline(always)]
            pub const fn undef_cmd_err(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Undefined Command Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_undef_cmd_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable Device Busy Interrupt to EC."]
            #[inline(always)]
            pub const fn dv_busy(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Device Busy Interrupt to EC."]
            #[inline(always)]
            pub fn set_dv_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable RX FIFO SIZE Error Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_size_err(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO SIZE Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_size_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable TX FIFO Underflow Interrupt to EC."]
            #[inline(always)]
            pub const fn txf_unflw(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Underflow Interrupt to EC."]
            #[inline(always)]
            pub fn set_txf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable TX FIFO Overflow Interrupt to EC."]
            #[inline(always)]
            pub const fn txf_ovrflw(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Overflow Interrupt to EC."]
            #[inline(always)]
            pub fn set_txf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable RX FIFO Underflow Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_unflw(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Underflow Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable RX FIFO Overflow Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_ovrflw(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Overflow Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for EcIen {
            #[inline(always)]
            fn default() -> EcIen {
                EcIen(0)
            }
        }
        impl core::fmt::Debug for EcIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcIen")
                    .field("mem_wr_done", &self.mem_wr_done())
                    .field("mem_rd_done", &self.mem_rd_done())
                    .field("mem_wr_busy", &self.mem_wr_busy())
                    .field("mem_rd_busy", &self.mem_rd_busy())
                    .field("sreg_trans", &self.sreg_trans())
                    .field("poll_hi", &self.poll_hi())
                    .field("rxf_emp", &self.rxf_emp())
                    .field("rxf_ful", &self.rxf_ful())
                    .field("txf_emp", &self.txf_emp())
                    .field("txf_ful", &self.txf_ful())
                    .field("tmclk_cnt_err", &self.tmclk_cnt_err())
                    .field("ibf_flg", &self.ibf_flg())
                    .field("obf_flg", &self.obf_flg())
                    .field("spim_rst_req", &self.spim_rst_req())
                    .field("rxf_rst_dn", &self.rxf_rst_dn())
                    .field("txf_rst_dn", &self.txf_rst_dn())
                    .field("ool0_err", &self.ool0_err())
                    .field("ool1_err", &self.ool1_err())
                    .field("armbus_err", &self.armbus_err())
                    .field("undef_cmd_err", &self.undef_cmd_err())
                    .field("dv_busy", &self.dv_busy())
                    .field("rxf_size_err", &self.rxf_size_err())
                    .field("txf_unflw", &self.txf_unflw())
                    .field("txf_ovrflw", &self.txf_ovrflw())
                    .field("rxf_unflw", &self.rxf_unflw())
                    .field("rxf_ovrflw", &self.rxf_ovrflw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcIen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcIen {{ mem_wr_done: {=bool:?}, mem_rd_done: {=bool:?}, mem_wr_busy: {=bool:?}, mem_rd_busy: {=bool:?}, sreg_trans: {=bool:?}, poll_hi: {=bool:?}, rxf_emp: {=bool:?}, rxf_ful: {=bool:?}, txf_emp: {=bool:?}, txf_ful: {=bool:?}, tmclk_cnt_err: {=bool:?}, ibf_flg: {=bool:?}, obf_flg: {=bool:?}, spim_rst_req: {=bool:?}, rxf_rst_dn: {=bool:?}, txf_rst_dn: {=bool:?}, ool0_err: {=bool:?}, ool1_err: {=bool:?}, armbus_err: {=bool:?}, undef_cmd_err: {=bool:?}, dv_busy: {=bool:?}, rxf_size_err: {=bool:?}, txf_unflw: {=bool:?}, txf_ovrflw: {=bool:?}, rxf_unflw: {=bool:?}, rxf_ovrflw: {=bool:?} }}" , self . mem_wr_done () , self . mem_rd_done () , self . mem_wr_busy () , self . mem_rd_busy () , self . sreg_trans () , self . poll_hi () , self . rxf_emp () , self . rxf_ful () , self . txf_emp () , self . txf_ful () , self . tmclk_cnt_err () , self . ibf_flg () , self . obf_flg () , self . spim_rst_req () , self . rxf_rst_dn () , self . txf_rst_dn () , self . ool0_err () , self . ool1_err () , self . armbus_err () , self . undef_cmd_err () , self . dv_busy () , self . rxf_size_err () , self . txf_unflw () , self . txf_ovrflw () , self . rxf_unflw () , self . rxf_ovrflw ())
            }
        }
        #[doc = "SPI Slave Memory Base Address0 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemBar0(pub u32);
        impl MemBar0 {
            #[doc = "Base Address for Region 0."]
            #[inline(always)]
            pub const fn bas_add0(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Base Address for Region 0."]
            #[inline(always)]
            pub fn set_bas_add0(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for MemBar0 {
            #[inline(always)]
            fn default() -> MemBar0 {
                MemBar0(0)
            }
        }
        impl core::fmt::Debug for MemBar0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemBar0").field("bas_add0", &self.bas_add0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemBar0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemBar0 {{ bas_add0: {=u32:?} }}", self.bas_add0())
            }
        }
        #[doc = "SPI Slave Memory Base Address1 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemBar1(pub u32);
        impl MemBar1 {
            #[doc = "Base Address for Region 1."]
            #[inline(always)]
            pub const fn add1(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Base Address for Region 1."]
            #[inline(always)]
            pub fn set_add1(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for MemBar1 {
            #[inline(always)]
            fn default() -> MemBar1 {
                MemBar1(0)
            }
        }
        impl core::fmt::Debug for MemBar1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemBar1").field("add1", &self.add1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemBar1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemBar1 {{ add1: {=u32:?} }}", self.add1())
            }
        }
        #[doc = "SPI Slave Memory Configuration Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemCfg(pub u32);
        impl MemCfg {
            #[doc = "Enables Region 0 operation. 0 = Disable Region 0. 1 = Enable Region 0."]
            #[inline(always)]
            pub const fn bar_en0_sel(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables Region 0 operation. 0 = Disable Region 0. 1 = Enable Region 0."]
            #[inline(always)]
            pub fn set_bar_en0_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enables Region 1 operation. 0 = Disable Region 1. 1 = Enable Region 1."]
            #[inline(always)]
            pub const fn bar_en1_sel(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enables Region 1 operation. 0 = Disable Region 1. 1 = Enable Region 1."]
            #[inline(always)]
            pub fn set_bar_en1_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for MemCfg {
            #[inline(always)]
            fn default() -> MemCfg {
                MemCfg(0)
            }
        }
        impl core::fmt::Debug for MemCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemCfg")
                    .field("bar_en0_sel", &self.bar_en0_sel())
                    .field("bar_en1_sel", &self.bar_en1_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "MemCfg {{ bar_en0_sel: {=bool:?}, bar_en1_sel: {=bool:?} }}",
                    self.bar_en0_sel(),
                    self.bar_en1_sel()
                )
            }
        }
        #[doc = "SPI Slave Memory Read LIMIT 0 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemRdLim0(pub u32);
        impl MemRdLim0 {
            #[doc = "Read Limit for Region 0."]
            #[inline(always)]
            pub const fn lmt0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Read Limit for Region 0."]
            #[inline(always)]
            pub fn set_lmt0(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for MemRdLim0 {
            #[inline(always)]
            fn default() -> MemRdLim0 {
                MemRdLim0(0)
            }
        }
        impl core::fmt::Debug for MemRdLim0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemRdLim0").field("lmt0", &self.lmt0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemRdLim0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemRdLim0 {{ lmt0: {=u16:?} }}", self.lmt0())
            }
        }
        #[doc = "SPI Slave Memory Read LIMIT 1 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemRdLim1(pub u32);
        impl MemRdLim1 {
            #[doc = "Read Limit for Region 1."]
            #[inline(always)]
            pub const fn lmt1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Read Limit for Region 1."]
            #[inline(always)]
            pub fn set_lmt1(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for MemRdLim1 {
            #[inline(always)]
            fn default() -> MemRdLim1 {
                MemRdLim1(0)
            }
        }
        impl core::fmt::Debug for MemRdLim1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemRdLim1").field("lmt1", &self.lmt1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemRdLim1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemRdLim1 {{ lmt1: {=u16:?} }}", self.lmt1())
            }
        }
        #[doc = "SPI Slave Memory Write LIMIT 0 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemWrLim0(pub u32);
        impl MemWrLim0 {
            #[doc = "Write Limit for Region 0."]
            #[inline(always)]
            pub const fn lmt0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Write Limit for Region 0."]
            #[inline(always)]
            pub fn set_lmt0(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for MemWrLim0 {
            #[inline(always)]
            fn default() -> MemWrLim0 {
                MemWrLim0(0)
            }
        }
        impl core::fmt::Debug for MemWrLim0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemWrLim0").field("lmt0", &self.lmt0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemWrLim0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemWrLim0 {{ lmt0: {=u16:?} }}", self.lmt0())
            }
        }
        #[doc = "SPI Slave Memory Write LIMIT 1 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemWrLim1(pub u32);
        impl MemWrLim1 {
            #[doc = "Write Limit for Region 1."]
            #[inline(always)]
            pub const fn lmt1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Write Limit for Region 1."]
            #[inline(always)]
            pub fn set_lmt1(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for MemWrLim1 {
            #[inline(always)]
            fn default() -> MemWrLim1 {
                MemWrLim1(0)
            }
        }
        impl core::fmt::Debug for MemWrLim1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemWrLim1").field("lmt1", &self.lmt1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemWrLim1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemWrLim1 {{ lmt1: {=u16:?} }}", self.lmt1())
            }
        }
        #[doc = "SPI Slave RX FIFO Byte Counter Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxfByteCnt(pub u32);
        impl RxfByteCnt {
            #[doc = "RX FIFO Byte Count Register."]
            #[inline(always)]
            pub const fn bcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "RX FIFO Byte Count Register."]
            #[inline(always)]
            pub fn set_bcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for RxfByteCnt {
            #[inline(always)]
            fn default() -> RxfByteCnt {
                RxfByteCnt(0)
            }
        }
        impl core::fmt::Debug for RxfByteCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxfByteCnt").field("bcnt", &self.bcnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxfByteCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxfByteCnt {{ bcnt: {=u16:?} }}", self.bcnt())
            }
        }
        #[doc = "SPI Slave RX FIFO Host Bar Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxfHostBar(pub u32);
        impl RxfHostBar {
            #[doc = "RX FIFO Host Bar Register."]
            #[inline(always)]
            pub const fn bar(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "RX FIFO Host Bar Register."]
            #[inline(always)]
            pub fn set_bar(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxfHostBar {
            #[inline(always)]
            fn default() -> RxfHostBar {
                RxfHostBar(0)
            }
        }
        impl core::fmt::Debug for RxfHostBar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxfHostBar").field("bar", &self.bar()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxfHostBar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxfHostBar {{ bar: {=u16:?} }}", self.bar())
            }
        }
        #[doc = "SPI Slave Communication Configuration Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpiCfg(pub u32);
        impl SpiCfg {
            #[doc = "This field defines the Single / Quad Wire mode of operation for SPI Slave block. 0 = Single Wire Slave SPI block operation. 1 = Quad Wire Slave SPI block operation."]
            #[inline(always)]
            pub const fn sng_qud_sel(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This field defines the Single / Quad Wire mode of operation for SPI Slave block. 0 = Single Wire Slave SPI block operation. 1 = Quad Wire Slave SPI block operation."]
            #[inline(always)]
            pub fn set_sng_qud_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Turn Around Time select for Quad wire mode. 0h = 1 cycle. 1h = 2 cycles. 2h = 4 cycles. 3h = 8 cycles. Other values are reserved."]
            #[inline(always)]
            pub const fn tar_tim_sel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "Turn Around Time select for Quad wire mode. 0h = 1 cycle. 1h = 2 cycles. 2h = 4 cycles. 3h = 8 cycles. Other values are reserved."]
            #[inline(always)]
            pub fn set_tar_tim_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize);
            }
            #[doc = "These bits set the amount of wait time in cycles before transmitting data back to master. During this wait time status bits will be transmitted"]
            #[inline(always)]
            pub const fn wait_time(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "These bits set the amount of wait time in cycles before transmitting data back to master. During this wait time status bits will be transmitted"]
            #[inline(always)]
            pub fn set_wait_time(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for SpiCfg {
            #[inline(always)]
            fn default() -> SpiCfg {
                SpiCfg(0)
            }
        }
        impl core::fmt::Debug for SpiCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpiCfg")
                    .field("sng_qud_sel", &self.sng_qud_sel())
                    .field("tar_tim_sel", &self.tar_tim_sel())
                    .field("wait_time", &self.wait_time())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpiCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SpiCfg {{ sng_qud_sel: {=bool:?}, tar_tim_sel: {=u8:?}, wait_time: {=u8:?} }}",
                    self.sng_qud_sel(),
                    self.tar_tim_sel(),
                    self.wait_time()
                )
            }
        }
        #[doc = "SPI Slave EC Status Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpiEcSts(pub u32);
        impl SpiEcSts {
            #[doc = "When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to Memory for Posted Writes .- clear with new Write request."]
            #[inline(always)]
            pub const fn mem_wr_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to Memory for Posted Writes .- clear with new Write request."]
            #[inline(always)]
            pub fn set_mem_wr_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data read from Memory for Posted Reads. - cleared with new Read request."]
            #[inline(always)]
            pub const fn mem_rd_done(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data read from Memory for Posted Reads. - cleared with new Read request."]
            #[inline(always)]
            pub fn set_mem_rd_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "When an Memory Write transaction is currently being processed."]
            #[inline(always)]
            pub const fn mem_wr_busy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "When an Memory Write transaction is currently being processed."]
            #[inline(always)]
            pub fn set_mem_wr_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "When an Memory Read transaction is currently being processed."]
            #[inline(always)]
            pub const fn mem_rd_busy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When an Memory Read transaction is currently being processed."]
            #[inline(always)]
            pub fn set_mem_rd_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When an SREG transaction is currently being processed."]
            #[inline(always)]
            pub const fn sreg_trans(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When an SREG transaction is currently being processed."]
            #[inline(always)]
            pub fn set_sreg_trans(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "If this bit is set, then something in the high 16-bit of status register is set and needs to be checked. SPI Master should take action to clear this."]
            #[inline(always)]
            pub const fn poll_hi(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is set, then something in the high 16-bit of status register is set and needs to be checked. SPI Master should take action to clear this."]
            #[inline(always)]
            pub fn set_poll_hi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Signifies all Memory write transactions for the SPI Masters requested size have been performed. New transactions are allowed."]
            #[inline(always)]
            pub const fn rxf_emp(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Signifies all Memory write transactions for the SPI Masters requested size have been performed. New transactions are allowed."]
            #[inline(always)]
            pub fn set_rxf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "The RX FIFO is full of data to be written to Memory."]
            #[inline(always)]
            pub const fn rxf_ful(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "The RX FIFO is full of data to be written to Memory."]
            #[inline(always)]
            pub fn set_rxf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Signifies SPI Master has read the data requested from Memory. Can be used to show there is data the SPI Master has requested and not been read yet. New read transactions will be aligned."]
            #[inline(always)]
            pub const fn txf_emp(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Signifies SPI Master has read the data requested from Memory. Can be used to show there is data the SPI Master has requested and not been read yet. New read transactions will be aligned."]
            #[inline(always)]
            pub fn set_txf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "The TX FIFO is full of data that was read from Memory."]
            #[inline(always)]
            pub const fn txf_ful(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "The TX FIFO is full of data that was read from Memory."]
            #[inline(always)]
            pub fn set_txf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."]
            #[inline(always)]
            pub const fn tmclk_cnt_err(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."]
            #[inline(always)]
            pub fn set_tmclk_cnt_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Set when the Host writes to the Input Buffer signaling there is data for the EC to read."]
            #[inline(always)]
            pub const fn ibf_flg(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the Host writes to the Input Buffer signaling there is data for the EC to read."]
            #[inline(always)]
            pub fn set_ibf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Set when the EC writes to the Output Buffer signaling there is data for the Host to read."]
            #[inline(always)]
            pub const fn obf_flg(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the EC writes to the Output Buffer signaling there is data for the Host to read."]
            #[inline(always)]
            pub fn set_obf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Set when the SPI Master Requested a Configuration Reset."]
            #[inline(always)]
            pub const fn spim_rst_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the SPI Master Requested a Configuration Reset."]
            #[inline(always)]
            pub fn set_spim_rst_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub const fn rxf_rst_dn(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub fn set_rxf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub const fn txf_rst_dn(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub fn set_txf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."]
            #[inline(always)]
            pub const fn ool0_err(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."]
            #[inline(always)]
            pub fn set_ool0_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."]
            #[inline(always)]
            pub const fn ool1_err(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."]
            #[inline(always)]
            pub fn set_ool1_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "ARM Bus Error returned for the curren data transfer."]
            #[inline(always)]
            pub const fn armbus_err(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "ARM Bus Error returned for the curren data transfer."]
            #[inline(always)]
            pub fn set_armbus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Undefined Command Error: The command received from the master isn't defined."]
            #[inline(always)]
            pub const fn undef_cmd_err(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Undefined Command Error: The command received from the master isn't defined."]
            #[inline(always)]
            pub fn set_undef_cmd_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "If the Master requested a transaction whose destination is busy the request is ignored. Should use the poll or wait for interrupts."]
            #[inline(always)]
            pub const fn dv_busy(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "If the Master requested a transaction whose destination is busy the request is ignored. Should use the poll or wait for interrupts."]
            #[inline(always)]
            pub fn set_dv_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "If size requested is more than what Master provided and the Master terminates early error flag shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and continue transaction, may be taking in garbage."]
            #[inline(always)]
            pub const fn rxf_size_err(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "If size requested is more than what Master provided and the Master terminates early error flag shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and continue transaction, may be taking in garbage."]
            #[inline(always)]
            pub fn set_rxf_size_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned will just be the last valid pointer value."]
            #[inline(always)]
            pub const fn txf_unflw(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned will just be the last valid pointer value."]
            #[inline(always)]
            pub fn set_txf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "If Master doesn't read all of the data it requested from the posted read block cycle, than data will still be left in the FIFO. This will cause misalignment with the following transactions and a new read cycle can cause overflow."]
            #[inline(always)]
            pub const fn txf_ovrflw(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "If Master doesn't read all of the data it requested from the posted read block cycle, than data will still be left in the FIFO. This will cause misalignment with the following transactions and a new read cycle can cause overflow."]
            #[inline(always)]
            pub fn set_txf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "If the SPI Slave reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition will never happen under normal situation."]
            #[inline(always)]
            pub const fn rxf_unflw(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "If the SPI Slave reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition will never happen under normal situation."]
            #[inline(always)]
            pub fn set_rxf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data will not be stored."]
            #[inline(always)]
            pub const fn rxf_ovrflw(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data will not be stored."]
            #[inline(always)]
            pub fn set_rxf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for SpiEcSts {
            #[inline(always)]
            fn default() -> SpiEcSts {
                SpiEcSts(0)
            }
        }
        impl core::fmt::Debug for SpiEcSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpiEcSts")
                    .field("mem_wr_done", &self.mem_wr_done())
                    .field("mem_rd_done", &self.mem_rd_done())
                    .field("mem_wr_busy", &self.mem_wr_busy())
                    .field("mem_rd_busy", &self.mem_rd_busy())
                    .field("sreg_trans", &self.sreg_trans())
                    .field("poll_hi", &self.poll_hi())
                    .field("rxf_emp", &self.rxf_emp())
                    .field("rxf_ful", &self.rxf_ful())
                    .field("txf_emp", &self.txf_emp())
                    .field("txf_ful", &self.txf_ful())
                    .field("tmclk_cnt_err", &self.tmclk_cnt_err())
                    .field("ibf_flg", &self.ibf_flg())
                    .field("obf_flg", &self.obf_flg())
                    .field("spim_rst_req", &self.spim_rst_req())
                    .field("rxf_rst_dn", &self.rxf_rst_dn())
                    .field("txf_rst_dn", &self.txf_rst_dn())
                    .field("ool0_err", &self.ool0_err())
                    .field("ool1_err", &self.ool1_err())
                    .field("armbus_err", &self.armbus_err())
                    .field("undef_cmd_err", &self.undef_cmd_err())
                    .field("dv_busy", &self.dv_busy())
                    .field("rxf_size_err", &self.rxf_size_err())
                    .field("txf_unflw", &self.txf_unflw())
                    .field("txf_ovrflw", &self.txf_ovrflw())
                    .field("rxf_unflw", &self.rxf_unflw())
                    .field("rxf_ovrflw", &self.rxf_ovrflw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpiEcSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SpiEcSts {{ mem_wr_done: {=bool:?}, mem_rd_done: {=bool:?}, mem_wr_busy: {=bool:?}, mem_rd_busy: {=bool:?}, sreg_trans: {=bool:?}, poll_hi: {=bool:?}, rxf_emp: {=bool:?}, rxf_ful: {=bool:?}, txf_emp: {=bool:?}, txf_ful: {=bool:?}, tmclk_cnt_err: {=bool:?}, ibf_flg: {=bool:?}, obf_flg: {=bool:?}, spim_rst_req: {=bool:?}, rxf_rst_dn: {=bool:?}, txf_rst_dn: {=bool:?}, ool0_err: {=bool:?}, ool1_err: {=bool:?}, armbus_err: {=bool:?}, undef_cmd_err: {=bool:?}, dv_busy: {=bool:?}, rxf_size_err: {=bool:?}, txf_unflw: {=bool:?}, txf_ovrflw: {=bool:?}, rxf_unflw: {=bool:?}, rxf_ovrflw: {=bool:?} }}" , self . mem_wr_done () , self . mem_rd_done () , self . mem_wr_busy () , self . mem_rd_busy () , self . sreg_trans () , self . poll_hi () , self . rxf_emp () , self . rxf_ful () , self . txf_emp () , self . txf_ful () , self . tmclk_cnt_err () , self . ibf_flg () , self . obf_flg () , self . spim_rst_req () , self . rxf_rst_dn () , self . txf_rst_dn () , self . ool0_err () , self . ool1_err () , self . armbus_err () , self . undef_cmd_err () , self . dv_busy () , self . rxf_size_err () , self . txf_unflw () , self . txf_ovrflw () , self . rxf_unflw () , self . rxf_ovrflw ())
            }
        }
        #[doc = "SPI Slave Interrupt Enable Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpiIen(pub u32);
        impl SpiIen {
            #[doc = "Enable Memory Write Done Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn mem_wr_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Write Done Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_mem_wr_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable Memory Read Done Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn mem_rd_done(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Read Done Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_mem_rd_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable Memory Write Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn mem_wr_busy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Write Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_mem_wr_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable Memory Read Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn mem_rd_busy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Read Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_mem_rd_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable SREG Trans Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn sreg_trans(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SREG Trans Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_sreg_trans(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable Poll High Request Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn poll_hi(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Poll High Request Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_poll_hi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable SREG RX FIFO Empty Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_emp(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SREG RX FIFO Empty Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable RX FIFO Full Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_ful(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Full Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable TX FIFO Empty Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn txf_emp(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Empty Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_txf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable TX FIFI FULL Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn txf_ful(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFI FULL Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_txf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable Test Mode SPI Clock Count Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn tmclk_cnt_err(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Test Mode SPI Clock Count Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_tmclk_cnt_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable Input Buffer Signaling Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn ibf_flg(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Input Buffer Signaling Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_ibf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable Output Buffer signaling Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn obf_flg(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Output Buffer signaling Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_obf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Enable SPI Master Request Reset Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn spim_rst_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SPI Master Request Reset Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_spim_rst_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Enable RX FIFO Reset Done Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_rst_dn(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Reset Done Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Enable TX FIFO Reset Done Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn txf_rst_dn(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Reset Done Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_txf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enable Out Of Limit 0 Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn ool0_err(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Out Of Limit 0 Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_ool0_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable Out Of Limit 1 Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn ool1_err(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Out Of Limit 1 Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_ool1_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable AHB BUS Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn armbus_err(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable AHB BUS Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_armbus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable Undefined Command Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn undef_cmd_err(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Undefined Command Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_undef_cmd_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable Device Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn dv_busy(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Device Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_dv_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable RX FIFO SIZE Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_size_err(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO SIZE Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_size_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable TX FIFO Underflow Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn txf_unflw(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Underflow Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_txf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable TX FIFO Overflow Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn txf_ovrflow(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Overflow Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_txf_ovrflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable RX FIFO Underflow Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_unflw(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Underflow Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable RX FIFO Overflow Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_ovrflw(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Overflow Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for SpiIen {
            #[inline(always)]
            fn default() -> SpiIen {
                SpiIen(0)
            }
        }
        impl core::fmt::Debug for SpiIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpiIen")
                    .field("mem_wr_done", &self.mem_wr_done())
                    .field("mem_rd_done", &self.mem_rd_done())
                    .field("mem_wr_busy", &self.mem_wr_busy())
                    .field("mem_rd_busy", &self.mem_rd_busy())
                    .field("sreg_trans", &self.sreg_trans())
                    .field("poll_hi", &self.poll_hi())
                    .field("rxf_emp", &self.rxf_emp())
                    .field("rxf_ful", &self.rxf_ful())
                    .field("txf_emp", &self.txf_emp())
                    .field("txf_ful", &self.txf_ful())
                    .field("tmclk_cnt_err", &self.tmclk_cnt_err())
                    .field("ibf_flg", &self.ibf_flg())
                    .field("obf_flg", &self.obf_flg())
                    .field("spim_rst_req", &self.spim_rst_req())
                    .field("rxf_rst_dn", &self.rxf_rst_dn())
                    .field("txf_rst_dn", &self.txf_rst_dn())
                    .field("ool0_err", &self.ool0_err())
                    .field("ool1_err", &self.ool1_err())
                    .field("armbus_err", &self.armbus_err())
                    .field("undef_cmd_err", &self.undef_cmd_err())
                    .field("dv_busy", &self.dv_busy())
                    .field("rxf_size_err", &self.rxf_size_err())
                    .field("txf_unflw", &self.txf_unflw())
                    .field("txf_ovrflow", &self.txf_ovrflow())
                    .field("rxf_unflw", &self.rxf_unflw())
                    .field("rxf_ovrflw", &self.rxf_ovrflw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpiIen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SpiIen {{ mem_wr_done: {=bool:?}, mem_rd_done: {=bool:?}, mem_wr_busy: {=bool:?}, mem_rd_busy: {=bool:?}, sreg_trans: {=bool:?}, poll_hi: {=bool:?}, rxf_emp: {=bool:?}, rxf_ful: {=bool:?}, txf_emp: {=bool:?}, txf_ful: {=bool:?}, tmclk_cnt_err: {=bool:?}, ibf_flg: {=bool:?}, obf_flg: {=bool:?}, spim_rst_req: {=bool:?}, rxf_rst_dn: {=bool:?}, txf_rst_dn: {=bool:?}, ool0_err: {=bool:?}, ool1_err: {=bool:?}, armbus_err: {=bool:?}, undef_cmd_err: {=bool:?}, dv_busy: {=bool:?}, rxf_size_err: {=bool:?}, txf_unflw: {=bool:?}, txf_ovrflow: {=bool:?}, rxf_unflw: {=bool:?}, rxf_ovrflw: {=bool:?} }}" , self . mem_wr_done () , self . mem_rd_done () , self . mem_wr_busy () , self . mem_rd_busy () , self . sreg_trans () , self . poll_hi () , self . rxf_emp () , self . rxf_ful () , self . txf_emp () , self . txf_ful () , self . tmclk_cnt_err () , self . ibf_flg () , self . obf_flg () , self . spim_rst_req () , self . rxf_rst_dn () , self . txf_rst_dn () , self . ool0_err () , self . ool1_err () , self . armbus_err () , self . undef_cmd_err () , self . dv_busy () , self . rxf_size_err () , self . txf_unflw () , self . txf_ovrflow () , self . rxf_unflw () , self . rxf_ovrflw ())
            }
        }
        #[doc = "SPI Slave Status Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpiSts(pub u32);
        impl SpiSts {
            #[doc = "When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to Memory for Posted Writes . Clear with new Write request."]
            #[inline(always)]
            pub const fn mem_wr_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to Memory for Posted Writes . Clear with new Write request."]
            #[inline(always)]
            pub fn set_mem_wr_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data read from Memory for Posted Reads. - cleared with new Read request."]
            #[inline(always)]
            pub const fn mem_rd_done(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data read from Memory for Posted Reads. - cleared with new Read request."]
            #[inline(always)]
            pub fn set_mem_rd_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "When an Memory Write transaction is currently being processed."]
            #[inline(always)]
            pub const fn mem_wr_busy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "When an Memory Write transaction is currently being processed."]
            #[inline(always)]
            pub fn set_mem_wr_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "When an Memory Read transaction is currently being processed."]
            #[inline(always)]
            pub const fn mem_rd_busy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When an Memory Read transaction is currently being processed."]
            #[inline(always)]
            pub fn set_mem_rd_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When an SREG transaction is currently being processed."]
            #[inline(always)]
            pub const fn sreg_trans(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When an SREG transaction is currently being processed."]
            #[inline(always)]
            pub fn set_sreg_trans(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "If this bit is set, then something in the high 16-bit of status register is set and needs to be checked. SPI Master should take action to clear this."]
            #[inline(always)]
            pub const fn poll_high(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is set, then something in the high 16-bit of status register is set and needs to be checked. SPI Master should take action to clear this."]
            #[inline(always)]
            pub fn set_poll_high(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Signifies all Memory write transactions for the SPI Masters requested size have been performed. New transactions are allowed."]
            #[inline(always)]
            pub const fn rxf_emp(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Signifies all Memory write transactions for the SPI Masters requested size have been performed. New transactions are allowed."]
            #[inline(always)]
            pub fn set_rxf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "The RX FIFO is full of data to be written to Memory."]
            #[inline(always)]
            pub const fn rxf_ful(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "The RX FIFO is full of data to be written to Memory."]
            #[inline(always)]
            pub fn set_rxf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Signifies SPI Master has read the data requested from Memory. Can be used to show there is data the SPI Master has requested and not been read yet. New read transactions will be aligned."]
            #[inline(always)]
            pub const fn txf_emp(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Signifies SPI Master has read the data requested from Memory. Can be used to show there is data the SPI Master has requested and not been read yet. New read transactions will be aligned."]
            #[inline(always)]
            pub fn set_txf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "The TX FIFO is full of data that was read from Memory."]
            #[inline(always)]
            pub const fn txf_ful(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "The TX FIFO is full of data that was read from Memory."]
            #[inline(always)]
            pub fn set_txf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."]
            #[inline(always)]
            pub const fn tmclk_cnt_err(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."]
            #[inline(always)]
            pub fn set_tmclk_cnt_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Set when the Host writes to the Input Buffer signaling there is data for the EC to read."]
            #[inline(always)]
            pub const fn ibf_flg(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the Host writes to the Input Buffer signaling there is data for the EC to read."]
            #[inline(always)]
            pub fn set_ibf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Set when the EC writes to the Output Buffer signaling there is data for the Host to read."]
            #[inline(always)]
            pub const fn obf_flg(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the EC writes to the Output Buffer signaling there is data for the Host to read."]
            #[inline(always)]
            pub fn set_obf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Set when the SPI Master Requested a Configuration Reset."]
            #[inline(always)]
            pub const fn spim_rst_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the SPI Master Requested a Configuration Reset."]
            #[inline(always)]
            pub fn set_spim_rst_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub const fn rxf_rst_dn(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub fn set_rxf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub const fn txf_rst_dn(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub fn set_txf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."]
            #[inline(always)]
            pub const fn ool0_err(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."]
            #[inline(always)]
            pub fn set_ool0_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."]
            #[inline(always)]
            pub const fn ool1_err(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."]
            #[inline(always)]
            pub fn set_ool1_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "ARM Bus Error returned for the curren data transfer."]
            #[inline(always)]
            pub const fn armbus_err(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "ARM Bus Error returned for the curren data transfer."]
            #[inline(always)]
            pub fn set_armbus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Undefined Command Error: The command received from the master isn't defined."]
            #[inline(always)]
            pub const fn undef_cmd_err(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Undefined Command Error: The command received from the master isn't defined."]
            #[inline(always)]
            pub fn set_undef_cmd_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "If the Master requested a transaction whose destination is busy the request is ignored. Should use the poll or wait for interrupts."]
            #[inline(always)]
            pub const fn dv_busy(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "If the Master requested a transaction whose destination is busy the request is ignored. Should use the poll or wait for interrupts."]
            #[inline(always)]
            pub fn set_dv_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "If size requested is more than what Master provided and the Master terminates early error flag shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and continue transaction, may be taking in garbage."]
            #[inline(always)]
            pub const fn rxf_size_err(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "If size requested is more than what Master provided and the Master terminates early error flag shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and continue transaction, may be taking in garbage."]
            #[inline(always)]
            pub fn set_rxf_size_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned will just be the last valid pointer value."]
            #[inline(always)]
            pub const fn txf_unflw(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned will just be the last valid pointer value."]
            #[inline(always)]
            pub fn set_txf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "If Master doesn't read all of the data it requested from the posted read block cycle, than data will still be left in the FIFO. This will cause misalignment with the following transactions and a new read cycle can cause overflow."]
            #[inline(always)]
            pub const fn txf_ovrflw(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "If Master doesn't read all of the data it requested from the posted read block cycle, than data will still be left in the FIFO. This will cause misalignment with the following transactions and a new read cycle can cause overflow."]
            #[inline(always)]
            pub fn set_txf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "If the SPI Slave reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition will never happen under normal situation."]
            #[inline(always)]
            pub const fn rxf_unflw(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "If the SPI Slave reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition will never happen under normal situation."]
            #[inline(always)]
            pub fn set_rxf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data will not be stored."]
            #[inline(always)]
            pub const fn rxf_ovrflw(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data will not be stored."]
            #[inline(always)]
            pub fn set_rxf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for SpiSts {
            #[inline(always)]
            fn default() -> SpiSts {
                SpiSts(0)
            }
        }
        impl core::fmt::Debug for SpiSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpiSts")
                    .field("mem_wr_done", &self.mem_wr_done())
                    .field("mem_rd_done", &self.mem_rd_done())
                    .field("mem_wr_busy", &self.mem_wr_busy())
                    .field("mem_rd_busy", &self.mem_rd_busy())
                    .field("sreg_trans", &self.sreg_trans())
                    .field("poll_high", &self.poll_high())
                    .field("rxf_emp", &self.rxf_emp())
                    .field("rxf_ful", &self.rxf_ful())
                    .field("txf_emp", &self.txf_emp())
                    .field("txf_ful", &self.txf_ful())
                    .field("tmclk_cnt_err", &self.tmclk_cnt_err())
                    .field("ibf_flg", &self.ibf_flg())
                    .field("obf_flg", &self.obf_flg())
                    .field("spim_rst_req", &self.spim_rst_req())
                    .field("rxf_rst_dn", &self.rxf_rst_dn())
                    .field("txf_rst_dn", &self.txf_rst_dn())
                    .field("ool0_err", &self.ool0_err())
                    .field("ool1_err", &self.ool1_err())
                    .field("armbus_err", &self.armbus_err())
                    .field("undef_cmd_err", &self.undef_cmd_err())
                    .field("dv_busy", &self.dv_busy())
                    .field("rxf_size_err", &self.rxf_size_err())
                    .field("txf_unflw", &self.txf_unflw())
                    .field("txf_ovrflw", &self.txf_ovrflw())
                    .field("rxf_unflw", &self.rxf_unflw())
                    .field("rxf_ovrflw", &self.rxf_ovrflw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpiSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SpiSts {{ mem_wr_done: {=bool:?}, mem_rd_done: {=bool:?}, mem_wr_busy: {=bool:?}, mem_rd_busy: {=bool:?}, sreg_trans: {=bool:?}, poll_high: {=bool:?}, rxf_emp: {=bool:?}, rxf_ful: {=bool:?}, txf_emp: {=bool:?}, txf_ful: {=bool:?}, tmclk_cnt_err: {=bool:?}, ibf_flg: {=bool:?}, obf_flg: {=bool:?}, spim_rst_req: {=bool:?}, rxf_rst_dn: {=bool:?}, txf_rst_dn: {=bool:?}, ool0_err: {=bool:?}, ool1_err: {=bool:?}, armbus_err: {=bool:?}, undef_cmd_err: {=bool:?}, dv_busy: {=bool:?}, rxf_size_err: {=bool:?}, txf_unflw: {=bool:?}, txf_ovrflw: {=bool:?}, rxf_unflw: {=bool:?}, rxf_ovrflw: {=bool:?} }}" , self . mem_wr_done () , self . mem_rd_done () , self . mem_wr_busy () , self . mem_rd_busy () , self . sreg_trans () , self . poll_high () , self . rxf_emp () , self . rxf_ful () , self . txf_emp () , self . txf_ful () , self . tmclk_cnt_err () , self . ibf_flg () , self . obf_flg () , self . spim_rst_req () , self . rxf_rst_dn () , self . txf_rst_dn () , self . ool0_err () , self . ool1_err () , self . armbus_err () , self . undef_cmd_err () , self . dv_busy () , self . rxf_size_err () , self . txf_unflw () , self . txf_ovrflw () , self . rxf_unflw () , self . rxf_ovrflw ())
            }
        }
        #[doc = "SPI Slave Master to EC Mailbox Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spim2ecMbx(pub u32);
        impl Spim2ecMbx {
            #[doc = "Write only register for the Host. When data is written to this register the IBF Flag is set. EC can read the data and writes of 0xFFFF will clear this register. Any form of read will clear the flag for this register."]
            #[inline(always)]
            pub const fn m2ec(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Write only register for the Host. When data is written to this register the IBF Flag is set. EC can read the data and writes of 0xFFFF will clear this register. Any form of read will clear the flag for this register."]
            #[inline(always)]
            pub fn set_m2ec(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Spim2ecMbx {
            #[inline(always)]
            fn default() -> Spim2ecMbx {
                Spim2ecMbx(0)
            }
        }
        impl core::fmt::Debug for Spim2ecMbx {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spim2ecMbx").field("m2ec", &self.m2ec()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spim2ecMbx {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Spim2ecMbx {{ m2ec: {=u32:?} }}", self.m2ec())
            }
        }
        #[doc = "SPI Slave System Configuration Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SysCfg(pub u32);
        impl SysCfg {
            #[doc = "Soft reset for entire SPI Slave Block. This bit is self clearing."]
            #[inline(always)]
            pub const fn soft_rst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Soft reset for entire SPI Slave Block. This bit is self clearing."]
            #[inline(always)]
            pub fn set_soft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock Quad / Single Write Mode bit, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_quad_sngl_wrmod(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Quad / Single Write Mode bit, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_quad_sngl_wrmod(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Lock Tar Time bit, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_tar_time(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Tar Time bit, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_tar_time(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Lock Wait Cycle bits, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_wait_cycl(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Wait Cycle bits, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_wait_cycl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Lock Memory Configuration register, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_mem_cfg(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Memory Configuration register, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_mem_cfg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Lock SPI Interrupt Enable register, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_spiint_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Lock SPI Interrupt Enable register, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_spiint_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Lock Memory Bar 0 register, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_mem_bar0(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Memory Bar 0 register, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_mem_bar0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Lock Memory Bar 1 register, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_mem_bar1(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Memory Bar 1 register, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_mem_bar1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Lock TEST Mode register, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_test_mode(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Lock TEST Mode register, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_test_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable / Disable SPI Slave Block. 0 = Disable SPI Slave module. 1 = Enable SPI Slave module."]
            #[inline(always)]
            pub const fn spi_slv_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable / Disable SPI Slave Block. 0 = Disable SPI Slave module. 1 = Enable SPI Slave module."]
            #[inline(always)]
            pub fn set_spi_slv_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Mask EC register 'fld_mask_ec_register' from SPI Master. All the register are neither readable now writable from SPI Master."]
            #[inline(always)]
            pub const fn mas_ecreg(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Mask EC register 'fld_mask_ec_register' from SPI Master. All the register are neither readable now writable from SPI Master."]
            #[inline(always)]
            pub fn set_mas_ecreg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Enable SPI Slave Simple Mode operation."]
            #[inline(always)]
            pub const fn sim_en(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SPI Slave Simple Mode operation."]
            #[inline(always)]
            pub fn set_sim_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Notification to TX FIFO Engine that data is available for AHB Transfer. This register but is cleared by Hardware at the end of the transaction, with SPI_CS_N de-assertion. (R/WC)."]
            #[inline(always)]
            pub const fn ecdatl(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Notification to TX FIFO Engine that data is available for AHB Transfer. This register but is cleared by Hardware at the end of the transaction, with SPI_CS_N de-assertion. (R/WC)."]
            #[inline(always)]
            pub fn set_ecdatl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for SysCfg {
            #[inline(always)]
            fn default() -> SysCfg {
                SysCfg(0)
            }
        }
        impl core::fmt::Debug for SysCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SysCfg")
                    .field("soft_rst", &self.soft_rst())
                    .field("lock_quad_sngl_wrmod", &self.lock_quad_sngl_wrmod())
                    .field("lock_tar_time", &self.lock_tar_time())
                    .field("lock_wait_cycl", &self.lock_wait_cycl())
                    .field("lock_mem_cfg", &self.lock_mem_cfg())
                    .field("lock_spiint_en", &self.lock_spiint_en())
                    .field("lock_mem_bar0", &self.lock_mem_bar0())
                    .field("lock_mem_bar1", &self.lock_mem_bar1())
                    .field("lock_test_mode", &self.lock_test_mode())
                    .field("spi_slv_en", &self.spi_slv_en())
                    .field("mas_ecreg", &self.mas_ecreg())
                    .field("sim_en", &self.sim_en())
                    .field("ecdatl", &self.ecdatl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SysCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SysCfg {{ soft_rst: {=bool:?}, lock_quad_sngl_wrmod: {=bool:?}, lock_tar_time: {=bool:?}, lock_wait_cycl: {=bool:?}, lock_mem_cfg: {=bool:?}, lock_spiint_en: {=bool:?}, lock_mem_bar0: {=bool:?}, lock_mem_bar1: {=bool:?}, lock_test_mode: {=bool:?}, spi_slv_en: {=bool:?}, mas_ecreg: {=bool:?}, sim_en: {=bool:?}, ecdatl: {=bool:?} }}" , self . soft_rst () , self . lock_quad_sngl_wrmod () , self . lock_tar_time () , self . lock_wait_cycl () , self . lock_mem_cfg () , self . lock_spiint_en () , self . lock_mem_bar0 () , self . lock_mem_bar1 () , self . lock_test_mode () , self . spi_slv_en () , self . mas_ecreg () , self . sim_en () , self . ecdatl ())
            }
        }
        #[doc = "SPI Slave TX FIFO Byte Counter Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxfByteCnt(pub u32);
        impl TxfByteCnt {
            #[doc = "TX FIFO Byte Count Register."]
            #[inline(always)]
            pub const fn bcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "TX FIFO Byte Count Register."]
            #[inline(always)]
            pub fn set_bcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for TxfByteCnt {
            #[inline(always)]
            fn default() -> TxfByteCnt {
                TxfByteCnt(0)
            }
        }
        impl core::fmt::Debug for TxfByteCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxfByteCnt").field("bcnt", &self.bcnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxfByteCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxfByteCnt {{ bcnt: {=u16:?} }}", self.bcnt())
            }
        }
        #[doc = "SPI Slave TX FIFO Host Bar Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxfHostBar(pub u32);
        impl TxfHostBar {
            #[doc = "TX FIFO Host Bar Register."]
            #[inline(always)]
            pub const fn bar(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "TX FIFO Host Bar Register."]
            #[inline(always)]
            pub fn set_bar(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxfHostBar {
            #[inline(always)]
            fn default() -> TxfHostBar {
                TxfHostBar(0)
            }
        }
        impl core::fmt::Debug for TxfHostBar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxfHostBar").field("bar", &self.bar()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxfHostBar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxfHostBar {{ bar: {=u16:?} }}", self.bar())
            }
        }
    }
}
pub mod tach0 {
    #[doc = "This block monitors TACH output signals from various types of fans, and determines their speed"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tach0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Tach0 {}
    unsafe impl Sync for Tach0 {}
    impl Tach0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "TACHx Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "TACHx Status Register"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "TACH HIGH LIMIT Register"]
        #[inline(always)]
        pub const fn lim_hi(self) -> crate::common::Reg<regs::LimHi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "TACHx Low Limit Register"]
        #[inline(always)]
        pub const fn lim_lo(self) -> crate::common::Reg<regs::LimLo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "TACHx Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "TACH_OUT_OF_LIMIT_ENABLE This bit is used to enable the TACH_OUT_OF_LIMIT_STATUS bit in the TACHx Status Register to generate an interrupt event. 1=Enable interrupt output from Tach block 0=Disable interrupt output from Tach block (default)"]
            #[inline(always)]
            pub const fn outof_lim_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "TACH_OUT_OF_LIMIT_ENABLE This bit is used to enable the TACH_OUT_OF_LIMIT_STATUS bit in the TACHx Status Register to generate an interrupt event. 1=Enable interrupt output from Tach block 0=Disable interrupt output from Tach block (default)"]
            #[inline(always)]
            pub fn set_outof_lim_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "TACH_ENABLE 1= TACH Monitoring enabled, clocks enabled. 0= TACH Idle, clocks gated"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "TACH_ENABLE 1= TACH Monitoring enabled, clocks enabled. 0= TACH Idle, clocks gated"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "FILTER_ENABLE This filter is used to remove high frequency glitches from Tach Input. When this filter is enabled, Tach input pulses less than two 100kHz_- Clk periods wide get filtered. 1= Filter enabled 0= Filter disabled (default) It is recommended that the Tach input filter always be enabled."]
            #[inline(always)]
            pub const fn filt_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "FILTER_ENABLE This filter is used to remove high frequency glitches from Tach Input. When this filter is enabled, Tach input pulses less than two 100kHz_- Clk periods wide get filtered. 1= Filter enabled 0= Filter disabled (default) It is recommended that the Tach input filter always be enabled."]
            #[inline(always)]
            pub fn set_filt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "TACH_READING_MODE_SELECT 1=Counter is incremented on the rising edge of the 100kHz_Clk input. The counter is latched into the TACHX_COUNTER field and reset when the programmed number of edges is detected. 0=Counter is incremented when Tach Input transitions from low-tohigh state (default)"]
            #[inline(always)]
            pub const fn rd_mod_sel(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "TACH_READING_MODE_SELECT 1=Counter is incremented on the rising edge of the 100kHz_Clk input. The counter is latched into the TACHX_COUNTER field and reset when the programmed number of edges is detected. 0=Counter is incremented when Tach Input transitions from low-tohigh state (default)"]
            #[inline(always)]
            pub fn set_rd_mod_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "TACH_EDGES A Tach signal is a square wave with a 50 percent duty cycle. Typically, two Tach periods represents one revolution of the fan. A Tach period consists of three Tach edges. This programmed value represents the number of Tach edges that will be used to determine the interval for which the number of 100kHz_Clk pulses will be counted 11b=9 Tach edges (4 Tach periods) 10b=5 Tach edges (2 Tach periods) 01b=3 Tach edges (1 Tach period) 00b=2 Tach edges (1/2 Tach period)"]
            #[inline(always)]
            pub const fn edges(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x03;
                val as u8
            }
            #[doc = "TACH_EDGES A Tach signal is a square wave with a 50 percent duty cycle. Typically, two Tach periods represents one revolution of the fan. A Tach period consists of three Tach edges. This programmed value represents the number of Tach edges that will be used to determine the interval for which the number of 100kHz_Clk pulses will be counted 11b=9 Tach edges (4 Tach periods) 10b=5 Tach edges (2 Tach periods) 01b=3 Tach edges (1 Tach period) 00b=2 Tach edges (1/2 Tach period)"]
            #[inline(always)]
            pub fn set_edges(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 11usize)) | (((val as u32) & 0x03) << 11usize);
            }
            #[doc = "COUNT_READY_INT_EN 1=Enable Count Ready interrupt from Tach block, 0=Disable Count Ready interrupt from Tach block"]
            #[inline(always)]
            pub const fn cnt_rdy_int_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "COUNT_READY_INT_EN 1=Enable Count Ready interrupt from Tach block, 0=Disable Count Ready interrupt from Tach block"]
            #[inline(always)]
            pub fn set_cnt_rdy_int_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "TACH_INPUT_INT_EN 1=Enable Tach Input toggle interrupt from Tach block, 0=Disable Tach Input toggle interrupt from Tach block"]
            #[inline(always)]
            pub const fn in_int_en(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "TACH_INPUT_INT_EN 1=Enable Tach Input toggle interrupt from Tach block, 0=Disable Tach Input toggle interrupt from Tach block"]
            #[inline(always)]
            pub fn set_in_int_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "This 16-bit field contains the latched value of the internal Tach pulse counter, which may be configured by the Tach Reading Mode Select field to operate as a free-running counter or to be gated by the Tach input signal."]
            #[inline(always)]
            pub const fn cntr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This 16-bit field contains the latched value of the internal Tach pulse counter, which may be configured by the Tach Reading Mode Select field to operate as a free-running counter or to be gated by the Tach input signal."]
            #[inline(always)]
            pub fn set_cntr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("outof_lim_en", &self.outof_lim_en())
                    .field("en", &self.en())
                    .field("filt_en", &self.filt_en())
                    .field("rd_mod_sel", &self.rd_mod_sel())
                    .field("edges", &self.edges())
                    .field("cnt_rdy_int_en", &self.cnt_rdy_int_en())
                    .field("in_int_en", &self.in_int_en())
                    .field("cntr", &self.cntr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ outof_lim_en: {=bool:?}, en: {=bool:?}, filt_en: {=bool:?}, rd_mod_sel: {=bool:?}, edges: {=u8:?}, cnt_rdy_int_en: {=bool:?}, in_int_en: {=bool:?}, cntr: {=u16:?} }}" , self . outof_lim_en () , self . en () , self . filt_en () , self . rd_mod_sel () , self . edges () , self . cnt_rdy_int_en () , self . in_int_en () , self . cntr ())
            }
        }
        #[doc = "TACH HIGH LIMIT Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LimHi(pub u32);
        impl LimHi {
            #[doc = "This value is compared with the value in the TACHX_COUNTER field. If the value in the counter is greater than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS status event may be enabled to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx Control Register."]
            #[inline(always)]
            pub const fn t_high(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This value is compared with the value in the TACHX_COUNTER field. If the value in the counter is greater than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS status event may be enabled to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx Control Register."]
            #[inline(always)]
            pub fn set_t_high(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for LimHi {
            #[inline(always)]
            fn default() -> LimHi {
                LimHi(0)
            }
        }
        impl core::fmt::Debug for LimHi {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LimHi").field("t_high", &self.t_high()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LimHi {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LimHi {{ t_high: {=u16:?} }}", self.t_high())
            }
        }
        #[doc = "TACHx Low Limit Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LimLo(pub u32);
        impl LimLo {
            #[doc = "This value is compared with the value in the TACHX_COUNTER field of the TACHx Control Register. If the value in the counter is less than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS status event may be enabled to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx Control Register To disable the TACH_OUT_OF_LIMIT_STATUS low event, program 0000h into this register."]
            #[inline(always)]
            pub const fn t_low(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This value is compared with the value in the TACHX_COUNTER field of the TACHx Control Register. If the value in the counter is less than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS status event may be enabled to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx Control Register To disable the TACH_OUT_OF_LIMIT_STATUS low event, program 0000h into this register."]
            #[inline(always)]
            pub fn set_t_low(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for LimLo {
            #[inline(always)]
            fn default() -> LimLo {
                LimLo(0)
            }
        }
        impl core::fmt::Debug for LimLo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LimLo").field("t_low", &self.t_low()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LimLo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LimLo {{ t_low: {=u16:?} }}", self.t_low())
            }
        }
        #[doc = "TACHx Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "TACH_OUT_OF_LIMIT_STATUS 1=Tach is outside of limits, 0=Tach is within limits (R/WC)"]
            #[inline(always)]
            pub const fn outof_lim_sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "TACH_OUT_OF_LIMIT_STATUS 1=Tach is outside of limits, 0=Tach is within limits (R/WC)"]
            #[inline(always)]
            pub fn set_outof_lim_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "TACH_PIN_STATUS 1= Tach Input is high, 0= Tach Input is low"]
            #[inline(always)]
            pub const fn pin_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "TACH_PIN_STATUS 1= Tach Input is high, 0= Tach Input is low"]
            #[inline(always)]
            pub fn set_pin_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "TOGGLE_STATUS 1=Tach Input changed state (this bit is set on a low-to-high or high-tolow transition), 0=Tach stable (R/WC)"]
            #[inline(always)]
            pub const fn tog_sts(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "TOGGLE_STATUS 1=Tach Input changed state (this bit is set on a low-to-high or high-tolow transition), 0=Tach stable (R/WC)"]
            #[inline(always)]
            pub fn set_tog_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "COUNT_READY_STATUS 1=Reading ready, 0=Reading not ready"]
            #[inline(always)]
            pub const fn cnt_rdy_sts(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "COUNT_READY_STATUS 1=Reading ready, 0=Reading not ready"]
            #[inline(always)]
            pub fn set_cnt_rdy_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("outof_lim_sts", &self.outof_lim_sts())
                    .field("pin_sts", &self.pin_sts())
                    .field("tog_sts", &self.tog_sts())
                    .field("cnt_rdy_sts", &self.cnt_rdy_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sts {{ outof_lim_sts: {=bool:?}, pin_sts: {=bool:?}, tog_sts: {=bool:?}, cnt_rdy_sts: {=bool:?} }}" , self . outof_lim_sts () , self . pin_sts () , self . tog_sts () , self . cnt_rdy_sts ())
            }
        }
    }
}
pub mod tfdp {
    #[doc = "The TFDP serially transmits EC-originated diagnostic vectors to an external debug trace system."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tfdp {
        ptr: *mut u8,
    }
    unsafe impl Send for Tfdp {}
    unsafe impl Sync for Tfdp {}
    impl Tfdp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Debug data to be shifted out on the TFDP Debug port. While data is being shifted out, the Host Interface will 'hold-off' additional writes to the data register until the transfer is complete."]
        #[inline(always)]
        pub const fn msdata(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Debug Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Debug Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u8);
        impl Ctrl {
            #[doc = "Enable. 1=Clock enabled, 0=Clock is disabled (Default)"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable. 1=Clock enabled, 0=Clock is disabled (Default)"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "1= Data is shifted out on the falling edge of the debug clock, 0= Data is shifted out on the rising edge of the debug clock (Default)"]
            #[inline(always)]
            pub const fn edge_sel(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1= Data is shifted out on the falling edge of the debug clock, 0= Data is shifted out on the rising edge of the debug clock (Default)"]
            #[inline(always)]
            pub fn set_edge_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Clock Divider Select."]
            #[inline(always)]
            pub const fn divsel(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "Clock Divider Select."]
            #[inline(always)]
            pub fn set_divsel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "Inter-packet Delay. The delay is in terms of TFDP Debug output clocks."]
            #[inline(always)]
            pub const fn ip_dly(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "Inter-packet Delay. The delay is in terms of TFDP Debug output clocks."]
            #[inline(always)]
            pub fn set_ip_dly(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("en", &self.en())
                    .field("edge_sel", &self.edge_sel())
                    .field("divsel", &self.divsel())
                    .field("ip_dly", &self.ip_dly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl {{ en: {=bool:?}, edge_sel: {=bool:?}, divsel: {=u8:?}, ip_dly: {=u8:?} }}",
                    self.en(),
                    self.edge_sel(),
                    self.divsel(),
                    self.ip_dly()
                )
            }
        }
    }
}
pub mod timer16_0 {
    #[doc = "This 16-bit timer block offers a simple mechanism for firmware to maintain a time base."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Timer160 {
        ptr: *mut u8,
    }
    unsafe impl Send for Timer160 {}
    unsafe impl Sync for Timer160 {}
    impl Timer160 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This is the value of the Timer counter."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is Timer pre-load for the counter."]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the interrupt status that fires when the timer reaches its limit"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the WDT Interrupt Enable Register"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Timer Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This enables the block for operation. 1=This block will function normally; 0=This block will gate its clock and go into its lowest power state"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the block for operation. 1=This block will function normally; 0=This block will gate its clock and go into its lowest power state"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment; 0=The counter will decrement"]
            #[inline(always)]
            pub const fn cnt_up(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment; 0=The counter will decrement"]
            #[inline(always)]
            pub fn set_cnt_up(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This will select the action taken upon completing a count. 1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register. The interrupt will be set in edge mode 0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."]
            #[inline(always)]
            pub const fn au_restrt(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This will select the action taken upon completing a count. 1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register. The interrupt will be set in edge mode 0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."]
            #[inline(always)]
            pub fn set_au_restrt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need to wait before reconfiguring the Basic Timer following soft reset."]
            #[inline(always)]
            pub const fn sft_rst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need to wait before reconfiguring the Basic Timer following soft reset."]
            #[inline(always)]
            pub fn set_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so this bit will never clear. Clearing this bit will halt the timer counter."]
            #[inline(always)]
            pub const fn strt(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so this bit will never clear. Clearing this bit will halt the timer counter."]
            #[inline(always)]
            pub fn set_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit reloads the counter without interrupting it operation. This will not function if the timer has already completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an event occurs. Usage while the timer is off may result in erroneous behaviour."]
            #[inline(always)]
            pub const fn rld(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reloads the counter without interrupting it operation. This will not function if the timer has already completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an event occurs. Usage while the timer is off may result in erroneous behaviour."]
            #[inline(always)]
            pub fn set_rld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."]
            #[inline(always)]
            pub const fn hlt(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."]
            #[inline(always)]
            pub fn set_hlt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts. The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1 runs at half speed."]
            #[inline(always)]
            pub const fn prescale(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts. The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1 runs at half speed."]
            #[inline(always)]
            pub fn set_prescale(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("en", &self.en())
                    .field("cnt_up", &self.cnt_up())
                    .field("au_restrt", &self.au_restrt())
                    .field("sft_rst", &self.sft_rst())
                    .field("strt", &self.strt())
                    .field("rld", &self.rld())
                    .field("hlt", &self.hlt())
                    .field("prescale", &self.prescale())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ en: {=bool:?}, cnt_up: {=bool:?}, au_restrt: {=bool:?}, sft_rst: {=bool:?}, strt: {=bool:?}, rld: {=bool:?}, hlt: {=bool:?}, prescale: {=u16:?} }}" , self . en () , self . cnt_up () , self . au_restrt () , self . sft_rst () , self . strt () , self . rld () , self . hlt () , self . prescale ())
            }
        }
        #[doc = "This is the WDT Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u32);
        impl Ien {
            #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ien {{ en: {=bool:?} }}", self.en())
            }
        }
        #[doc = "This is the interrupt status that fires when the timer reaches its limit"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer Control Register."]
            #[inline(always)]
            pub const fn evt_int(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer Control Register."]
            #[inline(always)]
            pub fn set_evt_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts").field("evt_int", &self.evt_int()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sts {{ evt_int: {=bool:?} }}", self.evt_int())
            }
        }
    }
}
pub mod timer32_0 {
    #[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Timer320 {
        ptr: *mut u8,
    }
    unsafe impl Send for Timer320 {}
    unsafe impl Sync for Timer320 {}
    impl Timer320 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This is the value of the Timer counter. This is updated by Hardware but may be set by Firmware."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the value of the Timer pre-load for the counter. This is used by H/W when the counter is to be restarted automatically; this will become the new value of the counter upon restart."]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the interrupt status that fires when the timer reaches its limit"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Timer Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This enables the block for operation. 1=This block will function normally; 0=This block will gate its clock and go into its lowest power state"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the block for operation. 1=This block will function normally; 0=This block will gate its clock and go into its lowest power state"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment; 0=The counter will decrement"]
            #[inline(always)]
            pub const fn cnt_up(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment; 0=The counter will decrement"]
            #[inline(always)]
            pub fn set_cnt_up(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This will select the action taken upon completing a count. 1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register. The interrupt will be set in edge mode 0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."]
            #[inline(always)]
            pub const fn au_restrt(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This will select the action taken upon completing a count. 1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register. The interrupt will be set in edge mode 0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."]
            #[inline(always)]
            pub fn set_au_restrt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need to wait before reconfiguring the Basic Timer following soft reset."]
            #[inline(always)]
            pub const fn sft_rst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need to wait before reconfiguring the Basic Timer following soft reset."]
            #[inline(always)]
            pub fn set_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so this bit will never clear. Clearing this bit will halt the timer counter."]
            #[inline(always)]
            pub const fn strt(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so this bit will never clear. Clearing this bit will halt the timer counter."]
            #[inline(always)]
            pub fn set_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit reloads the counter without interrupting it operation. This will not function if the timer has already completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an event occurs. Usage while the timer is off may result in erroneous behaviour."]
            #[inline(always)]
            pub const fn rld(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reloads the counter without interrupting it operation. This will not function if the timer has already completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an event occurs. Usage while the timer is off may result in erroneous behaviour."]
            #[inline(always)]
            pub fn set_rld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."]
            #[inline(always)]
            pub const fn hlt(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."]
            #[inline(always)]
            pub fn set_hlt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts. The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1 runs at half speed."]
            #[inline(always)]
            pub const fn prescale(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts. The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1 runs at half speed."]
            #[inline(always)]
            pub fn set_prescale(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("en", &self.en())
                    .field("cnt_up", &self.cnt_up())
                    .field("au_restrt", &self.au_restrt())
                    .field("sft_rst", &self.sft_rst())
                    .field("strt", &self.strt())
                    .field("rld", &self.rld())
                    .field("hlt", &self.hlt())
                    .field("prescale", &self.prescale())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ en: {=bool:?}, cnt_up: {=bool:?}, au_restrt: {=bool:?}, sft_rst: {=bool:?}, strt: {=bool:?}, rld: {=bool:?}, hlt: {=bool:?}, prescale: {=u16:?} }}" , self . en () , self . cnt_up () , self . au_restrt () , self . sft_rst () , self . strt () , self . rld () , self . hlt () , self . prescale ())
            }
        }
        #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u32);
        impl Ien {
            #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ien {{ en: {=bool:?} }}", self.en())
            }
        }
        #[doc = "This is the interrupt status that fires when the timer reaches its limit"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)"]
            #[inline(always)]
            pub const fn evt_int(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)"]
            #[inline(always)]
            pub fn set_evt_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts").field("evt_int", &self.evt_int()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sts {{ evt_int: {=bool:?} }}", self.evt_int())
            }
        }
    }
}
pub mod uart0 {
    #[doc = "UART when DLAB=0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Data {
        ptr: *mut u8,
    }
    unsafe impl Send for Data {}
    unsafe impl Sync for Data {}
    impl Data {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "UART Receive (Read) Buffer Register (DLAB=0)"]
        #[inline(always)]
        pub const fn rx_dat(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART Transmit (Write) Buffer Register (DLAB=0)"]
        #[inline(always)]
        pub const fn tx_dat(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART Interrupt Enable Register (DLAB=0)"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "UART FIFO Control Register"]
        #[inline(always)]
        pub const fn fifo_cr(self) -> crate::common::Reg<regs::DataFifoCr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[inline(always)]
        pub const fn int_id(self) -> crate::common::Reg<regs::DataIntId, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Line Control Register"]
        #[inline(always)]
        pub const fn lcr(self) -> crate::common::Reg<regs::DataLcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "UART Modem Control Register"]
        #[inline(always)]
        pub const fn mcr(self) -> crate::common::Reg<regs::DataMcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "UART Line Status Register"]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::DataLsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "UART Modem Status Register"]
        #[inline(always)]
        pub const fn msr(self) -> crate::common::Reg<regs::DataMsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "UART Scratchpad Register This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily."]
        #[inline(always)]
        pub const fn scr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "UART Activate Register. \\[0:0\\] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "UART Config Select Register"]
        #[inline(always)]
        pub const fn cfg_sel(self) -> crate::common::Reg<regs::DataCfgSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03f0usize) as _) }
        }
    }
    #[doc = "UART when DLAB=1"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dlab {
        ptr: *mut u8,
    }
    unsafe impl Send for Dlab {}
    unsafe impl Sync for Dlab {}
    impl Dlab {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "UART Programmable BAUD Rate Generator (LSB) Register (DLAB=1)"]
        #[inline(always)]
        pub const fn baudrt_lsb(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART Programmable BAUD Rate Generator (MSB) Register (DLAB=1). \\[6:0\\] BAUD_RATE_DIVISOR_MSB, \\[7:7\\] BAUD_CLK_SEL 1=If CLK_SRC is '0', the baud clock is derived from the 1.8432MHz_Clk. If CLK_SRC is '1', this bit has no effect 0=If CLK_SRC is '0', the baud clock is derived from the 24MHz_Clk. If CLK_SRC is '1', this bit has no effect"]
        #[inline(always)]
        pub const fn baudrt_msb(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "UART FIFO Control Register"]
        #[inline(always)]
        pub const fn fifo_cr(self) -> crate::common::Reg<regs::DlabFifoCr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[inline(always)]
        pub const fn int_id(self) -> crate::common::Reg<regs::DlabIntId, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Line Control Register"]
        #[inline(always)]
        pub const fn lcr(self) -> crate::common::Reg<regs::DlabLcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "UART Modem Control Register"]
        #[inline(always)]
        pub const fn mcr(self) -> crate::common::Reg<regs::DlabMcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "UART Line Status Register"]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::DlabLsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "UART Modem Status Register"]
        #[inline(always)]
        pub const fn msr(self) -> crate::common::Reg<regs::DlabMsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "UART Scratchpad Register This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily."]
        #[inline(always)]
        pub const fn scr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "UART Activate Register. \\[0:0\\] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "UART Config Select Register"]
        #[inline(always)]
        pub const fn cfg_sel(self) -> crate::common::Reg<regs::DlabCfgSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03f0usize) as _) }
        }
    }
    #[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uart0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Uart0 {}
    unsafe impl Sync for Uart0 {}
    impl Uart0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "UART when DLAB=0"]
        #[inline(always)]
        pub const fn data(self) -> Data {
            unsafe { Data::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART when DLAB=1"]
        #[inline(always)]
        pub const fn dlab(self) -> Dlab {
            unsafe { Dlab::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "UART Config Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataCfgSel(pub u8);
        impl DataCfgSel {
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub const fn clk_src(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub fn set_clk_src(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub const fn pwr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub fn set_pwr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub const fn polar(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub fn set_polar(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for DataCfgSel {
            #[inline(always)]
            fn default() -> DataCfgSel {
                DataCfgSel(0)
            }
        }
        impl core::fmt::Debug for DataCfgSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataCfgSel")
                    .field("clk_src", &self.clk_src())
                    .field("pwr", &self.pwr())
                    .field("polar", &self.polar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataCfgSel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DataCfgSel {{ clk_src: {=bool:?}, pwr: {=bool:?}, polar: {=bool:?} }}",
                    self.clk_src(),
                    self.pwr(),
                    self.polar()
                )
            }
        }
        #[doc = "UART FIFO Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataFifoCr(pub u8);
        impl DataFifoCr {
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub const fn exrf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub fn set_exrf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub const fn clr_recv_fifo(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub fn set_clr_recv_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub const fn clr_xmit_fifo(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub fn set_clr_xmit_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub const fn dma_mode_sel(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub fn set_dma_mode_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub const fn recv_fifo_trig_lvl(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub fn set_recv_fifo_trig_lvl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DataFifoCr {
            #[inline(always)]
            fn default() -> DataFifoCr {
                DataFifoCr(0)
            }
        }
        impl core::fmt::Debug for DataFifoCr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataFifoCr")
                    .field("exrf", &self.exrf())
                    .field("clr_recv_fifo", &self.clr_recv_fifo())
                    .field("clr_xmit_fifo", &self.clr_xmit_fifo())
                    .field("dma_mode_sel", &self.dma_mode_sel())
                    .field("recv_fifo_trig_lvl", &self.recv_fifo_trig_lvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataFifoCr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataFifoCr {{ exrf: {=bool:?}, clr_recv_fifo: {=bool:?}, clr_xmit_fifo: {=bool:?}, dma_mode_sel: {=bool:?}, recv_fifo_trig_lvl: {=u8:?} }}" , self . exrf () , self . clr_recv_fifo () , self . clr_xmit_fifo () , self . dma_mode_sel () , self . recv_fifo_trig_lvl ())
            }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataIntId(pub u8);
        impl DataIntId {
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub const fn ipend(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub fn set_ipend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub const fn intid(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub fn set_intid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u8) & 0x07) << 1usize);
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub const fn fifo_en(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub fn set_fifo_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DataIntId {
            #[inline(always)]
            fn default() -> DataIntId {
                DataIntId(0)
            }
        }
        impl core::fmt::Debug for DataIntId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataIntId")
                    .field("ipend", &self.ipend())
                    .field("intid", &self.intid())
                    .field("fifo_en", &self.fifo_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataIntId {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DataIntId {{ ipend: {=bool:?}, intid: {=u8:?}, fifo_en: {=u8:?} }}",
                    self.ipend(),
                    self.intid(),
                    self.fifo_en()
                )
            }
        }
        #[doc = "UART Line Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataLcr(pub u8);
        impl DataLcr {
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn word_len(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_word_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn stop_bits(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_stop_bits(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub const fn en_par(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub fn set_en_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub const fn par_sel(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub fn set_par_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub const fn stick_par(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub fn set_stick_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub const fn brk_ctrl(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub fn set_brk_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub const fn dlab(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub fn set_dlab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DataLcr {
            #[inline(always)]
            fn default() -> DataLcr {
                DataLcr(0)
            }
        }
        impl core::fmt::Debug for DataLcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataLcr")
                    .field("word_len", &self.word_len())
                    .field("stop_bits", &self.stop_bits())
                    .field("en_par", &self.en_par())
                    .field("par_sel", &self.par_sel())
                    .field("stick_par", &self.stick_par())
                    .field("brk_ctrl", &self.brk_ctrl())
                    .field("dlab", &self.dlab())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataLcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataLcr {{ word_len: {=u8:?}, stop_bits: {=bool:?}, en_par: {=bool:?}, par_sel: {=bool:?}, stick_par: {=bool:?}, brk_ctrl: {=bool:?}, dlab: {=bool:?} }}" , self . word_len () , self . stop_bits () , self . en_par () , self . par_sel () , self . stick_par () , self . brk_ctrl () , self . dlab ())
            }
        }
        #[doc = "UART Line Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataLsr(pub u8);
        impl DataLsr {
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub const fn data_ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub fn set_data_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub const fn pe(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub fn set_pe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub const fn frame_err(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub fn set_frame_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub const fn brk_intr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub fn set_brk_intr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub const fn trans_empty(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub fn set_trans_empty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub const fn trans_err(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub fn set_trans_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub const fn fifo_err(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub fn set_fifo_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DataLsr {
            #[inline(always)]
            fn default() -> DataLsr {
                DataLsr(0)
            }
        }
        impl core::fmt::Debug for DataLsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataLsr")
                    .field("data_ready", &self.data_ready())
                    .field("overrun", &self.overrun())
                    .field("pe", &self.pe())
                    .field("frame_err", &self.frame_err())
                    .field("brk_intr", &self.brk_intr())
                    .field("trans_empty", &self.trans_empty())
                    .field("trans_err", &self.trans_err())
                    .field("fifo_err", &self.fifo_err())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataLsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataLsr {{ data_ready: {=bool:?}, overrun: {=bool:?}, pe: {=bool:?}, frame_err: {=bool:?}, brk_intr: {=bool:?}, trans_empty: {=bool:?}, trans_err: {=bool:?}, fifo_err: {=bool:?} }}" , self . data_ready () , self . overrun () , self . pe () , self . frame_err () , self . brk_intr () , self . trans_empty () , self . trans_err () , self . fifo_err ())
            }
        }
        #[doc = "UART Modem Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataMcr(pub u8);
        impl DataMcr {
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub const fn dtr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub fn set_dtr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub const fn rts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub fn set_rts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub const fn out1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub fn set_out1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub const fn out2(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub fn set_out2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub const fn loopback(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub fn set_loopback(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for DataMcr {
            #[inline(always)]
            fn default() -> DataMcr {
                DataMcr(0)
            }
        }
        impl core::fmt::Debug for DataMcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataMcr")
                    .field("dtr", &self.dtr())
                    .field("rts", &self.rts())
                    .field("out1", &self.out1())
                    .field("out2", &self.out2())
                    .field("loopback", &self.loopback())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataMcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataMcr {{ dtr: {=bool:?}, rts: {=bool:?}, out1: {=bool:?}, out2: {=bool:?}, loopback: {=bool:?} }}" , self . dtr () , self . rts () , self . out1 () , self . out2 () , self . loopback ())
            }
        }
        #[doc = "UART Modem Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataMsr(pub u8);
        impl DataMsr {
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub const fn cts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub fn set_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub const fn dsr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub fn set_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub const fn ri(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub fn set_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub const fn dcd(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub fn set_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub const fn n_cts(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub fn set_n_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub const fn n_dsr(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub fn set_n_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub const fn n_ri(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub fn set_n_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub const fn n_dcd(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub fn set_n_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DataMsr {
            #[inline(always)]
            fn default() -> DataMsr {
                DataMsr(0)
            }
        }
        impl core::fmt::Debug for DataMsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataMsr")
                    .field("cts", &self.cts())
                    .field("dsr", &self.dsr())
                    .field("ri", &self.ri())
                    .field("dcd", &self.dcd())
                    .field("n_cts", &self.n_cts())
                    .field("n_dsr", &self.n_dsr())
                    .field("n_ri", &self.n_ri())
                    .field("n_dcd", &self.n_dcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataMsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataMsr {{ cts: {=bool:?}, dsr: {=bool:?}, ri: {=bool:?}, dcd: {=bool:?}, n_cts: {=bool:?}, n_dsr: {=bool:?}, n_ri: {=bool:?}, n_dcd: {=bool:?} }}" , self . cts () , self . dsr () , self . ri () , self . dcd () , self . n_cts () , self . n_dsr () , self . n_ri () , self . n_dcd ())
            }
        }
        #[doc = "UART Config Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabCfgSel(pub u8);
        impl DlabCfgSel {
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub const fn clk_src(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub fn set_clk_src(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub const fn pwr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub fn set_pwr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub const fn polar(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub fn set_polar(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for DlabCfgSel {
            #[inline(always)]
            fn default() -> DlabCfgSel {
                DlabCfgSel(0)
            }
        }
        impl core::fmt::Debug for DlabCfgSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabCfgSel")
                    .field("clk_src", &self.clk_src())
                    .field("pwr", &self.pwr())
                    .field("polar", &self.polar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabCfgSel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DlabCfgSel {{ clk_src: {=bool:?}, pwr: {=bool:?}, polar: {=bool:?} }}",
                    self.clk_src(),
                    self.pwr(),
                    self.polar()
                )
            }
        }
        #[doc = "UART FIFO Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabFifoCr(pub u8);
        impl DlabFifoCr {
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub const fn exrf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub fn set_exrf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub const fn clr_recv_fifo(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub fn set_clr_recv_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub const fn clr_xmit_fifo(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub fn set_clr_xmit_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub const fn dma_mode_sel(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub fn set_dma_mode_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub const fn recv_fifo_trig_lvl(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub fn set_recv_fifo_trig_lvl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DlabFifoCr {
            #[inline(always)]
            fn default() -> DlabFifoCr {
                DlabFifoCr(0)
            }
        }
        impl core::fmt::Debug for DlabFifoCr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabFifoCr")
                    .field("exrf", &self.exrf())
                    .field("clr_recv_fifo", &self.clr_recv_fifo())
                    .field("clr_xmit_fifo", &self.clr_xmit_fifo())
                    .field("dma_mode_sel", &self.dma_mode_sel())
                    .field("recv_fifo_trig_lvl", &self.recv_fifo_trig_lvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabFifoCr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabFifoCr {{ exrf: {=bool:?}, clr_recv_fifo: {=bool:?}, clr_xmit_fifo: {=bool:?}, dma_mode_sel: {=bool:?}, recv_fifo_trig_lvl: {=u8:?} }}" , self . exrf () , self . clr_recv_fifo () , self . clr_xmit_fifo () , self . dma_mode_sel () , self . recv_fifo_trig_lvl ())
            }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabIntId(pub u8);
        impl DlabIntId {
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub const fn ipend(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub fn set_ipend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub const fn intid(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub fn set_intid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u8) & 0x07) << 1usize);
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub const fn fifo_en(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub fn set_fifo_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DlabIntId {
            #[inline(always)]
            fn default() -> DlabIntId {
                DlabIntId(0)
            }
        }
        impl core::fmt::Debug for DlabIntId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabIntId")
                    .field("ipend", &self.ipend())
                    .field("intid", &self.intid())
                    .field("fifo_en", &self.fifo_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabIntId {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DlabIntId {{ ipend: {=bool:?}, intid: {=u8:?}, fifo_en: {=u8:?} }}",
                    self.ipend(),
                    self.intid(),
                    self.fifo_en()
                )
            }
        }
        #[doc = "UART Line Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabLcr(pub u8);
        impl DlabLcr {
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn word_len(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_word_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn stop_bits(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_stop_bits(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub const fn en_par(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub fn set_en_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub const fn par_sel(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub fn set_par_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub const fn stick_par(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub fn set_stick_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub const fn brk_ctrl(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub fn set_brk_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub const fn dlab(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub fn set_dlab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DlabLcr {
            #[inline(always)]
            fn default() -> DlabLcr {
                DlabLcr(0)
            }
        }
        impl core::fmt::Debug for DlabLcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabLcr")
                    .field("word_len", &self.word_len())
                    .field("stop_bits", &self.stop_bits())
                    .field("en_par", &self.en_par())
                    .field("par_sel", &self.par_sel())
                    .field("stick_par", &self.stick_par())
                    .field("brk_ctrl", &self.brk_ctrl())
                    .field("dlab", &self.dlab())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabLcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabLcr {{ word_len: {=u8:?}, stop_bits: {=bool:?}, en_par: {=bool:?}, par_sel: {=bool:?}, stick_par: {=bool:?}, brk_ctrl: {=bool:?}, dlab: {=bool:?} }}" , self . word_len () , self . stop_bits () , self . en_par () , self . par_sel () , self . stick_par () , self . brk_ctrl () , self . dlab ())
            }
        }
        #[doc = "UART Line Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabLsr(pub u8);
        impl DlabLsr {
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub const fn data_ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub fn set_data_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub const fn pe(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub fn set_pe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub const fn frame_err(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub fn set_frame_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub const fn brk_intr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub fn set_brk_intr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub const fn trans_empty(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub fn set_trans_empty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub const fn trans_err(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub fn set_trans_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub const fn fifo_err(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub fn set_fifo_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DlabLsr {
            #[inline(always)]
            fn default() -> DlabLsr {
                DlabLsr(0)
            }
        }
        impl core::fmt::Debug for DlabLsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabLsr")
                    .field("data_ready", &self.data_ready())
                    .field("overrun", &self.overrun())
                    .field("pe", &self.pe())
                    .field("frame_err", &self.frame_err())
                    .field("brk_intr", &self.brk_intr())
                    .field("trans_empty", &self.trans_empty())
                    .field("trans_err", &self.trans_err())
                    .field("fifo_err", &self.fifo_err())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabLsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabLsr {{ data_ready: {=bool:?}, overrun: {=bool:?}, pe: {=bool:?}, frame_err: {=bool:?}, brk_intr: {=bool:?}, trans_empty: {=bool:?}, trans_err: {=bool:?}, fifo_err: {=bool:?} }}" , self . data_ready () , self . overrun () , self . pe () , self . frame_err () , self . brk_intr () , self . trans_empty () , self . trans_err () , self . fifo_err ())
            }
        }
        #[doc = "UART Modem Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabMcr(pub u8);
        impl DlabMcr {
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub const fn dtr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub fn set_dtr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub const fn rts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub fn set_rts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub const fn out1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub fn set_out1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub const fn out2(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub fn set_out2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub const fn loopback(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub fn set_loopback(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for DlabMcr {
            #[inline(always)]
            fn default() -> DlabMcr {
                DlabMcr(0)
            }
        }
        impl core::fmt::Debug for DlabMcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabMcr")
                    .field("dtr", &self.dtr())
                    .field("rts", &self.rts())
                    .field("out1", &self.out1())
                    .field("out2", &self.out2())
                    .field("loopback", &self.loopback())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabMcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabMcr {{ dtr: {=bool:?}, rts: {=bool:?}, out1: {=bool:?}, out2: {=bool:?}, loopback: {=bool:?} }}" , self . dtr () , self . rts () , self . out1 () , self . out2 () , self . loopback ())
            }
        }
        #[doc = "UART Modem Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabMsr(pub u8);
        impl DlabMsr {
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub const fn cts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub fn set_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub const fn dsr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub fn set_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub const fn ri(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub fn set_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub const fn dcd(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub fn set_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub const fn n_cts(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub fn set_n_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub const fn n_dsr(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub fn set_n_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub const fn n_ri(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub fn set_n_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub const fn n_dcd(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub fn set_n_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DlabMsr {
            #[inline(always)]
            fn default() -> DlabMsr {
                DlabMsr(0)
            }
        }
        impl core::fmt::Debug for DlabMsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabMsr")
                    .field("cts", &self.cts())
                    .field("dsr", &self.dsr())
                    .field("ri", &self.ri())
                    .field("dcd", &self.dcd())
                    .field("n_cts", &self.n_cts())
                    .field("n_dsr", &self.n_dsr())
                    .field("n_ri", &self.n_ri())
                    .field("n_dcd", &self.n_dcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabMsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabMsr {{ cts: {=bool:?}, dsr: {=bool:?}, ri: {=bool:?}, dcd: {=bool:?}, n_cts: {=bool:?}, n_dsr: {=bool:?}, n_ri: {=bool:?}, n_dcd: {=bool:?} }}" , self . cts () , self . dsr () , self . ri () , self . dcd () , self . n_cts () , self . n_dsr () , self . n_ri () , self . n_dcd ())
            }
        }
        #[doc = "UART Interrupt Enable Register (DLAB=0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "ERDAI This bit enables the Received Data Available Interrupt (and timeout interrupts in the FIFO mode) when set to logic '1'."]
            #[inline(always)]
            pub const fn erdai(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "ERDAI This bit enables the Received Data Available Interrupt (and timeout interrupts in the FIFO mode) when set to logic '1'."]
            #[inline(always)]
            pub fn set_erdai(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "ETHREI This bit enables the Transmitter Holding Register Empty Interrupt when set to logic '1'."]
            #[inline(always)]
            pub const fn ethrei(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "ETHREI This bit enables the Transmitter Holding Register Empty Interrupt when set to logic '1'."]
            #[inline(always)]
            pub fn set_ethrei(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "ELSI This bit enables the Received Line Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub const fn elsi(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "ELSI This bit enables the Received Line Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub fn set_elsi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "EMSI This bit enables the MODEM Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub const fn emsi(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "EMSI This bit enables the MODEM Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub fn set_emsi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("erdai", &self.erdai())
                    .field("ethrei", &self.ethrei())
                    .field("elsi", &self.elsi())
                    .field("emsi", &self.emsi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ erdai: {=bool:?}, ethrei: {=bool:?}, elsi: {=bool:?}, emsi: {=bool:?} }}",
                    self.erdai(),
                    self.ethrei(),
                    self.elsi(),
                    self.emsi()
                )
            }
        }
    }
}
pub mod vbat {
    #[doc = "The VBAT Register Bank block is a block implemented for miscellaneous battery-backed registers."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vbat {
        ptr: *mut u8,
    }
    unsafe impl Send for Vbat {}
    unsafe impl Sync for Vbat {}
    impl Vbat {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The Power-Fail and Reset Status Register collects and retains the VBAT RST and WDT event status when VCC1 is unpowered."]
        #[inline(always)]
        pub const fn pfrs(self) -> crate::common::Reg<regs::Pfrs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "32KHz Clock Enable Register"]
        #[inline(always)]
        pub const fn clk_en(self) -> crate::common::Reg<regs::ClkEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "MONOTONIC COUNTER"]
        #[inline(always)]
        pub const fn mcnt_lo(self) -> crate::common::Reg<regs::McntLo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "COUNTER HIWORD"]
        #[inline(always)]
        pub const fn mcnt_hi(self) -> crate::common::Reg<regs::McntHi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Embedded Reset Debouce Enable."]
        #[inline(always)]
        pub const fn emdrst_dbnc_en(self) -> crate::common::Reg<regs::EmdrstDbncEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "32KHz Clock Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkEn(pub u32);
        impl ClkEn {
            #[doc = "This is a test bit and must not be modified."]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is a test bit and must not be modified."]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "XTAL Enable Enables/Starts the XTAL clock operation."]
            #[inline(always)]
            pub const fn xtal_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "XTAL Enable Enables/Starts the XTAL clock operation."]
            #[inline(always)]
            pub fn set_xtal_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This bit selects between a single-ended clock source for the crystal oscillator or an external parallel crystal. 1= the Crystal Oscillator is driven by a single-ended 32KHz clock source connected to the XTAL2 pin. 0= the Crystal Oscillator requires a 32KHz parallel resonant crystal connected between the XTAL1 and XTAL2 pins (default)."]
            #[inline(always)]
            pub const fn xosel(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects between a single-ended clock source for the crystal oscillator or an external parallel crystal. 1= the Crystal Oscillator is driven by a single-ended 32KHz clock source connected to the XTAL2 pin. 0= the Crystal Oscillator requires a 32KHz parallel resonant crystal connected between the XTAL1 and XTAL2 pins (default)."]
            #[inline(always)]
            pub fn set_xosel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "XTAL Startup Disable When enabled the XTAL, in Dual-Ended Mode, will enter a low power mode."]
            #[inline(always)]
            pub const fn xstrtp_dis(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "XTAL Startup Disable When enabled the XTAL, in Dual-Ended Mode, will enter a low power mode."]
            #[inline(always)]
            pub fn set_xstrtp_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "XTAL Gain Control 0 = Original Gain. 1 or 2=Gain reduced. 3= Gain is smallest."]
            #[inline(always)]
            pub const fn xtal_ctrl(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x03;
                val as u8
            }
            #[doc = "XTAL Gain Control 0 = Original Gain. 1 or 2=Gain reduced. 3= Gain is smallest."]
            #[inline(always)]
            pub fn set_xtal_ctrl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 11usize)) | (((val as u32) & 0x03) << 11usize);
            }
            #[doc = "MUX Select for the source of the 32kHz Peripheral Clock."]
            #[inline(always)]
            pub const fn prphl_32khz_clk(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x03;
                val as u8
            }
            #[doc = "MUX Select for the source of the 32kHz Peripheral Clock."]
            #[inline(always)]
            pub fn set_prphl_32khz_clk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 16usize)) | (((val as u32) & 0x03) << 16usize);
            }
            #[doc = "When enabled the Internal 32kHz VBAT clock source is suppressed (disabled) when VTR goes down."]
            #[inline(always)]
            pub const fn iclk_sprs(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "When enabled the Internal 32kHz VBAT clock source is suppressed (disabled) when VTR goes down."]
            #[inline(always)]
            pub fn set_iclk_sprs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for ClkEn {
            #[inline(always)]
            fn default() -> ClkEn {
                ClkEn(0)
            }
        }
        impl core::fmt::Debug for ClkEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkEn")
                    .field("test", &self.test())
                    .field("xtal_en", &self.xtal_en())
                    .field("xosel", &self.xosel())
                    .field("xstrtp_dis", &self.xstrtp_dis())
                    .field("xtal_ctrl", &self.xtal_ctrl())
                    .field("prphl_32khz_clk", &self.prphl_32khz_clk())
                    .field("iclk_sprs", &self.iclk_sprs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkEn {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkEn {{ test: {=bool:?}, xtal_en: {=bool:?}, xosel: {=bool:?}, xstrtp_dis: {=bool:?}, xtal_ctrl: {=u8:?}, prphl_32khz_clk: {=u8:?}, iclk_sprs: {=bool:?} }}" , self . test () , self . xtal_en () , self . xosel () , self . xstrtp_dis () , self . xtal_ctrl () , self . prphl_32khz_clk () , self . iclk_sprs ())
            }
        }
        #[doc = "Embedded Reset Debouce Enable."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EmdrstDbncEn(pub u32);
        impl EmdrstDbncEn {
            #[doc = "Embedded Reset Debouce Enable. 0 = Disable 1 = Enable"]
            #[inline(always)]
            pub const fn dbnc_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Embedded Reset Debouce Enable. 0 = Disable 1 = Enable"]
            #[inline(always)]
            pub fn set_dbnc_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EmdrstDbncEn {
            #[inline(always)]
            fn default() -> EmdrstDbncEn {
                EmdrstDbncEn(0)
            }
        }
        impl core::fmt::Debug for EmdrstDbncEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EmdrstDbncEn")
                    .field("dbnc_en", &self.dbnc_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EmdrstDbncEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EmdrstDbncEn {{ dbnc_en: {=bool:?} }}", self.dbnc_en())
            }
        }
        #[doc = "COUNTER HIWORD"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct McntHi(pub u32);
        impl McntHi {
            #[doc = "Thirty-two bit read/write register. If software sets this register to an incrementing value, based on an external non-volatile store, this register may be combined with the Monotonic Counter Register to form a 64-bit monotonic counter."]
            #[inline(always)]
            pub const fn cntr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Thirty-two bit read/write register. If software sets this register to an incrementing value, based on an external non-volatile store, this register may be combined with the Monotonic Counter Register to form a 64-bit monotonic counter."]
            #[inline(always)]
            pub fn set_cntr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for McntHi {
            #[inline(always)]
            fn default() -> McntHi {
                McntHi(0)
            }
        }
        impl core::fmt::Debug for McntHi {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("McntHi").field("cntr", &self.cntr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for McntHi {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "McntHi {{ cntr: {=u32:?} }}", self.cntr())
            }
        }
        #[doc = "MONOTONIC COUNTER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct McntLo(pub u32);
        impl McntLo {
            #[doc = "Read-only register that increments by 1 every time it is read. It is reset to 0 on a VBAT Power On Reset."]
            #[inline(always)]
            pub const fn cntr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Read-only register that increments by 1 every time it is read. It is reset to 0 on a VBAT Power On Reset."]
            #[inline(always)]
            pub fn set_cntr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for McntLo {
            #[inline(always)]
            fn default() -> McntLo {
                McntLo(0)
            }
        }
        impl core::fmt::Debug for McntLo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("McntLo").field("cntr", &self.cntr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for McntLo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "McntLo {{ cntr: {=u32:?} }}", self.cntr())
            }
        }
        #[doc = "The Power-Fail and Reset Status Register collects and retains the VBAT RST and WDT event status when VCC1 is unpowered."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pfrs(pub u8);
        impl Pfrs {
            #[doc = "This bit is set to '1b' if a was triggered by an assertion of the SOFT_SYS_RESET bit in the System Reset Register. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn soft(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a was triggered by an assertion of the SOFT_SYS_RESET bit in the System Reset Register. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_soft(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Test"]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Test"]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a low signal on the RESETI# input pin. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn rsti(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a low signal on the RESETI# input pin. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_rsti(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a Watchdog Timer event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn wdt_evt(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a Watchdog Timer event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_wdt_evt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by an ARM SYSRESETREQ event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn sys_rstreq(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by an ARM SYSRESETREQ event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_sys_rstreq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "The VBAT RST bit is set to '1' by hardware when a RESET_VBAT is detected. This is the register default value. To clear VBAT RST EC firmware must write a '1' to this bit; writing a '0' to VBAT RST has no affect.(R/WC)"]
            #[inline(always)]
            pub const fn vbat_rst(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The VBAT RST bit is set to '1' by hardware when a RESET_VBAT is detected. This is the register default value. To clear VBAT RST EC firmware must write a '1' to this bit; writing a '0' to VBAT RST has no affect.(R/WC)"]
            #[inline(always)]
            pub fn set_vbat_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Pfrs {
            #[inline(always)]
            fn default() -> Pfrs {
                Pfrs(0)
            }
        }
        impl core::fmt::Debug for Pfrs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pfrs")
                    .field("soft", &self.soft())
                    .field("test", &self.test())
                    .field("rsti", &self.rsti())
                    .field("wdt_evt", &self.wdt_evt())
                    .field("sys_rstreq", &self.sys_rstreq())
                    .field("vbat_rst", &self.vbat_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pfrs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pfrs {{ soft: {=bool:?}, test: {=bool:?}, rsti: {=bool:?}, wdt_evt: {=bool:?}, sys_rstreq: {=bool:?}, vbat_rst: {=bool:?} }}" , self . soft () , self . test () , self . rsti () , self . wdt_evt () , self . sys_rstreq () , self . vbat_rst ())
            }
        }
    }
}
pub mod vbat_ram {
    #[doc = "The VBAT RAM is operational while the main power rail is operational, and will retain its values powered by battery power while the main rail is unpowered."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct VbatRam {
        ptr: *mut u8,
    }
    unsafe impl Send for VbatRam {}
    unsafe impl Sync for VbatRam {}
    impl VbatRam {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "32-bits of VBAT powered RAM."]
        #[inline(always)]
        pub const fn mem(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
}
pub mod vci {
    #[doc = "The VBAT-Powered Control Interfaces with the RTC With Date and DST Adjustment as well as the Week Alarm."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vci {
        ptr: *mut u8,
    }
    unsafe impl Send for Vci {}
    unsafe impl Sync for Vci {}
    impl Vci {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "VCI Register"]
        #[inline(always)]
        pub const fn ctrl_sts(self) -> crate::common::Reg<regs::CtrlSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Latch Enable Register"]
        #[inline(always)]
        pub const fn latch_en(self) -> crate::common::Reg<regs::LatchEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Latch Resets Register"]
        #[inline(always)]
        pub const fn latch_rst(self) -> crate::common::Reg<regs::LatchRst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "VCI Input Enable Register"]
        #[inline(always)]
        pub const fn input_en(self) -> crate::common::Reg<regs::InputEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Holdoff Count Register"]
        #[inline(always)]
        pub const fn hldoff_cnt(self) -> crate::common::Reg<regs::HldoffCnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "VCI Polarity Register"]
        #[inline(always)]
        pub const fn polarity(self) -> crate::common::Reg<regs::Polarity, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "VCI Posedge Detect Register"]
        #[inline(always)]
        pub const fn pedge_det(self) -> crate::common::Reg<regs::PedgeDet, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "VCI Negedge Detect Register"]
        #[inline(always)]
        pub const fn nedge_det(self) -> crate::common::Reg<regs::NedgeDet, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "VCI Buffer Enable Register"]
        #[inline(always)]
        pub const fn buffer_en(self) -> crate::common::Reg<regs::BufferEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "VCI Buffer Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BufferEn(pub u32);
        impl BufferEn {
            #[doc = "Input Buffer enable. After changing the buffer enable for a VCI input, firmware should reset the input latch and clear any potential interrupt that may have been triggered by the input, as changing the buffer may cause the internal status to change. This register has no effect when VTR is powered. When VTR is on, the input buffers are enabled only by the IE bit. For each bit in the field: 1=VCI_IN# input buffer enabled independent of the IE bit. The edge detection latches for this input are always enabled 0=VCI_IN# input buffer enabled by the IE bit. The edge detection latches are only enabled when the IE bit is 1 (default)."]
            #[inline(always)]
            pub const fn v_buf(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Input Buffer enable. After changing the buffer enable for a VCI input, firmware should reset the input latch and clear any potential interrupt that may have been triggered by the input, as changing the buffer may cause the internal status to change. This register has no effect when VTR is powered. When VTR is on, the input buffers are enabled only by the IE bit. For each bit in the field: 1=VCI_IN# input buffer enabled independent of the IE bit. The edge detection latches for this input are always enabled 0=VCI_IN# input buffer enabled by the IE bit. The edge detection latches are only enabled when the IE bit is 1 (default)."]
            #[inline(always)]
            pub fn set_v_buf(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for BufferEn {
            #[inline(always)]
            fn default() -> BufferEn {
                BufferEn(0)
            }
        }
        impl core::fmt::Debug for BufferEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BufferEn").field("v_buf", &self.v_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BufferEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BufferEn {{ v_buf: {=u8:?} }}", self.v_buf())
            }
        }
        #[doc = "VCI Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CtrlSts(pub u32);
        impl CtrlSts {
            #[doc = "These bits provide the latched state of the associated VCI_IN# pin, if latching is enabled or the current state of the pin if latching is not enabled. In both cases, the value is determined after the action of the VCI Polarity Register. Note: The VCI_IN\\[6:0\\]# bits default to the state of their respective input pins."]
            #[inline(always)]
            pub const fn vci_in(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits provide the latched state of the associated VCI_IN# pin, if latching is enabled or the current state of the pin if latching is not enabled. In both cases, the value is determined after the action of the VCI Polarity Register. Note: The VCI_IN\\[6:0\\]# bits default to the state of their respective input pins."]
            #[inline(always)]
            pub fn set_vci_in(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "This bit selects the power source for GPIO outputs. 1= GPIO will be powered by VBAT power well (VCI_OUT functionality). 0= GPIO will be powered by VTR power well."]
            #[inline(always)]
            pub const fn vci_out_gpio_sel(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects the power source for GPIO outputs. 1= GPIO will be powered by VBAT power well (VCI_OUT functionality). 0= GPIO will be powered by VTR power well."]
            #[inline(always)]
            pub fn set_vci_out_gpio_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This bit provides the current status of the VCI_OVRD_IN pin. Note: The VCI_OVRD_IN bit defaults to the state of the respective input pin."]
            #[inline(always)]
            pub const fn vci_ovrd_in(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit provides the current status of the VCI_OVRD_IN pin. Note: The VCI_OVRD_IN bit defaults to the state of the respective input pin."]
            #[inline(always)]
            pub fn set_vci_ovrd_in(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This bit provides the current status of the VCI_OUT pin."]
            #[inline(always)]
            pub const fn vci_out(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This bit provides the current status of the VCI_OUT pin."]
            #[inline(always)]
            pub fn set_vci_out(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This bit can allow EC firmware to control the state of the VCI_OUT pin. For example, when VTR_PWRGD is asserted and the FW_EXT bit is 1, clearing the VCI_FW_CNTRL bit de-asserts the active high VCI_OUT pin. BIOS must set this bit to 1 prior to setting the FW_EXT bit to 1 on power up, in order to avoid glitches on the VCI_OUT pin."]
            #[inline(always)]
            pub const fn vci_fw_ctrl(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can allow EC firmware to control the state of the VCI_OUT pin. For example, when VTR_PWRGD is asserted and the FW_EXT bit is 1, clearing the VCI_FW_CNTRL bit de-asserts the active high VCI_OUT pin. BIOS must set this bit to 1 prior to setting the FW_EXT bit to 1 on power up, in order to avoid glitches on the VCI_OUT pin."]
            #[inline(always)]
            pub fn set_vci_fw_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This bit controls selecting between the external VBAT-Powered Control Interface inputs, or the VCI_FW_CNTRL bit output to control the VCI_OUT pin. 1=VCI_OUT is determined by the VCI_FW_CNTRL field, when VTR is active 0=VCI_OUT is determined by the external inputs. Note: This bit used to be called GPO/nEXT. The name was changed to distinguish it from the BGPOs, which are elsewhere, and to remove a / in a bit name."]
            #[inline(always)]
            pub const fn fw_ext(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls selecting between the external VBAT-Powered Control Interface inputs, or the VCI_FW_CNTRL bit output to control the VCI_OUT pin. 1=VCI_OUT is determined by the VCI_FW_CNTRL field, when VTR is active 0=VCI_OUT is determined by the external inputs. Note: This bit used to be called GPO/nEXT. The name was changed to distinguish it from the BGPOs, which are elsewhere, and to remove a / in a bit name."]
            #[inline(always)]
            pub fn set_fw_ext(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "The Filters Bypass bit is used to enable and disable the input filters on the VCI_IN# pins. 1=Filters disabled; 0=Filters enabled (default)."]
            #[inline(always)]
            pub const fn fltrs_bypass(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "The Filters Bypass bit is used to enable and disable the input filters on the VCI_IN# pins. 1=Filters disabled; 0=Filters enabled (default)."]
            #[inline(always)]
            pub fn set_fltrs_bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "If enabled by WEEK_ALRM_LE, this bit is set to 1 if the Week Alarm signal is asserted. It is reset by writes to WEEK_ALRM_LS."]
            #[inline(always)]
            pub const fn wk_alrm(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "If enabled by WEEK_ALRM_LE, this bit is set to 1 if the Week Alarm signal is asserted. It is reset by writes to WEEK_ALRM_LS."]
            #[inline(always)]
            pub fn set_wk_alrm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "If enabled by RTC_ALRM_LE, this bit is set to 1 if the RTC Alarm signal is asserted. It is reset by writes to RTC_ALRM_LS."]
            #[inline(always)]
            pub const fn rtc_alrm(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "If enabled by RTC_ALRM_LE, this bit is set to 1 if the RTC Alarm signal is asserted. It is reset by writes to RTC_ALRM_LS."]
            #[inline(always)]
            pub fn set_rtc_alrm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This is the System power present select bit. 1= VCI_IN3 is used as System power present. 0= VCI_IN3 is used as VCI_IN3."]
            #[inline(always)]
            pub const fn syspwr_pres(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This is the System power present select bit. 1= VCI_IN3 is used as System power present. 0= VCI_IN3 is used as VCI_IN3."]
            #[inline(always)]
            pub fn set_syspwr_pres(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for CtrlSts {
            #[inline(always)]
            fn default() -> CtrlSts {
                CtrlSts(0)
            }
        }
        impl core::fmt::Debug for CtrlSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CtrlSts")
                    .field("vci_in", &self.vci_in())
                    .field("vci_out_gpio_sel", &self.vci_out_gpio_sel())
                    .field("vci_ovrd_in", &self.vci_ovrd_in())
                    .field("vci_out", &self.vci_out())
                    .field("vci_fw_ctrl", &self.vci_fw_ctrl())
                    .field("fw_ext", &self.fw_ext())
                    .field("fltrs_bypass", &self.fltrs_bypass())
                    .field("wk_alrm", &self.wk_alrm())
                    .field("rtc_alrm", &self.rtc_alrm())
                    .field("syspwr_pres", &self.syspwr_pres())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CtrlSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CtrlSts {{ vci_in: {=u8:?}, vci_out_gpio_sel: {=bool:?}, vci_ovrd_in: {=bool:?}, vci_out: {=bool:?}, vci_fw_ctrl: {=bool:?}, fw_ext: {=bool:?}, fltrs_bypass: {=bool:?}, wk_alrm: {=bool:?}, rtc_alrm: {=bool:?}, syspwr_pres: {=bool:?} }}" , self . vci_in () , self . vci_out_gpio_sel () , self . vci_ovrd_in () , self . vci_out () , self . vci_fw_ctrl () , self . fw_ext () , self . fltrs_bypass () , self . wk_alrm () , self . rtc_alrm () , self . syspwr_pres ())
            }
        }
        #[doc = "Holdoff Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HldoffCnt(pub u32);
        impl HldoffCnt {
            #[doc = "These bits determine the period of time the VCI_OUT logic is inhibited from re-asserting VCI_OUT after a SYS_SHDN# event. FFh-01h=The Power On Inhibit Holdoff Time is set to a period between 125ms and 31.875 seconds. 0=The Power On Inhibit function is disabled."]
            #[inline(always)]
            pub const fn time(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These bits determine the period of time the VCI_OUT logic is inhibited from re-asserting VCI_OUT after a SYS_SHDN# event. FFh-01h=The Power On Inhibit Holdoff Time is set to a period between 125ms and 31.875 seconds. 0=The Power On Inhibit function is disabled."]
            #[inline(always)]
            pub fn set_time(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for HldoffCnt {
            #[inline(always)]
            fn default() -> HldoffCnt {
                HldoffCnt(0)
            }
        }
        impl core::fmt::Debug for HldoffCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HldoffCnt").field("time", &self.time()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HldoffCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HldoffCnt {{ time: {=u8:?} }}", self.time())
            }
        }
        #[doc = "VCI Input Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct InputEn(pub u32);
        impl InputEn {
            #[doc = "Input Enables for VCI_IN# signals. After changing the input enable for a VCI input, firmware should reset the input latch and clear any potential interrupt that may have been triggered by the input, as changing the enable may cause the internal status to change. For each bit in the field: 1=Enabled. The corresponding VCI_IN# input is not gated and toggling the pin will affect the VCI_OUT pin 0=Not Enabled. the corresponding VCI_IN# input does not affect the VCI_OUT pin, even if the input is '0'. Unless the corresponding bit in the VCI Buffer Enable Register is 1, latches are not asserted, even if the VCI_IN# pin is low, during a VBAT power transition"]
            #[inline(always)]
            pub const fn ie(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Input Enables for VCI_IN# signals. After changing the input enable for a VCI input, firmware should reset the input latch and clear any potential interrupt that may have been triggered by the input, as changing the enable may cause the internal status to change. For each bit in the field: 1=Enabled. The corresponding VCI_IN# input is not gated and toggling the pin will affect the VCI_OUT pin 0=Not Enabled. the corresponding VCI_IN# input does not affect the VCI_OUT pin, even if the input is '0'. Unless the corresponding bit in the VCI Buffer Enable Register is 1, latches are not asserted, even if the VCI_IN# pin is low, during a VBAT power transition"]
            #[inline(always)]
            pub fn set_ie(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for InputEn {
            #[inline(always)]
            fn default() -> InputEn {
                InputEn(0)
            }
        }
        impl core::fmt::Debug for InputEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("InputEn").field("ie", &self.ie()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for InputEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "InputEn {{ ie: {=u8:?} }}", self.ie())
            }
        }
        #[doc = "Latch Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LatchEn(pub u32);
        impl LatchEn {
            #[doc = "Latching Enables. Latching occurs after the Polarity configuration, so a VCI_INi# pin is asserted when it is '0' if VCI_IN_POL is '0', and asserted when it is '1' if VCI_IN_POL is '1'. For each bit in the field: 1=Enabled. Assertions of the VCI_INi# pin are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The VCI_INi# signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub const fn le(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Latching Enables. Latching occurs after the Polarity configuration, so a VCI_INi# pin is asserted when it is '0' if VCI_IN_POL is '0', and asserted when it is '1' if VCI_IN_POL is '1'. For each bit in the field: 1=Enabled. Assertions of the VCI_INi# pin are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The VCI_INi# signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub fn set_le(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Latch enable for the Week Alarm Power-Up signal. 1=Enabled. Assertions of the Week Alarm are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The Week Alarm signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub const fn wk_alrm_le(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Latch enable for the Week Alarm Power-Up signal. 1=Enabled. Assertions of the Week Alarm are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The Week Alarm signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub fn set_wk_alrm_le(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Latch enable for the RTC Power-Up signal. 1=Enabled. Assertions of the RTC Alarm are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The RTC Alarm signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub const fn rtc_alrm_le(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Latch enable for the RTC Power-Up signal. 1=Enabled. Assertions of the RTC Alarm are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The RTC Alarm signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub fn set_rtc_alrm_le(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for LatchEn {
            #[inline(always)]
            fn default() -> LatchEn {
                LatchEn(0)
            }
        }
        impl core::fmt::Debug for LatchEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LatchEn")
                    .field("le", &self.le())
                    .field("wk_alrm_le", &self.wk_alrm_le())
                    .field("rtc_alrm_le", &self.rtc_alrm_le())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LatchEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "LatchEn {{ le: {=u8:?}, wk_alrm_le: {=bool:?}, rtc_alrm_le: {=bool:?} }}",
                    self.le(),
                    self.wk_alrm_le(),
                    self.rtc_alrm_le()
                )
            }
        }
        #[doc = "Latch Resets Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LatchRst(pub u32);
        impl LatchRst {
            #[doc = "Latch Resets. When a Latch Resets bit is written with a '1', the corresponding VCI_INi# latch is de-asserted ('1'). The VCI_INi# input to the latch has priority over the Latch Reset input, so firmware cannot reset the latch while the VCI_INi# pin is asserted. Firmware should sample the state of the pin in the VCI Register before attempting to reset the latch. As noted in the Latch Enable Register, the assertion level is determined by the VCI_IN_POL bit. Reads of this register are undefined."]
            #[inline(always)]
            pub const fn ls(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Latch Resets. When a Latch Resets bit is written with a '1', the corresponding VCI_INi# latch is de-asserted ('1'). The VCI_INi# input to the latch has priority over the Latch Reset input, so firmware cannot reset the latch while the VCI_INi# pin is asserted. Firmware should sample the state of the pin in the VCI Register before attempting to reset the latch. As noted in the Latch Enable Register, the assertion level is determined by the VCI_IN_POL bit. Reads of this register are undefined."]
            #[inline(always)]
            pub fn set_ls(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Week Alarm Latch Reset. When this bit is written with a '1', the Week Alarm Event latch is reset. The Week Alarm input to the latch has priority over the Reset input Reads of this register are undefined."]
            #[inline(always)]
            pub const fn wk_alrm_ls(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Week Alarm Latch Reset. When this bit is written with a '1', the Week Alarm Event latch is reset. The Week Alarm input to the latch has priority over the Reset input Reads of this register are undefined."]
            #[inline(always)]
            pub fn set_wk_alrm_ls(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "RTC Alarm Latch Reset. When this bit is written with a '1', the RTC Alarm Event latch is reset. The RTC Alarm input to the latch has priority over the Reset input Reads of this register are undefined."]
            #[inline(always)]
            pub const fn rtc_alrm_ls(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "RTC Alarm Latch Reset. When this bit is written with a '1', the RTC Alarm Event latch is reset. The RTC Alarm input to the latch has priority over the Reset input Reads of this register are undefined."]
            #[inline(always)]
            pub fn set_rtc_alrm_ls(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for LatchRst {
            #[inline(always)]
            fn default() -> LatchRst {
                LatchRst(0)
            }
        }
        impl core::fmt::Debug for LatchRst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LatchRst")
                    .field("ls", &self.ls())
                    .field("wk_alrm_ls", &self.wk_alrm_ls())
                    .field("rtc_alrm_ls", &self.rtc_alrm_ls())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LatchRst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "LatchRst {{ ls: {=u8:?}, wk_alrm_ls: {=bool:?}, rtc_alrm_ls: {=bool:?} }}",
                    self.ls(),
                    self.wk_alrm_ls(),
                    self.rtc_alrm_ls()
                )
            }
        }
        #[doc = "VCI Negedge Detect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct NedgeDet(pub u32);
        impl NedgeDet {
            #[doc = "These bits record a high to low transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field: 1=Negative Edge Detected; 0=No edge detected."]
            #[inline(always)]
            pub const fn vci_in(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits record a high to low transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field: 1=Negative Edge Detected; 0=No edge detected."]
            #[inline(always)]
            pub fn set_vci_in(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for NedgeDet {
            #[inline(always)]
            fn default() -> NedgeDet {
                NedgeDet(0)
            }
        }
        impl core::fmt::Debug for NedgeDet {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("NedgeDet").field("vci_in", &self.vci_in()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NedgeDet {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "NedgeDet {{ vci_in: {=u8:?} }}", self.vci_in())
            }
        }
        #[doc = "VCI Posedge Detect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PedgeDet(pub u32);
        impl PedgeDet {
            #[doc = "These bits record a low to high transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field: 1=Positive Edge Detected; 0=No edge detected."]
            #[inline(always)]
            pub const fn vci_in(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits record a low to high transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field: 1=Positive Edge Detected; 0=No edge detected."]
            #[inline(always)]
            pub fn set_vci_in(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for PedgeDet {
            #[inline(always)]
            fn default() -> PedgeDet {
                PedgeDet(0)
            }
        }
        impl core::fmt::Debug for PedgeDet {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PedgeDet").field("vci_in", &self.vci_in()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PedgeDet {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PedgeDet {{ vci_in: {=u8:?} }}", self.vci_in())
            }
        }
        #[doc = "VCI Polarity Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Polarity(pub u32);
        impl Polarity {
            #[doc = "These bits determine the polarity of the VCI_IN input signals: For each bit in the field: 1=Active High. The value on the pins is inverted before use 0=Active Low (default)."]
            #[inline(always)]
            pub const fn vci_in(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "These bits determine the polarity of the VCI_IN input signals: For each bit in the field: 1=Active High. The value on the pins is inverted before use 0=Active Low (default)."]
            #[inline(always)]
            pub fn set_vci_in(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Polarity {
            #[inline(always)]
            fn default() -> Polarity {
                Polarity(0)
            }
        }
        impl core::fmt::Debug for Polarity {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Polarity").field("vci_in", &self.vci_in()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Polarity {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Polarity {{ vci_in: {=u8:?} }}", self.vci_in())
            }
        }
    }
}
pub mod wdt {
    #[doc = "The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Wdt {}
    unsafe impl Sync for Wdt {}
    impl Wdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Writing this field reloads the Watch Dog Timer counter."]
        #[inline(always)]
        pub const fn load(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "WDT Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The WDT Kick Register is a strobe. Reads of this register return 0. Writes to this register cause the WDT to reload the WDT Load Register value and start decrementing when the WDT_ENABLE bit in the WDT Control Register is set to '1'. When the WDT_ENABLE bit in the WDT Control Register is cleared to '0', writes to the WDT Kick Register have no effect."]
        #[inline(always)]
        pub const fn kick(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This read-only register provides the current WDT count."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "This register provides the current WDT count."]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Watch Dog Interrupt Enable Register."]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "WDT Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u16);
        impl Ctrl {
            #[doc = "WDT Block enabled"]
            #[inline(always)]
            pub const fn wdt_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "WDT Block enabled"]
            #[inline(always)]
            pub fn set_wdt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "WDT_STATUS is set by hardware if the last reset of the device was caused by an underflow of the WDT. This bit must be cleared by the EC firmware writing a '1' to this bit. Writing a '0' to this bit has no effect."]
            #[inline(always)]
            pub const fn wdt_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "WDT_STATUS is set by hardware if the last reset of the device was caused by an underflow of the WDT. This bit must be cleared by the EC firmware writing a '1' to this bit. Writing a '0' to this bit has no effect."]
            #[inline(always)]
            pub fn set_wdt_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u16) & 0x01) << 1usize);
            }
            #[doc = "This bit enables the WDT Stall function if the Hibernation Timer 0 is active. 1=The WDT is stalled while the Hibernation Timer 0 is active 0=The WDT is not affected by Hibernation Timer 0."]
            #[inline(always)]
            pub const fn hib_tmr0_stl(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the WDT Stall function if the Hibernation Timer 0 is active. 1=The WDT is stalled while the Hibernation Timer 0 is active 0=The WDT is not affected by Hibernation Timer 0."]
            #[inline(always)]
            pub fn set_hib_tmr0_stl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u16) & 0x01) << 2usize);
            }
            #[doc = "This bit enables the WDT Stall function if the Week Timer is active. 1=The WDT is stalled while the Week Timer is active 0=The WDT is not affected by the Week Timer."]
            #[inline(always)]
            pub const fn wk_tmr_stl(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the WDT Stall function if the Week Timer is active. 1=The WDT is stalled while the Week Timer is active 0=The WDT is not affected by the Week Timer."]
            #[inline(always)]
            pub fn set_wk_tmr_stl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u16) & 0x01) << 3usize);
            }
            #[doc = "This bit enables the WDT Stall function if JTAG or SWD debug functions are active 1=The WDT is stalled while either JTAG or SWD is active 0=The WDT is not affected by the JTAG debug interface."]
            #[inline(always)]
            pub const fn jtag_stl(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the WDT Stall function if JTAG or SWD debug functions are active 1=The WDT is stalled while either JTAG or SWD is active 0=The WDT is not affected by the JTAG debug interface."]
            #[inline(always)]
            pub fn set_jtag_stl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u16) & 0x01) << 4usize);
            }
            #[doc = "If the WDT_RESET bit is set and the watch dog timer expires, the Watch dog module will generate interrupt and clear the WDT_RESET to 0b."]
            #[inline(always)]
            pub const fn wdt_rst(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "If the WDT_RESET bit is set and the watch dog timer expires, the Watch dog module will generate interrupt and clear the WDT_RESET to 0b."]
            #[inline(always)]
            pub fn set_wdt_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u16) & 0x01) << 9usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("wdt_en", &self.wdt_en())
                    .field("wdt_sts", &self.wdt_sts())
                    .field("hib_tmr0_stl", &self.hib_tmr0_stl())
                    .field("wk_tmr_stl", &self.wk_tmr_stl())
                    .field("jtag_stl", &self.jtag_stl())
                    .field("wdt_rst", &self.wdt_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ wdt_en: {=bool:?}, wdt_sts: {=bool:?}, hib_tmr0_stl: {=bool:?}, wk_tmr_stl: {=bool:?}, jtag_stl: {=bool:?}, wdt_rst: {=bool:?} }}" , self . wdt_en () , self . wdt_sts () , self . hib_tmr0_stl () , self . wk_tmr_stl () , self . jtag_stl () , self . wdt_rst ())
            }
        }
        #[doc = "Watch Dog Interrupt Enable Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "WDT_Int_Enable: This is the interrupt enables bit for WDT_INT interrupt. 1= WDT_INT Interrupt Enable 0= WDT_INT Interrupt Disabled"]
            #[inline(always)]
            pub const fn wdt_inten(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "WDT_Int_Enable: This is the interrupt enables bit for WDT_INT interrupt. 1= WDT_INT Interrupt Enable 0= WDT_INT Interrupt Disabled"]
            #[inline(always)]
            pub fn set_wdt_inten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien").field("wdt_inten", &self.wdt_inten()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ien {{ wdt_inten: {=bool:?} }}", self.wdt_inten())
            }
        }
        #[doc = "This register provides the current WDT count."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u8);
        impl Sts {
            #[doc = "WDT_EVENT_IRQ : This bit indicates the status of interrupt from Watch dog module."]
            #[inline(always)]
            pub const fn wdt_ev_irq(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "WDT_EVENT_IRQ : This bit indicates the status of interrupt from Watch dog module."]
            #[inline(always)]
            pub fn set_wdt_ev_irq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts").field("wdt_ev_irq", &self.wdt_ev_irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sts {{ wdt_ev_irq: {=bool:?} }}", self.wdt_ev_irq())
            }
        }
    }
}
pub mod week {
    #[doc = "The Week Timer and the Sub-Week Timer assert the Power-Up Event Output which automatically powers-up the system from the G3 state"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Week {
        ptr: *mut u8,
    }
    unsafe impl Send for Week {}
    unsafe impl Sync for Week {}
    impl Week {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Week Alarm Counter Register"]
        #[inline(always)]
        pub const fn alarm_cnt(self) -> crate::common::Reg<regs::AlarmCnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Week Timer Compare Register"]
        #[inline(always)]
        pub const fn tmr_comp(self) -> crate::common::Reg<regs::TmrComp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Clock Divider Register"]
        #[inline(always)]
        pub const fn clkdiv(self) -> crate::common::Reg<regs::Clkdiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Sub-Second Programmable Interrupt Select Register"]
        #[inline(always)]
        pub const fn ss_intr_sel(self) -> crate::common::Reg<regs::SsIntrSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Sub-Week Control Register"]
        #[inline(always)]
        pub const fn swk_ctrl(self) -> crate::common::Reg<regs::SwkCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Sub-Week Alarm Counter Register"]
        #[inline(always)]
        pub const fn swk_alarm(self) -> crate::common::Reg<regs::SwkAlarm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "BGPO Data Register"]
        #[inline(always)]
        pub const fn bgpo_data(self) -> crate::common::Reg<regs::BgpoData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "BGPO Power Register"]
        #[inline(always)]
        pub const fn bgpo_pwr(self) -> crate::common::Reg<regs::BgpoPwr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "BGPO Reset Register"]
        #[inline(always)]
        pub const fn bgpo_rst(self) -> crate::common::Reg<regs::BgpoRst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Week Alarm Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AlarmCnt(pub u32);
        impl AlarmCnt {
            #[doc = "While the WT_ENABLE bit is 1, this register is incremented at a 1 Hz rate. Writes of this register may require one second to take effect. Reads return the current state of the register. Reads and writes complete independently of the state of WT_ENABLE."]
            #[inline(always)]
            pub const fn wk_cntr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0fff_ffff;
                val as u32
            }
            #[doc = "While the WT_ENABLE bit is 1, this register is incremented at a 1 Hz rate. Writes of this register may require one second to take effect. Reads return the current state of the register. Reads and writes complete independently of the state of WT_ENABLE."]
            #[inline(always)]
            pub fn set_wk_cntr(&mut self, val: u32) {
                self.0 = (self.0 & !(0x0fff_ffff << 0usize)) | (((val as u32) & 0x0fff_ffff) << 0usize);
            }
        }
        impl Default for AlarmCnt {
            #[inline(always)]
            fn default() -> AlarmCnt {
                AlarmCnt(0)
            }
        }
        impl core::fmt::Debug for AlarmCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AlarmCnt").field("wk_cntr", &self.wk_cntr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AlarmCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AlarmCnt {{ wk_cntr: {=u32:?} }}", self.wk_cntr())
            }
        }
        #[doc = "BGPO Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BgpoData(pub u32);
        impl BgpoData {
            #[doc = "Battery powered General Purpose Output. Each output pin may be individually configured to be either a VBAT-power BGPO or a VTR powered GPIO, based on the corresponding settings in the BGPO Power Register. Additionally, each output pin may be individually configured to reset to 0 on either RESET_VTR or RESET_SYS, based on the corresponding settings in the BGPO Reset Register. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] output is high; 0=BGPO\\[i\\] output is low."]
            #[inline(always)]
            pub const fn dat(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Battery powered General Purpose Output. Each output pin may be individually configured to be either a VBAT-power BGPO or a VTR powered GPIO, based on the corresponding settings in the BGPO Power Register. Additionally, each output pin may be individually configured to reset to 0 on either RESET_VTR or RESET_SYS, based on the corresponding settings in the BGPO Reset Register. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] output is high; 0=BGPO\\[i\\] output is low."]
            #[inline(always)]
            pub fn set_dat(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for BgpoData {
            #[inline(always)]
            fn default() -> BgpoData {
                BgpoData(0)
            }
        }
        impl core::fmt::Debug for BgpoData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BgpoData").field("dat", &self.dat()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BgpoData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BgpoData {{ dat: {=u8:?} }}", self.dat())
            }
        }
        #[doc = "BGPO Power Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BgpoPwr(pub u32);
        impl BgpoPwr {
            #[doc = "Battery powered General Purpose Output power source. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] is powered by VBAT. The BGPO\\[i\\] pin is always determined by the corresponding bit in the BGPO Data Register. The GPIO Input register for the GPIO that is multiplexed with the BGPO always returns a '1b'. 0=The pin for BGPO\\[i\\] functions as a GPIO. When VTR is powered, the pin associated with BGPO\\[i\\] is determined by the GPIO associated with the pin. When VTR is unpowered, the pin is tristated."]
            #[inline(always)]
            pub const fn pwr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Battery powered General Purpose Output power source. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] is powered by VBAT. The BGPO\\[i\\] pin is always determined by the corresponding bit in the BGPO Data Register. The GPIO Input register for the GPIO that is multiplexed with the BGPO always returns a '1b'. 0=The pin for BGPO\\[i\\] functions as a GPIO. When VTR is powered, the pin associated with BGPO\\[i\\] is determined by the GPIO associated with the pin. When VTR is unpowered, the pin is tristated."]
            #[inline(always)]
            pub fn set_pwr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for BgpoPwr {
            #[inline(always)]
            fn default() -> BgpoPwr {
                BgpoPwr(0)
            }
        }
        impl core::fmt::Debug for BgpoPwr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BgpoPwr").field("pwr", &self.pwr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BgpoPwr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BgpoPwr {{ pwr: {=u8:?} }}", self.pwr())
            }
        }
        #[doc = "BGPO Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BgpoRst(pub u32);
        impl BgpoRst {
            #[doc = "Battery powered General Purpose Output reset event. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] is reset to 0 on RESET_VTR; 0=BGPO\\[i\\] is reset to 0 on RESET_SYS."]
            #[inline(always)]
            pub const fn rst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Battery powered General Purpose Output reset event. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] is reset to 0 on RESET_VTR; 0=BGPO\\[i\\] is reset to 0 on RESET_SYS."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for BgpoRst {
            #[inline(always)]
            fn default() -> BgpoRst {
                BgpoRst(0)
            }
        }
        impl core::fmt::Debug for BgpoRst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BgpoRst").field("rst", &self.rst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BgpoRst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BgpoRst {{ rst: {=u8:?} }}", self.rst())
            }
        }
        #[doc = "Clock Divider Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clkdiv(pub u32);
        impl Clkdiv {
            #[doc = "Reads of this register return the current state of the Week Timer 15- bit clock divider."]
            #[inline(always)]
            pub const fn div(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Reads of this register return the current state of the Week Timer 15- bit clock divider."]
            #[inline(always)]
            pub fn set_div(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Clkdiv {
            #[inline(always)]
            fn default() -> Clkdiv {
                Clkdiv(0)
            }
        }
        impl core::fmt::Debug for Clkdiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clkdiv").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clkdiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Clkdiv {{ div: {=u16:?} }}", self.div())
            }
        }
        #[doc = "Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "The WT_ENABLE bit is used to start and stop the Week Alarm Counter Register and the Clock Divider Register. The value in the Counter Register is held when the WT_ENABLE bit is not asserted (0) and the count is resumed from the last value when the bit is asserted (1). The 15-Bit Clock Divider is reset to 00h and the Week Alarm Interface is in its lowest power consumption state when the WT_ENABLE bit is not asserted."]
            #[inline(always)]
            pub const fn wt_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The WT_ENABLE bit is used to start and stop the Week Alarm Counter Register and the Clock Divider Register. The value in the Counter Register is held when the WT_ENABLE bit is not asserted (0) and the count is resumed from the last value when the bit is asserted (1). The 15-Bit Clock Divider is reset to 00h and the Week Alarm Interface is in its lowest power consumption state when the WT_ENABLE bit is not asserted."]
            #[inline(always)]
            pub fn set_wt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit controls the state of the Power-Up Event Output and enables Week POWER-UP Event decoding in the VBAT-Powered Control Interface. 1=Power-Up Event Output Enabled 0=Power-Up Event Output Disabled and Reset"]
            #[inline(always)]
            pub const fn pwrup_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls the state of the Power-Up Event Output and enables Week POWER-UP Event decoding in the VBAT-Powered Control Interface. 1=Power-Up Event Output Enabled 0=Power-Up Event Output Disabled and Reset"]
            #[inline(always)]
            pub fn set_pwrup_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("wt_en", &self.wt_en())
                    .field("pwrup_en", &self.pwrup_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl {{ wt_en: {=bool:?}, pwrup_en: {=bool:?} }}",
                    self.wt_en(),
                    self.pwrup_en()
                )
            }
        }
        #[doc = "Sub-Second Programmable Interrupt Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SsIntrSel(pub u32);
        impl SsIntrSel {
            #[doc = "This field determines the rate at which Sub-Second interrupt events are generated."]
            #[inline(always)]
            pub const fn spisr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This field determines the rate at which Sub-Second interrupt events are generated."]
            #[inline(always)]
            pub fn set_spisr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for SsIntrSel {
            #[inline(always)]
            fn default() -> SsIntrSel {
                SsIntrSel(0)
            }
        }
        impl core::fmt::Debug for SsIntrSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SsIntrSel").field("spisr", &self.spisr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SsIntrSel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SsIntrSel {{ spisr: {=u8:?} }}", self.spisr())
            }
        }
        #[doc = "Sub-Week Alarm Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SwkAlarm(pub u32);
        impl SwkAlarm {
            #[doc = "Writes with a non-zero value to this field reload the 9-bit Sub-Week Alarm counter. Writes of 0 disable the counter. If the Sub-Week Alarm counter decrements to 0 and the AUTO_RELOAD bit is set, the value in this field is automatically loaded into the Sub-Week Alarm counter."]
            #[inline(always)]
            pub const fn cntr_load(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Writes with a non-zero value to this field reload the 9-bit Sub-Week Alarm counter. Writes of 0 disable the counter. If the Sub-Week Alarm counter decrements to 0 and the AUTO_RELOAD bit is set, the value in this field is automatically loaded into the Sub-Week Alarm counter."]
            #[inline(always)]
            pub fn set_cntr_load(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Reads of this register return the current state of the 9-bit Sub-Week Alarm counter."]
            #[inline(always)]
            pub const fn cntr_sts(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x01ff;
                val as u16
            }
            #[doc = "Reads of this register return the current state of the 9-bit Sub-Week Alarm counter."]
            #[inline(always)]
            pub fn set_cntr_sts(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 16usize)) | (((val as u32) & 0x01ff) << 16usize);
            }
        }
        impl Default for SwkAlarm {
            #[inline(always)]
            fn default() -> SwkAlarm {
                SwkAlarm(0)
            }
        }
        impl core::fmt::Debug for SwkAlarm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SwkAlarm")
                    .field("cntr_load", &self.cntr_load())
                    .field("cntr_sts", &self.cntr_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SwkAlarm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SwkAlarm {{ cntr_load: {=u16:?}, cntr_sts: {=u16:?} }}",
                    self.cntr_load(),
                    self.cntr_sts()
                )
            }
        }
        #[doc = "Sub-Week Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SwkCtrl(pub u32);
        impl SwkCtrl {
            #[doc = "This bit is set to 1 when the Sub-Week Alarm Counter Register decrements from 1 to 0 and the POWERUP_EN is 1. Writes of 1 clear this bit. Writes of 0 have no effect. Note: This bit MUST be cleared to remove a Sub-Week Timer Power-Up Event."]
            #[inline(always)]
            pub const fn swktmr_pwrup_evt_sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 when the Sub-Week Alarm Counter Register decrements from 1 to 0 and the POWERUP_EN is 1. Writes of 1 clear this bit. Writes of 0 have no effect. Note: This bit MUST be cleared to remove a Sub-Week Timer Power-Up Event."]
            #[inline(always)]
            pub fn set_swktmr_pwrup_evt_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to 1 when the Week Alarm Counter Register is greater than or equal the contents of the Week Timer Compare Register and the POWERUP_EN is 1. Writes of 1 clear this bit. Writes of 0 have no effect. Note: This bit does not have to be cleared to remove a Week Timer Power-Up Event."]
            #[inline(always)]
            pub const fn wktmr_pwrup_evt_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 when the Week Alarm Counter Register is greater than or equal the contents of the Week Timer Compare Register and the POWERUP_EN is 1. Writes of 1 clear this bit. Writes of 0 have no effect. Note: This bit does not have to be cleared to remove a Week Timer Power-Up Event."]
            #[inline(always)]
            pub fn set_wktmr_pwrup_evt_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Test"]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Test"]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Test"]
            #[inline(always)]
            pub const fn test0(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Test"]
            #[inline(always)]
            pub fn set_test0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "1= No reload occurs when the Sub-Week Counter expires 0= Reloads the SUBWEEK_COUNTER_LOAD field into the Sub- Week Counter when the counter expires."]
            #[inline(always)]
            pub const fn au_rld(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "1= No reload occurs when the Sub-Week Counter expires 0= Reloads the SUBWEEK_COUNTER_LOAD field into the Sub- Week Counter when the counter expires."]
            #[inline(always)]
            pub fn set_au_rld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This field selects the clock source for the Sub-Week Counter."]
            #[inline(always)]
            pub const fn swk_tick(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x07;
                val as u8
            }
            #[doc = "This field selects the clock source for the Sub-Week Counter."]
            #[inline(always)]
            pub fn set_swk_tick(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 7usize)) | (((val as u32) & 0x07) << 7usize);
            }
        }
        impl Default for SwkCtrl {
            #[inline(always)]
            fn default() -> SwkCtrl {
                SwkCtrl(0)
            }
        }
        impl core::fmt::Debug for SwkCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SwkCtrl")
                    .field("swktmr_pwrup_evt_sts", &self.swktmr_pwrup_evt_sts())
                    .field("wktmr_pwrup_evt_sts", &self.wktmr_pwrup_evt_sts())
                    .field("test", &self.test())
                    .field("test0", &self.test0())
                    .field("au_rld", &self.au_rld())
                    .field("swk_tick", &self.swk_tick())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SwkCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SwkCtrl {{ swktmr_pwrup_evt_sts: {=bool:?}, wktmr_pwrup_evt_sts: {=bool:?}, test: {=bool:?}, test0: {=bool:?}, au_rld: {=bool:?}, swk_tick: {=u8:?} }}" , self . swktmr_pwrup_evt_sts () , self . wktmr_pwrup_evt_sts () , self . test () , self . test0 () , self . au_rld () , self . swk_tick ())
            }
        }
        #[doc = "Week Timer Compare Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TmrComp(pub u32);
        impl TmrComp {
            #[doc = "A Week Alarm Interrupt and a Week Alarm Power-Up Event are asserted when the Week Alarm Counter Register is greater than or equal to the contents of this register. Reads and writes complete independently of the state of WT_ENABLE."]
            #[inline(always)]
            pub const fn wk_comp(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0fff_ffff;
                val as u32
            }
            #[doc = "A Week Alarm Interrupt and a Week Alarm Power-Up Event are asserted when the Week Alarm Counter Register is greater than or equal to the contents of this register. Reads and writes complete independently of the state of WT_ENABLE."]
            #[inline(always)]
            pub fn set_wk_comp(&mut self, val: u32) {
                self.0 = (self.0 & !(0x0fff_ffff << 0usize)) | (((val as u32) & 0x0fff_ffff) << 0usize);
            }
        }
        impl Default for TmrComp {
            #[inline(always)]
            fn default() -> TmrComp {
                TmrComp(0)
            }
        }
        impl core::fmt::Debug for TmrComp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TmrComp").field("wk_comp", &self.wk_comp()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TmrComp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TmrComp {{ wk_comp: {=u32:?} }}", self.wk_comp())
            }
        }
    }
}
