#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![doc = "Peripheral access API (generated using chiptool v0.1.0 (d771c7b 2025-03-27))"]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Interrupt {
    #[doc = "0 - GIRQ08"]
    GIRQ08 = 0,
    #[doc = "1 - GIRQ09"]
    GIRQ09 = 1,
    #[doc = "2 - GIRQ10"]
    GIRQ10 = 2,
    #[doc = "3 - GIRQ11"]
    GIRQ11 = 3,
    #[doc = "4 - GIRQ12"]
    GIRQ12 = 4,
    #[doc = "5 - GIRQ13"]
    GIRQ13 = 5,
    #[doc = "6 - GIRQ14"]
    GIRQ14 = 6,
    #[doc = "7 - GIRQ15"]
    GIRQ15 = 7,
    #[doc = "8 - GIRQ16"]
    GIRQ16 = 8,
    #[doc = "9 - GIRQ17"]
    GIRQ17 = 9,
    #[doc = "10 - GIRQ18"]
    GIRQ18 = 10,
    #[doc = "12 - GIRQ20"]
    GIRQ20 = 12,
    #[doc = "13 - GIRQ21"]
    GIRQ21 = 13,
    #[doc = "14 - GIRQ23"]
    GIRQ23 = 14,
    #[doc = "15 - GIRQ24"]
    GIRQ24 = 15,
    #[doc = "17 - GIRQ26"]
    GIRQ26 = 17,
    #[doc = "20 - I2CSMB0"]
    I2CSMB0 = 20,
    #[doc = "21 - I2CSMB1"]
    I2CSMB1 = 21,
    #[doc = "22 - I2CSMB2"]
    I2CSMB2 = 22,
    #[doc = "23 - I2CSMB3"]
    I2CSMB3 = 23,
    #[doc = "24 - DMA_CH00"]
    DMA_CH00 = 24,
    #[doc = "25 - DMA_CH01"]
    DMA_CH01 = 25,
    #[doc = "26 - DMA_CH02"]
    DMA_CH02 = 26,
    #[doc = "27 - DMA_CH03"]
    DMA_CH03 = 27,
    #[doc = "28 - DMA_CH04"]
    DMA_CH04 = 28,
    #[doc = "29 - DMA_CH05"]
    DMA_CH05 = 29,
    #[doc = "30 - DMA_CH06"]
    DMA_CH06 = 30,
    #[doc = "31 - DMA_CH07"]
    DMA_CH07 = 31,
    #[doc = "32 - DMA_CH08"]
    DMA_CH08 = 32,
    #[doc = "33 - DMA_CH09"]
    DMA_CH09 = 33,
    #[doc = "40 - UART0"]
    UART0 = 40,
    #[doc = "83 - LED0"]
    LED0 = 83,
    #[doc = "84 - LED1"]
    LED1 = 84,
    #[doc = "90 - SPT0"]
    SPT0 = 90,
    #[doc = "91 - QMSPI0"]
    QMSPI0 = 91,
    #[doc = "92 - QMSPI1"]
    QMSPI1 = 92,
    #[doc = "111 - RTMR"]
    RTMR = 111,
    #[doc = "112 - HTMR0"]
    HTMR0 = 112,
    #[doc = "113 - HTMR1"]
    HTMR1 = 113,
    #[doc = "134 - EMC"]
    EMC = 134,
    #[doc = "140 - TIMER32_0"]
    TIMER32_0 = 140,
    #[doc = "141 - TIMER32_1"]
    TIMER32_1 = 141,
    #[doc = "146 - CCT"]
    CCT = 146,
    #[doc = "147 - CCT_CAP0"]
    CCT_CAP0 = 147,
    #[doc = "148 - CCT_CAP1"]
    CCT_CAP1 = 148,
    #[doc = "149 - CCT_CAP2"]
    CCT_CAP2 = 149,
    #[doc = "150 - CCT_CAP3"]
    CCT_CAP3 = 150,
    #[doc = "151 - CCT_CAP4"]
    CCT_CAP4 = 151,
    #[doc = "152 - CCT_CAP5"]
    CCT_CAP5 = 152,
    #[doc = "153 - CCT_CMP0"]
    CCT_CMP0 = 153,
    #[doc = "154 - CCT_CMP1"]
    CCT_CMP1 = 154,
    #[doc = "158 - I2CSMB4"]
    I2CSMB4 = 158,
    #[doc = "171 - WDT"]
    WDT = 171,
    #[doc = "174 - CLK_MON"]
    CLK_MON = 174,
    #[doc = "181 - SWI0"]
    SWI0 = 181,
    #[doc = "182 - SWI1"]
    SWI1 = 182,
    #[doc = "183 - SWI2"]
    SWI2 = 183,
    #[doc = "184 - SWI3"]
    SWI3 = 184,
    #[doc = "185 - IMSPI"]
    IMSPI = 185,
    #[doc = "187 - SPT1"]
    SPT1 = 187,
    #[doc = "188 - SPIMON0_VLTN"]
    SPIMON0_VLTN = 188,
    #[doc = "189 - SPIMON0_MTMON"]
    SPIMON0_MTMON = 189,
    #[doc = "190 - SPIMON0_LTMON"]
    SPIMON0_LTMON = 190,
    #[doc = "191 - SPIMON1_VLTN"]
    SPIMON1_VLTN = 191,
    #[doc = "192 - SPIMON1_MTMON"]
    SPIMON1_MTMON = 192,
    #[doc = "193 - SPIMON1_LTMON"]
    SPIMON1_LTMON = 193,
    #[doc = "194 - VTR1_PAD_MON"]
    VTR1_PAD_MON = 194,
    #[doc = "195 - VTR2_PAD_MON"]
    VTR2_PAD_MON = 195,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[cfg(feature = "rt")]
mod _vectors {
    extern "C" {
        fn GIRQ08();
        fn GIRQ09();
        fn GIRQ10();
        fn GIRQ11();
        fn GIRQ12();
        fn GIRQ13();
        fn GIRQ14();
        fn GIRQ15();
        fn GIRQ16();
        fn GIRQ17();
        fn GIRQ18();
        fn GIRQ20();
        fn GIRQ21();
        fn GIRQ23();
        fn GIRQ24();
        fn GIRQ26();
        fn I2CSMB0();
        fn I2CSMB1();
        fn I2CSMB2();
        fn I2CSMB3();
        fn DMA_CH00();
        fn DMA_CH01();
        fn DMA_CH02();
        fn DMA_CH03();
        fn DMA_CH04();
        fn DMA_CH05();
        fn DMA_CH06();
        fn DMA_CH07();
        fn DMA_CH08();
        fn DMA_CH09();
        fn UART0();
        fn LED0();
        fn LED1();
        fn SPT0();
        fn QMSPI0();
        fn QMSPI1();
        fn RTMR();
        fn HTMR0();
        fn HTMR1();
        fn EMC();
        fn TIMER32_0();
        fn TIMER32_1();
        fn CCT();
        fn CCT_CAP0();
        fn CCT_CAP1();
        fn CCT_CAP2();
        fn CCT_CAP3();
        fn CCT_CAP4();
        fn CCT_CAP5();
        fn CCT_CMP0();
        fn CCT_CMP1();
        fn I2CSMB4();
        fn WDT();
        fn CLK_MON();
        fn SWI0();
        fn SWI1();
        fn SWI2();
        fn SWI3();
        fn IMSPI();
        fn SPT1();
        fn SPIMON0_VLTN();
        fn SPIMON0_MTMON();
        fn SPIMON0_LTMON();
        fn SPIMON1_VLTN();
        fn SPIMON1_MTMON();
        fn SPIMON1_LTMON();
        fn VTR1_PAD_MON();
        fn VTR2_PAD_MON();
    }
    pub union Vector {
        _handler: unsafe extern "C" fn(),
        _reserved: u32,
    }
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    pub static __INTERRUPTS: [Vector; 196] = [
        Vector { _handler: GIRQ08 },
        Vector { _handler: GIRQ09 },
        Vector { _handler: GIRQ10 },
        Vector { _handler: GIRQ11 },
        Vector { _handler: GIRQ12 },
        Vector { _handler: GIRQ13 },
        Vector { _handler: GIRQ14 },
        Vector { _handler: GIRQ15 },
        Vector { _handler: GIRQ16 },
        Vector { _handler: GIRQ17 },
        Vector { _handler: GIRQ18 },
        Vector { _reserved: 0 },
        Vector { _handler: GIRQ20 },
        Vector { _handler: GIRQ21 },
        Vector { _handler: GIRQ23 },
        Vector { _handler: GIRQ24 },
        Vector { _reserved: 0 },
        Vector { _handler: GIRQ26 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: I2CSMB0 },
        Vector { _handler: I2CSMB1 },
        Vector { _handler: I2CSMB2 },
        Vector { _handler: I2CSMB3 },
        Vector { _handler: DMA_CH00 },
        Vector { _handler: DMA_CH01 },
        Vector { _handler: DMA_CH02 },
        Vector { _handler: DMA_CH03 },
        Vector { _handler: DMA_CH04 },
        Vector { _handler: DMA_CH05 },
        Vector { _handler: DMA_CH06 },
        Vector { _handler: DMA_CH07 },
        Vector { _handler: DMA_CH08 },
        Vector { _handler: DMA_CH09 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: UART0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: LED0 },
        Vector { _handler: LED1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPT0 },
        Vector { _handler: QMSPI0 },
        Vector { _handler: QMSPI1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: RTMR },
        Vector { _handler: HTMR0 },
        Vector { _handler: HTMR1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: EMC },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: TIMER32_0 },
        Vector { _handler: TIMER32_1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: CCT },
        Vector { _handler: CCT_CAP0 },
        Vector { _handler: CCT_CAP1 },
        Vector { _handler: CCT_CAP2 },
        Vector { _handler: CCT_CAP3 },
        Vector { _handler: CCT_CAP4 },
        Vector { _handler: CCT_CAP5 },
        Vector { _handler: CCT_CMP0 },
        Vector { _handler: CCT_CMP1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: I2CSMB4 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: WDT },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: CLK_MON },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SWI0 },
        Vector { _handler: SWI1 },
        Vector { _handler: SWI2 },
        Vector { _handler: SWI3 },
        Vector { _handler: IMSPI },
        Vector { _reserved: 0 },
        Vector { _handler: SPT1 },
        Vector { _handler: SPIMON0_VLTN },
        Vector {
            _handler: SPIMON0_MTMON,
        },
        Vector {
            _handler: SPIMON0_LTMON,
        },
        Vector { _handler: SPIMON1_VLTN },
        Vector {
            _handler: SPIMON1_MTMON,
        },
        Vector {
            _handler: SPIMON1_LTMON,
        },
        Vector { _handler: VTR1_PAD_MON },
        Vector { _handler: VTR2_PAD_MON },
    ];
}
#[doc = "The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed."]
pub const WDT: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x4000_0400usize as _) };
#[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base."]
pub const TIMER32_0: timer32_0::Timer320 = unsafe { timer32_0::Timer320::from_ptr(0x4000_0c80usize as _) };
pub const TIMER32_1: timer32_0::Timer320 = unsafe { timer32_0::Timer320::from_ptr(0x4000_0ca0usize as _) };
#[doc = "This is a 16-bit auto-reloading timer/counter."]
pub const CCT: cct::Cct = unsafe { cct::Cct::from_ptr(0x4000_1000usize as _) };
#[doc = "DMA Main Registers"]
pub const DMA_MAIN: dma_main::DmaMain = unsafe { dma_main::DmaMain::from_ptr(0x4000_2400usize as _) };
#[doc = "DMA Channel 00 Registers"]
pub const DMA_CHAN00: dma_chan00::DmaChan00 = unsafe { dma_chan00::DmaChan00::from_ptr(0x4000_2440usize as _) };
#[doc = "DMA Channel 01 Registers"]
pub const DMA_CHAN01: dma_chan01::DmaChan01 = unsafe { dma_chan01::DmaChan01::from_ptr(0x4000_2480usize as _) };
#[doc = "DMA Channel 02 Registers"]
pub const DMA_CHAN02: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_24c0usize as _) };
pub const DMA_CHAN03: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2500usize as _) };
pub const DMA_CHAN04: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2540usize as _) };
pub const DMA_CHAN05: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2580usize as _) };
pub const DMA_CHAN06: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_25c0usize as _) };
pub const DMA_CHAN07: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2600usize as _) };
pub const DMA_CHAN08: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2640usize as _) };
pub const DMA_CHAN09: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2680usize as _) };
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub const SMB0: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4000usize as _) };
pub const SMB1: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4400usize as _) };
pub const SMB2: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4800usize as _) };
pub const SMB3: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4c00usize as _) };
pub const SMB4: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_5000usize as _) };
#[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz."]
pub const PWM0: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5800usize as _) };
pub const SPT1: spt0::Spt0 = unsafe { spt0::Spt0::from_ptr(0x4000_6c00usize as _) };
#[doc = "SPI Peripheral Target Register."]
pub const SPT0: spt0::Spt0 = unsafe { spt0::Spt0::from_ptr(0x4000_7000usize as _) };
#[doc = "RTOS is a 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states."]
pub const RTOS: rtos::Rtos = unsafe { rtos::Rtos::from_ptr(0x4000_7400usize as _) };
#[doc = "The TFDP serially transmits EC-originated diagnostic vectors to an external debug trace system."]
pub const TFDP: tfdp::Tfdp = unsafe { tfdp::Tfdp::from_ptr(0x4000_8c00usize as _) };
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode."]
pub const HTM0: htm0::Htm0 = unsafe { htm0::Htm0::from_ptr(0x4000_9800usize as _) };
pub const HTM1: htm0::Htm0 = unsafe { htm0::Htm0::from_ptr(0x4000_9820usize as _) };
#[doc = "The VBAT Register Bank block is a block implemented for miscellaneous battery-backed registers."]
pub const VTR_REG_BANK: vtr_reg_bank::VtrRegBank = unsafe { vtr_reg_bank::VtrRegBank::from_ptr(0x4000_a400usize as _) };
#[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
pub const LED0: led0::Led0 = unsafe { led0::Led0::from_ptr(0x4000_b800usize as _) };
pub const LED1: led0::Led0 = unsafe { led0::Led0::from_ptr(0x4000_b900usize as _) };
#[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub const UART0: uart0::Uart0 = unsafe { uart0::Uart0::from_ptr(0x4000_c400usize as _) };
#[doc = "The ECIA works in conjunction with the processor interrupt interface to handle hardware interrupts andd exceptions."]
pub const ECIA: ecia::Ecia = unsafe { ecia::Ecia::from_ptr(0x4000_e000usize as _) };
#[doc = "This block is designed to be accessed internally by the EC via the register interface."]
pub const EC_REG_BANK: ec_reg_bank::EcRegBank = unsafe { ec_reg_bank::EcRegBank::from_ptr(0x4000_fc00usize as _) };
#[doc = "SPI Monitor Block"]
pub const SPI_MON0: spi_mon0::SpiMon0 = unsafe { spi_mon0::SpiMon0::from_ptr(0x4001_0000usize as _) };
pub const SPI_MON1: spi_mon0::SpiMon0 = unsafe { spi_mon0::SpiMon0::from_ptr(0x4001_0400usize as _) };
#[doc = "The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface."]
pub const QMSPI0: qmspi0::Qmspi0 = unsafe { qmspi0::Qmspi0::from_ptr(0x4007_0000usize as _) };
pub const QMSPI1: qmspi0::Qmspi0 = unsafe { qmspi0::Qmspi0::from_ptr(0x4007_0200usize as _) };
#[doc = "The Power, Clocks, and Resets (PCR) Section identifies clock sources, and reset inputs to the chip."]
pub const PCR: pcr::Pcr = unsafe { pcr::Pcr::from_ptr(0x4008_0100usize as _) };
#[doc = "GPIO Pin Control Registers"]
pub const GPIO: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x4008_1000usize as _) };
#[doc = "OTP Programming registers."]
pub const OTP: otp::Otp = unsafe { otp::Otp::from_ptr(0x4008_2000usize as _) };
#[doc = "The Logical Device Configuration registers support motherboard designs in which the resources required by their components are known and assigned by the BIOS at POST."]
pub const GCR: gcr::Gcr = unsafe { gcr::Gcr::from_ptr(0x400f_ff00usize as _) };
#[doc = "Environmental Monitor Block"]
pub const ENV_MON: env_mon::EnvMon = unsafe { env_mon::EnvMon::from_ptr(0x4020_0600usize as _) };
#[doc = "Internal Master SPI."]
pub const IMSPI: imspi::Imspi = unsafe { imspi::Imspi::from_ptr(0x4022_0000usize as _) };
#[doc = "Floating Point Unit"]
pub const FPU: fpu::Fpu = unsafe { fpu::Fpu::from_ptr(0xe000_ef30usize as _) };
#[doc = r" Number available in the NVIC for configuring priority"]
#[cfg(feature = "rt")]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
pub use Interrupt as interrupt;
#[doc = "Pin buffer drive type."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum BufferType {
    #[doc = "Output buffer type is Open-drain."]
    PUSH_PULL = 0x0,
    #[doc = "Output buffer type is Push-pull."]
    OPEN_DRAIN = 0x01,
}
impl BufferType {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> BufferType {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for BufferType {
    #[inline(always)]
    fn from(val: u8) -> BufferType {
        BufferType::from_bits(val)
    }
}
impl From<BufferType> for u8 {
    #[inline(always)]
    fn from(val: BufferType) -> u8 {
        BufferType::to_bits(val)
    }
}
#[doc = "Pin direction."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Dir {
    #[doc = "Input GPIO."]
    INPUT = 0x0,
    #[doc = "Output GPIO."]
    OUTPUT = 0x01,
}
impl Dir {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Dir {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Dir {
    #[inline(always)]
    fn from(val: u8) -> Dir {
        Dir::from_bits(val)
    }
}
impl From<Dir> for u8 {
    #[inline(always)]
    fn from(val: Dir) -> u8 {
        Dir::to_bits(val)
    }
}
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Function {
    #[doc = "GPIO function selected."]
    GPIO = 0x0,
    #[doc = "Function 1 selected."]
    F1 = 0x01,
    #[doc = "Function 2 selected."]
    F2 = 0x02,
    #[doc = "Function 3 selected."]
    F3 = 0x03,
    #[doc = "Function 4 selected."]
    F4 = 0x04,
    #[doc = "Function 5 selected."]
    F5 = 0x05,
    _RESERVED_6 = 0x06,
    _RESERVED_7 = 0x07,
}
impl Function {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Function {
        unsafe { core::mem::transmute(val & 0x07) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Function {
    #[inline(always)]
    fn from(val: u8) -> Function {
        Function::from_bits(val)
    }
}
impl From<Function> for u8 {
    #[inline(always)]
    fn from(val: Function) -> u8 {
        Function::to_bits(val)
    }
}
#[doc = "Power Gating Signals provide the chip Power Emulation options."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Pgs {
    #[doc = "The output buffer is tristated when VTR_PWRGD=0."]
    VTR = 0x0,
    #[doc = "The output buffer is tristated when VCC_PWRGD=0."]
    VCC = 0x01,
    #[doc = "The always unpowered setting on a GPIO will force the pin to tristate. The input and output are disabled, and the pad is in the lowest power state."]
    UNPOWERED = 0x02,
    _RESERVED_3 = 0x03,
}
impl Pgs {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Pgs {
        unsafe { core::mem::transmute(val & 0x03) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Pgs {
    #[inline(always)]
    fn from(val: u8) -> Pgs {
        Pgs::from_bits(val)
    }
}
impl From<Pgs> for u8 {
    #[inline(always)]
    fn from(val: Pgs) -> u8 {
        Pgs::to_bits(val)
    }
}
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Pol {
    #[doc = "Non-inverted polarity."]
    NON_INVERTED = 0x0,
    #[doc = "Inverted polarity."]
    INVERTED = 0x01,
}
impl Pol {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Pol {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Pol {
    #[inline(always)]
    fn from(val: u8) -> Pol {
        Pol::from_bits(val)
    }
}
impl From<Pol> for u8 {
    #[inline(always)]
    fn from(val: Pol) -> u8 {
        Pol::to_bits(val)
    }
}
#[doc = "Configure internal pull-up and pull-down resistors."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Pull {
    #[doc = "Pin tristates when no active driver is present on the pin."]
    NONE = 0x0,
    #[doc = "Pull up enabled."]
    UP = 0x01,
    #[doc = "Pull down enabled."]
    DOWN = 0x02,
    #[doc = "Pin is kept at previous voltage level when no active driver is present on the pin."]
    REPEATER = 0x03,
}
impl Pull {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Pull {
        unsafe { core::mem::transmute(val & 0x03) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Pull {
    #[inline(always)]
    fn from(val: u8) -> Pull {
        Pull::from_bits(val)
    }
}
impl From<Pull> for u8 {
    #[inline(always)]
    fn from(val: Pull) -> u8 {
        Pull::to_bits(val)
    }
}
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Sel {
    #[doc = "Single GPIO output data bit is enabled."]
    PIN = 0x0,
    #[doc = "Grouped Output GPIO is enabled."]
    GROUP = 0x01,
}
impl Sel {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Sel {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Sel {
    #[inline(always)]
    fn from(val: u8) -> Sel {
        Sel::from_bits(val)
    }
}
impl From<Sel> for u8 {
    #[inline(always)]
    fn from(val: Sel) -> u8 {
        Sel::to_bits(val)
    }
}
pub mod cct {
    #[doc = "This is a 16-bit auto-reloading timer/counter."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cct {
        ptr: *mut u8,
    }
    unsafe impl Send for Cct {}
    unsafe impl Sync for Cct {}
    impl Cct {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This register controls the capture and compare timer."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This register is used to configure capture and compare timers 0-3."]
        #[inline(always)]
        pub const fn cap0_ctrl(self) -> crate::common::Reg<regs::Cap0ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This register is used to configure capture and compare timers 4-5."]
        #[inline(always)]
        pub const fn cap1_ctrl(self) -> crate::common::Reg<regs::Cap1ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This register contains the current value of the Free Running Timer."]
        #[inline(always)]
        pub const fn free_run(self) -> crate::common::Reg<regs::FreeRun, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[inline(always)]
        pub const fn cap0(self) -> crate::common::Reg<regs::Cap0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
        #[inline(always)]
        pub const fn cap1(self) -> crate::common::Reg<regs::Cap1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[inline(always)]
        pub const fn cap2(self) -> crate::common::Reg<regs::Cap2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[inline(always)]
        pub const fn cap3(self) -> crate::common::Reg<regs::Cap3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
        #[inline(always)]
        pub const fn cap4(self) -> crate::common::Reg<regs::Cap4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
        #[inline(always)]
        pub const fn cap5(self) -> crate::common::Reg<regs::Cap5, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[inline(always)]
        pub const fn comp0(self) -> crate::common::Reg<regs::Comp0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[inline(always)]
        pub const fn comp1(self) -> crate::common::Reg<regs::Comp1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "This register selects the pin mapping to the capture register."]
        #[inline(always)]
        pub const fn mux_sel(self) -> crate::common::Reg<regs::MuxSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap0(pub u32);
        impl Cap0 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
            #[inline(always)]
            pub const fn cap_0(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
            #[inline(always)]
            pub fn set_cap_0(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap0 {
            #[inline(always)]
            fn default() -> Cap0 {
                Cap0(0)
            }
        }
        impl core::fmt::Debug for Cap0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap0").field("cap_0", &self.cap_0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap0 {{ cap_0: {=u32:?} }}", self.cap_0())
            }
        }
        #[doc = "This register is used to configure capture and compare timers 0-3."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap0ctrl(pub u32);
        impl Cap0ctrl {
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 0."]
            #[inline(always)]
            pub const fn cap_edge0(&self) -> super::vals::CapEdge0 {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::CapEdge0::from_bits(val as u8)
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 0."]
            #[inline(always)]
            pub fn set_cap_edge0(&mut self, val: super::vals::CapEdge0) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 0, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp0(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 0, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 0."]
            #[inline(always)]
            pub const fn fclk_sel0(&self) -> super::vals::FclkSel0 {
                let val = (self.0 >> 5usize) & 0x07;
                super::vals::FclkSel0::from_bits(val as u8)
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 0."]
            #[inline(always)]
            pub fn set_fclk_sel0(&mut self, val: super::vals::FclkSel0) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val.to_bits() as u32) & 0x07) << 5usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 1."]
            #[inline(always)]
            pub const fn cap_edge1(&self) -> super::vals::CapEdge1 {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::CapEdge1::from_bits(val as u8)
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 1."]
            #[inline(always)]
            pub fn set_cap_edge1(&mut self, val: super::vals::CapEdge1) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 1, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp1(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 1, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 1."]
            #[inline(always)]
            pub const fn fclk_sel1(&self) -> super::vals::FclkSel1 {
                let val = (self.0 >> 13usize) & 0x07;
                super::vals::FclkSel1::from_bits(val as u8)
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 1."]
            #[inline(always)]
            pub fn set_fclk_sel1(&mut self, val: super::vals::FclkSel1) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val.to_bits() as u32) & 0x07) << 13usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 2."]
            #[inline(always)]
            pub const fn cap_edge2(&self) -> super::vals::CapEdge2 {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::CapEdge2::from_bits(val as u8)
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 2."]
            #[inline(always)]
            pub fn set_cap_edge2(&mut self, val: super::vals::CapEdge2) {
                self.0 = (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 2, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 2, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 2."]
            #[inline(always)]
            pub const fn fclk_sel2(&self) -> super::vals::FclkSel2 {
                let val = (self.0 >> 21usize) & 0x07;
                super::vals::FclkSel2::from_bits(val as u8)
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 2."]
            #[inline(always)]
            pub fn set_fclk_sel2(&mut self, val: super::vals::FclkSel2) {
                self.0 = (self.0 & !(0x07 << 21usize)) | (((val.to_bits() as u32) & 0x07) << 21usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 3."]
            #[inline(always)]
            pub const fn cap_edge3(&self) -> super::vals::CapEdge3 {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::CapEdge3::from_bits(val as u8)
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 3."]
            #[inline(always)]
            pub fn set_cap_edge3(&mut self, val: super::vals::CapEdge3) {
                self.0 = (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 3, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp3(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 3, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 3."]
            #[inline(always)]
            pub const fn fclk_sel3(&self) -> super::vals::FclkSel3 {
                let val = (self.0 >> 29usize) & 0x07;
                super::vals::FclkSel3::from_bits(val as u8)
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 3."]
            #[inline(always)]
            pub fn set_fclk_sel3(&mut self, val: super::vals::FclkSel3) {
                self.0 = (self.0 & !(0x07 << 29usize)) | (((val.to_bits() as u32) & 0x07) << 29usize);
            }
        }
        impl Default for Cap0ctrl {
            #[inline(always)]
            fn default() -> Cap0ctrl {
                Cap0ctrl(0)
            }
        }
        impl core::fmt::Debug for Cap0ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap0ctrl")
                    .field("cap_edge0", &self.cap_edge0())
                    .field("filter_byp0", &self.filter_byp0())
                    .field("fclk_sel0", &self.fclk_sel0())
                    .field("cap_edge1", &self.cap_edge1())
                    .field("filter_byp1", &self.filter_byp1())
                    .field("fclk_sel1", &self.fclk_sel1())
                    .field("cap_edge2", &self.cap_edge2())
                    .field("filter_byp2", &self.filter_byp2())
                    .field("fclk_sel2", &self.fclk_sel2())
                    .field("cap_edge3", &self.cap_edge3())
                    .field("filter_byp3", &self.filter_byp3())
                    .field("fclk_sel3", &self.fclk_sel3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap0ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cap0ctrl {{ cap_edge0: {:?}, filter_byp0: {=bool:?}, fclk_sel0: {:?}, cap_edge1: {:?}, filter_byp1: {=bool:?}, fclk_sel1: {:?}, cap_edge2: {:?}, filter_byp2: {=bool:?}, fclk_sel2: {:?}, cap_edge3: {:?}, filter_byp3: {=bool:?}, fclk_sel3: {:?} }}" , self . cap_edge0 () , self . filter_byp0 () , self . fclk_sel0 () , self . cap_edge1 () , self . filter_byp1 () , self . fclk_sel1 () , self . cap_edge2 () , self . filter_byp2 () , self . fclk_sel2 () , self . cap_edge3 () , self . filter_byp3 () , self . fclk_sel3 ())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap1(pub u32);
        impl Cap1 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
            #[inline(always)]
            pub const fn cap_1(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
            #[inline(always)]
            pub fn set_cap_1(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap1 {
            #[inline(always)]
            fn default() -> Cap1 {
                Cap1(0)
            }
        }
        impl core::fmt::Debug for Cap1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap1").field("cap_1", &self.cap_1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap1 {{ cap_1: {=u32:?} }}", self.cap_1())
            }
        }
        #[doc = "This register is used to configure capture and compare timers 4-5."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap1ctrl(pub u32);
        impl Cap1ctrl {
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 4."]
            #[inline(always)]
            pub const fn cap_edge4(&self) -> super::vals::CapEdge4 {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::CapEdge4::from_bits(val as u8)
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 4."]
            #[inline(always)]
            pub fn set_cap_edge4(&mut self, val: super::vals::CapEdge4) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 4, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp4(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 4, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 4."]
            #[inline(always)]
            pub const fn fclk_sel4(&self) -> super::vals::FclkSel4 {
                let val = (self.0 >> 5usize) & 0x07;
                super::vals::FclkSel4::from_bits(val as u8)
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 4."]
            #[inline(always)]
            pub fn set_fclk_sel4(&mut self, val: super::vals::FclkSel4) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val.to_bits() as u32) & 0x07) << 5usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 5."]
            #[inline(always)]
            pub const fn cap_edge5(&self) -> super::vals::CapEdge5 {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::CapEdge5::from_bits(val as u8)
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 5."]
            #[inline(always)]
            pub fn set_cap_edge5(&mut self, val: super::vals::CapEdge5) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 5, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp5(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 5, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 5."]
            #[inline(always)]
            pub const fn fclk_sel5(&self) -> super::vals::FclkSel5 {
                let val = (self.0 >> 13usize) & 0x07;
                super::vals::FclkSel5::from_bits(val as u8)
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 5."]
            #[inline(always)]
            pub fn set_fclk_sel5(&mut self, val: super::vals::FclkSel5) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val.to_bits() as u32) & 0x07) << 13usize);
            }
        }
        impl Default for Cap1ctrl {
            #[inline(always)]
            fn default() -> Cap1ctrl {
                Cap1ctrl(0)
            }
        }
        impl core::fmt::Debug for Cap1ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap1ctrl")
                    .field("cap_edge4", &self.cap_edge4())
                    .field("filter_byp4", &self.filter_byp4())
                    .field("fclk_sel4", &self.fclk_sel4())
                    .field("cap_edge5", &self.cap_edge5())
                    .field("filter_byp5", &self.filter_byp5())
                    .field("fclk_sel5", &self.fclk_sel5())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap1ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cap1ctrl {{ cap_edge4: {:?}, filter_byp4: {=bool:?}, fclk_sel4: {:?}, cap_edge5: {:?}, filter_byp5: {=bool:?}, fclk_sel5: {:?} }}" , self . cap_edge4 () , self . filter_byp4 () , self . fclk_sel4 () , self . cap_edge5 () , self . filter_byp5 () , self . fclk_sel5 ())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap2(pub u32);
        impl Cap2 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT2."]
            #[inline(always)]
            pub const fn cap_2(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT2."]
            #[inline(always)]
            pub fn set_cap_2(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap2 {
            #[inline(always)]
            fn default() -> Cap2 {
                Cap2(0)
            }
        }
        impl core::fmt::Debug for Cap2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap2").field("cap_2", &self.cap_2()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap2 {{ cap_2: {=u32:?} }}", self.cap_2())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap3(pub u32);
        impl Cap3 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT3."]
            #[inline(always)]
            pub const fn cap_3(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT3."]
            #[inline(always)]
            pub fn set_cap_3(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap3 {
            #[inline(always)]
            fn default() -> Cap3 {
                Cap3(0)
            }
        }
        impl core::fmt::Debug for Cap3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap3").field("cap_3", &self.cap_3()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap3 {{ cap_3: {=u32:?} }}", self.cap_3())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap4(pub u32);
        impl Cap4 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
            #[inline(always)]
            pub const fn cap_4(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
            #[inline(always)]
            pub fn set_cap_4(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap4 {
            #[inline(always)]
            fn default() -> Cap4 {
                Cap4(0)
            }
        }
        impl core::fmt::Debug for Cap4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap4").field("cap_4", &self.cap_4()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap4 {{ cap_4: {=u32:?} }}", self.cap_4())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap5(pub u32);
        impl Cap5 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
            #[inline(always)]
            pub const fn cap_5(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
            #[inline(always)]
            pub fn set_cap_5(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap5 {
            #[inline(always)]
            fn default() -> Cap5 {
                Cap5(0)
            }
        }
        impl core::fmt::Debug for Cap5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap5").field("cap_5", &self.cap_5()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap5 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap5 {{ cap_5: {=u32:?} }}", self.cap_5())
            }
        }
        #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Comp0(pub u32);
        impl Comp0 {
            #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub const fn comp_0(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub fn set_comp_0(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Comp0 {
            #[inline(always)]
            fn default() -> Comp0 {
                Comp0(0)
            }
        }
        impl core::fmt::Debug for Comp0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Comp0").field("comp_0", &self.comp_0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Comp0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Comp0 {{ comp_0: {=u32:?} }}", self.comp_0())
            }
        }
        #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Comp1(pub u32);
        impl Comp1 {
            #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub const fn comp_1(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub fn set_comp_1(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Comp1 {
            #[inline(always)]
            fn default() -> Comp1 {
                Comp1(0)
            }
        }
        impl core::fmt::Debug for Comp1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Comp1").field("comp_1", &self.comp_1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Comp1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Comp1 {{ comp_1: {=u32:?} }}", self.comp_1())
            }
        }
        #[doc = "This register controls the capture and compare timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This bit is used to start the capture and compare timer running and power it down."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to start the capture and compare timer running and power it down."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Free-Running Timer Enable. This bit is used to start and stop the free running timer."]
            #[inline(always)]
            pub const fn free_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Free-Running Timer Enable. This bit is used to start and stop the free running timer."]
            #[inline(always)]
            pub fn set_free_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Free Running Timer Reset. This bit stops the timer and resets the internal counter to 0000_0000h."]
            #[inline(always)]
            pub const fn free_rst(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Free Running Timer Reset. This bit stops the timer and resets the internal counter to 0000_0000h."]
            #[inline(always)]
            pub fn set_free_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This 3-bit field sets the clock source for the Free-Running Counter."]
            #[inline(always)]
            pub const fn tclk(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the Free-Running Counter."]
            #[inline(always)]
            pub fn set_tclk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
            }
            #[doc = "Compare Enable for Compare 0 Register."]
            #[inline(always)]
            pub const fn cmp_en0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Compare Enable for Compare 0 Register."]
            #[inline(always)]
            pub fn set_cmp_en0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Compare Enable for Compare 1 Register."]
            #[inline(always)]
            pub const fn cmp_en1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Compare Enable for Compare 1 Register."]
            #[inline(always)]
            pub fn set_cmp_en1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub const fn cmp_set1(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub fn set_cmp_set1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub const fn cmp_set0(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub fn set_cmp_set0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub const fn cmp_clr1(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub fn set_cmp_clr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub const fn cmp_clr0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub fn set_cmp_clr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("act", &self.act())
                    .field("free_en", &self.free_en())
                    .field("free_rst", &self.free_rst())
                    .field("tclk", &self.tclk())
                    .field("cmp_en0", &self.cmp_en0())
                    .field("cmp_en1", &self.cmp_en1())
                    .field("cmp_set1", &self.cmp_set1())
                    .field("cmp_set0", &self.cmp_set0())
                    .field("cmp_clr1", &self.cmp_clr1())
                    .field("cmp_clr0", &self.cmp_clr0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ act: {=bool:?}, free_en: {=bool:?}, free_rst: {=bool:?}, tclk: {=u8:?}, cmp_en0: {=bool:?}, cmp_en1: {=bool:?}, cmp_set1: {=bool:?}, cmp_set0: {=bool:?}, cmp_clr1: {=bool:?}, cmp_clr0: {=bool:?} }}" , self . act () , self . free_en () , self . free_rst () , self . tclk () , self . cmp_en0 () , self . cmp_en1 () , self . cmp_set1 () , self . cmp_set0 () , self . cmp_clr1 () , self . cmp_clr0 ())
            }
        }
        #[doc = "This register contains the current value of the Free Running Timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FreeRun(pub u32);
        impl FreeRun {
            #[doc = "This register contains the current value of the Free Running Timer."]
            #[inline(always)]
            pub const fn tmr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register contains the current value of the Free Running Timer."]
            #[inline(always)]
            pub fn set_tmr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FreeRun {
            #[inline(always)]
            fn default() -> FreeRun {
                FreeRun(0)
            }
        }
        impl core::fmt::Debug for FreeRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FreeRun").field("tmr", &self.tmr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FreeRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FreeRun {{ tmr: {=u32:?} }}", self.tmr())
            }
        }
        #[doc = "This register selects the pin mapping to the capture register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MuxSel(pub u32);
        impl MuxSel {
            #[doc = "Mux Select for Capture 0 register."]
            #[inline(always)]
            pub const fn cap0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 0 register."]
            #[inline(always)]
            pub fn set_cap0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Mux Select for Capture 1 register."]
            #[inline(always)]
            pub const fn cap1(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 1 register."]
            #[inline(always)]
            pub fn set_cap1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Mux Select for Capture 2 register."]
            #[inline(always)]
            pub const fn cap2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 2 register."]
            #[inline(always)]
            pub fn set_cap2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Mux Select for Capture 3 register."]
            #[inline(always)]
            pub const fn cap3(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 3 register."]
            #[inline(always)]
            pub fn set_cap3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "Mux Select for Capture 4 register."]
            #[inline(always)]
            pub const fn cap4(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 4 register."]
            #[inline(always)]
            pub fn set_cap4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Mux Select for Capture 5 register."]
            #[inline(always)]
            pub const fn cap5(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Mux Select for Capture 5 register."]
            #[inline(always)]
            pub fn set_cap5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
        }
        impl Default for MuxSel {
            #[inline(always)]
            fn default() -> MuxSel {
                MuxSel(0)
            }
        }
        impl core::fmt::Debug for MuxSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MuxSel")
                    .field("cap0", &self.cap0())
                    .field("cap1", &self.cap1())
                    .field("cap2", &self.cap2())
                    .field("cap3", &self.cap3())
                    .field("cap4", &self.cap4())
                    .field("cap5", &self.cap5())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MuxSel {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MuxSel {{ cap0: {=u8:?}, cap1: {=u8:?}, cap2: {=u8:?}, cap3: {=u8:?}, cap4: {=u8:?}, cap5: {=u8:?} }}" , self . cap0 () , self . cap1 () , self . cap2 () , self . cap3 () , self . cap4 () , self . cap5 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CapEdge0 {
            #[doc = "Capture on falling edge"]
            FALLING = 0x0,
            #[doc = "Capture on rising edge"]
            RISING = 0x01,
            #[doc = "Capture on both falling and rising edges"]
            BOTH = 0x02,
            #[doc = "Capture event disabled"]
            DISABLED = 0x03,
        }
        impl CapEdge0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CapEdge0 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CapEdge0 {
            #[inline(always)]
            fn from(val: u8) -> CapEdge0 {
                CapEdge0::from_bits(val)
            }
        }
        impl From<CapEdge0> for u8 {
            #[inline(always)]
            fn from(val: CapEdge0) -> u8 {
                CapEdge0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CapEdge1 {
            #[doc = "Capture on falling edge"]
            FALLING = 0x0,
            #[doc = "Capture on rising edge"]
            RISING = 0x01,
            #[doc = "Capture on both falling and rising edges"]
            BOTH = 0x02,
            #[doc = "Capture event disabled"]
            DISABLED = 0x03,
        }
        impl CapEdge1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CapEdge1 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CapEdge1 {
            #[inline(always)]
            fn from(val: u8) -> CapEdge1 {
                CapEdge1::from_bits(val)
            }
        }
        impl From<CapEdge1> for u8 {
            #[inline(always)]
            fn from(val: CapEdge1) -> u8 {
                CapEdge1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CapEdge2 {
            #[doc = "Capture on falling edge"]
            FALLING = 0x0,
            #[doc = "Capture on rising edge"]
            RISING = 0x01,
            #[doc = "Capture on both falling and rising edges"]
            BOTH = 0x02,
            #[doc = "Capture event disabled"]
            DISABLED = 0x03,
        }
        impl CapEdge2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CapEdge2 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CapEdge2 {
            #[inline(always)]
            fn from(val: u8) -> CapEdge2 {
                CapEdge2::from_bits(val)
            }
        }
        impl From<CapEdge2> for u8 {
            #[inline(always)]
            fn from(val: CapEdge2) -> u8 {
                CapEdge2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CapEdge3 {
            #[doc = "Capture on falling edge"]
            FALLING = 0x0,
            #[doc = "Capture on rising edge"]
            RISING = 0x01,
            #[doc = "Capture on both falling and rising edges"]
            BOTH = 0x02,
            #[doc = "Capture event disabled"]
            DISABLED = 0x03,
        }
        impl CapEdge3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CapEdge3 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CapEdge3 {
            #[inline(always)]
            fn from(val: u8) -> CapEdge3 {
                CapEdge3::from_bits(val)
            }
        }
        impl From<CapEdge3> for u8 {
            #[inline(always)]
            fn from(val: CapEdge3) -> u8 {
                CapEdge3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CapEdge4 {
            #[doc = "Capture on falling edge"]
            FALLING = 0x0,
            #[doc = "Capture on rising edge"]
            RISING = 0x01,
            #[doc = "Capture on both falling and rising edges"]
            BOTH = 0x02,
            #[doc = "Capture event disabled"]
            DISABLED = 0x03,
        }
        impl CapEdge4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CapEdge4 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CapEdge4 {
            #[inline(always)]
            fn from(val: u8) -> CapEdge4 {
                CapEdge4::from_bits(val)
            }
        }
        impl From<CapEdge4> for u8 {
            #[inline(always)]
            fn from(val: CapEdge4) -> u8 {
                CapEdge4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CapEdge5 {
            #[doc = "Capture on falling edge"]
            FALLING = 0x0,
            #[doc = "Capture on rising edge"]
            RISING = 0x01,
            #[doc = "Capture on both falling and rising edges"]
            BOTH = 0x02,
            #[doc = "Capture event disabled"]
            DISABLED = 0x03,
        }
        impl CapEdge5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CapEdge5 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CapEdge5 {
            #[inline(always)]
            fn from(val: u8) -> CapEdge5 {
                CapEdge5::from_bits(val)
            }
        }
        impl From<CapEdge5> for u8 {
            #[inline(always)]
            fn from(val: CapEdge5) -> u8 {
                CapEdge5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FclkSel0 {
            #[doc = "Divide by 1 (48 MHz)"]
            DIV_1 = 0x0,
            #[doc = "Divide by 2 (24 MHz)"]
            DIV_2 = 0x01,
            #[doc = "Divide by 4 (12 MHz)"]
            DIV_4 = 0x02,
            #[doc = "Divide by 8 (6 MHz)"]
            DIV_8 = 0x03,
            #[doc = "Divide by 16 (3 MHz)"]
            DIV_16 = 0x04,
            #[doc = "Divide by 32 (1.5 MHz)"]
            DIV_32 = 0x05,
            #[doc = "Divide by 64 (750 KHz)"]
            DIV_64 = 0x06,
            #[doc = "Divide by 128 (375 KHz)"]
            DIV_128 = 0x07,
        }
        impl FclkSel0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FclkSel0 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FclkSel0 {
            #[inline(always)]
            fn from(val: u8) -> FclkSel0 {
                FclkSel0::from_bits(val)
            }
        }
        impl From<FclkSel0> for u8 {
            #[inline(always)]
            fn from(val: FclkSel0) -> u8 {
                FclkSel0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FclkSel1 {
            #[doc = "Divide by 1 (48 MHz)"]
            DIV_1 = 0x0,
            #[doc = "Divide by 2 (24 MHz)"]
            DIV_2 = 0x01,
            #[doc = "Divide by 4 (12 MHz)"]
            DIV_4 = 0x02,
            #[doc = "Divide by 8 (6 MHz)"]
            DIV_8 = 0x03,
            #[doc = "Divide by 16 (3 MHz)"]
            DIV_16 = 0x04,
            #[doc = "Divide by 32 (1.5 MHz)"]
            DIV_32 = 0x05,
            #[doc = "Divide by 64 (750 KHz)"]
            DIV_64 = 0x06,
            #[doc = "Divide by 128 (375 KHz)"]
            DIV_128 = 0x07,
        }
        impl FclkSel1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FclkSel1 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FclkSel1 {
            #[inline(always)]
            fn from(val: u8) -> FclkSel1 {
                FclkSel1::from_bits(val)
            }
        }
        impl From<FclkSel1> for u8 {
            #[inline(always)]
            fn from(val: FclkSel1) -> u8 {
                FclkSel1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FclkSel2 {
            #[doc = "Divide by 1 (48 MHz)"]
            DIV_1 = 0x0,
            #[doc = "Divide by 2 (24 MHz)"]
            DIV_2 = 0x01,
            #[doc = "Divide by 4 (12 MHz)"]
            DIV_4 = 0x02,
            #[doc = "Divide by 8 (6 MHz)"]
            DIV_8 = 0x03,
            #[doc = "Divide by 16 (3 MHz)"]
            DIV_16 = 0x04,
            #[doc = "Divide by 32 (1.5 MHz)"]
            DIV_32 = 0x05,
            #[doc = "Divide by 64 (750 KHz)"]
            DIV_64 = 0x06,
            #[doc = "Divide by 128 (375 KHz)"]
            DIV_128 = 0x07,
        }
        impl FclkSel2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FclkSel2 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FclkSel2 {
            #[inline(always)]
            fn from(val: u8) -> FclkSel2 {
                FclkSel2::from_bits(val)
            }
        }
        impl From<FclkSel2> for u8 {
            #[inline(always)]
            fn from(val: FclkSel2) -> u8 {
                FclkSel2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FclkSel3 {
            #[doc = "Divide by 1 (48 MHz)"]
            DIV_1 = 0x0,
            #[doc = "Divide by 2 (24 MHz)"]
            DIV_2 = 0x01,
            #[doc = "Divide by 4 (12 MHz)"]
            DIV_4 = 0x02,
            #[doc = "Divide by 8 (6 MHz)"]
            DIV_8 = 0x03,
            #[doc = "Divide by 16 (3 MHz)"]
            DIV_16 = 0x04,
            #[doc = "Divide by 32 (1.5 MHz)"]
            DIV_32 = 0x05,
            #[doc = "Divide by 64 (750 KHz)"]
            DIV_64 = 0x06,
            #[doc = "Divide by 128 (375 KHz)"]
            DIV_128 = 0x07,
        }
        impl FclkSel3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FclkSel3 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FclkSel3 {
            #[inline(always)]
            fn from(val: u8) -> FclkSel3 {
                FclkSel3::from_bits(val)
            }
        }
        impl From<FclkSel3> for u8 {
            #[inline(always)]
            fn from(val: FclkSel3) -> u8 {
                FclkSel3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FclkSel4 {
            #[doc = "Divide by 1 (48 MHz)"]
            DIV_1 = 0x0,
            #[doc = "Divide by 2 (24 MHz)"]
            DIV_2 = 0x01,
            #[doc = "Divide by 4 (12 MHz)"]
            DIV_4 = 0x02,
            #[doc = "Divide by 8 (6 MHz)"]
            DIV_8 = 0x03,
            #[doc = "Divide by 16 (3 MHz)"]
            DIV_16 = 0x04,
            #[doc = "Divide by 32 (1.5 MHz)"]
            DIV_32 = 0x05,
            #[doc = "Divide by 64 (750 KHz)"]
            DIV_64 = 0x06,
            #[doc = "Divide by 128 (375 KHz)"]
            DIV_128 = 0x07,
        }
        impl FclkSel4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FclkSel4 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FclkSel4 {
            #[inline(always)]
            fn from(val: u8) -> FclkSel4 {
                FclkSel4::from_bits(val)
            }
        }
        impl From<FclkSel4> for u8 {
            #[inline(always)]
            fn from(val: FclkSel4) -> u8 {
                FclkSel4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FclkSel5 {
            #[doc = "Divide by 1 (48 MHz)"]
            DIV_1 = 0x0,
            #[doc = "Divide by 2 (24 MHz)"]
            DIV_2 = 0x01,
            #[doc = "Divide by 4 (12 MHz)"]
            DIV_4 = 0x02,
            #[doc = "Divide by 8 (6 MHz)"]
            DIV_8 = 0x03,
            #[doc = "Divide by 16 (3 MHz)"]
            DIV_16 = 0x04,
            #[doc = "Divide by 32 (1.5 MHz)"]
            DIV_32 = 0x05,
            #[doc = "Divide by 64 (750 KHz)"]
            DIV_64 = 0x06,
            #[doc = "Divide by 128 (375 KHz)"]
            DIV_128 = 0x07,
        }
        impl FclkSel5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FclkSel5 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FclkSel5 {
            #[inline(always)]
            fn from(val: u8) -> FclkSel5 {
                FclkSel5::from_bits(val)
            }
        }
        impl From<FclkSel5> for u8 {
            #[inline(always)]
            fn from(val: FclkSel5) -> u8 {
                FclkSel5::to_bits(val)
            }
        }
    }
}
pub mod common {
    use core::marker::PhantomData;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct RW;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct R;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct W;
    mod sealed {
        use super::*;
        pub trait Access {}
        impl Access for R {}
        impl Access for W {}
        impl Access for RW {}
    }
    pub trait Access: sealed::Access + Copy {}
    impl Access for R {}
    impl Access for W {}
    impl Access for RW {}
    pub trait Read: Access {}
    impl Read for RW {}
    impl Read for R {}
    pub trait Write: Access {}
    impl Write for RW {}
    impl Write for W {}
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct Reg<T: Copy, A: Access> {
        ptr: *mut u8,
        phantom: PhantomData<*mut (T, A)>,
    }
    unsafe impl<T: Copy, A: Access> Send for Reg<T, A> {}
    unsafe impl<T: Copy, A: Access> Sync for Reg<T, A> {}
    impl<T: Copy, A: Access> Reg<T, A> {
        #[allow(clippy::missing_safety_doc)]
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut T) -> Self {
            Self {
                ptr: ptr as _,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut T {
            self.ptr as _
        }
    }
    impl<T: Copy, A: Read> Reg<T, A> {
        #[inline(always)]
        pub fn read(&self) -> T {
            unsafe { (self.ptr as *mut T).read_volatile() }
        }
    }
    impl<T: Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write_value(&self, val: T) {
            unsafe { (self.ptr as *mut T).write_volatile(val) }
        }
    }
    impl<T: Default + Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = Default::default();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
    impl<T: Copy, A: Read + Write> Reg<T, A> {
        #[inline(always)]
        pub fn modify<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = self.read();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
}
pub mod dma_chan00 {
    #[doc = "DMA Channel 00 Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaChan00 {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaChan00 {}
    unsafe impl Sync for DmaChan00 {}
    impl DmaChan00 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<regs::Activate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the starting address for the Memory device."]
        #[inline(always)]
        pub const fn mstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the ending address for the Memory device."]
        #[inline(always)]
        pub const fn mend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the Master Device address."]
        #[inline(always)]
        pub const fn dstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DMA Channel N Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[inline(always)]
        pub const fn ists(self) -> crate::common::Reg<regs::Ists, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "DMA CHANNEL N CRC ENABLE"]
        #[inline(always)]
        pub const fn crc_en(self) -> crate::common::Reg<regs::CrcEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "DMA CHANNEL N CRC DATA"]
        #[inline(always)]
        pub const fn crc_data(self) -> crate::common::Reg<regs::CrcData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "DMA CHANNEL N CRC POST STATUS"]
        #[inline(always)]
        pub const fn crc_post_sts(self) -> crate::common::Reg<regs::CrcPostSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate(pub u8);
        impl Activate {
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate {
            #[inline(always)]
            fn default() -> Activate {
                Activate(0)
            }
        }
        impl core::fmt::Debug for Activate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate {{ chn: {=bool:?} }}", self.chn())
            }
        }
        #[doc = "DMA CHANNEL N CRC DATA"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcData(pub u32);
        impl CrcData {
            #[doc = "Writes to this register initialize the CRC generator. Reads from this register return the output of the CRC that is calculated from the data transferred by DMA Channel N. The output of the CRC generator is bit-reversed and inverted on reads, as required by the CRC-32-IEEE definition. A CRC can be accumulated across multiple DMA transactions on Channel N. If it is necessary to save the intermediate CRC value, the result of the read of this register must be bit-reversed and inverted before being written back to this register."]
            #[inline(always)]
            pub const fn crc(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Writes to this register initialize the CRC generator. Reads from this register return the output of the CRC that is calculated from the data transferred by DMA Channel N. The output of the CRC generator is bit-reversed and inverted on reads, as required by the CRC-32-IEEE definition. A CRC can be accumulated across multiple DMA transactions on Channel N. If it is necessary to save the intermediate CRC value, the result of the read of this register must be bit-reversed and inverted before being written back to this register."]
            #[inline(always)]
            pub fn set_crc(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for CrcData {
            #[inline(always)]
            fn default() -> CrcData {
                CrcData(0)
            }
        }
        impl core::fmt::Debug for CrcData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcData").field("crc", &self.crc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CrcData {{ crc: {=u32:?} }}", self.crc())
            }
        }
        #[doc = "DMA CHANNEL N CRC ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcEn(pub u32);
        impl CrcEn {
            #[doc = "1=Enable the calculation of CRC-32 for DMA Channel N 0=Disable the calculation of CRC-32 for DMA Channel N"]
            #[inline(always)]
            pub const fn mode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable the calculation of CRC-32 for DMA Channel N 0=Disable the calculation of CRC-32 for DMA Channel N"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The bit enables the transfer of the calculated CRC-32 after the completion of the DMA transaction. If the DMA transaction is aborted by either firmware or an internal bus error, the transfer will not occur. If the target of the DMA transfer is a device and the device signaled the termination of the DMA transaction, the CRC post transfer will not occur. 1=Enable the transfer of CRC-32 for DMA Channel N after the DMA transaction completes 0=Disable the automatic transfer of the CRC"]
            #[inline(always)]
            pub const fn post_trans(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The bit enables the transfer of the calculated CRC-32 after the completion of the DMA transaction. If the DMA transaction is aborted by either firmware or an internal bus error, the transfer will not occur. If the target of the DMA transfer is a device and the device signaled the termination of the DMA transaction, the CRC post transfer will not occur. 1=Enable the transfer of CRC-32 for DMA Channel N after the DMA transaction completes 0=Disable the automatic transfer of the CRC"]
            #[inline(always)]
            pub fn set_post_trans(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for CrcEn {
            #[inline(always)]
            fn default() -> CrcEn {
                CrcEn(0)
            }
        }
        impl core::fmt::Debug for CrcEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcEn")
                    .field("mode", &self.mode())
                    .field("post_trans", &self.post_trans())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "CrcEn {{ mode: {=bool:?}, post_trans: {=bool:?} }}",
                    self.mode(),
                    self.post_trans()
                )
            }
        }
        #[doc = "DMA CHANNEL N CRC POST STATUS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcPostSts(pub u32);
        impl CrcPostSts {
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub const fn crc_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub fn set_crc_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub const fn crc_running(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub fn set_crc_running(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller has completed the post-transfer of the CRC data. This bit is cleared to '0b' when the a new DMA transfer starts."]
            #[inline(always)]
            pub const fn crc_data_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller has completed the post-transfer of the CRC data. This bit is cleared to '0b' when the a new DMA transfer starts."]
            #[inline(always)]
            pub fn set_crc_data_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller is processing the post-transfer of the CRC data. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub const fn crc_data_ready(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller is processing the post-transfer of the CRC data. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub fn set_crc_data_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for CrcPostSts {
            #[inline(always)]
            fn default() -> CrcPostSts {
                CrcPostSts(0)
            }
        }
        impl core::fmt::Debug for CrcPostSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcPostSts")
                    .field("crc_done", &self.crc_done())
                    .field("crc_running", &self.crc_running())
                    .field("crc_data_done", &self.crc_data_done())
                    .field("crc_data_ready", &self.crc_data_ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcPostSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CrcPostSts {{ crc_done: {=bool:?}, crc_running: {=bool:?}, crc_data_done: {=bool:?}, crc_data_ready: {=bool:?} }}" , self . crc_done () , self . crc_running () , self . crc_data_done () , self . crc_data_ready ())
            }
        }
        #[doc = "DMA Channel N Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub const fn run(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub fn set_run(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub const fn req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub fn set_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Sts {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Sts::from_bits(val as u8)
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Sts) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u32) & 0x03) << 3usize);
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub const fn tx_dir(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub fn set_tx_dir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub const fn hw_flow_ctrl_dev(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub fn set_hw_flow_ctrl_dev(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u32) & 0x7f) << 9usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub const fn inc_mem_addr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub fn set_inc_mem_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub const fn inc_dev_addr(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub fn set_inc_dev_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub const fn dis_hw_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub fn set_dis_hw_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub const fn trans_size(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub fn set_trans_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub const fn trans_go(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub fn set_trans_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub const fn trans_abort(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub fn set_trans_abort(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("run", &self.run())
                    .field("req", &self.req())
                    .field("done", &self.done())
                    .field("sts", &self.sts())
                    .field("busy", &self.busy())
                    .field("tx_dir", &self.tx_dir())
                    .field("hw_flow_ctrl_dev", &self.hw_flow_ctrl_dev())
                    .field("inc_mem_addr", &self.inc_mem_addr())
                    .field("inc_dev_addr", &self.inc_dev_addr())
                    .field("lock", &self.lock())
                    .field("dis_hw_flow_ctrl", &self.dis_hw_flow_ctrl())
                    .field("trans_size", &self.trans_size())
                    .field("trans_go", &self.trans_go())
                    .field("trans_abort", &self.trans_abort())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ run: {=bool:?}, req: {=bool:?}, done: {=bool:?}, sts: {:?}, busy: {=bool:?}, tx_dir: {=bool:?}, hw_flow_ctrl_dev: {=u8:?}, inc_mem_addr: {=bool:?}, inc_dev_addr: {=bool:?}, lock: {=bool:?}, dis_hw_flow_ctrl: {=bool:?}, trans_size: {=u8:?}, trans_go: {=bool:?}, trans_abort: {=bool:?} }}" , self . run () , self . req () , self . done () , self . sts () , self . busy () , self . tx_dir () , self . hw_flow_ctrl_dev () , self . inc_mem_addr () , self . inc_dev_addr () , self . lock () , self . dis_hw_flow_ctrl () , self . trans_size () , self . trans_go () , self . trans_abort ())
            }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("sts_en_bus_err", &self.sts_en_bus_err())
                    .field("sts_en_flow_ctrl", &self.sts_en_flow_ctrl())
                    .field("sts_en_done", &self.sts_en_done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ sts_en_bus_err: {=bool:?}, sts_en_flow_ctrl: {=bool:?}, sts_en_done: {=bool:?} }}",
                    self.sts_en_bus_err(),
                    self.sts_en_flow_ctrl(),
                    self.sts_en_done()
                )
            }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ists(pub u8);
        impl Ists {
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub const fn bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub fn set_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub const fn flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub fn set_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ists {
            #[inline(always)]
            fn default() -> Ists {
                Ists(0)
            }
        }
        impl core::fmt::Debug for Ists {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ists")
                    .field("bus_err", &self.bus_err())
                    .field("flow_ctrl", &self.flow_ctrl())
                    .field("done", &self.done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ists {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ists {{ bus_err: {=bool:?}, flow_ctrl: {=bool:?}, done: {=bool:?} }}",
                    self.bus_err(),
                    self.flow_ctrl(),
                    self.done()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sts {
            #[doc = "0: DMA Channel Control:Run is Disabled (0x0)"]
            DIS = 0x0,
            #[doc = "1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address"]
            LOC_DONE = 0x01,
            #[doc = "2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term"]
            EXT_DONE = 0x02,
            #[doc = "3: Error detected by the DMA"]
            ERROR = 0x03,
        }
        impl Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sts {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sts {
            #[inline(always)]
            fn from(val: u8) -> Sts {
                Sts::from_bits(val)
            }
        }
        impl From<Sts> for u8 {
            #[inline(always)]
            fn from(val: Sts) -> u8 {
                Sts::to_bits(val)
            }
        }
    }
}
pub mod dma_chan01 {
    #[doc = "DMA Channel 01 Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaChan01 {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaChan01 {}
    unsafe impl Sync for DmaChan01 {}
    impl DmaChan01 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<regs::Activate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the starting address for the Memory device."]
        #[inline(always)]
        pub const fn mstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the ending address for the Memory device."]
        #[inline(always)]
        pub const fn mend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the Master Device address."]
        #[inline(always)]
        pub const fn dstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DMA Channel N Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[inline(always)]
        pub const fn ists(self) -> crate::common::Reg<regs::Ists, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "DMA CHANNEL N FILL ENABLE"]
        #[inline(always)]
        pub const fn fill_en(self) -> crate::common::Reg<regs::FillEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "DMA CHANNEL N FILL DATA"]
        #[inline(always)]
        pub const fn fill_data(self) -> crate::common::Reg<regs::FillData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "DMA CHANNEL N FILL STATUS"]
        #[inline(always)]
        pub const fn fill_sts(self) -> crate::common::Reg<regs::FillSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate(pub u8);
        impl Activate {
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate {
            #[inline(always)]
            fn default() -> Activate {
                Activate(0)
            }
        }
        impl core::fmt::Debug for Activate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate {{ chn: {=bool:?} }}", self.chn())
            }
        }
        #[doc = "DMA Channel N Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub const fn run(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub fn set_run(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub const fn req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub fn set_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Sts {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Sts::from_bits(val as u8)
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Sts) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u32) & 0x03) << 3usize);
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub const fn tx_dir(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub fn set_tx_dir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub const fn hw_flow_ctrl_dev(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub fn set_hw_flow_ctrl_dev(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u32) & 0x7f) << 9usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub const fn inc_mem_addr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub fn set_inc_mem_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub const fn inc_dev_addr(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub fn set_inc_dev_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub const fn dis_hw_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub fn set_dis_hw_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub const fn trans_size(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub fn set_trans_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub const fn trans_go(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub fn set_trans_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub const fn trans_abort(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub fn set_trans_abort(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("run", &self.run())
                    .field("req", &self.req())
                    .field("done", &self.done())
                    .field("sts", &self.sts())
                    .field("busy", &self.busy())
                    .field("tx_dir", &self.tx_dir())
                    .field("hw_flow_ctrl_dev", &self.hw_flow_ctrl_dev())
                    .field("inc_mem_addr", &self.inc_mem_addr())
                    .field("inc_dev_addr", &self.inc_dev_addr())
                    .field("lock", &self.lock())
                    .field("dis_hw_flow_ctrl", &self.dis_hw_flow_ctrl())
                    .field("trans_size", &self.trans_size())
                    .field("trans_go", &self.trans_go())
                    .field("trans_abort", &self.trans_abort())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ run: {=bool:?}, req: {=bool:?}, done: {=bool:?}, sts: {:?}, busy: {=bool:?}, tx_dir: {=bool:?}, hw_flow_ctrl_dev: {=u8:?}, inc_mem_addr: {=bool:?}, inc_dev_addr: {=bool:?}, lock: {=bool:?}, dis_hw_flow_ctrl: {=bool:?}, trans_size: {=u8:?}, trans_go: {=bool:?}, trans_abort: {=bool:?} }}" , self . run () , self . req () , self . done () , self . sts () , self . busy () , self . tx_dir () , self . hw_flow_ctrl_dev () , self . inc_mem_addr () , self . inc_dev_addr () , self . lock () , self . dis_hw_flow_ctrl () , self . trans_size () , self . trans_go () , self . trans_abort ())
            }
        }
        #[doc = "DMA CHANNEL N FILL DATA"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FillData(pub u32);
        impl FillData {
            #[doc = "This is the data pattern used to fill memory."]
            #[inline(always)]
            pub const fn data(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the data pattern used to fill memory."]
            #[inline(always)]
            pub fn set_data(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FillData {
            #[inline(always)]
            fn default() -> FillData {
                FillData(0)
            }
        }
        impl core::fmt::Debug for FillData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FillData").field("data", &self.data()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FillData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FillData {{ data: {=u32:?} }}", self.data())
            }
        }
        #[doc = "DMA CHANNEL N FILL ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FillEn(pub u32);
        impl FillEn {
            #[doc = "1=Enable the DMA Channel Fill Engine N 0=Disable the DMA Channel Fill Engine"]
            #[inline(always)]
            pub const fn mode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable the DMA Channel Fill Engine N 0=Disable the DMA Channel Fill Engine"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for FillEn {
            #[inline(always)]
            fn default() -> FillEn {
                FillEn(0)
            }
        }
        impl core::fmt::Debug for FillEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FillEn").field("mode", &self.mode()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FillEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FillEn {{ mode: {=bool:?} }}", self.mode())
            }
        }
        #[doc = "DMA CHANNEL N FILL STATUS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FillSts(pub u32);
        impl FillSts {
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub const fn running(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub fn set_running(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for FillSts {
            #[inline(always)]
            fn default() -> FillSts {
                FillSts(0)
            }
        }
        impl core::fmt::Debug for FillSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FillSts")
                    .field("done", &self.done())
                    .field("running", &self.running())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FillSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FillSts {{ done: {=bool:?}, running: {=bool:?} }}",
                    self.done(),
                    self.running()
                )
            }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("sts_en_bus_err", &self.sts_en_bus_err())
                    .field("sts_en_flow_ctrl", &self.sts_en_flow_ctrl())
                    .field("sts_en_done", &self.sts_en_done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ sts_en_bus_err: {=bool:?}, sts_en_flow_ctrl: {=bool:?}, sts_en_done: {=bool:?} }}",
                    self.sts_en_bus_err(),
                    self.sts_en_flow_ctrl(),
                    self.sts_en_done()
                )
            }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ists(pub u8);
        impl Ists {
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub const fn bus_error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub fn set_bus_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub const fn flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub fn set_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ists {
            #[inline(always)]
            fn default() -> Ists {
                Ists(0)
            }
        }
        impl core::fmt::Debug for Ists {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ists")
                    .field("bus_error", &self.bus_error())
                    .field("flow_ctrl", &self.flow_ctrl())
                    .field("done", &self.done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ists {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ists {{ bus_error: {=bool:?}, flow_ctrl: {=bool:?}, done: {=bool:?} }}",
                    self.bus_error(),
                    self.flow_ctrl(),
                    self.done()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sts {
            #[doc = "0: DMA Channel Control:Run is Disabled (0x0)"]
            DIS = 0x0,
            #[doc = "1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address"]
            LOC_DONE = 0x01,
            #[doc = "2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term"]
            EXT_DONE = 0x02,
            #[doc = "3: Error detected by the DMA"]
            ERROR = 0x03,
        }
        impl Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sts {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sts {
            #[inline(always)]
            fn from(val: u8) -> Sts {
                Sts::from_bits(val)
            }
        }
        impl From<Sts> for u8 {
            #[inline(always)]
            fn from(val: Sts) -> u8 {
                Sts::to_bits(val)
            }
        }
    }
}
pub mod dma_chan02 {
    #[doc = "DMA Channel 02 Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaChan02 {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaChan02 {}
    unsafe impl Sync for DmaChan02 {}
    impl DmaChan02 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<regs::Activate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the starting address for the Memory device."]
        #[inline(always)]
        pub const fn mstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the ending address for the Memory device."]
        #[inline(always)]
        pub const fn mend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the Master Device address."]
        #[inline(always)]
        pub const fn dstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DMA Channel N Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[inline(always)]
        pub const fn ists(self) -> crate::common::Reg<regs::Ists, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate(pub u8);
        impl Activate {
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate {
            #[inline(always)]
            fn default() -> Activate {
                Activate(0)
            }
        }
        impl core::fmt::Debug for Activate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate {{ chn: {=bool:?} }}", self.chn())
            }
        }
        #[doc = "DMA Channel N Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub const fn run(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub fn set_run(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub const fn req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub fn set_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Sts {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Sts::from_bits(val as u8)
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Sts) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u32) & 0x03) << 3usize);
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub const fn tx_dir(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub fn set_tx_dir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub const fn hw_flow_ctrl_dev(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub fn set_hw_flow_ctrl_dev(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u32) & 0x7f) << 9usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub const fn inc_mem_addr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub fn set_inc_mem_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub const fn inc_dev_addr(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub fn set_inc_dev_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub const fn dis_hw_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub fn set_dis_hw_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub const fn trans_size(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub fn set_trans_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub const fn trans_go(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub fn set_trans_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub const fn trans_abort(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub fn set_trans_abort(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("run", &self.run())
                    .field("req", &self.req())
                    .field("done", &self.done())
                    .field("sts", &self.sts())
                    .field("busy", &self.busy())
                    .field("tx_dir", &self.tx_dir())
                    .field("hw_flow_ctrl_dev", &self.hw_flow_ctrl_dev())
                    .field("inc_mem_addr", &self.inc_mem_addr())
                    .field("inc_dev_addr", &self.inc_dev_addr())
                    .field("lock", &self.lock())
                    .field("dis_hw_flow_ctrl", &self.dis_hw_flow_ctrl())
                    .field("trans_size", &self.trans_size())
                    .field("trans_go", &self.trans_go())
                    .field("trans_abort", &self.trans_abort())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ run: {=bool:?}, req: {=bool:?}, done: {=bool:?}, sts: {:?}, busy: {=bool:?}, tx_dir: {=bool:?}, hw_flow_ctrl_dev: {=u8:?}, inc_mem_addr: {=bool:?}, inc_dev_addr: {=bool:?}, lock: {=bool:?}, dis_hw_flow_ctrl: {=bool:?}, trans_size: {=u8:?}, trans_go: {=bool:?}, trans_abort: {=bool:?} }}" , self . run () , self . req () , self . done () , self . sts () , self . busy () , self . tx_dir () , self . hw_flow_ctrl_dev () , self . inc_mem_addr () , self . inc_dev_addr () , self . lock () , self . dis_hw_flow_ctrl () , self . trans_size () , self . trans_go () , self . trans_abort ())
            }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("sts_en_bus_err", &self.sts_en_bus_err())
                    .field("sts_en_flow_ctrl", &self.sts_en_flow_ctrl())
                    .field("sts_en_done", &self.sts_en_done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ sts_en_bus_err: {=bool:?}, sts_en_flow_ctrl: {=bool:?}, sts_en_done: {=bool:?} }}",
                    self.sts_en_bus_err(),
                    self.sts_en_flow_ctrl(),
                    self.sts_en_done()
                )
            }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ists(pub u8);
        impl Ists {
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub const fn bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub fn set_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub const fn flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub fn set_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ists {
            #[inline(always)]
            fn default() -> Ists {
                Ists(0)
            }
        }
        impl core::fmt::Debug for Ists {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ists")
                    .field("bus_err", &self.bus_err())
                    .field("flow_ctrl", &self.flow_ctrl())
                    .field("done", &self.done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ists {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ists {{ bus_err: {=bool:?}, flow_ctrl: {=bool:?}, done: {=bool:?} }}",
                    self.bus_err(),
                    self.flow_ctrl(),
                    self.done()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sts {
            #[doc = "0: DMA Channel Control:Run is Disabled (0x0)"]
            DIS = 0x0,
            #[doc = "1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address"]
            LOC_DONE = 0x01,
            #[doc = "2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term"]
            EXT_DONE = 0x02,
            #[doc = "3: Error detected by the DMA"]
            ERROR = 0x03,
        }
        impl Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sts {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sts {
            #[inline(always)]
            fn from(val: u8) -> Sts {
                Sts::from_bits(val)
            }
        }
        impl From<Sts> for u8 {
            #[inline(always)]
            fn from(val: Sts) -> u8 {
                Sts::to_bits(val)
            }
        }
    }
}
pub mod dma_main {
    #[doc = "DMA Main Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaMain {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaMain {}
    unsafe impl Sync for DmaMain {}
    impl DmaMain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Soft reset the entire module. Enable the blocks operation."]
        #[inline(always)]
        pub const fn actrst(self) -> crate::common::Reg<regs::Actrst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Debug register that has the data that is stored in the Data Packet. This data is read data from the currently active transfer source."]
        #[inline(always)]
        pub const fn data_pkt(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Soft reset the entire module. Enable the blocks operation."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Actrst(pub u8);
        impl Actrst {
            #[doc = "Enable the blocks operation. (R/WS) 1=Enable block. Each individual channel must be enabled separately. 0=Disable all channels."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the blocks operation. (R/WS) 1=Enable block. Each individual channel must be enabled separately. 0=Disable all channels."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Soft reset the entire module. This bit is self-clearing."]
            #[inline(always)]
            pub const fn soft_rst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Soft reset the entire module. This bit is self-clearing."]
            #[inline(always)]
            pub fn set_soft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Actrst {
            #[inline(always)]
            fn default() -> Actrst {
                Actrst(0)
            }
        }
        impl core::fmt::Debug for Actrst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Actrst")
                    .field("act", &self.act())
                    .field("soft_rst", &self.soft_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Actrst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Actrst {{ act: {=bool:?}, soft_rst: {=bool:?} }}",
                    self.act(),
                    self.soft_rst()
                )
            }
        }
    }
}
pub mod ec_reg_bank {
    #[doc = "This block is designed to be accessed internally by the EC via the register interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EcRegBank {
        ptr: *mut u8,
    }
    unsafe impl Send for EcRegBank {}
    unsafe impl Sync for EcRegBank {}
    impl EcRegBank {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SRAM Configuration Register"]
        #[inline(always)]
        pub const fn sram_cnfg(self) -> crate::common::Reg<regs::SramCnfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "AHB Error Address \\[0:0\\]"]
        #[inline(always)]
        pub const fn ahb_err_addr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "AHB Error Control \\[0:0\\] AHB_ERROR_DISABLE, 0: EC memory exceptions are enabled. 1: EC memory exceptions are disabled."]
        #[inline(always)]
        pub const fn ahb_err_ctrl(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Interrupt Control \\[0:0\\] NVIC_EN (NVIC_EN) This bit enables Alternate NVIC IRQ's Vectors. The Alternate NVIC Vectors provides each interrupt event with a dedicated (direct) NVIC vector. 0 = Alternate NVIC vectors disabled, 1= Alternate NVIC vectors enabled"]
        #[inline(always)]
        pub const fn intr_ctrl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "ETM TRACE Enable \\[0:0\\] TRACE_EN (TRACE_EN) This bit enables the ARM TRACE debug port (ETM/ITM). The Trace Debug Interface pins are forced to the TRACE functions. 0 = ARM TRACE port disabled, 1= ARM TRACE port enabled"]
        #[inline(always)]
        pub const fn etm_ctrl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Debug Enable Register"]
        #[inline(always)]
        pub const fn debug_ctrl(self) -> crate::common::Reg<regs::DebugCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Lock Register"]
        #[inline(always)]
        pub const fn otp_lock(self) -> crate::common::Reg<regs::OtpLock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "WDT Event Count \\[3:0\\] WDT_COUNT (WDT_COUNT) These EC R/W bits are cleared to 0 on VCC1 POR, but not on a WDT. Note: This field is written by Boot ROM firmware to indicate the number of times a WDT fired before loading a good EC code image."]
        #[inline(always)]
        pub const fn wdt_cnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "AES HASH Byte Swap Control Register."]
        #[inline(always)]
        pub const fn aesh_bswap_ctrl(self) -> crate::common::Reg<regs::AeshBswapCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "GPIO Bank Power Register"]
        #[inline(always)]
        pub const fn gpio_bank_pwr(self) -> crate::common::Reg<regs::GpioBankPwr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "Security Monitor SRAM Bank Swap Register"]
        #[inline(always)]
        pub const fn sram_bnk_swp(self) -> crate::common::Reg<regs::SramBnkSwp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "Virtual Wire Source Configuration Register"]
        #[inline(always)]
        pub const fn vw_src_cngf(self) -> crate::common::Reg<regs::VwSrcCngf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "SPI Monitor's Inter-Bus Configuration Register"]
        #[inline(always)]
        pub const fn spimon_ib_cngf(self) -> crate::common::Reg<regs::SpimonIbCngf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc4usize) as _) }
        }
        #[doc = "PAD Monitor Control Register"]
        #[inline(always)]
        pub const fn pd_mon_ctrl(self) -> crate::common::Reg<regs::PdMonCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0240usize) as _) }
        }
        #[doc = "PAD Monitor Interrupt Enable Register"]
        #[inline(always)]
        pub const fn pd_mon_int_en(self) -> crate::common::Reg<regs::PdMonIntEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0244usize) as _) }
        }
        #[doc = "PAD Monitor Status Register"]
        #[inline(always)]
        pub const fn pd_mon_sts(self) -> crate::common::Reg<regs::PdMonSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0248usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "AES HASH Byte Swap Control Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AeshBswapCtrl(pub u32);
        impl AeshBswapCtrl {
            #[doc = "Used to enable byte swap on a DWORD during AHB read from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub const fn ip_byte_swap_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Used to enable byte swap on a DWORD during AHB read from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub fn set_ip_byte_swap_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Used to enable byte swap on a DWORD during AHB write from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub const fn op_byte_swap_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Used to enable byte swap on a DWORD during AHB write from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub fn set_op_byte_swap_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Used to enable word swap on a DWORD during AHB read from AES / HASH block 0=Disable."]
            #[inline(always)]
            pub const fn ip_blk_swap_en(&self) -> super::vals::IpBlkSwapEn {
                let val = (self.0 >> 2usize) & 0x07;
                super::vals::IpBlkSwapEn::from_bits(val as u8)
            }
            #[doc = "Used to enable word swap on a DWORD during AHB read from AES / HASH block 0=Disable."]
            #[inline(always)]
            pub fn set_ip_blk_swap_en(&mut self, val: super::vals::IpBlkSwapEn) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val.to_bits() as u32) & 0x07) << 2usize);
            }
            #[doc = "Used to enable word swap on a DWORD during AHB write from AES / HASH block 0=Disable."]
            #[inline(always)]
            pub const fn op_blk_swap_en(&self) -> super::vals::OpBlkSwapEn {
                let val = (self.0 >> 5usize) & 0x07;
                super::vals::OpBlkSwapEn::from_bits(val as u8)
            }
            #[doc = "Used to enable word swap on a DWORD during AHB write from AES / HASH block 0=Disable."]
            #[inline(always)]
            pub fn set_op_blk_swap_en(&mut self, val: super::vals::OpBlkSwapEn) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val.to_bits() as u32) & 0x07) << 5usize);
            }
        }
        impl Default for AeshBswapCtrl {
            #[inline(always)]
            fn default() -> AeshBswapCtrl {
                AeshBswapCtrl(0)
            }
        }
        impl core::fmt::Debug for AeshBswapCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AeshBswapCtrl")
                    .field("ip_byte_swap_en", &self.ip_byte_swap_en())
                    .field("op_byte_swap_en", &self.op_byte_swap_en())
                    .field("ip_blk_swap_en", &self.ip_blk_swap_en())
                    .field("op_blk_swap_en", &self.op_blk_swap_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AeshBswapCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "AeshBswapCtrl {{ ip_byte_swap_en: {=bool:?}, op_byte_swap_en: {=bool:?}, ip_blk_swap_en: {:?}, op_blk_swap_en: {:?} }}" , self . ip_byte_swap_en () , self . op_byte_swap_en () , self . ip_blk_swap_en () , self . op_blk_swap_en ())
            }
        }
        #[doc = "Debug Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DebugCtrl(pub u32);
        impl DebugCtrl {
            #[doc = "DEBUG_EN (JTAG_EN) This bit enables the JTAG/SWD debug port. 0= JTAG/SWD port disabled. JTAG/SWD cannot be enabled (i.e., the TRST# pin is ignored and the JTAG signals remain in their non-JTAG state) 1= JTAG/SWD port enabled. A high on TRST# enables JTAG or SWD, as determined by SWD_EN."]
            #[inline(always)]
            pub const fn jtag_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DEBUG_EN (JTAG_EN) This bit enables the JTAG/SWD debug port. 0= JTAG/SWD port disabled. JTAG/SWD cannot be enabled (i.e., the TRST# pin is ignored and the JTAG signals remain in their non-JTAG state) 1= JTAG/SWD port enabled. A high on TRST# enables JTAG or SWD, as determined by SWD_EN."]
            #[inline(always)]
            pub fn set_jtag_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This field determines which pins are affected by the TRST# debug enable pin. 3=Reserved 2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required 1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) and Serial Wire Viewer (SWV) are both required for debugging 0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high. This setting should be used when the JTAG TAP controller is required for debugging."]
            #[inline(always)]
            pub const fn dbg_pin_cfg(&self) -> super::vals::DbgPinCfg {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::DbgPinCfg::from_bits(val as u8)
            }
            #[doc = "This field determines which pins are affected by the TRST# debug enable pin. 3=Reserved 2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required 1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) and Serial Wire Viewer (SWV) are both required for debugging 0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high. This setting should be used when the JTAG TAP controller is required for debugging."]
            #[inline(always)]
            pub fn set_dbg_pin_cfg(&mut self, val: super::vals::DbgPinCfg) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u32) & 0x03) << 1usize);
            }
            #[doc = "If this bit is set to '1b' internal pull-up resistors are automatically enabled on the appropriate debugging port wires whenever the debug port is enabled (the DEBUG_EN bit in this register is '1b' and the JTAG_RST# pin is high). The setting of DEBUG_PIN_CFG determines which pins have pull-ups enabled when the debug port is enabled."]
            #[inline(always)]
            pub const fn jtag_pu_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is set to '1b' internal pull-up resistors are automatically enabled on the appropriate debugging port wires whenever the debug port is enabled (the DEBUG_EN bit in this register is '1b' and the JTAG_RST# pin is high). The setting of DEBUG_PIN_CFG determines which pins have pull-ups enabled when the debug port is enabled."]
            #[inline(always)]
            pub fn set_jtag_pu_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit sets the boundary scan tap controller accessibility from JTAG port. 1= Boundary scan tap controller accessibile through JTAG Port. 0= Boundary scan tap controller not accessibile through JTAG Port."]
            #[inline(always)]
            pub const fn bs_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit sets the boundary scan tap controller accessibility from JTAG port. 1= Boundary scan tap controller accessibile through JTAG Port. 0= Boundary scan tap controller not accessibile through JTAG Port."]
            #[inline(always)]
            pub fn set_bs_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for DebugCtrl {
            #[inline(always)]
            fn default() -> DebugCtrl {
                DebugCtrl(0)
            }
        }
        impl core::fmt::Debug for DebugCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DebugCtrl")
                    .field("jtag_en", &self.jtag_en())
                    .field("dbg_pin_cfg", &self.dbg_pin_cfg())
                    .field("jtag_pu_en", &self.jtag_pu_en())
                    .field("bs_en", &self.bs_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DebugCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DebugCtrl {{ jtag_en: {=bool:?}, dbg_pin_cfg: {:?}, jtag_pu_en: {=bool:?}, bs_en: {=bool:?} }}",
                    self.jtag_en(),
                    self.dbg_pin_cfg(),
                    self.jtag_pu_en(),
                    self.bs_en()
                )
            }
        }
        #[doc = "GPIO Bank Power Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GpioBankPwr(pub u32);
        impl GpioBankPwr {
            #[doc = "This bit must be programmed to 0h for proper operation of the device."]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit must be programmed to 0h for proper operation of the device."]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Voltage value on VTR2. This bit is set by Firmware after a VTR Power On Reset. It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7. 1=VTR2 is powered by 1.8V 0=VTR2 is powered by 3.3V."]
            #[inline(always)]
            pub const fn vtr_lvl2(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Voltage value on VTR2. This bit is set by Firmware after a VTR Power On Reset. It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7. 1=VTR2 is powered by 1.8V 0=VTR2 is powered by 3.3V."]
            #[inline(always)]
            pub fn set_vtr_lvl2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "GPIO Bank Power Lock. 0: VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are R/W 1 = VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are Read Only."]
            #[inline(always)]
            pub const fn gpio_bank_pwr_lock(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO Bank Power Lock. 0: VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are R/W 1 = VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are Read Only."]
            #[inline(always)]
            pub fn set_gpio_bank_pwr_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for GpioBankPwr {
            #[inline(always)]
            fn default() -> GpioBankPwr {
                GpioBankPwr(0)
            }
        }
        impl core::fmt::Debug for GpioBankPwr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GpioBankPwr")
                    .field("test", &self.test())
                    .field("vtr_lvl2", &self.vtr_lvl2())
                    .field("gpio_bank_pwr_lock", &self.gpio_bank_pwr_lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GpioBankPwr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GpioBankPwr {{ test: {=bool:?}, vtr_lvl2: {=bool:?}, gpio_bank_pwr_lock: {=bool:?} }}",
                    self.test(),
                    self.vtr_lvl2(),
                    self.gpio_bank_pwr_lock()
                )
            }
        }
        #[doc = "Lock Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OtpLock(pub u32);
        impl OtpLock {
            #[doc = "Test"]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Test"]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "VBAT RAM LOCK bit. 0 = Not Locked. 1 = Locked."]
            #[inline(always)]
            pub const fn vbat_ram_lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "VBAT RAM LOCK bit. 0 = Not Locked. 1 = Locked."]
            #[inline(always)]
            pub fn set_vbat_ram_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "VBAT REG LOCK. 0 = Not Locked. 1 = Locked."]
            #[inline(always)]
            pub const fn vbat_reg_lock(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "VBAT REG LOCK. 0 = Not Locked. 1 = Locked."]
            #[inline(always)]
            pub fn set_vbat_reg_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Secure Mailbox LOCK. 0 = Not Locked. 1 = Write Locked."]
            #[inline(always)]
            pub const fn scur_mbx_lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Secure Mailbox LOCK. 0 = Not Locked. 1 = Write Locked."]
            #[inline(always)]
            pub fn set_scur_mbx_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for OtpLock {
            #[inline(always)]
            fn default() -> OtpLock {
                OtpLock(0)
            }
        }
        impl core::fmt::Debug for OtpLock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OtpLock")
                    .field("test", &self.test())
                    .field("vbat_ram_lock", &self.vbat_ram_lock())
                    .field("vbat_reg_lock", &self.vbat_reg_lock())
                    .field("scur_mbx_lock", &self.scur_mbx_lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OtpLock {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "OtpLock {{ test: {=bool:?}, vbat_ram_lock: {=bool:?}, vbat_reg_lock: {=bool:?}, scur_mbx_lock: {=bool:?} }}" , self . test () , self . vbat_ram_lock () , self . vbat_reg_lock () , self . scur_mbx_lock ())
            }
        }
        #[doc = "PAD Monitor Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PdMonCtrl(pub u32);
        impl PdMonCtrl {
            #[doc = "Pad Monitor Control VTR1. 0=OFF, 1=1ms delay, 2=10ms delay, 3=100ms delay"]
            #[inline(always)]
            pub const fn ctrl_vtr1(&self) -> super::vals::CtrlVtr1 {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::CtrlVtr1::from_bits(val as u8)
            }
            #[doc = "Pad Monitor Control VTR1. 0=OFF, 1=1ms delay, 2=10ms delay, 3=100ms delay"]
            #[inline(always)]
            pub fn set_ctrl_vtr1(&mut self, val: super::vals::CtrlVtr1) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "PAD Monitor Override VTR1 0=Normal Operation 1=Override input_disable and pad_protect_n"]
            #[inline(always)]
            pub const fn ovrd_vtr1(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PAD Monitor Override VTR1 0=Normal Operation 1=Override input_disable and pad_protect_n"]
            #[inline(always)]
            pub fn set_ovrd_vtr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "PAD Monitor Override Input Disable VTR1. 0=Normal Operation 1=input_disable"]
            #[inline(always)]
            pub const fn vtr1_inpt_dis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "PAD Monitor Override Input Disable VTR1. 0=Normal Operation 1=input_disable"]
            #[inline(always)]
            pub fn set_vtr1_inpt_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "PAD Monitor Override Protect N VTR1."]
            #[inline(always)]
            pub const fn vtr1_protecn(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "PAD Monitor Override Protect N VTR1."]
            #[inline(always)]
            pub fn set_vtr1_protecn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Pad Monitor Control VTR2. 0=OFF, 1=1ms delay, 2=10ms delay, 3=100ms delay"]
            #[inline(always)]
            pub const fn ctrl_vtr2(&self) -> super::vals::CtrlVtr2 {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::CtrlVtr2::from_bits(val as u8)
            }
            #[doc = "Pad Monitor Control VTR2. 0=OFF, 1=1ms delay, 2=10ms delay, 3=100ms delay"]
            #[inline(always)]
            pub fn set_ctrl_vtr2(&mut self, val: super::vals::CtrlVtr2) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "PAD Monitor Override VTR2 0=Normal Operation 1=Override input_disable and pad_protect_n"]
            #[inline(always)]
            pub const fn ovrd_vtr2(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "PAD Monitor Override VTR2 0=Normal Operation 1=Override input_disable and pad_protect_n"]
            #[inline(always)]
            pub fn set_ovrd_vtr2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "PAD Monitor Override Input Disable VTR2. 0=Normal Operation 1=input_disable"]
            #[inline(always)]
            pub const fn vtr2_inpt_dis(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "PAD Monitor Override Input Disable VTR2. 0=Normal Operation 1=input_disable"]
            #[inline(always)]
            pub fn set_vtr2_inpt_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "PAD Monitor Override Protect N VTR2."]
            #[inline(always)]
            pub const fn vtr2_protecn(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "PAD Monitor Override Protect N VTR2."]
            #[inline(always)]
            pub fn set_vtr2_protecn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for PdMonCtrl {
            #[inline(always)]
            fn default() -> PdMonCtrl {
                PdMonCtrl(0)
            }
        }
        impl core::fmt::Debug for PdMonCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PdMonCtrl")
                    .field("ctrl_vtr1", &self.ctrl_vtr1())
                    .field("ovrd_vtr1", &self.ovrd_vtr1())
                    .field("vtr1_inpt_dis", &self.vtr1_inpt_dis())
                    .field("vtr1_protecn", &self.vtr1_protecn())
                    .field("ctrl_vtr2", &self.ctrl_vtr2())
                    .field("ovrd_vtr2", &self.ovrd_vtr2())
                    .field("vtr2_inpt_dis", &self.vtr2_inpt_dis())
                    .field("vtr2_protecn", &self.vtr2_protecn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PdMonCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PdMonCtrl {{ ctrl_vtr1: {:?}, ovrd_vtr1: {=bool:?}, vtr1_inpt_dis: {=bool:?}, vtr1_protecn: {=bool:?}, ctrl_vtr2: {:?}, ovrd_vtr2: {=bool:?}, vtr2_inpt_dis: {=bool:?}, vtr2_protecn: {=bool:?} }}" , self . ctrl_vtr1 () , self . ovrd_vtr1 () , self . vtr1_inpt_dis () , self . vtr1_protecn () , self . ctrl_vtr2 () , self . ovrd_vtr2 () , self . vtr2_inpt_dis () , self . vtr2_protecn ())
            }
        }
        #[doc = "PAD Monitor Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PdMonIntEn(pub u32);
        impl PdMonIntEn {
            #[doc = "Pad Monitor VTR1 Power Down Interrupt Enable."]
            #[inline(always)]
            pub const fn vtr1_pd_inten(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Pad Monitor VTR1 Power Down Interrupt Enable."]
            #[inline(always)]
            pub fn set_vtr1_pd_inten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Pad Monitor VTR1 Power Up Interrupt Enable"]
            #[inline(always)]
            pub const fn vtr1_pu_inten(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Pad Monitor VTR1 Power Up Interrupt Enable"]
            #[inline(always)]
            pub fn set_vtr1_pu_inten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Pad Monitor VTR2 Power Down Interrupt Enable."]
            #[inline(always)]
            pub const fn vtr2_pd_inten(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Pad Monitor VTR2 Power Down Interrupt Enable."]
            #[inline(always)]
            pub fn set_vtr2_pd_inten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Pad Monitor VTR2 Power Up Interrupt Enable"]
            #[inline(always)]
            pub const fn vtr2_pu_inten(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Pad Monitor VTR2 Power Up Interrupt Enable"]
            #[inline(always)]
            pub fn set_vtr2_pu_inten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for PdMonIntEn {
            #[inline(always)]
            fn default() -> PdMonIntEn {
                PdMonIntEn(0)
            }
        }
        impl core::fmt::Debug for PdMonIntEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PdMonIntEn")
                    .field("vtr1_pd_inten", &self.vtr1_pd_inten())
                    .field("vtr1_pu_inten", &self.vtr1_pu_inten())
                    .field("vtr2_pd_inten", &self.vtr2_pd_inten())
                    .field("vtr2_pu_inten", &self.vtr2_pu_inten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PdMonIntEn {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PdMonIntEn {{ vtr1_pd_inten: {=bool:?}, vtr1_pu_inten: {=bool:?}, vtr2_pd_inten: {=bool:?}, vtr2_pu_inten: {=bool:?} }}" , self . vtr1_pd_inten () , self . vtr1_pu_inten () , self . vtr2_pd_inten () , self . vtr2_pu_inten ())
            }
        }
        #[doc = "PAD Monitor Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PdMonSts(pub u32);
        impl PdMonSts {
            #[doc = "Pad Monitor VTR1 Power Down Status"]
            #[inline(always)]
            pub const fn vtr1_pd_sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Pad Monitor VTR1 Power Down Status"]
            #[inline(always)]
            pub fn set_vtr1_pd_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Pad Monitor VTR1 Power Up Status"]
            #[inline(always)]
            pub const fn vtr1_pu_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Pad Monitor VTR1 Power Up Status"]
            #[inline(always)]
            pub fn set_vtr1_pu_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Pad Monitor Current state VTR1"]
            #[inline(always)]
            pub const fn vtr1_cs_sts(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Pad Monitor Current state VTR1"]
            #[inline(always)]
            pub fn set_vtr1_cs_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Pad Monitor VTR2 Power Down Status"]
            #[inline(always)]
            pub const fn vtr2_pd_sts(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Pad Monitor VTR2 Power Down Status"]
            #[inline(always)]
            pub fn set_vtr2_pd_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Pad Monitor VTR2 Power Up Status"]
            #[inline(always)]
            pub const fn vtr2_pu_sts(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Pad Monitor VTR2 Power Up Status"]
            #[inline(always)]
            pub fn set_vtr2_pu_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Pad Monitor Current state VTR2"]
            #[inline(always)]
            pub const fn vtr2_cs_sts(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Pad Monitor Current state VTR2"]
            #[inline(always)]
            pub fn set_vtr2_cs_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for PdMonSts {
            #[inline(always)]
            fn default() -> PdMonSts {
                PdMonSts(0)
            }
        }
        impl core::fmt::Debug for PdMonSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PdMonSts")
                    .field("vtr1_pd_sts", &self.vtr1_pd_sts())
                    .field("vtr1_pu_sts", &self.vtr1_pu_sts())
                    .field("vtr1_cs_sts", &self.vtr1_cs_sts())
                    .field("vtr2_pd_sts", &self.vtr2_pd_sts())
                    .field("vtr2_pu_sts", &self.vtr2_pu_sts())
                    .field("vtr2_cs_sts", &self.vtr2_cs_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PdMonSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PdMonSts {{ vtr1_pd_sts: {=bool:?}, vtr1_pu_sts: {=bool:?}, vtr1_cs_sts: {=bool:?}, vtr2_pd_sts: {=bool:?}, vtr2_pu_sts: {=bool:?}, vtr2_cs_sts: {=bool:?} }}" , self . vtr1_pd_sts () , self . vtr1_pu_sts () , self . vtr1_cs_sts () , self . vtr2_pd_sts () , self . vtr2_pu_sts () , self . vtr2_cs_sts ())
            }
        }
        #[doc = "SPI Monitor's Inter-Bus Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpimonIbCngf(pub u32);
        impl SpimonIbCngf {
            #[doc = "QSPI0 Monitor 0. 1 = Route QMSPI0 Traffic to Monitor. 0 = Route Host AP0 Traffic to Monitor"]
            #[inline(always)]
            pub const fn mon0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "QSPI0 Monitor 0. 1 = Route QMSPI0 Traffic to Monitor. 0 = Route Host AP0 Traffic to Monitor"]
            #[inline(always)]
            pub fn set_mon0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "QSPI1 Monitor 1. 1 = Route QMSPI1 Traffic to Monitor. 0 = Route Host AP1 Traffic to Monitor"]
            #[inline(always)]
            pub const fn mon1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "QSPI1 Monitor 1. 1 = Route QMSPI1 Traffic to Monitor. 0 = Route Host AP1 Traffic to Monitor"]
            #[inline(always)]
            pub fn set_mon1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Lock bit for IDE"]
            #[inline(always)]
            pub const fn idl(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Lock bit for IDE"]
            #[inline(always)]
            pub fn set_idl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Delay Value"]
            #[inline(always)]
            pub const fn idv(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x1f;
                val as u8
            }
            #[doc = "Delay Value"]
            #[inline(always)]
            pub fn set_idv(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 20usize)) | (((val as u32) & 0x1f) << 20usize);
            }
            #[doc = "Delay Units"]
            #[inline(always)]
            pub const fn idu(&self) -> u8 {
                let val = (self.0 >> 25usize) & 0x03;
                val as u8
            }
            #[doc = "Delay Units"]
            #[inline(always)]
            pub fn set_idu(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 25usize)) | (((val as u32) & 0x03) << 25usize);
            }
            #[doc = "Inter-Bus Intervention Enable"]
            #[inline(always)]
            pub const fn ide(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Inter-Bus Intervention Enable"]
            #[inline(always)]
            pub fn set_ide(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
        }
        impl Default for SpimonIbCngf {
            #[inline(always)]
            fn default() -> SpimonIbCngf {
                SpimonIbCngf(0)
            }
        }
        impl core::fmt::Debug for SpimonIbCngf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpimonIbCngf")
                    .field("mon0", &self.mon0())
                    .field("mon1", &self.mon1())
                    .field("idl", &self.idl())
                    .field("idv", &self.idv())
                    .field("idu", &self.idu())
                    .field("ide", &self.ide())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpimonIbCngf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SpimonIbCngf {{ mon0: {=bool:?}, mon1: {=bool:?}, idl: {=bool:?}, idv: {=u8:?}, idu: {=u8:?}, ide: {=bool:?} }}" , self . mon0 () , self . mon1 () , self . idl () , self . idv () , self . idu () , self . ide ())
            }
        }
        #[doc = "Security Monitor SRAM Bank Swap Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SramBnkSwp(pub u32);
        impl SramBnkSwp {
            #[doc = "SRAM bank Swap Register"]
            #[inline(always)]
            pub const fn bnk_swp(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SRAM bank Swap Register"]
            #[inline(always)]
            pub fn set_bnk_swp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SramBnkSwp {
            #[inline(always)]
            fn default() -> SramBnkSwp {
                SramBnkSwp(0)
            }
        }
        impl core::fmt::Debug for SramBnkSwp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SramBnkSwp").field("bnk_swp", &self.bnk_swp()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SramBnkSwp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SramBnkSwp {{ bnk_swp: {=bool:?} }}", self.bnk_swp())
            }
        }
        #[doc = "SRAM Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SramCnfg(pub u8);
        impl SramCnfg {
            #[doc = "SRAM Configuration Register: 0: 384KB (352k Code, 32k Data) 1: 320kB (288k Code, 32k Data) 2: 256kB (224k Code, 32k Data) 3: Illegal 256kB (224k Code, 32k Data)"]
            #[inline(always)]
            pub const fn sram_size(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "SRAM Configuration Register: 0: 384KB (352k Code, 32k Data) 1: 320kB (288k Code, 32k Data) 2: 256kB (224k Code, 32k Data) 3: Illegal 256kB (224k Code, 32k Data)"]
            #[inline(always)]
            pub fn set_sram_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
        }
        impl Default for SramCnfg {
            #[inline(always)]
            fn default() -> SramCnfg {
                SramCnfg(0)
            }
        }
        impl core::fmt::Debug for SramCnfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SramCnfg")
                    .field("sram_size", &self.sram_size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SramCnfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SramCnfg {{ sram_size: {=u8:?} }}", self.sram_size())
            }
        }
        #[doc = "Virtual Wire Source Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VwSrcCngf(pub u32);
        impl VwSrcCngf {
            #[doc = "VWIRE_SOURCE \\[2\\], VWIRE_SOURCE \\[1\\], VWIRE_SOURCE \\[0\\]"]
            #[inline(always)]
            pub const fn vw_src(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "VWIRE_SOURCE \\[2\\], VWIRE_SOURCE \\[1\\], VWIRE_SOURCE \\[0\\]"]
            #[inline(always)]
            pub fn set_vw_src(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for VwSrcCngf {
            #[inline(always)]
            fn default() -> VwSrcCngf {
                VwSrcCngf(0)
            }
        }
        impl core::fmt::Debug for VwSrcCngf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VwSrcCngf").field("vw_src", &self.vw_src()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VwSrcCngf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VwSrcCngf {{ vw_src: {=u8:?} }}", self.vw_src())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CtrlVtr1 {
            #[doc = "Disabled"]
            DISABLED = 0x0,
            #[doc = "1ms Debounce Counter Enable"]
            _1MS_DEBOUNCE_CNTR = 0x01,
            #[doc = "10ms Debounce Counter Enable"]
            _10MS_DEBOUNCE_CNTR = 0x02,
            #[doc = "100ms Debounce Counter Enable"]
            _100MS_DEBOUNCE_CNTR = 0x03,
        }
        impl CtrlVtr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CtrlVtr1 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CtrlVtr1 {
            #[inline(always)]
            fn from(val: u8) -> CtrlVtr1 {
                CtrlVtr1::from_bits(val)
            }
        }
        impl From<CtrlVtr1> for u8 {
            #[inline(always)]
            fn from(val: CtrlVtr1) -> u8 {
                CtrlVtr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CtrlVtr2 {
            #[doc = "Disabled"]
            DISABLED = 0x0,
            #[doc = "1ms Debounce Counter Enable"]
            _1MS_DEBOUNCE_CNTR = 0x01,
            #[doc = "10ms Debounce Counter Enable"]
            _10MS_DEBOUNCE_CNTR = 0x02,
            #[doc = "100ms Debounce Counter Enable"]
            _100MS_DEBOUNCE_CNTR = 0x03,
        }
        impl CtrlVtr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CtrlVtr2 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CtrlVtr2 {
            #[inline(always)]
            fn from(val: u8) -> CtrlVtr2 {
                CtrlVtr2::from_bits(val)
            }
        }
        impl From<CtrlVtr2> for u8 {
            #[inline(always)]
            fn from(val: CtrlVtr2) -> u8 {
                CtrlVtr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgPinCfg {
            #[doc = "0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high. This setting should be used when the JTAG TAP controller is required for debugging."]
            JTAG_TCK_TMS_TDO_TDI = 0x0,
            #[doc = "1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) and Serial Wire Viewer (SWV) are both required for debugging"]
            JTAG_TCK_TMS_TDO = 0x01,
            #[doc = "2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required"]
            JTAG_TCK_TMS = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl DbgPinCfg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgPinCfg {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgPinCfg {
            #[inline(always)]
            fn from(val: u8) -> DbgPinCfg {
                DbgPinCfg::from_bits(val)
            }
        }
        impl From<DbgPinCfg> for u8 {
            #[inline(always)]
            fn from(val: DbgPinCfg) -> u8 {
                DbgPinCfg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IpBlkSwapEn {
            #[doc = "0=Disable."]
            DIS = 0x0,
            #[doc = "1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4, 0x0, 0xC, 0x8, ..."]
            SWAP_8_BYTE_BLOCK = 0x01,
            #[doc = "2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,..."]
            SWAP_16_BYTE_BLOCK = 0x02,
            #[doc = "3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C, 0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,..."]
            SWAP_64_BYTE_BLOCK = 0x03,
            #[doc = "4=Swap 32-bit doublewords in 128-byte blocks"]
            SWAP_128_BYTE_BLOCK = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl IpBlkSwapEn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IpBlkSwapEn {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IpBlkSwapEn {
            #[inline(always)]
            fn from(val: u8) -> IpBlkSwapEn {
                IpBlkSwapEn::from_bits(val)
            }
        }
        impl From<IpBlkSwapEn> for u8 {
            #[inline(always)]
            fn from(val: IpBlkSwapEn) -> u8 {
                IpBlkSwapEn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum OpBlkSwapEn {
            #[doc = "0=Disable."]
            DIS = 0x0,
            #[doc = "1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4, 0x0, 0xC, 0x8, ..."]
            SWAP_8_BYTE_BLOCK = 0x01,
            #[doc = "2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,..."]
            SWAP_16_BYTE_BLOCK = 0x02,
            #[doc = "3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C, 0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,..."]
            SWAP_64_BYTE_BLOCK = 0x03,
            #[doc = "4=Swap 32-bit doublewords in 128-byte blocks"]
            SWAP_128_BYTE_BLOCK = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl OpBlkSwapEn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> OpBlkSwapEn {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for OpBlkSwapEn {
            #[inline(always)]
            fn from(val: u8) -> OpBlkSwapEn {
                OpBlkSwapEn::from_bits(val)
            }
        }
        impl From<OpBlkSwapEn> for u8 {
            #[inline(always)]
            fn from(val: OpBlkSwapEn) -> u8 {
                OpBlkSwapEn::to_bits(val)
            }
        }
    }
}
pub mod ecia {
    #[doc = "The ECIA works in conjunction with the processor interrupt interface to handle hardware interrupts andd exceptions."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ecia {
        ptr: *mut u8,
    }
    unsafe impl Send for Ecia {}
    unsafe impl Sync for Ecia {}
    impl Ecia {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "GIRQ8 SOURCE"]
        #[inline(always)]
        pub const fn src8(self) -> crate::common::Reg<regs::Src8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "GIRQ8 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set8(self) -> crate::common::Reg<regs::EnSet8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "GIRQ8 RESULT"]
        #[inline(always)]
        pub const fn result8(self) -> crate::common::Reg<regs::Result8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "GIRQ8 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr8(self) -> crate::common::Reg<regs::EnClr8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "GIRQ9 SOURCE"]
        #[inline(always)]
        pub const fn src9(self) -> crate::common::Reg<regs::Src9, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "GIRQ9 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set9(self) -> crate::common::Reg<regs::EnSet9, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "GIRQ9 RESULT"]
        #[inline(always)]
        pub const fn result9(self) -> crate::common::Reg<regs::Result9, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "GIRQ9 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr9(self) -> crate::common::Reg<regs::EnClr9, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "GIRQ10 SOURCE"]
        #[inline(always)]
        pub const fn src10(self) -> crate::common::Reg<regs::Src10, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "GIRQ10 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set10(self) -> crate::common::Reg<regs::EnSet10, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "GIRQ10 RESULT"]
        #[inline(always)]
        pub const fn result10(self) -> crate::common::Reg<regs::Result10, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "GIRQ10 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr10(self) -> crate::common::Reg<regs::EnClr10, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "GIRQ11 SOURCE"]
        #[inline(always)]
        pub const fn src11(self) -> crate::common::Reg<regs::Src11, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "GIRQ11 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set11(self) -> crate::common::Reg<regs::EnSet11, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "GIRQ11 RESULT"]
        #[inline(always)]
        pub const fn result11(self) -> crate::common::Reg<regs::Result11, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "GIRQ11 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr11(self) -> crate::common::Reg<regs::EnClr11, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "GIRQ12 SOURCE"]
        #[inline(always)]
        pub const fn src12(self) -> crate::common::Reg<regs::Src12, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "GIRQ12 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set12(self) -> crate::common::Reg<regs::EnSet12, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "GIRQ12 RESULT"]
        #[inline(always)]
        pub const fn result12(self) -> crate::common::Reg<regs::Result12, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "GIRQ12 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr12(self) -> crate::common::Reg<regs::EnClr12, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "GIRQ13 SOURCE"]
        #[inline(always)]
        pub const fn src13(self) -> crate::common::Reg<regs::Src13, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "GIRQ13 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set13(self) -> crate::common::Reg<regs::EnSet13, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize) as _) }
        }
        #[doc = "GIRQ13 RESULT"]
        #[inline(always)]
        pub const fn result13(self) -> crate::common::Reg<regs::Result13, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6cusize) as _) }
        }
        #[doc = "GIRQ13 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr13(self) -> crate::common::Reg<regs::EnClr13, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "GIRQ14 SOURCE"]
        #[inline(always)]
        pub const fn src14(self) -> crate::common::Reg<regs::Src14, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "GIRQ14 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set14(self) -> crate::common::Reg<regs::EnSet14, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "GIRQ14 RESULT"]
        #[inline(always)]
        pub const fn result14(self) -> crate::common::Reg<regs::Result14, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "GIRQ14 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr14(self) -> crate::common::Reg<regs::EnClr14, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "GIRQ15 SOURCE"]
        #[inline(always)]
        pub const fn src15(self) -> crate::common::Reg<regs::Src15, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "GIRQ15 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set15(self) -> crate::common::Reg<regs::EnSet15, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "GIRQ15 RESULT"]
        #[inline(always)]
        pub const fn result15(self) -> crate::common::Reg<regs::Result15, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "GIRQ15 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr15(self) -> crate::common::Reg<regs::EnClr15, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "GIRQ16 SOURCE"]
        #[inline(always)]
        pub const fn src16(self) -> crate::common::Reg<regs::Src16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "GIRQ16 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set16(self) -> crate::common::Reg<regs::EnSet16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "GIRQ16 RESULT"]
        #[inline(always)]
        pub const fn result16(self) -> crate::common::Reg<regs::Result16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "GIRQ16 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr16(self) -> crate::common::Reg<regs::EnClr16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xacusize) as _) }
        }
        #[doc = "GIRQ17 SOURCE"]
        #[inline(always)]
        pub const fn src17(self) -> crate::common::Reg<regs::Src17, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb4usize) as _) }
        }
        #[doc = "GIRQ17 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set17(self) -> crate::common::Reg<regs::EnSet17, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb8usize) as _) }
        }
        #[doc = "GIRQ17 RESULT"]
        #[inline(always)]
        pub const fn result17(self) -> crate::common::Reg<regs::Result17, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xbcusize) as _) }
        }
        #[doc = "GIRQ17 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr17(self) -> crate::common::Reg<regs::EnClr17, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "GIRQ18 SOURCE"]
        #[inline(always)]
        pub const fn src18(self) -> crate::common::Reg<regs::Src18, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc8usize) as _) }
        }
        #[doc = "GIRQ18 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set18(self) -> crate::common::Reg<regs::EnSet18, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xccusize) as _) }
        }
        #[doc = "GIRQ18 RESULT"]
        #[inline(always)]
        pub const fn result18(self) -> crate::common::Reg<regs::Result18, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd0usize) as _) }
        }
        #[doc = "GIRQ18 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr18(self) -> crate::common::Reg<regs::EnClr18, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd4usize) as _) }
        }
        #[doc = "GIRQ19 SOURCE"]
        #[inline(always)]
        pub const fn src19(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdcusize) as _) }
        }
        #[doc = "GIRQ19 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set19(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize) as _) }
        }
        #[doc = "GIRQ19 RESULT"]
        #[inline(always)]
        pub const fn result19(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe4usize) as _) }
        }
        #[doc = "GIRQ19 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr19(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe8usize) as _) }
        }
        #[doc = "GIRQ20 SOURCE"]
        #[inline(always)]
        pub const fn src20(self) -> crate::common::Reg<regs::Src20, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf0usize) as _) }
        }
        #[doc = "GIRQ20 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set20(self) -> crate::common::Reg<regs::EnSet20, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf4usize) as _) }
        }
        #[doc = "GIRQ20 RESULT"]
        #[inline(always)]
        pub const fn result20(self) -> crate::common::Reg<regs::Result20, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf8usize) as _) }
        }
        #[doc = "GIRQ20 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr20(self) -> crate::common::Reg<regs::EnClr20, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xfcusize) as _) }
        }
        #[doc = "GIRQ21 SOURCE"]
        #[inline(always)]
        pub const fn src21(self) -> crate::common::Reg<regs::Src21, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "GIRQ21 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set21(self) -> crate::common::Reg<regs::EnSet21, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "GIRQ21 RESULT"]
        #[inline(always)]
        pub const fn result21(self) -> crate::common::Reg<regs::Result21, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "GIRQ21 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr21(self) -> crate::common::Reg<regs::EnClr21, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "GIRQ22 SOURCE"]
        #[inline(always)]
        pub const fn src22(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "GIRQ22 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set22(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "GIRQ22 RESULT"]
        #[inline(always)]
        pub const fn result22(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "GIRQ22 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr22(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "GIRQ23 SOURCE"]
        #[inline(always)]
        pub const fn src23(self) -> crate::common::Reg<regs::Src23, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
        }
        #[doc = "GIRQ23 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set23(self) -> crate::common::Reg<regs::EnSet23, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "GIRQ23 RESULT"]
        #[inline(always)]
        pub const fn result23(self) -> crate::common::Reg<regs::Result23, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
        #[doc = "GIRQ23 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr23(self) -> crate::common::Reg<regs::EnClr23, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "GIRQ24 SOURCE"]
        #[inline(always)]
        pub const fn src24(self) -> crate::common::Reg<regs::Src24, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[doc = "GIRQ24 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set24(self) -> crate::common::Reg<regs::EnSet24, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0144usize) as _) }
        }
        #[doc = "GIRQ24 RESULT"]
        #[inline(always)]
        pub const fn result24(self) -> crate::common::Reg<regs::Result24, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0148usize) as _) }
        }
        #[doc = "GIRQ24 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr24(self) -> crate::common::Reg<regs::EnClr24, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "GIRQ25 SOURCE"]
        #[inline(always)]
        pub const fn src25(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0154usize) as _) }
        }
        #[doc = "GIRQ25 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set25(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0158usize) as _) }
        }
        #[doc = "GIRQ25 RESULT"]
        #[inline(always)]
        pub const fn result25(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x015cusize) as _) }
        }
        #[doc = "GIRQ25 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr25(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0160usize) as _) }
        }
        #[doc = "GIRQ26 SOURCE"]
        #[inline(always)]
        pub const fn src26(self) -> crate::common::Reg<regs::Src26, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0168usize) as _) }
        }
        #[doc = "GIRQ26 ENABLE SET"]
        #[inline(always)]
        pub const fn en_set26(self) -> crate::common::Reg<regs::EnSet26, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x016cusize) as _) }
        }
        #[doc = "GIRQ26 RESULT"]
        #[inline(always)]
        pub const fn result26(self) -> crate::common::Reg<regs::Result26, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0170usize) as _) }
        }
        #[doc = "GIRQ26 ENABLE CLEAR"]
        #[inline(always)]
        pub const fn en_clr26(self) -> crate::common::Reg<regs::EnClr26, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0174usize) as _) }
        }
        #[doc = "Block Enable Set Register"]
        #[inline(always)]
        pub const fn blk_en_set(self) -> crate::common::Reg<regs::BlkEnSet, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Block Enable Clear Register."]
        #[inline(always)]
        pub const fn blk_en_clr(self) -> crate::common::Reg<regs::BlkEnClr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize) as _) }
        }
        #[doc = "Block IRQ Vector Register"]
        #[inline(always)]
        pub const fn blk_irq_vtor(self) -> crate::common::Reg<regs::BlkIrqVtor, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Block Enable Clear Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BlkEnClr(pub u32);
        impl BlkEnClr {
            #[doc = "Each GIRQx bit can be individually disabled to inhibit an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WC) 1=All interrupts in the GIRQx Source Register are disabled 0=No effect."]
            #[inline(always)]
            pub const fn vtor_en_clr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "Each GIRQx bit can be individually disabled to inhibit an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WC) 1=All interrupts in the GIRQx Source Register are disabled 0=No effect."]
            #[inline(always)]
            pub fn set_vtor_en_clr(&mut self, val: u32) {
                self.0 = (self.0 & !(0x7fff_ffff << 0usize)) | (((val as u32) & 0x7fff_ffff) << 0usize);
            }
        }
        impl Default for BlkEnClr {
            #[inline(always)]
            fn default() -> BlkEnClr {
                BlkEnClr(0)
            }
        }
        impl core::fmt::Debug for BlkEnClr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BlkEnClr")
                    .field("vtor_en_clr", &self.vtor_en_clr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BlkEnClr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BlkEnClr {{ vtor_en_clr: {=u32:?} }}", self.vtor_en_clr())
            }
        }
        #[doc = "Block Enable Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BlkEnSet(pub u32);
        impl BlkEnSet {
            #[doc = "Each GIRQx bit can be individually enabled to assert an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WS) 1=Interrupts in the GIRQx Source Register may be enabled 0=No effect."]
            #[inline(always)]
            pub const fn vtor_en_set(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "Each GIRQx bit can be individually enabled to assert an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WS) 1=Interrupts in the GIRQx Source Register may be enabled 0=No effect."]
            #[inline(always)]
            pub fn set_vtor_en_set(&mut self, val: u32) {
                self.0 = (self.0 & !(0x7fff_ffff << 0usize)) | (((val as u32) & 0x7fff_ffff) << 0usize);
            }
        }
        impl Default for BlkEnSet {
            #[inline(always)]
            fn default() -> BlkEnSet {
                BlkEnSet(0)
            }
        }
        impl core::fmt::Debug for BlkEnSet {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BlkEnSet")
                    .field("vtor_en_set", &self.vtor_en_set())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BlkEnSet {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BlkEnSet {{ vtor_en_set: {=u32:?} }}", self.vtor_en_set())
            }
        }
        #[doc = "Block IRQ Vector Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BlkIrqVtor(pub u32);
        impl BlkIrqVtor {
            #[doc = "Each bit in this field reports the status of the group GIRQ interrupt assertion to the NVIC. If the GIRQx interrupt is disabled as a group, by the Block Enable Clear Register, then the corresponding bit will be '0'b and no interrupt will be asserted."]
            #[inline(always)]
            pub const fn vtor(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x01ff_ffff;
                val as u32
            }
            #[doc = "Each bit in this field reports the status of the group GIRQ interrupt assertion to the NVIC. If the GIRQx interrupt is disabled as a group, by the Block Enable Clear Register, then the corresponding bit will be '0'b and no interrupt will be asserted."]
            #[inline(always)]
            pub fn set_vtor(&mut self, val: u32) {
                self.0 = (self.0 & !(0x01ff_ffff << 0usize)) | (((val as u32) & 0x01ff_ffff) << 0usize);
            }
        }
        impl Default for BlkIrqVtor {
            #[inline(always)]
            fn default() -> BlkIrqVtor {
                BlkIrqVtor(0)
            }
        }
        impl core::fmt::Debug for BlkIrqVtor {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BlkIrqVtor").field("vtor", &self.vtor()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BlkIrqVtor {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BlkIrqVtor {{ vtor: {=u32:?} }}", self.vtor())
            }
        }
        #[doc = "GIRQ10 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr10(pub u32);
        impl EnClr10 {
            #[doc = "GPIO 045"]
            #[inline(always)]
            pub const fn gpio045(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 045"]
            #[inline(always)]
            pub fn set_gpio045(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 046"]
            #[inline(always)]
            pub const fn gpio046(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 046"]
            #[inline(always)]
            pub fn set_gpio046(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 047"]
            #[inline(always)]
            pub const fn gpio047(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 047"]
            #[inline(always)]
            pub fn set_gpio047(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 050"]
            #[inline(always)]
            pub const fn gpio050(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 050"]
            #[inline(always)]
            pub fn set_gpio050(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO 053"]
            #[inline(always)]
            pub const fn gpio053(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 053"]
            #[inline(always)]
            pub fn set_gpio053(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 055"]
            #[inline(always)]
            pub const fn gpio055(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 055"]
            #[inline(always)]
            pub fn set_gpio055(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "GPIO 056"]
            #[inline(always)]
            pub const fn gpio056(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 056"]
            #[inline(always)]
            pub fn set_gpio056(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 057"]
            #[inline(always)]
            pub const fn gpio057(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 057"]
            #[inline(always)]
            pub fn set_gpio057(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "GPIO 060"]
            #[inline(always)]
            pub const fn gpio063(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 060"]
            #[inline(always)]
            pub fn set_gpio063(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 070"]
            #[inline(always)]
            pub const fn gpio070(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 070"]
            #[inline(always)]
            pub fn set_gpio070(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 071"]
            #[inline(always)]
            pub const fn gpio071(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 071"]
            #[inline(always)]
            pub fn set_gpio071(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for EnClr10 {
            #[inline(always)]
            fn default() -> EnClr10 {
                EnClr10(0)
            }
        }
        impl core::fmt::Debug for EnClr10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr10")
                    .field("gpio045", &self.gpio045())
                    .field("gpio046", &self.gpio046())
                    .field("gpio047", &self.gpio047())
                    .field("gpio050", &self.gpio050())
                    .field("gpio053", &self.gpio053())
                    .field("gpio055", &self.gpio055())
                    .field("gpio056", &self.gpio056())
                    .field("gpio057", &self.gpio057())
                    .field("gpio063", &self.gpio063())
                    .field("gpio070", &self.gpio070())
                    .field("gpio071", &self.gpio071())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr10 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr10 {{ gpio045: {=bool:?}, gpio046: {=bool:?}, gpio047: {=bool:?}, gpio050: {=bool:?}, gpio053: {=bool:?}, gpio055: {=bool:?}, gpio056: {=bool:?}, gpio057: {=bool:?}, gpio063: {=bool:?}, gpio070: {=bool:?}, gpio071: {=bool:?} }}" , self . gpio045 () , self . gpio046 () , self . gpio047 () , self . gpio050 () , self . gpio053 () , self . gpio055 () , self . gpio056 () , self . gpio057 () , self . gpio063 () , self . gpio070 () , self . gpio071 ())
            }
        }
        #[doc = "GIRQ11 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr11(pub u32);
        impl EnClr11 {
            #[doc = "GPIO 000"]
            #[inline(always)]
            pub const fn gpio000(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 000"]
            #[inline(always)]
            pub fn set_gpio000(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 002"]
            #[inline(always)]
            pub const fn gpio002(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 002"]
            #[inline(always)]
            pub fn set_gpio002(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GPIO 003"]
            #[inline(always)]
            pub const fn gpio003(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 003"]
            #[inline(always)]
            pub fn set_gpio003(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 004"]
            #[inline(always)]
            pub const fn gpio004(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 004"]
            #[inline(always)]
            pub fn set_gpio004(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 012"]
            #[inline(always)]
            pub const fn gpio012(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 012"]
            #[inline(always)]
            pub fn set_gpio012(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "GPIO 013"]
            #[inline(always)]
            pub const fn gpio013(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 013"]
            #[inline(always)]
            pub fn set_gpio013(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 015"]
            #[inline(always)]
            pub const fn gpio015(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 015"]
            #[inline(always)]
            pub fn set_gpio015(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "GPIO 016"]
            #[inline(always)]
            pub const fn gpio016(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 016"]
            #[inline(always)]
            pub fn set_gpio016(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 020"]
            #[inline(always)]
            pub const fn gpio020(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 020"]
            #[inline(always)]
            pub fn set_gpio020(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPIO 021"]
            #[inline(always)]
            pub const fn gpio021(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 021"]
            #[inline(always)]
            pub fn set_gpio021(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "GPIO 022"]
            #[inline(always)]
            pub const fn gpio022(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 022"]
            #[inline(always)]
            pub fn set_gpio022(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "GPIO 023"]
            #[inline(always)]
            pub const fn gpio023(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 023"]
            #[inline(always)]
            pub fn set_gpio023(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 024"]
            #[inline(always)]
            pub const fn gpio024(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 024"]
            #[inline(always)]
            pub fn set_gpio024(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 026"]
            #[inline(always)]
            pub const fn gpio026(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 026"]
            #[inline(always)]
            pub fn set_gpio026(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 027"]
            #[inline(always)]
            pub const fn gpio027(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 027"]
            #[inline(always)]
            pub fn set_gpio027(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "GPIO 030"]
            #[inline(always)]
            pub const fn gpio030(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 030"]
            #[inline(always)]
            pub fn set_gpio030(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 031"]
            #[inline(always)]
            pub const fn gpio031(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 031"]
            #[inline(always)]
            pub fn set_gpio031(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "GPIO 032"]
            #[inline(always)]
            pub const fn gpio032(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 032"]
            #[inline(always)]
            pub fn set_gpio032(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "GPIO 033"]
            #[inline(always)]
            pub const fn gpio033(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 033"]
            #[inline(always)]
            pub fn set_gpio033(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "GPIO 034"]
            #[inline(always)]
            pub const fn gpio034(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 034"]
            #[inline(always)]
            pub fn set_gpio034(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for EnClr11 {
            #[inline(always)]
            fn default() -> EnClr11 {
                EnClr11(0)
            }
        }
        impl core::fmt::Debug for EnClr11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr11")
                    .field("gpio000", &self.gpio000())
                    .field("gpio002", &self.gpio002())
                    .field("gpio003", &self.gpio003())
                    .field("gpio004", &self.gpio004())
                    .field("gpio012", &self.gpio012())
                    .field("gpio013", &self.gpio013())
                    .field("gpio015", &self.gpio015())
                    .field("gpio016", &self.gpio016())
                    .field("gpio020", &self.gpio020())
                    .field("gpio021", &self.gpio021())
                    .field("gpio022", &self.gpio022())
                    .field("gpio023", &self.gpio023())
                    .field("gpio024", &self.gpio024())
                    .field("gpio026", &self.gpio026())
                    .field("gpio027", &self.gpio027())
                    .field("gpio030", &self.gpio030())
                    .field("gpio031", &self.gpio031())
                    .field("gpio032", &self.gpio032())
                    .field("gpio033", &self.gpio033())
                    .field("gpio034", &self.gpio034())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr11 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr11 {{ gpio000: {=bool:?}, gpio002: {=bool:?}, gpio003: {=bool:?}, gpio004: {=bool:?}, gpio012: {=bool:?}, gpio013: {=bool:?}, gpio015: {=bool:?}, gpio016: {=bool:?}, gpio020: {=bool:?}, gpio021: {=bool:?}, gpio022: {=bool:?}, gpio023: {=bool:?}, gpio024: {=bool:?}, gpio026: {=bool:?}, gpio027: {=bool:?}, gpio030: {=bool:?}, gpio031: {=bool:?}, gpio032: {=bool:?}, gpio033: {=bool:?}, gpio034: {=bool:?} }}" , self . gpio000 () , self . gpio002 () , self . gpio003 () , self . gpio004 () , self . gpio012 () , self . gpio013 () , self . gpio015 () , self . gpio016 () , self . gpio020 () , self . gpio021 () , self . gpio022 () , self . gpio023 () , self . gpio024 () , self . gpio026 () , self . gpio027 () , self . gpio030 () , self . gpio031 () , self . gpio032 () , self . gpio033 () , self . gpio034 ())
            }
        }
        #[doc = "GIRQ12 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr12(pub u32);
        impl EnClr12 {
            #[doc = "GPIO 200"]
            #[inline(always)]
            pub const fn gpio200(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 200"]
            #[inline(always)]
            pub fn set_gpio200(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 201"]
            #[inline(always)]
            pub const fn gpio201(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 201"]
            #[inline(always)]
            pub fn set_gpio201(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "GPIO 202"]
            #[inline(always)]
            pub const fn gpio202(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 202"]
            #[inline(always)]
            pub fn set_gpio202(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GPIO 203"]
            #[inline(always)]
            pub const fn gpio203(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 203"]
            #[inline(always)]
            pub fn set_gpio203(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 204"]
            #[inline(always)]
            pub const fn gpio204(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 204"]
            #[inline(always)]
            pub fn set_gpio204(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 223"]
            #[inline(always)]
            pub const fn gpio223(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 223"]
            #[inline(always)]
            pub fn set_gpio223(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 224"]
            #[inline(always)]
            pub const fn gpio224(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 224"]
            #[inline(always)]
            pub fn set_gpio224(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 227"]
            #[inline(always)]
            pub const fn gpio227(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 227"]
            #[inline(always)]
            pub fn set_gpio227(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for EnClr12 {
            #[inline(always)]
            fn default() -> EnClr12 {
                EnClr12(0)
            }
        }
        impl core::fmt::Debug for EnClr12 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr12")
                    .field("gpio200", &self.gpio200())
                    .field("gpio201", &self.gpio201())
                    .field("gpio202", &self.gpio202())
                    .field("gpio203", &self.gpio203())
                    .field("gpio204", &self.gpio204())
                    .field("gpio223", &self.gpio223())
                    .field("gpio224", &self.gpio224())
                    .field("gpio227", &self.gpio227())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr12 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr12 {{ gpio200: {=bool:?}, gpio201: {=bool:?}, gpio202: {=bool:?}, gpio203: {=bool:?}, gpio204: {=bool:?}, gpio223: {=bool:?}, gpio224: {=bool:?}, gpio227: {=bool:?} }}" , self . gpio200 () , self . gpio201 () , self . gpio202 () , self . gpio203 () , self . gpio204 () , self . gpio223 () , self . gpio224 () , self . gpio227 ())
            }
        }
        #[doc = "GIRQ13 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr13(pub u32);
        impl EnClr13 {
            #[doc = "I2CSMB0"]
            #[inline(always)]
            pub const fn i2csmb0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB0"]
            #[inline(always)]
            pub fn set_i2csmb0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "I2CSMB1"]
            #[inline(always)]
            pub const fn i2csmb1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB1"]
            #[inline(always)]
            pub fn set_i2csmb1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "I2CSMB2"]
            #[inline(always)]
            pub const fn i2csmb2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB2"]
            #[inline(always)]
            pub fn set_i2csmb2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "I2CSMB3"]
            #[inline(always)]
            pub const fn i2csmb3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB3"]
            #[inline(always)]
            pub fn set_i2csmb3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "I2CSMB4"]
            #[inline(always)]
            pub const fn i2csmb4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB4"]
            #[inline(always)]
            pub fn set_i2csmb4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for EnClr13 {
            #[inline(always)]
            fn default() -> EnClr13 {
                EnClr13(0)
            }
        }
        impl core::fmt::Debug for EnClr13 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr13")
                    .field("i2csmb0", &self.i2csmb0())
                    .field("i2csmb1", &self.i2csmb1())
                    .field("i2csmb2", &self.i2csmb2())
                    .field("i2csmb3", &self.i2csmb3())
                    .field("i2csmb4", &self.i2csmb4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr13 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr13 {{ i2csmb0: {=bool:?}, i2csmb1: {=bool:?}, i2csmb2: {=bool:?}, i2csmb3: {=bool:?}, i2csmb4: {=bool:?} }}" , self . i2csmb0 () , self . i2csmb1 () , self . i2csmb2 () , self . i2csmb3 () , self . i2csmb4 ())
            }
        }
        #[doc = "GIRQ14 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr14(pub u32);
        impl EnClr14 {
            #[doc = "DMA CH00"]
            #[inline(always)]
            pub const fn dma_ch00(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH00"]
            #[inline(always)]
            pub fn set_dma_ch00(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "DMA CH01"]
            #[inline(always)]
            pub const fn dma_ch01(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH01"]
            #[inline(always)]
            pub fn set_dma_ch01(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "DMA CH02"]
            #[inline(always)]
            pub const fn dma_ch02(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH02"]
            #[inline(always)]
            pub fn set_dma_ch02(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "DMA CH03"]
            #[inline(always)]
            pub const fn dma_ch03(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH03"]
            #[inline(always)]
            pub fn set_dma_ch03(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "DMA CH04"]
            #[inline(always)]
            pub const fn dma_ch04(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH04"]
            #[inline(always)]
            pub fn set_dma_ch04(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "DMA CH05"]
            #[inline(always)]
            pub const fn dma_ch05(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH05"]
            #[inline(always)]
            pub fn set_dma_ch05(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "DMA CH06"]
            #[inline(always)]
            pub const fn dma_ch06(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH06"]
            #[inline(always)]
            pub fn set_dma_ch06(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "DMA CH07"]
            #[inline(always)]
            pub const fn dma_ch07(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH07"]
            #[inline(always)]
            pub fn set_dma_ch07(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "DMA CH08"]
            #[inline(always)]
            pub const fn dma_ch08(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH08"]
            #[inline(always)]
            pub fn set_dma_ch08(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "DMA CH09"]
            #[inline(always)]
            pub const fn dma_ch09(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH09"]
            #[inline(always)]
            pub fn set_dma_ch09(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for EnClr14 {
            #[inline(always)]
            fn default() -> EnClr14 {
                EnClr14(0)
            }
        }
        impl core::fmt::Debug for EnClr14 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr14")
                    .field("dma_ch00", &self.dma_ch00())
                    .field("dma_ch01", &self.dma_ch01())
                    .field("dma_ch02", &self.dma_ch02())
                    .field("dma_ch03", &self.dma_ch03())
                    .field("dma_ch04", &self.dma_ch04())
                    .field("dma_ch05", &self.dma_ch05())
                    .field("dma_ch06", &self.dma_ch06())
                    .field("dma_ch07", &self.dma_ch07())
                    .field("dma_ch08", &self.dma_ch08())
                    .field("dma_ch09", &self.dma_ch09())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr14 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr14 {{ dma_ch00: {=bool:?}, dma_ch01: {=bool:?}, dma_ch02: {=bool:?}, dma_ch03: {=bool:?}, dma_ch04: {=bool:?}, dma_ch05: {=bool:?}, dma_ch06: {=bool:?}, dma_ch07: {=bool:?}, dma_ch08: {=bool:?}, dma_ch09: {=bool:?} }}" , self . dma_ch00 () , self . dma_ch01 () , self . dma_ch02 () , self . dma_ch03 () , self . dma_ch04 () , self . dma_ch05 () , self . dma_ch06 () , self . dma_ch07 () , self . dma_ch08 () , self . dma_ch09 ())
            }
        }
        #[doc = "GIRQ15 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr15(pub u32);
        impl EnClr15 {
            #[doc = "UART0"]
            #[inline(always)]
            pub const fn uart0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "UART0"]
            #[inline(always)]
            pub fn set_uart0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EnClr15 {
            #[inline(always)]
            fn default() -> EnClr15 {
                EnClr15(0)
            }
        }
        impl core::fmt::Debug for EnClr15 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr15").field("uart0", &self.uart0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr15 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EnClr15 {{ uart0: {=bool:?} }}", self.uart0())
            }
        }
        #[doc = "GIRQ16 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr16(pub u32);
        impl EnClr16 {
            #[doc = "PKE ERR"]
            #[inline(always)]
            pub const fn pke_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PKE ERR"]
            #[inline(always)]
            pub fn set_pke_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PKE END"]
            #[inline(always)]
            pub const fn pke_end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PKE END"]
            #[inline(always)]
            pub fn set_pke_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "RNG"]
            #[inline(always)]
            pub const fn rng(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RNG"]
            #[inline(always)]
            pub fn set_rng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "AES"]
            #[inline(always)]
            pub const fn aes(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "AES"]
            #[inline(always)]
            pub fn set_aes(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "HASH"]
            #[inline(always)]
            pub const fn hash(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "HASH"]
            #[inline(always)]
            pub fn set_hash(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for EnClr16 {
            #[inline(always)]
            fn default() -> EnClr16 {
                EnClr16(0)
            }
        }
        impl core::fmt::Debug for EnClr16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr16")
                    .field("pke_err", &self.pke_err())
                    .field("pke_end", &self.pke_end())
                    .field("rng", &self.rng())
                    .field("aes", &self.aes())
                    .field("hash", &self.hash())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr16 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr16 {{ pke_err: {=bool:?}, pke_end: {=bool:?}, rng: {=bool:?}, aes: {=bool:?}, hash: {=bool:?} }}" , self . pke_err () , self . pke_end () , self . rng () , self . aes () , self . hash ())
            }
        }
        #[doc = "GIRQ17 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr17(pub u32);
        impl EnClr17 {
            #[doc = "Breating LED0"]
            #[inline(always)]
            pub const fn led0(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Breating LED0"]
            #[inline(always)]
            pub fn set_led0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Breating LED1"]
            #[inline(always)]
            pub const fn led1(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Breating LED1"]
            #[inline(always)]
            pub fn set_led1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for EnClr17 {
            #[inline(always)]
            fn default() -> EnClr17 {
                EnClr17(0)
            }
        }
        impl core::fmt::Debug for EnClr17 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr17")
                    .field("led0", &self.led0())
                    .field("led1", &self.led1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr17 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EnClr17 {{ led0: {=bool:?}, led1: {=bool:?} }}",
                    self.led0(),
                    self.led1()
                )
            }
        }
        #[doc = "GIRQ18 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr18(pub u32);
        impl EnClr18 {
            #[doc = "SPT0"]
            #[inline(always)]
            pub const fn spt0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SPT0"]
            #[inline(always)]
            pub fn set_spt0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "QMSPI0"]
            #[inline(always)]
            pub const fn qmspi0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI0"]
            #[inline(always)]
            pub fn set_qmspi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "QMSPI1"]
            #[inline(always)]
            pub const fn qmspi1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI1"]
            #[inline(always)]
            pub fn set_qmspi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SPT1"]
            #[inline(always)]
            pub const fn spt1(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "SPT1"]
            #[inline(always)]
            pub fn set_spt1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "CCT"]
            #[inline(always)]
            pub const fn cct(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "CCT"]
            #[inline(always)]
            pub fn set_cct(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "CCT_CAP0"]
            #[inline(always)]
            pub const fn cct_cap0(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP0"]
            #[inline(always)]
            pub fn set_cct_cap0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "CCT_CAP1"]
            #[inline(always)]
            pub const fn cct_cap1(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP1"]
            #[inline(always)]
            pub fn set_cct_cap1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "CCT_CAP2"]
            #[inline(always)]
            pub const fn cct_cap2(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP2"]
            #[inline(always)]
            pub fn set_cct_cap2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "CCT_CAP3"]
            #[inline(always)]
            pub const fn cct_cap3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP3"]
            #[inline(always)]
            pub fn set_cct_cap3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "CCT_CAP4"]
            #[inline(always)]
            pub const fn cct_cap4(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP4"]
            #[inline(always)]
            pub fn set_cct_cap4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "CCT_CAP5"]
            #[inline(always)]
            pub const fn cct_cap5(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP5"]
            #[inline(always)]
            pub fn set_cct_cap5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "CCT_CMP0"]
            #[inline(always)]
            pub const fn cct_cmp0(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CMP0"]
            #[inline(always)]
            pub fn set_cct_cmp0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "CCT_CMP1"]
            #[inline(always)]
            pub const fn cct_cmp1(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CMP1"]
            #[inline(always)]
            pub fn set_cct_cmp1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for EnClr18 {
            #[inline(always)]
            fn default() -> EnClr18 {
                EnClr18(0)
            }
        }
        impl core::fmt::Debug for EnClr18 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr18")
                    .field("spt0", &self.spt0())
                    .field("qmspi0", &self.qmspi0())
                    .field("qmspi1", &self.qmspi1())
                    .field("spt1", &self.spt1())
                    .field("cct", &self.cct())
                    .field("cct_cap0", &self.cct_cap0())
                    .field("cct_cap1", &self.cct_cap1())
                    .field("cct_cap2", &self.cct_cap2())
                    .field("cct_cap3", &self.cct_cap3())
                    .field("cct_cap4", &self.cct_cap4())
                    .field("cct_cap5", &self.cct_cap5())
                    .field("cct_cmp0", &self.cct_cmp0())
                    .field("cct_cmp1", &self.cct_cmp1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr18 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr18 {{ spt0: {=bool:?}, qmspi0: {=bool:?}, qmspi1: {=bool:?}, spt1: {=bool:?}, cct: {=bool:?}, cct_cap0: {=bool:?}, cct_cap1: {=bool:?}, cct_cap2: {=bool:?}, cct_cap3: {=bool:?}, cct_cap4: {=bool:?}, cct_cap5: {=bool:?}, cct_cmp0: {=bool:?}, cct_cmp1: {=bool:?} }}" , self . spt0 () , self . qmspi0 () , self . qmspi1 () , self . spt1 () , self . cct () , self . cct_cap0 () , self . cct_cap1 () , self . cct_cap2 () , self . cct_cap3 () , self . cct_cap4 () , self . cct_cap5 () , self . cct_cmp0 () , self . cct_cmp1 ())
            }
        }
        #[doc = "GIRQ20 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr20(pub u32);
        impl EnClr20 {
            #[doc = "IMSPI"]
            #[inline(always)]
            pub const fn imspi(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "IMSPI"]
            #[inline(always)]
            pub fn set_imspi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "CLK_MON"]
            #[inline(always)]
            pub const fn clk_mon(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "CLK_MON"]
            #[inline(always)]
            pub fn set_clk_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "VTR1_PAD_MON"]
            #[inline(always)]
            pub const fn vtr1_pad_mon(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "VTR1_PAD_MON"]
            #[inline(always)]
            pub fn set_vtr1_pad_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "VTR2_PAD_MON"]
            #[inline(always)]
            pub const fn vtr2_pad_mon(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "VTR2_PAD_MON"]
            #[inline(always)]
            pub fn set_vtr2_pad_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for EnClr20 {
            #[inline(always)]
            fn default() -> EnClr20 {
                EnClr20(0)
            }
        }
        impl core::fmt::Debug for EnClr20 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr20")
                    .field("imspi", &self.imspi())
                    .field("clk_mon", &self.clk_mon())
                    .field("vtr1_pad_mon", &self.vtr1_pad_mon())
                    .field("vtr2_pad_mon", &self.vtr2_pad_mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr20 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr20 {{ imspi: {=bool:?}, clk_mon: {=bool:?}, vtr1_pad_mon: {=bool:?}, vtr2_pad_mon: {=bool:?} }}" , self . imspi () , self . clk_mon () , self . vtr1_pad_mon () , self . vtr2_pad_mon ())
            }
        }
        #[doc = "GIRQ21 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr21(pub u32);
        impl EnClr21 {
            #[doc = "WDT"]
            #[inline(always)]
            pub const fn wdt(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "WDT"]
            #[inline(always)]
            pub fn set_wdt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "EMC"]
            #[inline(always)]
            pub const fn emc(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "EMC"]
            #[inline(always)]
            pub fn set_emc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for EnClr21 {
            #[inline(always)]
            fn default() -> EnClr21 {
                EnClr21(0)
            }
        }
        impl core::fmt::Debug for EnClr21 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr21")
                    .field("wdt", &self.wdt())
                    .field("emc", &self.emc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr21 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EnClr21 {{ wdt: {=bool:?}, emc: {=bool:?} }}",
                    self.wdt(),
                    self.emc()
                )
            }
        }
        #[doc = "GIRQ23 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr23(pub u32);
        impl EnClr23 {
            #[doc = "TIMER32_0"]
            #[inline(always)]
            pub const fn timer32_0(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0"]
            #[inline(always)]
            pub fn set_timer32_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "TIMER32_1"]
            #[inline(always)]
            pub const fn timer32_1(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1"]
            #[inline(always)]
            pub fn set_timer32_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "RTMR"]
            #[inline(always)]
            pub const fn rtmr(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "RTMR"]
            #[inline(always)]
            pub fn set_rtmr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "SWI0"]
            #[inline(always)]
            pub const fn swi0(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "SWI0"]
            #[inline(always)]
            pub fn set_swi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "SWI1"]
            #[inline(always)]
            pub const fn swi1(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "SWI1"]
            #[inline(always)]
            pub fn set_swi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "SWI2"]
            #[inline(always)]
            pub const fn swi2(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SWI2"]
            #[inline(always)]
            pub fn set_swi2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SWI3"]
            #[inline(always)]
            pub const fn swi3(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SWI3"]
            #[inline(always)]
            pub fn set_swi3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "HTMR0"]
            #[inline(always)]
            pub const fn htmr0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "HTMR0"]
            #[inline(always)]
            pub fn set_htmr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "HTMR1"]
            #[inline(always)]
            pub const fn htmr1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "HTMR1"]
            #[inline(always)]
            pub fn set_htmr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for EnClr23 {
            #[inline(always)]
            fn default() -> EnClr23 {
                EnClr23(0)
            }
        }
        impl core::fmt::Debug for EnClr23 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr23")
                    .field("timer32_0", &self.timer32_0())
                    .field("timer32_1", &self.timer32_1())
                    .field("rtmr", &self.rtmr())
                    .field("swi0", &self.swi0())
                    .field("swi1", &self.swi1())
                    .field("swi2", &self.swi2())
                    .field("swi3", &self.swi3())
                    .field("htmr0", &self.htmr0())
                    .field("htmr1", &self.htmr1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr23 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr23 {{ timer32_0: {=bool:?}, timer32_1: {=bool:?}, rtmr: {=bool:?}, swi0: {=bool:?}, swi1: {=bool:?}, swi2: {=bool:?}, swi3: {=bool:?}, htmr0: {=bool:?}, htmr1: {=bool:?} }}" , self . timer32_0 () , self . timer32_1 () , self . rtmr () , self . swi0 () , self . swi1 () , self . swi2 () , self . swi3 () , self . htmr0 () , self . htmr1 ())
            }
        }
        #[doc = "GIRQ24 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr24(pub u32);
        impl EnClr24 {
            #[doc = "SPIMON0_VLTN"]
            #[inline(always)]
            pub const fn spimon0_vltn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_VLTN"]
            #[inline(always)]
            pub fn set_spimon0_vltn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SPIMON0_MTMON"]
            #[inline(always)]
            pub const fn spimon0_mtmon(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_MTMON"]
            #[inline(always)]
            pub fn set_spimon0_mtmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "SPIMON0_LTMON"]
            #[inline(always)]
            pub const fn spimon0_ltmon(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_LTMON"]
            #[inline(always)]
            pub fn set_spimon0_ltmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SPIMON1_VLTN"]
            #[inline(always)]
            pub const fn spimon1_vltn(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_VLTN"]
            #[inline(always)]
            pub fn set_spimon1_vltn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "SPIMON1_MTMON"]
            #[inline(always)]
            pub const fn spimon1_mtmon(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_MTMON"]
            #[inline(always)]
            pub fn set_spimon1_mtmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "SPIMON1_LTMON"]
            #[inline(always)]
            pub const fn spimon1_ltmon(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_LTMON"]
            #[inline(always)]
            pub fn set_spimon1_ltmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for EnClr24 {
            #[inline(always)]
            fn default() -> EnClr24 {
                EnClr24(0)
            }
        }
        impl core::fmt::Debug for EnClr24 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr24")
                    .field("spimon0_vltn", &self.spimon0_vltn())
                    .field("spimon0_mtmon", &self.spimon0_mtmon())
                    .field("spimon0_ltmon", &self.spimon0_ltmon())
                    .field("spimon1_vltn", &self.spimon1_vltn())
                    .field("spimon1_mtmon", &self.spimon1_mtmon())
                    .field("spimon1_ltmon", &self.spimon1_ltmon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr24 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr24 {{ spimon0_vltn: {=bool:?}, spimon0_mtmon: {=bool:?}, spimon0_ltmon: {=bool:?}, spimon1_vltn: {=bool:?}, spimon1_mtmon: {=bool:?}, spimon1_ltmon: {=bool:?} }}" , self . spimon0_vltn () , self . spimon0_mtmon () , self . spimon0_ltmon () , self . spimon1_vltn () , self . spimon1_mtmon () , self . spimon1_ltmon ())
            }
        }
        #[doc = "GIRQ26 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr26(pub u32);
        impl EnClr26 {
            #[doc = "GPIO250"]
            #[inline(always)]
            pub const fn gpio250(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO250"]
            #[inline(always)]
            pub fn set_gpio250(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO260"]
            #[inline(always)]
            pub const fn gpio260(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO260"]
            #[inline(always)]
            pub fn set_gpio260(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for EnClr26 {
            #[inline(always)]
            fn default() -> EnClr26 {
                EnClr26(0)
            }
        }
        impl core::fmt::Debug for EnClr26 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr26")
                    .field("gpio250", &self.gpio250())
                    .field("gpio260", &self.gpio260())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr26 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EnClr26 {{ gpio250: {=bool:?}, gpio260: {=bool:?} }}",
                    self.gpio250(),
                    self.gpio260()
                )
            }
        }
        #[doc = "GIRQ8 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr8(pub u32);
        impl EnClr8 {
            #[doc = "GPIO 140"]
            #[inline(always)]
            pub const fn gpio140(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 140"]
            #[inline(always)]
            pub fn set_gpio140(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 143"]
            #[inline(always)]
            pub const fn gpio143(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 143"]
            #[inline(always)]
            pub fn set_gpio143(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 144"]
            #[inline(always)]
            pub const fn gpio144(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 144"]
            #[inline(always)]
            pub fn set_gpio144(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 145"]
            #[inline(always)]
            pub const fn gpio145(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 145"]
            #[inline(always)]
            pub fn set_gpio145(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 146"]
            #[inline(always)]
            pub const fn gpio146(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 146"]
            #[inline(always)]
            pub fn set_gpio146(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 147"]
            #[inline(always)]
            pub const fn gpio147(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 147"]
            #[inline(always)]
            pub fn set_gpio147(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 150"]
            #[inline(always)]
            pub const fn gpio150(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 150"]
            #[inline(always)]
            pub fn set_gpio150(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO 156"]
            #[inline(always)]
            pub const fn gpio156(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 156"]
            #[inline(always)]
            pub fn set_gpio156(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 157"]
            #[inline(always)]
            pub const fn gpio157(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 157"]
            #[inline(always)]
            pub fn set_gpio157(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "GPIO 163"]
            #[inline(always)]
            pub const fn gpio163(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 163"]
            #[inline(always)]
            pub fn set_gpio163(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 165"]
            #[inline(always)]
            pub const fn gpio165(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 165"]
            #[inline(always)]
            pub fn set_gpio165(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "GPIO 166"]
            #[inline(always)]
            pub const fn gpio166(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 166"]
            #[inline(always)]
            pub fn set_gpio166(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 170"]
            #[inline(always)]
            pub const fn gpio170(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 170"]
            #[inline(always)]
            pub fn set_gpio170(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 171"]
            #[inline(always)]
            pub const fn gpio171(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 171"]
            #[inline(always)]
            pub fn set_gpio171(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for EnClr8 {
            #[inline(always)]
            fn default() -> EnClr8 {
                EnClr8(0)
            }
        }
        impl core::fmt::Debug for EnClr8 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr8")
                    .field("gpio140", &self.gpio140())
                    .field("gpio143", &self.gpio143())
                    .field("gpio144", &self.gpio144())
                    .field("gpio145", &self.gpio145())
                    .field("gpio146", &self.gpio146())
                    .field("gpio147", &self.gpio147())
                    .field("gpio150", &self.gpio150())
                    .field("gpio156", &self.gpio156())
                    .field("gpio157", &self.gpio157())
                    .field("gpio163", &self.gpio163())
                    .field("gpio165", &self.gpio165())
                    .field("gpio166", &self.gpio166())
                    .field("gpio170", &self.gpio170())
                    .field("gpio171", &self.gpio171())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr8 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr8 {{ gpio140: {=bool:?}, gpio143: {=bool:?}, gpio144: {=bool:?}, gpio145: {=bool:?}, gpio146: {=bool:?}, gpio147: {=bool:?}, gpio150: {=bool:?}, gpio156: {=bool:?}, gpio157: {=bool:?}, gpio163: {=bool:?}, gpio165: {=bool:?}, gpio166: {=bool:?}, gpio170: {=bool:?}, gpio171: {=bool:?} }}" , self . gpio140 () , self . gpio143 () , self . gpio144 () , self . gpio145 () , self . gpio146 () , self . gpio147 () , self . gpio150 () , self . gpio156 () , self . gpio157 () , self . gpio163 () , self . gpio165 () , self . gpio166 () , self . gpio170 () , self . gpio171 ())
            }
        }
        #[doc = "GIRQ9 ENABLE CLEAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnClr9(pub u32);
        impl EnClr9 {
            #[doc = "GPIO 104"]
            #[inline(always)]
            pub const fn gpio104(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 104"]
            #[inline(always)]
            pub fn set_gpio104(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 105"]
            #[inline(always)]
            pub const fn gpio105(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 105"]
            #[inline(always)]
            pub fn set_gpio105(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 106"]
            #[inline(always)]
            pub const fn gpio106(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 106"]
            #[inline(always)]
            pub fn set_gpio106(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 107"]
            #[inline(always)]
            pub const fn gpio107(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 107"]
            #[inline(always)]
            pub fn set_gpio107(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 112"]
            #[inline(always)]
            pub const fn gpio112(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 112"]
            #[inline(always)]
            pub fn set_gpio112(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "GPIO 113"]
            #[inline(always)]
            pub const fn gpio113(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 113"]
            #[inline(always)]
            pub fn set_gpio113(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 120"]
            #[inline(always)]
            pub const fn gpio120(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 120"]
            #[inline(always)]
            pub fn set_gpio120(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPIO 121"]
            #[inline(always)]
            pub const fn gpio121(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 121"]
            #[inline(always)]
            pub fn set_gpio121(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "GPIO 122"]
            #[inline(always)]
            pub const fn gpio122(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 122"]
            #[inline(always)]
            pub fn set_gpio122(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "GPIO 123"]
            #[inline(always)]
            pub const fn gpio123(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 123"]
            #[inline(always)]
            pub fn set_gpio123(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 124"]
            #[inline(always)]
            pub const fn gpio124(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 124"]
            #[inline(always)]
            pub fn set_gpio124(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 125"]
            #[inline(always)]
            pub const fn gpio125(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 125"]
            #[inline(always)]
            pub fn set_gpio125(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "GPIO 126"]
            #[inline(always)]
            pub const fn gpio126(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 126"]
            #[inline(always)]
            pub fn set_gpio126(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 127"]
            #[inline(always)]
            pub const fn gpio127(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 127"]
            #[inline(always)]
            pub fn set_gpio127(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "GPIO 130"]
            #[inline(always)]
            pub const fn gpio130(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 130"]
            #[inline(always)]
            pub fn set_gpio130(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 131"]
            #[inline(always)]
            pub const fn gpio131(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 131"]
            #[inline(always)]
            pub fn set_gpio131(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "GPIO 132"]
            #[inline(always)]
            pub const fn gpio132(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 132"]
            #[inline(always)]
            pub fn set_gpio132(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
        }
        impl Default for EnClr9 {
            #[inline(always)]
            fn default() -> EnClr9 {
                EnClr9(0)
            }
        }
        impl core::fmt::Debug for EnClr9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnClr9")
                    .field("gpio104", &self.gpio104())
                    .field("gpio105", &self.gpio105())
                    .field("gpio106", &self.gpio106())
                    .field("gpio107", &self.gpio107())
                    .field("gpio112", &self.gpio112())
                    .field("gpio113", &self.gpio113())
                    .field("gpio120", &self.gpio120())
                    .field("gpio121", &self.gpio121())
                    .field("gpio122", &self.gpio122())
                    .field("gpio123", &self.gpio123())
                    .field("gpio124", &self.gpio124())
                    .field("gpio125", &self.gpio125())
                    .field("gpio126", &self.gpio126())
                    .field("gpio127", &self.gpio127())
                    .field("gpio130", &self.gpio130())
                    .field("gpio131", &self.gpio131())
                    .field("gpio132", &self.gpio132())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnClr9 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnClr9 {{ gpio104: {=bool:?}, gpio105: {=bool:?}, gpio106: {=bool:?}, gpio107: {=bool:?}, gpio112: {=bool:?}, gpio113: {=bool:?}, gpio120: {=bool:?}, gpio121: {=bool:?}, gpio122: {=bool:?}, gpio123: {=bool:?}, gpio124: {=bool:?}, gpio125: {=bool:?}, gpio126: {=bool:?}, gpio127: {=bool:?}, gpio130: {=bool:?}, gpio131: {=bool:?}, gpio132: {=bool:?} }}" , self . gpio104 () , self . gpio105 () , self . gpio106 () , self . gpio107 () , self . gpio112 () , self . gpio113 () , self . gpio120 () , self . gpio121 () , self . gpio122 () , self . gpio123 () , self . gpio124 () , self . gpio125 () , self . gpio126 () , self . gpio127 () , self . gpio130 () , self . gpio131 () , self . gpio132 ())
            }
        }
        #[doc = "GIRQ10 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet10(pub u32);
        impl EnSet10 {
            #[doc = "GPIO 045"]
            #[inline(always)]
            pub const fn gpio045(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 045"]
            #[inline(always)]
            pub fn set_gpio045(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 046"]
            #[inline(always)]
            pub const fn gpio046(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 046"]
            #[inline(always)]
            pub fn set_gpio046(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 047"]
            #[inline(always)]
            pub const fn gpio047(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 047"]
            #[inline(always)]
            pub fn set_gpio047(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 050"]
            #[inline(always)]
            pub const fn gpio050(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 050"]
            #[inline(always)]
            pub fn set_gpio050(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO 053"]
            #[inline(always)]
            pub const fn gpio053(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 053"]
            #[inline(always)]
            pub fn set_gpio053(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 055"]
            #[inline(always)]
            pub const fn gpio055(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 055"]
            #[inline(always)]
            pub fn set_gpio055(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "GPIO 056"]
            #[inline(always)]
            pub const fn gpio056(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 056"]
            #[inline(always)]
            pub fn set_gpio056(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 057"]
            #[inline(always)]
            pub const fn gpio057(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 057"]
            #[inline(always)]
            pub fn set_gpio057(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "GPIO 060"]
            #[inline(always)]
            pub const fn gpio063(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 060"]
            #[inline(always)]
            pub fn set_gpio063(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 070"]
            #[inline(always)]
            pub const fn gpio070(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 070"]
            #[inline(always)]
            pub fn set_gpio070(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 071"]
            #[inline(always)]
            pub const fn gpio071(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 071"]
            #[inline(always)]
            pub fn set_gpio071(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for EnSet10 {
            #[inline(always)]
            fn default() -> EnSet10 {
                EnSet10(0)
            }
        }
        impl core::fmt::Debug for EnSet10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet10")
                    .field("gpio045", &self.gpio045())
                    .field("gpio046", &self.gpio046())
                    .field("gpio047", &self.gpio047())
                    .field("gpio050", &self.gpio050())
                    .field("gpio053", &self.gpio053())
                    .field("gpio055", &self.gpio055())
                    .field("gpio056", &self.gpio056())
                    .field("gpio057", &self.gpio057())
                    .field("gpio063", &self.gpio063())
                    .field("gpio070", &self.gpio070())
                    .field("gpio071", &self.gpio071())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet10 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet10 {{ gpio045: {=bool:?}, gpio046: {=bool:?}, gpio047: {=bool:?}, gpio050: {=bool:?}, gpio053: {=bool:?}, gpio055: {=bool:?}, gpio056: {=bool:?}, gpio057: {=bool:?}, gpio063: {=bool:?}, gpio070: {=bool:?}, gpio071: {=bool:?} }}" , self . gpio045 () , self . gpio046 () , self . gpio047 () , self . gpio050 () , self . gpio053 () , self . gpio055 () , self . gpio056 () , self . gpio057 () , self . gpio063 () , self . gpio070 () , self . gpio071 ())
            }
        }
        #[doc = "GIRQ11 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet11(pub u32);
        impl EnSet11 {
            #[doc = "GPIO 000"]
            #[inline(always)]
            pub const fn gpio000(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 000"]
            #[inline(always)]
            pub fn set_gpio000(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 002"]
            #[inline(always)]
            pub const fn gpio002(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 002"]
            #[inline(always)]
            pub fn set_gpio002(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GPIO 003"]
            #[inline(always)]
            pub const fn gpio003(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 003"]
            #[inline(always)]
            pub fn set_gpio003(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 004"]
            #[inline(always)]
            pub const fn gpio004(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 004"]
            #[inline(always)]
            pub fn set_gpio004(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 012"]
            #[inline(always)]
            pub const fn gpio012(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 012"]
            #[inline(always)]
            pub fn set_gpio012(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "GPIO 013"]
            #[inline(always)]
            pub const fn gpio013(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 013"]
            #[inline(always)]
            pub fn set_gpio013(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 015"]
            #[inline(always)]
            pub const fn gpio015(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 015"]
            #[inline(always)]
            pub fn set_gpio015(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "GPIO 016"]
            #[inline(always)]
            pub const fn gpio016(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 016"]
            #[inline(always)]
            pub fn set_gpio016(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 020"]
            #[inline(always)]
            pub const fn gpio020(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 020"]
            #[inline(always)]
            pub fn set_gpio020(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPIO 021"]
            #[inline(always)]
            pub const fn gpio021(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 021"]
            #[inline(always)]
            pub fn set_gpio021(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "GPIO 022"]
            #[inline(always)]
            pub const fn gpio022(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 022"]
            #[inline(always)]
            pub fn set_gpio022(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "GPIO 023"]
            #[inline(always)]
            pub const fn gpio023(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 023"]
            #[inline(always)]
            pub fn set_gpio023(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 024"]
            #[inline(always)]
            pub const fn gpio024(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 024"]
            #[inline(always)]
            pub fn set_gpio024(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 026"]
            #[inline(always)]
            pub const fn gpio026(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 026"]
            #[inline(always)]
            pub fn set_gpio026(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 027"]
            #[inline(always)]
            pub const fn gpio027(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 027"]
            #[inline(always)]
            pub fn set_gpio027(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "GPIO 030"]
            #[inline(always)]
            pub const fn gpio030(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 030"]
            #[inline(always)]
            pub fn set_gpio030(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 031"]
            #[inline(always)]
            pub const fn gpio031(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 031"]
            #[inline(always)]
            pub fn set_gpio031(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "GPIO 032"]
            #[inline(always)]
            pub const fn gpio032(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 032"]
            #[inline(always)]
            pub fn set_gpio032(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "GPIO 033"]
            #[inline(always)]
            pub const fn gpio033(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 033"]
            #[inline(always)]
            pub fn set_gpio033(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "GPIO 034"]
            #[inline(always)]
            pub const fn gpio034(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 034"]
            #[inline(always)]
            pub fn set_gpio034(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for EnSet11 {
            #[inline(always)]
            fn default() -> EnSet11 {
                EnSet11(0)
            }
        }
        impl core::fmt::Debug for EnSet11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet11")
                    .field("gpio000", &self.gpio000())
                    .field("gpio002", &self.gpio002())
                    .field("gpio003", &self.gpio003())
                    .field("gpio004", &self.gpio004())
                    .field("gpio012", &self.gpio012())
                    .field("gpio013", &self.gpio013())
                    .field("gpio015", &self.gpio015())
                    .field("gpio016", &self.gpio016())
                    .field("gpio020", &self.gpio020())
                    .field("gpio021", &self.gpio021())
                    .field("gpio022", &self.gpio022())
                    .field("gpio023", &self.gpio023())
                    .field("gpio024", &self.gpio024())
                    .field("gpio026", &self.gpio026())
                    .field("gpio027", &self.gpio027())
                    .field("gpio030", &self.gpio030())
                    .field("gpio031", &self.gpio031())
                    .field("gpio032", &self.gpio032())
                    .field("gpio033", &self.gpio033())
                    .field("gpio034", &self.gpio034())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet11 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet11 {{ gpio000: {=bool:?}, gpio002: {=bool:?}, gpio003: {=bool:?}, gpio004: {=bool:?}, gpio012: {=bool:?}, gpio013: {=bool:?}, gpio015: {=bool:?}, gpio016: {=bool:?}, gpio020: {=bool:?}, gpio021: {=bool:?}, gpio022: {=bool:?}, gpio023: {=bool:?}, gpio024: {=bool:?}, gpio026: {=bool:?}, gpio027: {=bool:?}, gpio030: {=bool:?}, gpio031: {=bool:?}, gpio032: {=bool:?}, gpio033: {=bool:?}, gpio034: {=bool:?} }}" , self . gpio000 () , self . gpio002 () , self . gpio003 () , self . gpio004 () , self . gpio012 () , self . gpio013 () , self . gpio015 () , self . gpio016 () , self . gpio020 () , self . gpio021 () , self . gpio022 () , self . gpio023 () , self . gpio024 () , self . gpio026 () , self . gpio027 () , self . gpio030 () , self . gpio031 () , self . gpio032 () , self . gpio033 () , self . gpio034 ())
            }
        }
        #[doc = "GIRQ12 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet12(pub u32);
        impl EnSet12 {
            #[doc = "GPIO 200"]
            #[inline(always)]
            pub const fn gpio200(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 200"]
            #[inline(always)]
            pub fn set_gpio200(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 201"]
            #[inline(always)]
            pub const fn gpio201(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 201"]
            #[inline(always)]
            pub fn set_gpio201(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "GPIO 202"]
            #[inline(always)]
            pub const fn gpio202(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 202"]
            #[inline(always)]
            pub fn set_gpio202(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GPIO 203"]
            #[inline(always)]
            pub const fn gpio203(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 203"]
            #[inline(always)]
            pub fn set_gpio203(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 204"]
            #[inline(always)]
            pub const fn gpio204(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 204"]
            #[inline(always)]
            pub fn set_gpio204(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 223"]
            #[inline(always)]
            pub const fn gpio223(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 223"]
            #[inline(always)]
            pub fn set_gpio223(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 224"]
            #[inline(always)]
            pub const fn gpio224(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 224"]
            #[inline(always)]
            pub fn set_gpio224(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 227"]
            #[inline(always)]
            pub const fn gpio227(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 227"]
            #[inline(always)]
            pub fn set_gpio227(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for EnSet12 {
            #[inline(always)]
            fn default() -> EnSet12 {
                EnSet12(0)
            }
        }
        impl core::fmt::Debug for EnSet12 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet12")
                    .field("gpio200", &self.gpio200())
                    .field("gpio201", &self.gpio201())
                    .field("gpio202", &self.gpio202())
                    .field("gpio203", &self.gpio203())
                    .field("gpio204", &self.gpio204())
                    .field("gpio223", &self.gpio223())
                    .field("gpio224", &self.gpio224())
                    .field("gpio227", &self.gpio227())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet12 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet12 {{ gpio200: {=bool:?}, gpio201: {=bool:?}, gpio202: {=bool:?}, gpio203: {=bool:?}, gpio204: {=bool:?}, gpio223: {=bool:?}, gpio224: {=bool:?}, gpio227: {=bool:?} }}" , self . gpio200 () , self . gpio201 () , self . gpio202 () , self . gpio203 () , self . gpio204 () , self . gpio223 () , self . gpio224 () , self . gpio227 ())
            }
        }
        #[doc = "GIRQ13 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet13(pub u32);
        impl EnSet13 {
            #[doc = "I2CSMB0"]
            #[inline(always)]
            pub const fn i2csmb0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB0"]
            #[inline(always)]
            pub fn set_i2csmb0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "I2CSMB1"]
            #[inline(always)]
            pub const fn i2csmb1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB1"]
            #[inline(always)]
            pub fn set_i2csmb1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "I2CSMB2"]
            #[inline(always)]
            pub const fn i2csmb2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB2"]
            #[inline(always)]
            pub fn set_i2csmb2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "I2CSMB3"]
            #[inline(always)]
            pub const fn i2csmb3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB3"]
            #[inline(always)]
            pub fn set_i2csmb3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "I2CSMB4"]
            #[inline(always)]
            pub const fn i2csmb4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB4"]
            #[inline(always)]
            pub fn set_i2csmb4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for EnSet13 {
            #[inline(always)]
            fn default() -> EnSet13 {
                EnSet13(0)
            }
        }
        impl core::fmt::Debug for EnSet13 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet13")
                    .field("i2csmb0", &self.i2csmb0())
                    .field("i2csmb1", &self.i2csmb1())
                    .field("i2csmb2", &self.i2csmb2())
                    .field("i2csmb3", &self.i2csmb3())
                    .field("i2csmb4", &self.i2csmb4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet13 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet13 {{ i2csmb0: {=bool:?}, i2csmb1: {=bool:?}, i2csmb2: {=bool:?}, i2csmb3: {=bool:?}, i2csmb4: {=bool:?} }}" , self . i2csmb0 () , self . i2csmb1 () , self . i2csmb2 () , self . i2csmb3 () , self . i2csmb4 ())
            }
        }
        #[doc = "GIRQ14 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet14(pub u32);
        impl EnSet14 {
            #[doc = "DMA CH00"]
            #[inline(always)]
            pub const fn dma_ch00(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH00"]
            #[inline(always)]
            pub fn set_dma_ch00(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "DMA CH01"]
            #[inline(always)]
            pub const fn dma_ch01(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH01"]
            #[inline(always)]
            pub fn set_dma_ch01(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "DMA CH02"]
            #[inline(always)]
            pub const fn dma_ch02(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH02"]
            #[inline(always)]
            pub fn set_dma_ch02(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "DMA CH03"]
            #[inline(always)]
            pub const fn dma_ch03(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH03"]
            #[inline(always)]
            pub fn set_dma_ch03(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "DMA CH04"]
            #[inline(always)]
            pub const fn dma_ch04(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH04"]
            #[inline(always)]
            pub fn set_dma_ch04(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "DMA CH05"]
            #[inline(always)]
            pub const fn dma_ch05(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH05"]
            #[inline(always)]
            pub fn set_dma_ch05(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "DMA CH06"]
            #[inline(always)]
            pub const fn dma_ch06(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH06"]
            #[inline(always)]
            pub fn set_dma_ch06(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "DMA CH07"]
            #[inline(always)]
            pub const fn dma_ch07(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH07"]
            #[inline(always)]
            pub fn set_dma_ch07(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "DMA CH08"]
            #[inline(always)]
            pub const fn dma_ch08(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH08"]
            #[inline(always)]
            pub fn set_dma_ch08(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "DMA CH09"]
            #[inline(always)]
            pub const fn dma_ch09(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH09"]
            #[inline(always)]
            pub fn set_dma_ch09(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for EnSet14 {
            #[inline(always)]
            fn default() -> EnSet14 {
                EnSet14(0)
            }
        }
        impl core::fmt::Debug for EnSet14 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet14")
                    .field("dma_ch00", &self.dma_ch00())
                    .field("dma_ch01", &self.dma_ch01())
                    .field("dma_ch02", &self.dma_ch02())
                    .field("dma_ch03", &self.dma_ch03())
                    .field("dma_ch04", &self.dma_ch04())
                    .field("dma_ch05", &self.dma_ch05())
                    .field("dma_ch06", &self.dma_ch06())
                    .field("dma_ch07", &self.dma_ch07())
                    .field("dma_ch08", &self.dma_ch08())
                    .field("dma_ch09", &self.dma_ch09())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet14 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet14 {{ dma_ch00: {=bool:?}, dma_ch01: {=bool:?}, dma_ch02: {=bool:?}, dma_ch03: {=bool:?}, dma_ch04: {=bool:?}, dma_ch05: {=bool:?}, dma_ch06: {=bool:?}, dma_ch07: {=bool:?}, dma_ch08: {=bool:?}, dma_ch09: {=bool:?} }}" , self . dma_ch00 () , self . dma_ch01 () , self . dma_ch02 () , self . dma_ch03 () , self . dma_ch04 () , self . dma_ch05 () , self . dma_ch06 () , self . dma_ch07 () , self . dma_ch08 () , self . dma_ch09 ())
            }
        }
        #[doc = "GIRQ15 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet15(pub u32);
        impl EnSet15 {
            #[doc = "UART0"]
            #[inline(always)]
            pub const fn uart0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "UART0"]
            #[inline(always)]
            pub fn set_uart0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EnSet15 {
            #[inline(always)]
            fn default() -> EnSet15 {
                EnSet15(0)
            }
        }
        impl core::fmt::Debug for EnSet15 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet15").field("uart0", &self.uart0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet15 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EnSet15 {{ uart0: {=bool:?} }}", self.uart0())
            }
        }
        #[doc = "GIRQ16 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet16(pub u32);
        impl EnSet16 {
            #[doc = "PKE ERR"]
            #[inline(always)]
            pub const fn pke_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PKE ERR"]
            #[inline(always)]
            pub fn set_pke_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PKE END"]
            #[inline(always)]
            pub const fn pke_end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PKE END"]
            #[inline(always)]
            pub fn set_pke_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "RNG"]
            #[inline(always)]
            pub const fn rng(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RNG"]
            #[inline(always)]
            pub fn set_rng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "AES"]
            #[inline(always)]
            pub const fn aes(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "AES"]
            #[inline(always)]
            pub fn set_aes(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "HASH"]
            #[inline(always)]
            pub const fn hash(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "HASH"]
            #[inline(always)]
            pub fn set_hash(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for EnSet16 {
            #[inline(always)]
            fn default() -> EnSet16 {
                EnSet16(0)
            }
        }
        impl core::fmt::Debug for EnSet16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet16")
                    .field("pke_err", &self.pke_err())
                    .field("pke_end", &self.pke_end())
                    .field("rng", &self.rng())
                    .field("aes", &self.aes())
                    .field("hash", &self.hash())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet16 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet16 {{ pke_err: {=bool:?}, pke_end: {=bool:?}, rng: {=bool:?}, aes: {=bool:?}, hash: {=bool:?} }}" , self . pke_err () , self . pke_end () , self . rng () , self . aes () , self . hash ())
            }
        }
        #[doc = "GIRQ17 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet17(pub u32);
        impl EnSet17 {
            #[doc = "Breating LED0"]
            #[inline(always)]
            pub const fn led0(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Breating LED0"]
            #[inline(always)]
            pub fn set_led0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Breating LED1"]
            #[inline(always)]
            pub const fn led1(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Breating LED1"]
            #[inline(always)]
            pub fn set_led1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for EnSet17 {
            #[inline(always)]
            fn default() -> EnSet17 {
                EnSet17(0)
            }
        }
        impl core::fmt::Debug for EnSet17 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet17")
                    .field("led0", &self.led0())
                    .field("led1", &self.led1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet17 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EnSet17 {{ led0: {=bool:?}, led1: {=bool:?} }}",
                    self.led0(),
                    self.led1()
                )
            }
        }
        #[doc = "GIRQ18 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet18(pub u32);
        impl EnSet18 {
            #[doc = "SPT0"]
            #[inline(always)]
            pub const fn spt0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SPT0"]
            #[inline(always)]
            pub fn set_spt0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "QMSPI0"]
            #[inline(always)]
            pub const fn qmspi0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI0"]
            #[inline(always)]
            pub fn set_qmspi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "QMSPI1"]
            #[inline(always)]
            pub const fn qmspi1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI1"]
            #[inline(always)]
            pub fn set_qmspi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SPT1"]
            #[inline(always)]
            pub const fn spt1(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "SPT1"]
            #[inline(always)]
            pub fn set_spt1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "CCT"]
            #[inline(always)]
            pub const fn cct(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "CCT"]
            #[inline(always)]
            pub fn set_cct(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "CCT_CAP0"]
            #[inline(always)]
            pub const fn cct_cap0(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP0"]
            #[inline(always)]
            pub fn set_cct_cap0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "CCT_CAP1"]
            #[inline(always)]
            pub const fn cct_cap1(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP1"]
            #[inline(always)]
            pub fn set_cct_cap1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "CCT_CAP2"]
            #[inline(always)]
            pub const fn cct_cap2(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP2"]
            #[inline(always)]
            pub fn set_cct_cap2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "CCT_CAP3"]
            #[inline(always)]
            pub const fn cct_cap3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP3"]
            #[inline(always)]
            pub fn set_cct_cap3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "CCT_CAP4"]
            #[inline(always)]
            pub const fn cct_cap4(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP4"]
            #[inline(always)]
            pub fn set_cct_cap4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "CCT_CAP5"]
            #[inline(always)]
            pub const fn cct_cap5(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP5"]
            #[inline(always)]
            pub fn set_cct_cap5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "CCT_CMP0"]
            #[inline(always)]
            pub const fn cct_cmp0(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CMP0"]
            #[inline(always)]
            pub fn set_cct_cmp0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "CCT_CMP1"]
            #[inline(always)]
            pub const fn cct_cmp1(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CMP1"]
            #[inline(always)]
            pub fn set_cct_cmp1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for EnSet18 {
            #[inline(always)]
            fn default() -> EnSet18 {
                EnSet18(0)
            }
        }
        impl core::fmt::Debug for EnSet18 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet18")
                    .field("spt0", &self.spt0())
                    .field("qmspi0", &self.qmspi0())
                    .field("qmspi1", &self.qmspi1())
                    .field("spt1", &self.spt1())
                    .field("cct", &self.cct())
                    .field("cct_cap0", &self.cct_cap0())
                    .field("cct_cap1", &self.cct_cap1())
                    .field("cct_cap2", &self.cct_cap2())
                    .field("cct_cap3", &self.cct_cap3())
                    .field("cct_cap4", &self.cct_cap4())
                    .field("cct_cap5", &self.cct_cap5())
                    .field("cct_cmp0", &self.cct_cmp0())
                    .field("cct_cmp1", &self.cct_cmp1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet18 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet18 {{ spt0: {=bool:?}, qmspi0: {=bool:?}, qmspi1: {=bool:?}, spt1: {=bool:?}, cct: {=bool:?}, cct_cap0: {=bool:?}, cct_cap1: {=bool:?}, cct_cap2: {=bool:?}, cct_cap3: {=bool:?}, cct_cap4: {=bool:?}, cct_cap5: {=bool:?}, cct_cmp0: {=bool:?}, cct_cmp1: {=bool:?} }}" , self . spt0 () , self . qmspi0 () , self . qmspi1 () , self . spt1 () , self . cct () , self . cct_cap0 () , self . cct_cap1 () , self . cct_cap2 () , self . cct_cap3 () , self . cct_cap4 () , self . cct_cap5 () , self . cct_cmp0 () , self . cct_cmp1 ())
            }
        }
        #[doc = "GIRQ20 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet20(pub u32);
        impl EnSet20 {
            #[doc = "IMSPI"]
            #[inline(always)]
            pub const fn imspi(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "IMSPI"]
            #[inline(always)]
            pub fn set_imspi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "CLK_MON"]
            #[inline(always)]
            pub const fn clk_mon(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "CLK_MON"]
            #[inline(always)]
            pub fn set_clk_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "VTR1_PAD_MON"]
            #[inline(always)]
            pub const fn vtr1_pad_mon(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "VTR1_PAD_MON"]
            #[inline(always)]
            pub fn set_vtr1_pad_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "VTR2_PAD_MON"]
            #[inline(always)]
            pub const fn vtr2_pad_mon(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "VTR2_PAD_MON"]
            #[inline(always)]
            pub fn set_vtr2_pad_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for EnSet20 {
            #[inline(always)]
            fn default() -> EnSet20 {
                EnSet20(0)
            }
        }
        impl core::fmt::Debug for EnSet20 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet20")
                    .field("imspi", &self.imspi())
                    .field("clk_mon", &self.clk_mon())
                    .field("vtr1_pad_mon", &self.vtr1_pad_mon())
                    .field("vtr2_pad_mon", &self.vtr2_pad_mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet20 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet20 {{ imspi: {=bool:?}, clk_mon: {=bool:?}, vtr1_pad_mon: {=bool:?}, vtr2_pad_mon: {=bool:?} }}" , self . imspi () , self . clk_mon () , self . vtr1_pad_mon () , self . vtr2_pad_mon ())
            }
        }
        #[doc = "GIRQ21 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet21(pub u32);
        impl EnSet21 {
            #[doc = "WDT"]
            #[inline(always)]
            pub const fn wdt(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "WDT"]
            #[inline(always)]
            pub fn set_wdt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "EMC"]
            #[inline(always)]
            pub const fn emc(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "EMC"]
            #[inline(always)]
            pub fn set_emc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for EnSet21 {
            #[inline(always)]
            fn default() -> EnSet21 {
                EnSet21(0)
            }
        }
        impl core::fmt::Debug for EnSet21 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet21")
                    .field("wdt", &self.wdt())
                    .field("emc", &self.emc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet21 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EnSet21 {{ wdt: {=bool:?}, emc: {=bool:?} }}",
                    self.wdt(),
                    self.emc()
                )
            }
        }
        #[doc = "GIRQ23 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet23(pub u32);
        impl EnSet23 {
            #[doc = "TIMER32_0"]
            #[inline(always)]
            pub const fn timer32_0(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0"]
            #[inline(always)]
            pub fn set_timer32_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "TIMER32_1"]
            #[inline(always)]
            pub const fn timer32_1(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1"]
            #[inline(always)]
            pub fn set_timer32_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "RTMR"]
            #[inline(always)]
            pub const fn rtmr(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "RTMR"]
            #[inline(always)]
            pub fn set_rtmr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "SWI0"]
            #[inline(always)]
            pub const fn swi0(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "SWI0"]
            #[inline(always)]
            pub fn set_swi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "SWI1"]
            #[inline(always)]
            pub const fn swi1(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "SWI1"]
            #[inline(always)]
            pub fn set_swi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "SWI2"]
            #[inline(always)]
            pub const fn swi2(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SWI2"]
            #[inline(always)]
            pub fn set_swi2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SWI3"]
            #[inline(always)]
            pub const fn swi3(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SWI3"]
            #[inline(always)]
            pub fn set_swi3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "HTMR0"]
            #[inline(always)]
            pub const fn htmr0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "HTMR0"]
            #[inline(always)]
            pub fn set_htmr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "HTMR1"]
            #[inline(always)]
            pub const fn htmr1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "HTMR1"]
            #[inline(always)]
            pub fn set_htmr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for EnSet23 {
            #[inline(always)]
            fn default() -> EnSet23 {
                EnSet23(0)
            }
        }
        impl core::fmt::Debug for EnSet23 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet23")
                    .field("timer32_0", &self.timer32_0())
                    .field("timer32_1", &self.timer32_1())
                    .field("rtmr", &self.rtmr())
                    .field("swi0", &self.swi0())
                    .field("swi1", &self.swi1())
                    .field("swi2", &self.swi2())
                    .field("swi3", &self.swi3())
                    .field("htmr0", &self.htmr0())
                    .field("htmr1", &self.htmr1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet23 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet23 {{ timer32_0: {=bool:?}, timer32_1: {=bool:?}, rtmr: {=bool:?}, swi0: {=bool:?}, swi1: {=bool:?}, swi2: {=bool:?}, swi3: {=bool:?}, htmr0: {=bool:?}, htmr1: {=bool:?} }}" , self . timer32_0 () , self . timer32_1 () , self . rtmr () , self . swi0 () , self . swi1 () , self . swi2 () , self . swi3 () , self . htmr0 () , self . htmr1 ())
            }
        }
        #[doc = "GIRQ24 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet24(pub u32);
        impl EnSet24 {
            #[doc = "SPIMON0_VLTN"]
            #[inline(always)]
            pub const fn spimon0_vltn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_VLTN"]
            #[inline(always)]
            pub fn set_spimon0_vltn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SPIMON0_MTMON"]
            #[inline(always)]
            pub const fn spimon0_mtmon(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_MTMON"]
            #[inline(always)]
            pub fn set_spimon0_mtmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "SPIMON0_LTMON"]
            #[inline(always)]
            pub const fn spimon0_ltmon(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_LTMON"]
            #[inline(always)]
            pub fn set_spimon0_ltmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SPIMON1_VLTN"]
            #[inline(always)]
            pub const fn spimon1_vltn(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_VLTN"]
            #[inline(always)]
            pub fn set_spimon1_vltn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "SPIMON1_MTMON"]
            #[inline(always)]
            pub const fn spimon1_mtmon(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_MTMON"]
            #[inline(always)]
            pub fn set_spimon1_mtmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "SPIMON1_LTMON"]
            #[inline(always)]
            pub const fn spimon1_ltmon(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_LTMON"]
            #[inline(always)]
            pub fn set_spimon1_ltmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for EnSet24 {
            #[inline(always)]
            fn default() -> EnSet24 {
                EnSet24(0)
            }
        }
        impl core::fmt::Debug for EnSet24 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet24")
                    .field("spimon0_vltn", &self.spimon0_vltn())
                    .field("spimon0_mtmon", &self.spimon0_mtmon())
                    .field("spimon0_ltmon", &self.spimon0_ltmon())
                    .field("spimon1_vltn", &self.spimon1_vltn())
                    .field("spimon1_mtmon", &self.spimon1_mtmon())
                    .field("spimon1_ltmon", &self.spimon1_ltmon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet24 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet24 {{ spimon0_vltn: {=bool:?}, spimon0_mtmon: {=bool:?}, spimon0_ltmon: {=bool:?}, spimon1_vltn: {=bool:?}, spimon1_mtmon: {=bool:?}, spimon1_ltmon: {=bool:?} }}" , self . spimon0_vltn () , self . spimon0_mtmon () , self . spimon0_ltmon () , self . spimon1_vltn () , self . spimon1_mtmon () , self . spimon1_ltmon ())
            }
        }
        #[doc = "GIRQ26 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet26(pub u32);
        impl EnSet26 {
            #[doc = "GPIO250"]
            #[inline(always)]
            pub const fn gpio250(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO250"]
            #[inline(always)]
            pub fn set_gpio250(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO260"]
            #[inline(always)]
            pub const fn gpio260(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO260"]
            #[inline(always)]
            pub fn set_gpio260(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for EnSet26 {
            #[inline(always)]
            fn default() -> EnSet26 {
                EnSet26(0)
            }
        }
        impl core::fmt::Debug for EnSet26 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet26")
                    .field("gpio250", &self.gpio250())
                    .field("gpio260", &self.gpio260())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet26 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "EnSet26 {{ gpio250: {=bool:?}, gpio260: {=bool:?} }}",
                    self.gpio250(),
                    self.gpio260()
                )
            }
        }
        #[doc = "GIRQ8 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet8(pub u32);
        impl EnSet8 {
            #[doc = "GPIO 140"]
            #[inline(always)]
            pub const fn gpio140(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 140"]
            #[inline(always)]
            pub fn set_gpio140(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 143"]
            #[inline(always)]
            pub const fn gpio143(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 143"]
            #[inline(always)]
            pub fn set_gpio143(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 144"]
            #[inline(always)]
            pub const fn gpio144(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 144"]
            #[inline(always)]
            pub fn set_gpio144(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 145"]
            #[inline(always)]
            pub const fn gpio145(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 145"]
            #[inline(always)]
            pub fn set_gpio145(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 146"]
            #[inline(always)]
            pub const fn gpio146(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 146"]
            #[inline(always)]
            pub fn set_gpio146(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 147"]
            #[inline(always)]
            pub const fn gpio147(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 147"]
            #[inline(always)]
            pub fn set_gpio147(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 150"]
            #[inline(always)]
            pub const fn gpio150(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 150"]
            #[inline(always)]
            pub fn set_gpio150(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO 156"]
            #[inline(always)]
            pub const fn gpio156(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 156"]
            #[inline(always)]
            pub fn set_gpio156(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 157"]
            #[inline(always)]
            pub const fn gpio157(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 157"]
            #[inline(always)]
            pub fn set_gpio157(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "GPIO 163"]
            #[inline(always)]
            pub const fn gpio163(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 163"]
            #[inline(always)]
            pub fn set_gpio163(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 165"]
            #[inline(always)]
            pub const fn gpio165(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 165"]
            #[inline(always)]
            pub fn set_gpio165(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "GPIO 166"]
            #[inline(always)]
            pub const fn gpio166(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 166"]
            #[inline(always)]
            pub fn set_gpio166(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 170"]
            #[inline(always)]
            pub const fn gpio170(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 170"]
            #[inline(always)]
            pub fn set_gpio170(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 171"]
            #[inline(always)]
            pub const fn gpio171(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 171"]
            #[inline(always)]
            pub fn set_gpio171(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for EnSet8 {
            #[inline(always)]
            fn default() -> EnSet8 {
                EnSet8(0)
            }
        }
        impl core::fmt::Debug for EnSet8 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet8")
                    .field("gpio140", &self.gpio140())
                    .field("gpio143", &self.gpio143())
                    .field("gpio144", &self.gpio144())
                    .field("gpio145", &self.gpio145())
                    .field("gpio146", &self.gpio146())
                    .field("gpio147", &self.gpio147())
                    .field("gpio150", &self.gpio150())
                    .field("gpio156", &self.gpio156())
                    .field("gpio157", &self.gpio157())
                    .field("gpio163", &self.gpio163())
                    .field("gpio165", &self.gpio165())
                    .field("gpio166", &self.gpio166())
                    .field("gpio170", &self.gpio170())
                    .field("gpio171", &self.gpio171())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet8 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet8 {{ gpio140: {=bool:?}, gpio143: {=bool:?}, gpio144: {=bool:?}, gpio145: {=bool:?}, gpio146: {=bool:?}, gpio147: {=bool:?}, gpio150: {=bool:?}, gpio156: {=bool:?}, gpio157: {=bool:?}, gpio163: {=bool:?}, gpio165: {=bool:?}, gpio166: {=bool:?}, gpio170: {=bool:?}, gpio171: {=bool:?} }}" , self . gpio140 () , self . gpio143 () , self . gpio144 () , self . gpio145 () , self . gpio146 () , self . gpio147 () , self . gpio150 () , self . gpio156 () , self . gpio157 () , self . gpio163 () , self . gpio165 () , self . gpio166 () , self . gpio170 () , self . gpio171 ())
            }
        }
        #[doc = "GIRQ9 ENABLE SET"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EnSet9(pub u32);
        impl EnSet9 {
            #[doc = "GPIO 104"]
            #[inline(always)]
            pub const fn gpio104(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 104"]
            #[inline(always)]
            pub fn set_gpio104(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 105"]
            #[inline(always)]
            pub const fn gpio105(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 105"]
            #[inline(always)]
            pub fn set_gpio105(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 106"]
            #[inline(always)]
            pub const fn gpio106(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 106"]
            #[inline(always)]
            pub fn set_gpio106(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 107"]
            #[inline(always)]
            pub const fn gpio107(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 107"]
            #[inline(always)]
            pub fn set_gpio107(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 112"]
            #[inline(always)]
            pub const fn gpio112(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 112"]
            #[inline(always)]
            pub fn set_gpio112(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "GPIO 113"]
            #[inline(always)]
            pub const fn gpio113(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 113"]
            #[inline(always)]
            pub fn set_gpio113(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 120"]
            #[inline(always)]
            pub const fn gpio120(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 120"]
            #[inline(always)]
            pub fn set_gpio120(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPIO 121"]
            #[inline(always)]
            pub const fn gpio121(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 121"]
            #[inline(always)]
            pub fn set_gpio121(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "GPIO 122"]
            #[inline(always)]
            pub const fn gpio122(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 122"]
            #[inline(always)]
            pub fn set_gpio122(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "GPIO 123"]
            #[inline(always)]
            pub const fn gpio123(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 123"]
            #[inline(always)]
            pub fn set_gpio123(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 124"]
            #[inline(always)]
            pub const fn gpio124(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 124"]
            #[inline(always)]
            pub fn set_gpio124(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 125"]
            #[inline(always)]
            pub const fn gpio125(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 125"]
            #[inline(always)]
            pub fn set_gpio125(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "GPIO 126"]
            #[inline(always)]
            pub const fn gpio126(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 126"]
            #[inline(always)]
            pub fn set_gpio126(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 127"]
            #[inline(always)]
            pub const fn gpio127(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 127"]
            #[inline(always)]
            pub fn set_gpio127(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "GPIO 130"]
            #[inline(always)]
            pub const fn gpio130(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 130"]
            #[inline(always)]
            pub fn set_gpio130(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 131"]
            #[inline(always)]
            pub const fn gpio131(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 131"]
            #[inline(always)]
            pub fn set_gpio131(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "GPIO 132"]
            #[inline(always)]
            pub const fn gpio132(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 132"]
            #[inline(always)]
            pub fn set_gpio132(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
        }
        impl Default for EnSet9 {
            #[inline(always)]
            fn default() -> EnSet9 {
                EnSet9(0)
            }
        }
        impl core::fmt::Debug for EnSet9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EnSet9")
                    .field("gpio104", &self.gpio104())
                    .field("gpio105", &self.gpio105())
                    .field("gpio106", &self.gpio106())
                    .field("gpio107", &self.gpio107())
                    .field("gpio112", &self.gpio112())
                    .field("gpio113", &self.gpio113())
                    .field("gpio120", &self.gpio120())
                    .field("gpio121", &self.gpio121())
                    .field("gpio122", &self.gpio122())
                    .field("gpio123", &self.gpio123())
                    .field("gpio124", &self.gpio124())
                    .field("gpio125", &self.gpio125())
                    .field("gpio126", &self.gpio126())
                    .field("gpio127", &self.gpio127())
                    .field("gpio130", &self.gpio130())
                    .field("gpio131", &self.gpio131())
                    .field("gpio132", &self.gpio132())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EnSet9 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EnSet9 {{ gpio104: {=bool:?}, gpio105: {=bool:?}, gpio106: {=bool:?}, gpio107: {=bool:?}, gpio112: {=bool:?}, gpio113: {=bool:?}, gpio120: {=bool:?}, gpio121: {=bool:?}, gpio122: {=bool:?}, gpio123: {=bool:?}, gpio124: {=bool:?}, gpio125: {=bool:?}, gpio126: {=bool:?}, gpio127: {=bool:?}, gpio130: {=bool:?}, gpio131: {=bool:?}, gpio132: {=bool:?} }}" , self . gpio104 () , self . gpio105 () , self . gpio106 () , self . gpio107 () , self . gpio112 () , self . gpio113 () , self . gpio120 () , self . gpio121 () , self . gpio122 () , self . gpio123 () , self . gpio124 () , self . gpio125 () , self . gpio126 () , self . gpio127 () , self . gpio130 () , self . gpio131 () , self . gpio132 ())
            }
        }
        #[doc = "GIRQ10 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result10(pub u32);
        impl Result10 {
            #[doc = "GPIO 045"]
            #[inline(always)]
            pub const fn gpio045(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 045"]
            #[inline(always)]
            pub fn set_gpio045(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 046"]
            #[inline(always)]
            pub const fn gpio046(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 046"]
            #[inline(always)]
            pub fn set_gpio046(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 047"]
            #[inline(always)]
            pub const fn gpio047(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 047"]
            #[inline(always)]
            pub fn set_gpio047(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 050"]
            #[inline(always)]
            pub const fn gpio050(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 050"]
            #[inline(always)]
            pub fn set_gpio050(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO 053"]
            #[inline(always)]
            pub const fn gpio053(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 053"]
            #[inline(always)]
            pub fn set_gpio053(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 055"]
            #[inline(always)]
            pub const fn gpio055(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 055"]
            #[inline(always)]
            pub fn set_gpio055(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "GPIO 056"]
            #[inline(always)]
            pub const fn gpio056(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 056"]
            #[inline(always)]
            pub fn set_gpio056(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 057"]
            #[inline(always)]
            pub const fn gpio057(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 057"]
            #[inline(always)]
            pub fn set_gpio057(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "GPIO 060"]
            #[inline(always)]
            pub const fn gpio063(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 060"]
            #[inline(always)]
            pub fn set_gpio063(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 070"]
            #[inline(always)]
            pub const fn gpio070(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 070"]
            #[inline(always)]
            pub fn set_gpio070(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 071"]
            #[inline(always)]
            pub const fn gpio071(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 071"]
            #[inline(always)]
            pub fn set_gpio071(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Result10 {
            #[inline(always)]
            fn default() -> Result10 {
                Result10(0)
            }
        }
        impl core::fmt::Debug for Result10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result10")
                    .field("gpio045", &self.gpio045())
                    .field("gpio046", &self.gpio046())
                    .field("gpio047", &self.gpio047())
                    .field("gpio050", &self.gpio050())
                    .field("gpio053", &self.gpio053())
                    .field("gpio055", &self.gpio055())
                    .field("gpio056", &self.gpio056())
                    .field("gpio057", &self.gpio057())
                    .field("gpio063", &self.gpio063())
                    .field("gpio070", &self.gpio070())
                    .field("gpio071", &self.gpio071())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result10 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result10 {{ gpio045: {=bool:?}, gpio046: {=bool:?}, gpio047: {=bool:?}, gpio050: {=bool:?}, gpio053: {=bool:?}, gpio055: {=bool:?}, gpio056: {=bool:?}, gpio057: {=bool:?}, gpio063: {=bool:?}, gpio070: {=bool:?}, gpio071: {=bool:?} }}" , self . gpio045 () , self . gpio046 () , self . gpio047 () , self . gpio050 () , self . gpio053 () , self . gpio055 () , self . gpio056 () , self . gpio057 () , self . gpio063 () , self . gpio070 () , self . gpio071 ())
            }
        }
        #[doc = "GIRQ11 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result11(pub u32);
        impl Result11 {
            #[doc = "GPIO 000"]
            #[inline(always)]
            pub const fn gpio000(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 000"]
            #[inline(always)]
            pub fn set_gpio000(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 002"]
            #[inline(always)]
            pub const fn gpio002(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 002"]
            #[inline(always)]
            pub fn set_gpio002(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GPIO 003"]
            #[inline(always)]
            pub const fn gpio003(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 003"]
            #[inline(always)]
            pub fn set_gpio003(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 004"]
            #[inline(always)]
            pub const fn gpio004(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 004"]
            #[inline(always)]
            pub fn set_gpio004(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 012"]
            #[inline(always)]
            pub const fn gpio012(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 012"]
            #[inline(always)]
            pub fn set_gpio012(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "GPIO 013"]
            #[inline(always)]
            pub const fn gpio013(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 013"]
            #[inline(always)]
            pub fn set_gpio013(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 015"]
            #[inline(always)]
            pub const fn gpio015(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 015"]
            #[inline(always)]
            pub fn set_gpio015(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "GPIO 016"]
            #[inline(always)]
            pub const fn gpio016(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 016"]
            #[inline(always)]
            pub fn set_gpio016(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 020"]
            #[inline(always)]
            pub const fn gpio020(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 020"]
            #[inline(always)]
            pub fn set_gpio020(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPIO 021"]
            #[inline(always)]
            pub const fn gpio021(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 021"]
            #[inline(always)]
            pub fn set_gpio021(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "GPIO 022"]
            #[inline(always)]
            pub const fn gpio022(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 022"]
            #[inline(always)]
            pub fn set_gpio022(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "GPIO 023"]
            #[inline(always)]
            pub const fn gpio023(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 023"]
            #[inline(always)]
            pub fn set_gpio023(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 024"]
            #[inline(always)]
            pub const fn gpio024(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 024"]
            #[inline(always)]
            pub fn set_gpio024(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 026"]
            #[inline(always)]
            pub const fn gpio026(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 026"]
            #[inline(always)]
            pub fn set_gpio026(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 027"]
            #[inline(always)]
            pub const fn gpio027(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 027"]
            #[inline(always)]
            pub fn set_gpio027(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "GPIO 030"]
            #[inline(always)]
            pub const fn gpio030(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 030"]
            #[inline(always)]
            pub fn set_gpio030(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 031"]
            #[inline(always)]
            pub const fn gpio031(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 031"]
            #[inline(always)]
            pub fn set_gpio031(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "GPIO 032"]
            #[inline(always)]
            pub const fn gpio032(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 032"]
            #[inline(always)]
            pub fn set_gpio032(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "GPIO 033"]
            #[inline(always)]
            pub const fn gpio033(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 033"]
            #[inline(always)]
            pub fn set_gpio033(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "GPIO 034"]
            #[inline(always)]
            pub const fn gpio034(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 034"]
            #[inline(always)]
            pub fn set_gpio034(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Result11 {
            #[inline(always)]
            fn default() -> Result11 {
                Result11(0)
            }
        }
        impl core::fmt::Debug for Result11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result11")
                    .field("gpio000", &self.gpio000())
                    .field("gpio002", &self.gpio002())
                    .field("gpio003", &self.gpio003())
                    .field("gpio004", &self.gpio004())
                    .field("gpio012", &self.gpio012())
                    .field("gpio013", &self.gpio013())
                    .field("gpio015", &self.gpio015())
                    .field("gpio016", &self.gpio016())
                    .field("gpio020", &self.gpio020())
                    .field("gpio021", &self.gpio021())
                    .field("gpio022", &self.gpio022())
                    .field("gpio023", &self.gpio023())
                    .field("gpio024", &self.gpio024())
                    .field("gpio026", &self.gpio026())
                    .field("gpio027", &self.gpio027())
                    .field("gpio030", &self.gpio030())
                    .field("gpio031", &self.gpio031())
                    .field("gpio032", &self.gpio032())
                    .field("gpio033", &self.gpio033())
                    .field("gpio034", &self.gpio034())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result11 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result11 {{ gpio000: {=bool:?}, gpio002: {=bool:?}, gpio003: {=bool:?}, gpio004: {=bool:?}, gpio012: {=bool:?}, gpio013: {=bool:?}, gpio015: {=bool:?}, gpio016: {=bool:?}, gpio020: {=bool:?}, gpio021: {=bool:?}, gpio022: {=bool:?}, gpio023: {=bool:?}, gpio024: {=bool:?}, gpio026: {=bool:?}, gpio027: {=bool:?}, gpio030: {=bool:?}, gpio031: {=bool:?}, gpio032: {=bool:?}, gpio033: {=bool:?}, gpio034: {=bool:?} }}" , self . gpio000 () , self . gpio002 () , self . gpio003 () , self . gpio004 () , self . gpio012 () , self . gpio013 () , self . gpio015 () , self . gpio016 () , self . gpio020 () , self . gpio021 () , self . gpio022 () , self . gpio023 () , self . gpio024 () , self . gpio026 () , self . gpio027 () , self . gpio030 () , self . gpio031 () , self . gpio032 () , self . gpio033 () , self . gpio034 ())
            }
        }
        #[doc = "GIRQ12 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result12(pub u32);
        impl Result12 {
            #[doc = "GPIO 200"]
            #[inline(always)]
            pub const fn gpio200(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 200"]
            #[inline(always)]
            pub fn set_gpio200(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 201"]
            #[inline(always)]
            pub const fn gpio201(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 201"]
            #[inline(always)]
            pub fn set_gpio201(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "GPIO 202"]
            #[inline(always)]
            pub const fn gpio202(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 202"]
            #[inline(always)]
            pub fn set_gpio202(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GPIO 203"]
            #[inline(always)]
            pub const fn gpio203(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 203"]
            #[inline(always)]
            pub fn set_gpio203(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 204"]
            #[inline(always)]
            pub const fn gpio204(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 204"]
            #[inline(always)]
            pub fn set_gpio204(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 223"]
            #[inline(always)]
            pub const fn gpio223(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 223"]
            #[inline(always)]
            pub fn set_gpio223(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 224"]
            #[inline(always)]
            pub const fn gpio224(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 224"]
            #[inline(always)]
            pub fn set_gpio224(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 227"]
            #[inline(always)]
            pub const fn gpio227(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 227"]
            #[inline(always)]
            pub fn set_gpio227(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Result12 {
            #[inline(always)]
            fn default() -> Result12 {
                Result12(0)
            }
        }
        impl core::fmt::Debug for Result12 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result12")
                    .field("gpio200", &self.gpio200())
                    .field("gpio201", &self.gpio201())
                    .field("gpio202", &self.gpio202())
                    .field("gpio203", &self.gpio203())
                    .field("gpio204", &self.gpio204())
                    .field("gpio223", &self.gpio223())
                    .field("gpio224", &self.gpio224())
                    .field("gpio227", &self.gpio227())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result12 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result12 {{ gpio200: {=bool:?}, gpio201: {=bool:?}, gpio202: {=bool:?}, gpio203: {=bool:?}, gpio204: {=bool:?}, gpio223: {=bool:?}, gpio224: {=bool:?}, gpio227: {=bool:?} }}" , self . gpio200 () , self . gpio201 () , self . gpio202 () , self . gpio203 () , self . gpio204 () , self . gpio223 () , self . gpio224 () , self . gpio227 ())
            }
        }
        #[doc = "GIRQ13 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result13(pub u32);
        impl Result13 {
            #[doc = "I2CSMB0"]
            #[inline(always)]
            pub const fn i2csmb0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB0"]
            #[inline(always)]
            pub fn set_i2csmb0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "I2CSMB1"]
            #[inline(always)]
            pub const fn i2csmb1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB1"]
            #[inline(always)]
            pub fn set_i2csmb1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "I2CSMB2"]
            #[inline(always)]
            pub const fn i2csmb2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB2"]
            #[inline(always)]
            pub fn set_i2csmb2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "I2CSMB3"]
            #[inline(always)]
            pub const fn i2csmb3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB3"]
            #[inline(always)]
            pub fn set_i2csmb3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "I2CSMB4"]
            #[inline(always)]
            pub const fn i2csmb4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB4"]
            #[inline(always)]
            pub fn set_i2csmb4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Result13 {
            #[inline(always)]
            fn default() -> Result13 {
                Result13(0)
            }
        }
        impl core::fmt::Debug for Result13 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result13")
                    .field("i2csmb0", &self.i2csmb0())
                    .field("i2csmb1", &self.i2csmb1())
                    .field("i2csmb2", &self.i2csmb2())
                    .field("i2csmb3", &self.i2csmb3())
                    .field("i2csmb4", &self.i2csmb4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result13 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result13 {{ i2csmb0: {=bool:?}, i2csmb1: {=bool:?}, i2csmb2: {=bool:?}, i2csmb3: {=bool:?}, i2csmb4: {=bool:?} }}" , self . i2csmb0 () , self . i2csmb1 () , self . i2csmb2 () , self . i2csmb3 () , self . i2csmb4 ())
            }
        }
        #[doc = "GIRQ14 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result14(pub u32);
        impl Result14 {
            #[doc = "DMA CH00"]
            #[inline(always)]
            pub const fn dma_ch00(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH00"]
            #[inline(always)]
            pub fn set_dma_ch00(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "DMA CH01"]
            #[inline(always)]
            pub const fn dma_ch01(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH01"]
            #[inline(always)]
            pub fn set_dma_ch01(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "DMA CH02"]
            #[inline(always)]
            pub const fn dma_ch02(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH02"]
            #[inline(always)]
            pub fn set_dma_ch02(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "DMA CH03"]
            #[inline(always)]
            pub const fn dma_ch03(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH03"]
            #[inline(always)]
            pub fn set_dma_ch03(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "DMA CH04"]
            #[inline(always)]
            pub const fn dma_ch04(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH04"]
            #[inline(always)]
            pub fn set_dma_ch04(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "DMA CH05"]
            #[inline(always)]
            pub const fn dma_ch05(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH05"]
            #[inline(always)]
            pub fn set_dma_ch05(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "DMA CH06"]
            #[inline(always)]
            pub const fn dma_ch06(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH06"]
            #[inline(always)]
            pub fn set_dma_ch06(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "DMA CH07"]
            #[inline(always)]
            pub const fn dma_ch07(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH07"]
            #[inline(always)]
            pub fn set_dma_ch07(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "DMA CH08"]
            #[inline(always)]
            pub const fn dma_ch08(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH08"]
            #[inline(always)]
            pub fn set_dma_ch08(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "DMA CH09"]
            #[inline(always)]
            pub const fn dma_ch09(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH09"]
            #[inline(always)]
            pub fn set_dma_ch09(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Result14 {
            #[inline(always)]
            fn default() -> Result14 {
                Result14(0)
            }
        }
        impl core::fmt::Debug for Result14 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result14")
                    .field("dma_ch00", &self.dma_ch00())
                    .field("dma_ch01", &self.dma_ch01())
                    .field("dma_ch02", &self.dma_ch02())
                    .field("dma_ch03", &self.dma_ch03())
                    .field("dma_ch04", &self.dma_ch04())
                    .field("dma_ch05", &self.dma_ch05())
                    .field("dma_ch06", &self.dma_ch06())
                    .field("dma_ch07", &self.dma_ch07())
                    .field("dma_ch08", &self.dma_ch08())
                    .field("dma_ch09", &self.dma_ch09())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result14 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result14 {{ dma_ch00: {=bool:?}, dma_ch01: {=bool:?}, dma_ch02: {=bool:?}, dma_ch03: {=bool:?}, dma_ch04: {=bool:?}, dma_ch05: {=bool:?}, dma_ch06: {=bool:?}, dma_ch07: {=bool:?}, dma_ch08: {=bool:?}, dma_ch09: {=bool:?} }}" , self . dma_ch00 () , self . dma_ch01 () , self . dma_ch02 () , self . dma_ch03 () , self . dma_ch04 () , self . dma_ch05 () , self . dma_ch06 () , self . dma_ch07 () , self . dma_ch08 () , self . dma_ch09 ())
            }
        }
        #[doc = "GIRQ15 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result15(pub u32);
        impl Result15 {
            #[doc = "UART0"]
            #[inline(always)]
            pub const fn uart0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "UART0"]
            #[inline(always)]
            pub fn set_uart0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Result15 {
            #[inline(always)]
            fn default() -> Result15 {
                Result15(0)
            }
        }
        impl core::fmt::Debug for Result15 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result15").field("uart0", &self.uart0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result15 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Result15 {{ uart0: {=bool:?} }}", self.uart0())
            }
        }
        #[doc = "GIRQ16 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result16(pub u32);
        impl Result16 {
            #[doc = "PKE ERR"]
            #[inline(always)]
            pub const fn pke_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PKE ERR"]
            #[inline(always)]
            pub fn set_pke_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PKE END"]
            #[inline(always)]
            pub const fn pke_end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PKE END"]
            #[inline(always)]
            pub fn set_pke_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "RNG"]
            #[inline(always)]
            pub const fn rng(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RNG"]
            #[inline(always)]
            pub fn set_rng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "AES"]
            #[inline(always)]
            pub const fn aes(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "AES"]
            #[inline(always)]
            pub fn set_aes(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "HASH"]
            #[inline(always)]
            pub const fn hash(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "HASH"]
            #[inline(always)]
            pub fn set_hash(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Result16 {
            #[inline(always)]
            fn default() -> Result16 {
                Result16(0)
            }
        }
        impl core::fmt::Debug for Result16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result16")
                    .field("pke_err", &self.pke_err())
                    .field("pke_end", &self.pke_end())
                    .field("rng", &self.rng())
                    .field("aes", &self.aes())
                    .field("hash", &self.hash())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result16 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result16 {{ pke_err: {=bool:?}, pke_end: {=bool:?}, rng: {=bool:?}, aes: {=bool:?}, hash: {=bool:?} }}" , self . pke_err () , self . pke_end () , self . rng () , self . aes () , self . hash ())
            }
        }
        #[doc = "GIRQ17 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result17(pub u32);
        impl Result17 {
            #[doc = "Breating LED0"]
            #[inline(always)]
            pub const fn led0(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Breating LED0"]
            #[inline(always)]
            pub fn set_led0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Breating LED1"]
            #[inline(always)]
            pub const fn led1(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Breating LED1"]
            #[inline(always)]
            pub fn set_led1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Result17 {
            #[inline(always)]
            fn default() -> Result17 {
                Result17(0)
            }
        }
        impl core::fmt::Debug for Result17 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result17")
                    .field("led0", &self.led0())
                    .field("led1", &self.led1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result17 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Result17 {{ led0: {=bool:?}, led1: {=bool:?} }}",
                    self.led0(),
                    self.led1()
                )
            }
        }
        #[doc = "GIRQ18 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result18(pub u32);
        impl Result18 {
            #[doc = "SPT0"]
            #[inline(always)]
            pub const fn spt0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SPT0"]
            #[inline(always)]
            pub fn set_spt0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "QMSPI0"]
            #[inline(always)]
            pub const fn qmspi0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI0"]
            #[inline(always)]
            pub fn set_qmspi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "QMSPI1"]
            #[inline(always)]
            pub const fn qmspi1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI1"]
            #[inline(always)]
            pub fn set_qmspi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SPT1"]
            #[inline(always)]
            pub const fn spt1(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "SPT1"]
            #[inline(always)]
            pub fn set_spt1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "CCT"]
            #[inline(always)]
            pub const fn cct(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "CCT"]
            #[inline(always)]
            pub fn set_cct(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "CCT_CAP0"]
            #[inline(always)]
            pub const fn cct_cap0(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP0"]
            #[inline(always)]
            pub fn set_cct_cap0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "CCT_CAP1"]
            #[inline(always)]
            pub const fn cct_cap1(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP1"]
            #[inline(always)]
            pub fn set_cct_cap1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "CCT_CAP2"]
            #[inline(always)]
            pub const fn cct_cap2(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP2"]
            #[inline(always)]
            pub fn set_cct_cap2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "CCT_CAP3"]
            #[inline(always)]
            pub const fn cct_cap3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP3"]
            #[inline(always)]
            pub fn set_cct_cap3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "CCT_CAP4"]
            #[inline(always)]
            pub const fn cct_cap4(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP4"]
            #[inline(always)]
            pub fn set_cct_cap4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "CCT_CAP5"]
            #[inline(always)]
            pub const fn cct_cap5(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP5"]
            #[inline(always)]
            pub fn set_cct_cap5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "CCT_CMP0"]
            #[inline(always)]
            pub const fn cct_cmp0(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CMP0"]
            #[inline(always)]
            pub fn set_cct_cmp0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "CCT_CMP1"]
            #[inline(always)]
            pub const fn cct_cmp1(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CMP1"]
            #[inline(always)]
            pub fn set_cct_cmp1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Result18 {
            #[inline(always)]
            fn default() -> Result18 {
                Result18(0)
            }
        }
        impl core::fmt::Debug for Result18 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result18")
                    .field("spt0", &self.spt0())
                    .field("qmspi0", &self.qmspi0())
                    .field("qmspi1", &self.qmspi1())
                    .field("spt1", &self.spt1())
                    .field("cct", &self.cct())
                    .field("cct_cap0", &self.cct_cap0())
                    .field("cct_cap1", &self.cct_cap1())
                    .field("cct_cap2", &self.cct_cap2())
                    .field("cct_cap3", &self.cct_cap3())
                    .field("cct_cap4", &self.cct_cap4())
                    .field("cct_cap5", &self.cct_cap5())
                    .field("cct_cmp0", &self.cct_cmp0())
                    .field("cct_cmp1", &self.cct_cmp1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result18 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result18 {{ spt0: {=bool:?}, qmspi0: {=bool:?}, qmspi1: {=bool:?}, spt1: {=bool:?}, cct: {=bool:?}, cct_cap0: {=bool:?}, cct_cap1: {=bool:?}, cct_cap2: {=bool:?}, cct_cap3: {=bool:?}, cct_cap4: {=bool:?}, cct_cap5: {=bool:?}, cct_cmp0: {=bool:?}, cct_cmp1: {=bool:?} }}" , self . spt0 () , self . qmspi0 () , self . qmspi1 () , self . spt1 () , self . cct () , self . cct_cap0 () , self . cct_cap1 () , self . cct_cap2 () , self . cct_cap3 () , self . cct_cap4 () , self . cct_cap5 () , self . cct_cmp0 () , self . cct_cmp1 ())
            }
        }
        #[doc = "GIRQ20 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result20(pub u32);
        impl Result20 {
            #[doc = "IMSPI"]
            #[inline(always)]
            pub const fn imspi(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "IMSPI"]
            #[inline(always)]
            pub fn set_imspi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "CLK_MON"]
            #[inline(always)]
            pub const fn clk_mon(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "CLK_MON"]
            #[inline(always)]
            pub fn set_clk_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "VTR1_PAD_MON"]
            #[inline(always)]
            pub const fn vtr1_pad_mon(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "VTR1_PAD_MON"]
            #[inline(always)]
            pub fn set_vtr1_pad_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "VTR2_PAD_MON"]
            #[inline(always)]
            pub const fn vtr2_pad_mon(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "VTR2_PAD_MON"]
            #[inline(always)]
            pub fn set_vtr2_pad_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for Result20 {
            #[inline(always)]
            fn default() -> Result20 {
                Result20(0)
            }
        }
        impl core::fmt::Debug for Result20 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result20")
                    .field("imspi", &self.imspi())
                    .field("clk_mon", &self.clk_mon())
                    .field("vtr1_pad_mon", &self.vtr1_pad_mon())
                    .field("vtr2_pad_mon", &self.vtr2_pad_mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result20 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result20 {{ imspi: {=bool:?}, clk_mon: {=bool:?}, vtr1_pad_mon: {=bool:?}, vtr2_pad_mon: {=bool:?} }}" , self . imspi () , self . clk_mon () , self . vtr1_pad_mon () , self . vtr2_pad_mon ())
            }
        }
        #[doc = "GIRQ21 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result21(pub u32);
        impl Result21 {
            #[doc = "WDT"]
            #[inline(always)]
            pub const fn wdt(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "WDT"]
            #[inline(always)]
            pub fn set_wdt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "EMC"]
            #[inline(always)]
            pub const fn emc(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "EMC"]
            #[inline(always)]
            pub fn set_emc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Result21 {
            #[inline(always)]
            fn default() -> Result21 {
                Result21(0)
            }
        }
        impl core::fmt::Debug for Result21 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result21")
                    .field("wdt", &self.wdt())
                    .field("emc", &self.emc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result21 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Result21 {{ wdt: {=bool:?}, emc: {=bool:?} }}",
                    self.wdt(),
                    self.emc()
                )
            }
        }
        #[doc = "GIRQ23 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result23(pub u32);
        impl Result23 {
            #[doc = "TIMER32_0"]
            #[inline(always)]
            pub const fn timer32_0(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0"]
            #[inline(always)]
            pub fn set_timer32_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "TIMER32_1"]
            #[inline(always)]
            pub const fn timer32_1(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1"]
            #[inline(always)]
            pub fn set_timer32_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "RTMR"]
            #[inline(always)]
            pub const fn rtmr(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "RTMR"]
            #[inline(always)]
            pub fn set_rtmr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "SWI0"]
            #[inline(always)]
            pub const fn swi0(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "SWI0"]
            #[inline(always)]
            pub fn set_swi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "SWI1"]
            #[inline(always)]
            pub const fn swi1(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "SWI1"]
            #[inline(always)]
            pub fn set_swi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "SWI2"]
            #[inline(always)]
            pub const fn swi2(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SWI2"]
            #[inline(always)]
            pub fn set_swi2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SWI3"]
            #[inline(always)]
            pub const fn swi3(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SWI3"]
            #[inline(always)]
            pub fn set_swi3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "HTMR0"]
            #[inline(always)]
            pub const fn htmr0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "HTMR0"]
            #[inline(always)]
            pub fn set_htmr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "HTMR1"]
            #[inline(always)]
            pub const fn htmr1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "HTMR1"]
            #[inline(always)]
            pub fn set_htmr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Result23 {
            #[inline(always)]
            fn default() -> Result23 {
                Result23(0)
            }
        }
        impl core::fmt::Debug for Result23 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result23")
                    .field("timer32_0", &self.timer32_0())
                    .field("timer32_1", &self.timer32_1())
                    .field("rtmr", &self.rtmr())
                    .field("swi0", &self.swi0())
                    .field("swi1", &self.swi1())
                    .field("swi2", &self.swi2())
                    .field("swi3", &self.swi3())
                    .field("htmr0", &self.htmr0())
                    .field("htmr1", &self.htmr1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result23 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result23 {{ timer32_0: {=bool:?}, timer32_1: {=bool:?}, rtmr: {=bool:?}, swi0: {=bool:?}, swi1: {=bool:?}, swi2: {=bool:?}, swi3: {=bool:?}, htmr0: {=bool:?}, htmr1: {=bool:?} }}" , self . timer32_0 () , self . timer32_1 () , self . rtmr () , self . swi0 () , self . swi1 () , self . swi2 () , self . swi3 () , self . htmr0 () , self . htmr1 ())
            }
        }
        #[doc = "GIRQ24 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result24(pub u32);
        impl Result24 {
            #[doc = "SPIMON0_VLTN"]
            #[inline(always)]
            pub const fn spimon0_vltn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_VLTN"]
            #[inline(always)]
            pub fn set_spimon0_vltn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SPIMON0_MTMON"]
            #[inline(always)]
            pub const fn spimon0_mtmon(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_MTMON"]
            #[inline(always)]
            pub fn set_spimon0_mtmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "SPIMON0_LTMON"]
            #[inline(always)]
            pub const fn spimon0_ltmon(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_LTMON"]
            #[inline(always)]
            pub fn set_spimon0_ltmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SPIMON1_VLTN"]
            #[inline(always)]
            pub const fn spimon1_vltn(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_VLTN"]
            #[inline(always)]
            pub fn set_spimon1_vltn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "SPIMON1_MTMON"]
            #[inline(always)]
            pub const fn spimon1_mtmon(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_MTMON"]
            #[inline(always)]
            pub fn set_spimon1_mtmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "SPIMON1_LTMON"]
            #[inline(always)]
            pub const fn spimon1_ltmon(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_LTMON"]
            #[inline(always)]
            pub fn set_spimon1_ltmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Result24 {
            #[inline(always)]
            fn default() -> Result24 {
                Result24(0)
            }
        }
        impl core::fmt::Debug for Result24 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result24")
                    .field("spimon0_vltn", &self.spimon0_vltn())
                    .field("spimon0_mtmon", &self.spimon0_mtmon())
                    .field("spimon0_ltmon", &self.spimon0_ltmon())
                    .field("spimon1_vltn", &self.spimon1_vltn())
                    .field("spimon1_mtmon", &self.spimon1_mtmon())
                    .field("spimon1_ltmon", &self.spimon1_ltmon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result24 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result24 {{ spimon0_vltn: {=bool:?}, spimon0_mtmon: {=bool:?}, spimon0_ltmon: {=bool:?}, spimon1_vltn: {=bool:?}, spimon1_mtmon: {=bool:?}, spimon1_ltmon: {=bool:?} }}" , self . spimon0_vltn () , self . spimon0_mtmon () , self . spimon0_ltmon () , self . spimon1_vltn () , self . spimon1_mtmon () , self . spimon1_ltmon ())
            }
        }
        #[doc = "GIRQ26 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result26(pub u32);
        impl Result26 {
            #[doc = "GPIO250"]
            #[inline(always)]
            pub const fn gpio250(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO250"]
            #[inline(always)]
            pub fn set_gpio250(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO260"]
            #[inline(always)]
            pub const fn gpio260(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO260"]
            #[inline(always)]
            pub fn set_gpio260(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for Result26 {
            #[inline(always)]
            fn default() -> Result26 {
                Result26(0)
            }
        }
        impl core::fmt::Debug for Result26 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result26")
                    .field("gpio250", &self.gpio250())
                    .field("gpio260", &self.gpio260())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result26 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Result26 {{ gpio250: {=bool:?}, gpio260: {=bool:?} }}",
                    self.gpio250(),
                    self.gpio260()
                )
            }
        }
        #[doc = "GIRQ8 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result8(pub u32);
        impl Result8 {
            #[doc = "GPIO 140"]
            #[inline(always)]
            pub const fn gpio140(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 140"]
            #[inline(always)]
            pub fn set_gpio140(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 143"]
            #[inline(always)]
            pub const fn gpio143(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 143"]
            #[inline(always)]
            pub fn set_gpio143(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 144"]
            #[inline(always)]
            pub const fn gpio144(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 144"]
            #[inline(always)]
            pub fn set_gpio144(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 145"]
            #[inline(always)]
            pub const fn gpio145(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 145"]
            #[inline(always)]
            pub fn set_gpio145(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 146"]
            #[inline(always)]
            pub const fn gpio146(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 146"]
            #[inline(always)]
            pub fn set_gpio146(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 147"]
            #[inline(always)]
            pub const fn gpio147(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 147"]
            #[inline(always)]
            pub fn set_gpio147(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 150"]
            #[inline(always)]
            pub const fn gpio150(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 150"]
            #[inline(always)]
            pub fn set_gpio150(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO 156"]
            #[inline(always)]
            pub const fn gpio156(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 156"]
            #[inline(always)]
            pub fn set_gpio156(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 157"]
            #[inline(always)]
            pub const fn gpio157(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 157"]
            #[inline(always)]
            pub fn set_gpio157(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "GPIO 163"]
            #[inline(always)]
            pub const fn gpio163(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 163"]
            #[inline(always)]
            pub fn set_gpio163(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 165"]
            #[inline(always)]
            pub const fn gpio165(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 165"]
            #[inline(always)]
            pub fn set_gpio165(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "GPIO 166"]
            #[inline(always)]
            pub const fn gpio166(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 166"]
            #[inline(always)]
            pub fn set_gpio166(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 170"]
            #[inline(always)]
            pub const fn gpio170(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 170"]
            #[inline(always)]
            pub fn set_gpio170(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 171"]
            #[inline(always)]
            pub const fn gpio171(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 171"]
            #[inline(always)]
            pub fn set_gpio171(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Result8 {
            #[inline(always)]
            fn default() -> Result8 {
                Result8(0)
            }
        }
        impl core::fmt::Debug for Result8 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result8")
                    .field("gpio140", &self.gpio140())
                    .field("gpio143", &self.gpio143())
                    .field("gpio144", &self.gpio144())
                    .field("gpio145", &self.gpio145())
                    .field("gpio146", &self.gpio146())
                    .field("gpio147", &self.gpio147())
                    .field("gpio150", &self.gpio150())
                    .field("gpio156", &self.gpio156())
                    .field("gpio157", &self.gpio157())
                    .field("gpio163", &self.gpio163())
                    .field("gpio165", &self.gpio165())
                    .field("gpio166", &self.gpio166())
                    .field("gpio170", &self.gpio170())
                    .field("gpio171", &self.gpio171())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result8 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result8 {{ gpio140: {=bool:?}, gpio143: {=bool:?}, gpio144: {=bool:?}, gpio145: {=bool:?}, gpio146: {=bool:?}, gpio147: {=bool:?}, gpio150: {=bool:?}, gpio156: {=bool:?}, gpio157: {=bool:?}, gpio163: {=bool:?}, gpio165: {=bool:?}, gpio166: {=bool:?}, gpio170: {=bool:?}, gpio171: {=bool:?} }}" , self . gpio140 () , self . gpio143 () , self . gpio144 () , self . gpio145 () , self . gpio146 () , self . gpio147 () , self . gpio150 () , self . gpio156 () , self . gpio157 () , self . gpio163 () , self . gpio165 () , self . gpio166 () , self . gpio170 () , self . gpio171 ())
            }
        }
        #[doc = "GIRQ9 RESULT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result9(pub u32);
        impl Result9 {
            #[doc = "GPIO 104"]
            #[inline(always)]
            pub const fn gpio104(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 104"]
            #[inline(always)]
            pub fn set_gpio104(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 105"]
            #[inline(always)]
            pub const fn gpio105(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 105"]
            #[inline(always)]
            pub fn set_gpio105(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 106"]
            #[inline(always)]
            pub const fn gpio106(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 106"]
            #[inline(always)]
            pub fn set_gpio106(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 107"]
            #[inline(always)]
            pub const fn gpio107(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 107"]
            #[inline(always)]
            pub fn set_gpio107(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 112"]
            #[inline(always)]
            pub const fn gpio112(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 112"]
            #[inline(always)]
            pub fn set_gpio112(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "GPIO 113"]
            #[inline(always)]
            pub const fn gpio113(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 113"]
            #[inline(always)]
            pub fn set_gpio113(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 120"]
            #[inline(always)]
            pub const fn gpio120(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 120"]
            #[inline(always)]
            pub fn set_gpio120(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPIO 121"]
            #[inline(always)]
            pub const fn gpio121(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 121"]
            #[inline(always)]
            pub fn set_gpio121(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "GPIO 122"]
            #[inline(always)]
            pub const fn gpio122(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 122"]
            #[inline(always)]
            pub fn set_gpio122(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "GPIO 123"]
            #[inline(always)]
            pub const fn gpio123(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 123"]
            #[inline(always)]
            pub fn set_gpio123(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 124"]
            #[inline(always)]
            pub const fn gpio124(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 124"]
            #[inline(always)]
            pub fn set_gpio124(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 125"]
            #[inline(always)]
            pub const fn gpio125(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 125"]
            #[inline(always)]
            pub fn set_gpio125(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "GPIO 126"]
            #[inline(always)]
            pub const fn gpio126(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 126"]
            #[inline(always)]
            pub fn set_gpio126(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 127"]
            #[inline(always)]
            pub const fn gpio127(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 127"]
            #[inline(always)]
            pub fn set_gpio127(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "GPIO 130"]
            #[inline(always)]
            pub const fn gpio130(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 130"]
            #[inline(always)]
            pub fn set_gpio130(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 131"]
            #[inline(always)]
            pub const fn gpio131(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 131"]
            #[inline(always)]
            pub fn set_gpio131(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "GPIO 132"]
            #[inline(always)]
            pub const fn gpio132(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 132"]
            #[inline(always)]
            pub fn set_gpio132(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
        }
        impl Default for Result9 {
            #[inline(always)]
            fn default() -> Result9 {
                Result9(0)
            }
        }
        impl core::fmt::Debug for Result9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result9")
                    .field("gpio104", &self.gpio104())
                    .field("gpio105", &self.gpio105())
                    .field("gpio106", &self.gpio106())
                    .field("gpio107", &self.gpio107())
                    .field("gpio112", &self.gpio112())
                    .field("gpio113", &self.gpio113())
                    .field("gpio120", &self.gpio120())
                    .field("gpio121", &self.gpio121())
                    .field("gpio122", &self.gpio122())
                    .field("gpio123", &self.gpio123())
                    .field("gpio124", &self.gpio124())
                    .field("gpio125", &self.gpio125())
                    .field("gpio126", &self.gpio126())
                    .field("gpio127", &self.gpio127())
                    .field("gpio130", &self.gpio130())
                    .field("gpio131", &self.gpio131())
                    .field("gpio132", &self.gpio132())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result9 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Result9 {{ gpio104: {=bool:?}, gpio105: {=bool:?}, gpio106: {=bool:?}, gpio107: {=bool:?}, gpio112: {=bool:?}, gpio113: {=bool:?}, gpio120: {=bool:?}, gpio121: {=bool:?}, gpio122: {=bool:?}, gpio123: {=bool:?}, gpio124: {=bool:?}, gpio125: {=bool:?}, gpio126: {=bool:?}, gpio127: {=bool:?}, gpio130: {=bool:?}, gpio131: {=bool:?}, gpio132: {=bool:?} }}" , self . gpio104 () , self . gpio105 () , self . gpio106 () , self . gpio107 () , self . gpio112 () , self . gpio113 () , self . gpio120 () , self . gpio121 () , self . gpio122 () , self . gpio123 () , self . gpio124 () , self . gpio125 () , self . gpio126 () , self . gpio127 () , self . gpio130 () , self . gpio131 () , self . gpio132 ())
            }
        }
        #[doc = "GIRQ10 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src10(pub u32);
        impl Src10 {
            #[doc = "GPIO 045"]
            #[inline(always)]
            pub const fn gpio045(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 045"]
            #[inline(always)]
            pub fn set_gpio045(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 046"]
            #[inline(always)]
            pub const fn gpio046(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 046"]
            #[inline(always)]
            pub fn set_gpio046(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 047"]
            #[inline(always)]
            pub const fn gpio047(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 047"]
            #[inline(always)]
            pub fn set_gpio047(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 050"]
            #[inline(always)]
            pub const fn gpio050(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 050"]
            #[inline(always)]
            pub fn set_gpio050(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO 053"]
            #[inline(always)]
            pub const fn gpio053(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 053"]
            #[inline(always)]
            pub fn set_gpio053(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 055"]
            #[inline(always)]
            pub const fn gpio055(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 055"]
            #[inline(always)]
            pub fn set_gpio055(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "GPIO 056"]
            #[inline(always)]
            pub const fn gpio056(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 056"]
            #[inline(always)]
            pub fn set_gpio056(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 057"]
            #[inline(always)]
            pub const fn gpio057(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 057"]
            #[inline(always)]
            pub fn set_gpio057(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "GPIO 060"]
            #[inline(always)]
            pub const fn gpio063(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 060"]
            #[inline(always)]
            pub fn set_gpio063(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 070"]
            #[inline(always)]
            pub const fn gpio070(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 070"]
            #[inline(always)]
            pub fn set_gpio070(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 071"]
            #[inline(always)]
            pub const fn gpio071(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 071"]
            #[inline(always)]
            pub fn set_gpio071(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Src10 {
            #[inline(always)]
            fn default() -> Src10 {
                Src10(0)
            }
        }
        impl core::fmt::Debug for Src10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src10")
                    .field("gpio045", &self.gpio045())
                    .field("gpio046", &self.gpio046())
                    .field("gpio047", &self.gpio047())
                    .field("gpio050", &self.gpio050())
                    .field("gpio053", &self.gpio053())
                    .field("gpio055", &self.gpio055())
                    .field("gpio056", &self.gpio056())
                    .field("gpio057", &self.gpio057())
                    .field("gpio063", &self.gpio063())
                    .field("gpio070", &self.gpio070())
                    .field("gpio071", &self.gpio071())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src10 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src10 {{ gpio045: {=bool:?}, gpio046: {=bool:?}, gpio047: {=bool:?}, gpio050: {=bool:?}, gpio053: {=bool:?}, gpio055: {=bool:?}, gpio056: {=bool:?}, gpio057: {=bool:?}, gpio063: {=bool:?}, gpio070: {=bool:?}, gpio071: {=bool:?} }}" , self . gpio045 () , self . gpio046 () , self . gpio047 () , self . gpio050 () , self . gpio053 () , self . gpio055 () , self . gpio056 () , self . gpio057 () , self . gpio063 () , self . gpio070 () , self . gpio071 ())
            }
        }
        #[doc = "GIRQ11 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src11(pub u32);
        impl Src11 {
            #[doc = "GPIO 000"]
            #[inline(always)]
            pub const fn gpio000(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 000"]
            #[inline(always)]
            pub fn set_gpio000(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 002"]
            #[inline(always)]
            pub const fn gpio002(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 002"]
            #[inline(always)]
            pub fn set_gpio002(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GPIO 003"]
            #[inline(always)]
            pub const fn gpio003(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 003"]
            #[inline(always)]
            pub fn set_gpio003(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 004"]
            #[inline(always)]
            pub const fn gpio004(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 004"]
            #[inline(always)]
            pub fn set_gpio004(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 012"]
            #[inline(always)]
            pub const fn gpio012(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 012"]
            #[inline(always)]
            pub fn set_gpio012(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "GPIO 013"]
            #[inline(always)]
            pub const fn gpio013(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 013"]
            #[inline(always)]
            pub fn set_gpio013(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 015"]
            #[inline(always)]
            pub const fn gpio015(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 015"]
            #[inline(always)]
            pub fn set_gpio015(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "GPIO 016"]
            #[inline(always)]
            pub const fn gpio016(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 016"]
            #[inline(always)]
            pub fn set_gpio016(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 020"]
            #[inline(always)]
            pub const fn gpio020(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 020"]
            #[inline(always)]
            pub fn set_gpio020(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPIO 021"]
            #[inline(always)]
            pub const fn gpio021(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 021"]
            #[inline(always)]
            pub fn set_gpio021(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "GPIO 022"]
            #[inline(always)]
            pub const fn gpio022(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 022"]
            #[inline(always)]
            pub fn set_gpio022(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "GPIO 023"]
            #[inline(always)]
            pub const fn gpio023(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 023"]
            #[inline(always)]
            pub fn set_gpio023(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 024"]
            #[inline(always)]
            pub const fn gpio024(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 024"]
            #[inline(always)]
            pub fn set_gpio024(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 026"]
            #[inline(always)]
            pub const fn gpio026(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 026"]
            #[inline(always)]
            pub fn set_gpio026(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 027"]
            #[inline(always)]
            pub const fn gpio027(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 027"]
            #[inline(always)]
            pub fn set_gpio027(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "GPIO 030"]
            #[inline(always)]
            pub const fn gpio030(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 030"]
            #[inline(always)]
            pub fn set_gpio030(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 031"]
            #[inline(always)]
            pub const fn gpio031(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 031"]
            #[inline(always)]
            pub fn set_gpio031(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "GPIO 032"]
            #[inline(always)]
            pub const fn gpio032(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 032"]
            #[inline(always)]
            pub fn set_gpio032(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "GPIO 033"]
            #[inline(always)]
            pub const fn gpio033(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 033"]
            #[inline(always)]
            pub fn set_gpio033(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "GPIO 034"]
            #[inline(always)]
            pub const fn gpio034(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 034"]
            #[inline(always)]
            pub fn set_gpio034(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Src11 {
            #[inline(always)]
            fn default() -> Src11 {
                Src11(0)
            }
        }
        impl core::fmt::Debug for Src11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src11")
                    .field("gpio000", &self.gpio000())
                    .field("gpio002", &self.gpio002())
                    .field("gpio003", &self.gpio003())
                    .field("gpio004", &self.gpio004())
                    .field("gpio012", &self.gpio012())
                    .field("gpio013", &self.gpio013())
                    .field("gpio015", &self.gpio015())
                    .field("gpio016", &self.gpio016())
                    .field("gpio020", &self.gpio020())
                    .field("gpio021", &self.gpio021())
                    .field("gpio022", &self.gpio022())
                    .field("gpio023", &self.gpio023())
                    .field("gpio024", &self.gpio024())
                    .field("gpio026", &self.gpio026())
                    .field("gpio027", &self.gpio027())
                    .field("gpio030", &self.gpio030())
                    .field("gpio031", &self.gpio031())
                    .field("gpio032", &self.gpio032())
                    .field("gpio033", &self.gpio033())
                    .field("gpio034", &self.gpio034())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src11 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src11 {{ gpio000: {=bool:?}, gpio002: {=bool:?}, gpio003: {=bool:?}, gpio004: {=bool:?}, gpio012: {=bool:?}, gpio013: {=bool:?}, gpio015: {=bool:?}, gpio016: {=bool:?}, gpio020: {=bool:?}, gpio021: {=bool:?}, gpio022: {=bool:?}, gpio023: {=bool:?}, gpio024: {=bool:?}, gpio026: {=bool:?}, gpio027: {=bool:?}, gpio030: {=bool:?}, gpio031: {=bool:?}, gpio032: {=bool:?}, gpio033: {=bool:?}, gpio034: {=bool:?} }}" , self . gpio000 () , self . gpio002 () , self . gpio003 () , self . gpio004 () , self . gpio012 () , self . gpio013 () , self . gpio015 () , self . gpio016 () , self . gpio020 () , self . gpio021 () , self . gpio022 () , self . gpio023 () , self . gpio024 () , self . gpio026 () , self . gpio027 () , self . gpio030 () , self . gpio031 () , self . gpio032 () , self . gpio033 () , self . gpio034 ())
            }
        }
        #[doc = "GIRQ12 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src12(pub u32);
        impl Src12 {
            #[doc = "GPIO 200"]
            #[inline(always)]
            pub const fn gpio200(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 200"]
            #[inline(always)]
            pub fn set_gpio200(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 201"]
            #[inline(always)]
            pub const fn gpio201(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 201"]
            #[inline(always)]
            pub fn set_gpio201(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "GPIO 202"]
            #[inline(always)]
            pub const fn gpio202(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 202"]
            #[inline(always)]
            pub fn set_gpio202(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GPIO 203"]
            #[inline(always)]
            pub const fn gpio203(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 203"]
            #[inline(always)]
            pub fn set_gpio203(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 204"]
            #[inline(always)]
            pub const fn gpio204(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 204"]
            #[inline(always)]
            pub fn set_gpio204(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 223"]
            #[inline(always)]
            pub const fn gpio223(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 223"]
            #[inline(always)]
            pub fn set_gpio223(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 224"]
            #[inline(always)]
            pub const fn gpio224(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 224"]
            #[inline(always)]
            pub fn set_gpio224(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 227"]
            #[inline(always)]
            pub const fn gpio227(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 227"]
            #[inline(always)]
            pub fn set_gpio227(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Src12 {
            #[inline(always)]
            fn default() -> Src12 {
                Src12(0)
            }
        }
        impl core::fmt::Debug for Src12 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src12")
                    .field("gpio200", &self.gpio200())
                    .field("gpio201", &self.gpio201())
                    .field("gpio202", &self.gpio202())
                    .field("gpio203", &self.gpio203())
                    .field("gpio204", &self.gpio204())
                    .field("gpio223", &self.gpio223())
                    .field("gpio224", &self.gpio224())
                    .field("gpio227", &self.gpio227())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src12 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src12 {{ gpio200: {=bool:?}, gpio201: {=bool:?}, gpio202: {=bool:?}, gpio203: {=bool:?}, gpio204: {=bool:?}, gpio223: {=bool:?}, gpio224: {=bool:?}, gpio227: {=bool:?} }}" , self . gpio200 () , self . gpio201 () , self . gpio202 () , self . gpio203 () , self . gpio204 () , self . gpio223 () , self . gpio224 () , self . gpio227 ())
            }
        }
        #[doc = "GIRQ13 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src13(pub u32);
        impl Src13 {
            #[doc = "I2CSMB0"]
            #[inline(always)]
            pub const fn i2csmb0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB0"]
            #[inline(always)]
            pub fn set_i2csmb0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "I2CSMB1"]
            #[inline(always)]
            pub const fn i2csmb1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB1"]
            #[inline(always)]
            pub fn set_i2csmb1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "I2CSMB2"]
            #[inline(always)]
            pub const fn i2csmb2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB2"]
            #[inline(always)]
            pub fn set_i2csmb2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "I2CSMB3"]
            #[inline(always)]
            pub const fn i2csmb3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB3"]
            #[inline(always)]
            pub fn set_i2csmb3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "I2CSMB4"]
            #[inline(always)]
            pub const fn i2csmb4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "I2CSMB4"]
            #[inline(always)]
            pub fn set_i2csmb4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Src13 {
            #[inline(always)]
            fn default() -> Src13 {
                Src13(0)
            }
        }
        impl core::fmt::Debug for Src13 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src13")
                    .field("i2csmb0", &self.i2csmb0())
                    .field("i2csmb1", &self.i2csmb1())
                    .field("i2csmb2", &self.i2csmb2())
                    .field("i2csmb3", &self.i2csmb3())
                    .field("i2csmb4", &self.i2csmb4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src13 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src13 {{ i2csmb0: {=bool:?}, i2csmb1: {=bool:?}, i2csmb2: {=bool:?}, i2csmb3: {=bool:?}, i2csmb4: {=bool:?} }}" , self . i2csmb0 () , self . i2csmb1 () , self . i2csmb2 () , self . i2csmb3 () , self . i2csmb4 ())
            }
        }
        #[doc = "GIRQ14 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src14(pub u32);
        impl Src14 {
            #[doc = "DMA CH00"]
            #[inline(always)]
            pub const fn dma_ch00(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH00"]
            #[inline(always)]
            pub fn set_dma_ch00(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "DMA CH01"]
            #[inline(always)]
            pub const fn dma_ch01(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH01"]
            #[inline(always)]
            pub fn set_dma_ch01(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "DMA CH02"]
            #[inline(always)]
            pub const fn dma_ch02(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH02"]
            #[inline(always)]
            pub fn set_dma_ch02(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "DMA CH03"]
            #[inline(always)]
            pub const fn dma_ch03(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH03"]
            #[inline(always)]
            pub fn set_dma_ch03(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "DMA CH04"]
            #[inline(always)]
            pub const fn dma_ch04(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH04"]
            #[inline(always)]
            pub fn set_dma_ch04(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "DMA CH05"]
            #[inline(always)]
            pub const fn dma_ch05(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH05"]
            #[inline(always)]
            pub fn set_dma_ch05(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "DMA CH06"]
            #[inline(always)]
            pub const fn dma_ch06(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH06"]
            #[inline(always)]
            pub fn set_dma_ch06(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "DMA CH07"]
            #[inline(always)]
            pub const fn dma_ch07(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH07"]
            #[inline(always)]
            pub fn set_dma_ch07(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "DMA CH08"]
            #[inline(always)]
            pub const fn dma_ch08(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH08"]
            #[inline(always)]
            pub fn set_dma_ch08(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "DMA CH09"]
            #[inline(always)]
            pub const fn dma_ch09(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "DMA CH09"]
            #[inline(always)]
            pub fn set_dma_ch09(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Src14 {
            #[inline(always)]
            fn default() -> Src14 {
                Src14(0)
            }
        }
        impl core::fmt::Debug for Src14 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src14")
                    .field("dma_ch00", &self.dma_ch00())
                    .field("dma_ch01", &self.dma_ch01())
                    .field("dma_ch02", &self.dma_ch02())
                    .field("dma_ch03", &self.dma_ch03())
                    .field("dma_ch04", &self.dma_ch04())
                    .field("dma_ch05", &self.dma_ch05())
                    .field("dma_ch06", &self.dma_ch06())
                    .field("dma_ch07", &self.dma_ch07())
                    .field("dma_ch08", &self.dma_ch08())
                    .field("dma_ch09", &self.dma_ch09())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src14 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src14 {{ dma_ch00: {=bool:?}, dma_ch01: {=bool:?}, dma_ch02: {=bool:?}, dma_ch03: {=bool:?}, dma_ch04: {=bool:?}, dma_ch05: {=bool:?}, dma_ch06: {=bool:?}, dma_ch07: {=bool:?}, dma_ch08: {=bool:?}, dma_ch09: {=bool:?} }}" , self . dma_ch00 () , self . dma_ch01 () , self . dma_ch02 () , self . dma_ch03 () , self . dma_ch04 () , self . dma_ch05 () , self . dma_ch06 () , self . dma_ch07 () , self . dma_ch08 () , self . dma_ch09 ())
            }
        }
        #[doc = "GIRQ15 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src15(pub u32);
        impl Src15 {
            #[doc = "UART0"]
            #[inline(always)]
            pub const fn uart0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "UART0"]
            #[inline(always)]
            pub fn set_uart0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Src15 {
            #[inline(always)]
            fn default() -> Src15 {
                Src15(0)
            }
        }
        impl core::fmt::Debug for Src15 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src15").field("uart0", &self.uart0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src15 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Src15 {{ uart0: {=bool:?} }}", self.uart0())
            }
        }
        #[doc = "GIRQ16 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src16(pub u32);
        impl Src16 {
            #[doc = "PKE ERR"]
            #[inline(always)]
            pub const fn pke_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PKE ERR"]
            #[inline(always)]
            pub fn set_pke_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PKE END"]
            #[inline(always)]
            pub const fn pke_end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PKE END"]
            #[inline(always)]
            pub fn set_pke_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "RNG"]
            #[inline(always)]
            pub const fn rng(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RNG"]
            #[inline(always)]
            pub fn set_rng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "AES"]
            #[inline(always)]
            pub const fn aes(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "AES"]
            #[inline(always)]
            pub fn set_aes(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "HASH"]
            #[inline(always)]
            pub const fn hash(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "HASH"]
            #[inline(always)]
            pub fn set_hash(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Src16 {
            #[inline(always)]
            fn default() -> Src16 {
                Src16(0)
            }
        }
        impl core::fmt::Debug for Src16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src16")
                    .field("pke_err", &self.pke_err())
                    .field("pke_end", &self.pke_end())
                    .field("rng", &self.rng())
                    .field("aes", &self.aes())
                    .field("hash", &self.hash())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src16 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src16 {{ pke_err: {=bool:?}, pke_end: {=bool:?}, rng: {=bool:?}, aes: {=bool:?}, hash: {=bool:?} }}" , self . pke_err () , self . pke_end () , self . rng () , self . aes () , self . hash ())
            }
        }
        #[doc = "GIRQ17 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src17(pub u32);
        impl Src17 {
            #[doc = "Breating LED0"]
            #[inline(always)]
            pub const fn led0(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Breating LED0"]
            #[inline(always)]
            pub fn set_led0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Breating LED1"]
            #[inline(always)]
            pub const fn led1(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Breating LED1"]
            #[inline(always)]
            pub fn set_led1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Src17 {
            #[inline(always)]
            fn default() -> Src17 {
                Src17(0)
            }
        }
        impl core::fmt::Debug for Src17 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src17")
                    .field("led0", &self.led0())
                    .field("led1", &self.led1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src17 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Src17 {{ led0: {=bool:?}, led1: {=bool:?} }}",
                    self.led0(),
                    self.led1()
                )
            }
        }
        #[doc = "GIRQ18 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src18(pub u32);
        impl Src18 {
            #[doc = "SPT0"]
            #[inline(always)]
            pub const fn spt0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SPT0"]
            #[inline(always)]
            pub fn set_spt0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "QMSPI0"]
            #[inline(always)]
            pub const fn qmspi0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI0"]
            #[inline(always)]
            pub fn set_qmspi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "QMSPI1"]
            #[inline(always)]
            pub const fn qmspi1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI1"]
            #[inline(always)]
            pub fn set_qmspi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SPT1"]
            #[inline(always)]
            pub const fn spt1(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "SPT1"]
            #[inline(always)]
            pub fn set_spt1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "CCT"]
            #[inline(always)]
            pub const fn cct(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "CCT"]
            #[inline(always)]
            pub fn set_cct(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "CCT_CAP0"]
            #[inline(always)]
            pub const fn cct_cap0(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP0"]
            #[inline(always)]
            pub fn set_cct_cap0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "CCT_CAP1"]
            #[inline(always)]
            pub const fn cct_cap1(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP1"]
            #[inline(always)]
            pub fn set_cct_cap1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "CCT_CAP2"]
            #[inline(always)]
            pub const fn cct_cap2(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP2"]
            #[inline(always)]
            pub fn set_cct_cap2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "CCT_CAP3"]
            #[inline(always)]
            pub const fn cct_cap3(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP3"]
            #[inline(always)]
            pub fn set_cct_cap3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "CCT_CAP4"]
            #[inline(always)]
            pub const fn cct_cap4(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP4"]
            #[inline(always)]
            pub fn set_cct_cap4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "CCT_CAP5"]
            #[inline(always)]
            pub const fn cct_cap5(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CAP5"]
            #[inline(always)]
            pub fn set_cct_cap5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "CCT_CMP0"]
            #[inline(always)]
            pub const fn cct_cmp0(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CMP0"]
            #[inline(always)]
            pub fn set_cct_cmp0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "CCT_CMP1"]
            #[inline(always)]
            pub const fn cct_cmp1(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "CCT_CMP1"]
            #[inline(always)]
            pub fn set_cct_cmp1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Src18 {
            #[inline(always)]
            fn default() -> Src18 {
                Src18(0)
            }
        }
        impl core::fmt::Debug for Src18 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src18")
                    .field("spt0", &self.spt0())
                    .field("qmspi0", &self.qmspi0())
                    .field("qmspi1", &self.qmspi1())
                    .field("spt1", &self.spt1())
                    .field("cct", &self.cct())
                    .field("cct_cap0", &self.cct_cap0())
                    .field("cct_cap1", &self.cct_cap1())
                    .field("cct_cap2", &self.cct_cap2())
                    .field("cct_cap3", &self.cct_cap3())
                    .field("cct_cap4", &self.cct_cap4())
                    .field("cct_cap5", &self.cct_cap5())
                    .field("cct_cmp0", &self.cct_cmp0())
                    .field("cct_cmp1", &self.cct_cmp1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src18 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src18 {{ spt0: {=bool:?}, qmspi0: {=bool:?}, qmspi1: {=bool:?}, spt1: {=bool:?}, cct: {=bool:?}, cct_cap0: {=bool:?}, cct_cap1: {=bool:?}, cct_cap2: {=bool:?}, cct_cap3: {=bool:?}, cct_cap4: {=bool:?}, cct_cap5: {=bool:?}, cct_cmp0: {=bool:?}, cct_cmp1: {=bool:?} }}" , self . spt0 () , self . qmspi0 () , self . qmspi1 () , self . spt1 () , self . cct () , self . cct_cap0 () , self . cct_cap1 () , self . cct_cap2 () , self . cct_cap3 () , self . cct_cap4 () , self . cct_cap5 () , self . cct_cmp0 () , self . cct_cmp1 ())
            }
        }
        #[doc = "GIRQ20 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src20(pub u32);
        impl Src20 {
            #[doc = "IMSPI"]
            #[inline(always)]
            pub const fn imspi(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "IMSPI"]
            #[inline(always)]
            pub fn set_imspi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "CLK_MON"]
            #[inline(always)]
            pub const fn clk_mon(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "CLK_MON"]
            #[inline(always)]
            pub fn set_clk_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "VTR1_PAD_MON"]
            #[inline(always)]
            pub const fn vtr1_pad_mon(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "VTR1_PAD_MON"]
            #[inline(always)]
            pub fn set_vtr1_pad_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "VTR2_PAD_MON"]
            #[inline(always)]
            pub const fn vtr2_pad_mon(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "VTR2_PAD_MON"]
            #[inline(always)]
            pub fn set_vtr2_pad_mon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for Src20 {
            #[inline(always)]
            fn default() -> Src20 {
                Src20(0)
            }
        }
        impl core::fmt::Debug for Src20 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src20")
                    .field("imspi", &self.imspi())
                    .field("clk_mon", &self.clk_mon())
                    .field("vtr1_pad_mon", &self.vtr1_pad_mon())
                    .field("vtr2_pad_mon", &self.vtr2_pad_mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src20 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src20 {{ imspi: {=bool:?}, clk_mon: {=bool:?}, vtr1_pad_mon: {=bool:?}, vtr2_pad_mon: {=bool:?} }}" , self . imspi () , self . clk_mon () , self . vtr1_pad_mon () , self . vtr2_pad_mon ())
            }
        }
        #[doc = "GIRQ21 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src21(pub u32);
        impl Src21 {
            #[doc = "WDT"]
            #[inline(always)]
            pub const fn wdt(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "WDT"]
            #[inline(always)]
            pub fn set_wdt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "EMC"]
            #[inline(always)]
            pub const fn emc(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "EMC"]
            #[inline(always)]
            pub fn set_emc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Src21 {
            #[inline(always)]
            fn default() -> Src21 {
                Src21(0)
            }
        }
        impl core::fmt::Debug for Src21 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src21")
                    .field("wdt", &self.wdt())
                    .field("emc", &self.emc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src21 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Src21 {{ wdt: {=bool:?}, emc: {=bool:?} }}", self.wdt(), self.emc())
            }
        }
        #[doc = "GIRQ23 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src23(pub u32);
        impl Src23 {
            #[doc = "TIMER32_0"]
            #[inline(always)]
            pub const fn timer32_0(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0"]
            #[inline(always)]
            pub fn set_timer32_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "TIMER32_1"]
            #[inline(always)]
            pub const fn timer32_1(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1"]
            #[inline(always)]
            pub fn set_timer32_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "RTMR"]
            #[inline(always)]
            pub const fn rtmr(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "RTMR"]
            #[inline(always)]
            pub fn set_rtmr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "SWI0"]
            #[inline(always)]
            pub const fn swi0(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "SWI0"]
            #[inline(always)]
            pub fn set_swi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "SWI1"]
            #[inline(always)]
            pub const fn swi1(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "SWI1"]
            #[inline(always)]
            pub fn set_swi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "SWI2"]
            #[inline(always)]
            pub const fn swi2(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SWI2"]
            #[inline(always)]
            pub fn set_swi2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SWI3"]
            #[inline(always)]
            pub const fn swi3(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SWI3"]
            #[inline(always)]
            pub fn set_swi3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "HTMR0"]
            #[inline(always)]
            pub const fn htmr0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "HTMR0"]
            #[inline(always)]
            pub fn set_htmr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "HTMR1"]
            #[inline(always)]
            pub const fn htmr1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "HTMR1"]
            #[inline(always)]
            pub fn set_htmr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Src23 {
            #[inline(always)]
            fn default() -> Src23 {
                Src23(0)
            }
        }
        impl core::fmt::Debug for Src23 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src23")
                    .field("timer32_0", &self.timer32_0())
                    .field("timer32_1", &self.timer32_1())
                    .field("rtmr", &self.rtmr())
                    .field("swi0", &self.swi0())
                    .field("swi1", &self.swi1())
                    .field("swi2", &self.swi2())
                    .field("swi3", &self.swi3())
                    .field("htmr0", &self.htmr0())
                    .field("htmr1", &self.htmr1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src23 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src23 {{ timer32_0: {=bool:?}, timer32_1: {=bool:?}, rtmr: {=bool:?}, swi0: {=bool:?}, swi1: {=bool:?}, swi2: {=bool:?}, swi3: {=bool:?}, htmr0: {=bool:?}, htmr1: {=bool:?} }}" , self . timer32_0 () , self . timer32_1 () , self . rtmr () , self . swi0 () , self . swi1 () , self . swi2 () , self . swi3 () , self . htmr0 () , self . htmr1 ())
            }
        }
        #[doc = "GIRQ24 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src24(pub u32);
        impl Src24 {
            #[doc = "SPIMON0_VLTN"]
            #[inline(always)]
            pub const fn spimon0_vltn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_VLTN"]
            #[inline(always)]
            pub fn set_spimon0_vltn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SPIMON0_MTMON"]
            #[inline(always)]
            pub const fn spimon0_mtmon(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_MTMON"]
            #[inline(always)]
            pub fn set_spimon0_mtmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "SPIMON0_LTMON"]
            #[inline(always)]
            pub const fn spimon0_ltmon(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON0_LTMON"]
            #[inline(always)]
            pub fn set_spimon0_ltmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SPIMON1_VLTN"]
            #[inline(always)]
            pub const fn spimon1_vltn(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_VLTN"]
            #[inline(always)]
            pub fn set_spimon1_vltn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "SPIMON1_MTMON"]
            #[inline(always)]
            pub const fn spimon1_mtmon(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_MTMON"]
            #[inline(always)]
            pub fn set_spimon1_mtmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "SPIMON1_LTMON"]
            #[inline(always)]
            pub const fn spimon1_ltmon(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "SPIMON1_LTMON"]
            #[inline(always)]
            pub fn set_spimon1_ltmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Src24 {
            #[inline(always)]
            fn default() -> Src24 {
                Src24(0)
            }
        }
        impl core::fmt::Debug for Src24 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src24")
                    .field("spimon0_vltn", &self.spimon0_vltn())
                    .field("spimon0_mtmon", &self.spimon0_mtmon())
                    .field("spimon0_ltmon", &self.spimon0_ltmon())
                    .field("spimon1_vltn", &self.spimon1_vltn())
                    .field("spimon1_mtmon", &self.spimon1_mtmon())
                    .field("spimon1_ltmon", &self.spimon1_ltmon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src24 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src24 {{ spimon0_vltn: {=bool:?}, spimon0_mtmon: {=bool:?}, spimon0_ltmon: {=bool:?}, spimon1_vltn: {=bool:?}, spimon1_mtmon: {=bool:?}, spimon1_ltmon: {=bool:?} }}" , self . spimon0_vltn () , self . spimon0_mtmon () , self . spimon0_ltmon () , self . spimon1_vltn () , self . spimon1_mtmon () , self . spimon1_ltmon ())
            }
        }
        #[doc = "GIRQ26 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src26(pub u32);
        impl Src26 {
            #[doc = "GPIO250"]
            #[inline(always)]
            pub const fn gpio250(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO250"]
            #[inline(always)]
            pub fn set_gpio250(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO253"]
            #[inline(always)]
            pub const fn gpio253(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO253"]
            #[inline(always)]
            pub fn set_gpio253(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for Src26 {
            #[inline(always)]
            fn default() -> Src26 {
                Src26(0)
            }
        }
        impl core::fmt::Debug for Src26 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src26")
                    .field("gpio250", &self.gpio250())
                    .field("gpio253", &self.gpio253())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src26 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Src26 {{ gpio250: {=bool:?}, gpio253: {=bool:?} }}",
                    self.gpio250(),
                    self.gpio253()
                )
            }
        }
        #[doc = "GIRQ8 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src8(pub u32);
        impl Src8 {
            #[doc = "GPIO 140"]
            #[inline(always)]
            pub const fn gpio140(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 140"]
            #[inline(always)]
            pub fn set_gpio140(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "GPIO 143"]
            #[inline(always)]
            pub const fn gpio143(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 143"]
            #[inline(always)]
            pub fn set_gpio143(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GPIO 144"]
            #[inline(always)]
            pub const fn gpio144(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 144"]
            #[inline(always)]
            pub fn set_gpio144(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 145"]
            #[inline(always)]
            pub const fn gpio145(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 145"]
            #[inline(always)]
            pub fn set_gpio145(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 146"]
            #[inline(always)]
            pub const fn gpio146(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 146"]
            #[inline(always)]
            pub fn set_gpio146(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 147"]
            #[inline(always)]
            pub const fn gpio147(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 147"]
            #[inline(always)]
            pub fn set_gpio147(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 150"]
            #[inline(always)]
            pub const fn gpio150(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 150"]
            #[inline(always)]
            pub fn set_gpio150(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "GPIO 156"]
            #[inline(always)]
            pub const fn gpio156(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 156"]
            #[inline(always)]
            pub fn set_gpio156(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "GPIO 157"]
            #[inline(always)]
            pub const fn gpio157(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 157"]
            #[inline(always)]
            pub fn set_gpio157(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "GPIO 163"]
            #[inline(always)]
            pub const fn gpio163(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 163"]
            #[inline(always)]
            pub fn set_gpio163(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 165"]
            #[inline(always)]
            pub const fn gpio165(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 165"]
            #[inline(always)]
            pub fn set_gpio165(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "GPIO 166"]
            #[inline(always)]
            pub const fn gpio166(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 166"]
            #[inline(always)]
            pub fn set_gpio166(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 170"]
            #[inline(always)]
            pub const fn gpio170(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 170"]
            #[inline(always)]
            pub fn set_gpio170(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 171"]
            #[inline(always)]
            pub const fn gpio171(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 171"]
            #[inline(always)]
            pub fn set_gpio171(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Src8 {
            #[inline(always)]
            fn default() -> Src8 {
                Src8(0)
            }
        }
        impl core::fmt::Debug for Src8 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src8")
                    .field("gpio140", &self.gpio140())
                    .field("gpio143", &self.gpio143())
                    .field("gpio144", &self.gpio144())
                    .field("gpio145", &self.gpio145())
                    .field("gpio146", &self.gpio146())
                    .field("gpio147", &self.gpio147())
                    .field("gpio150", &self.gpio150())
                    .field("gpio156", &self.gpio156())
                    .field("gpio157", &self.gpio157())
                    .field("gpio163", &self.gpio163())
                    .field("gpio165", &self.gpio165())
                    .field("gpio166", &self.gpio166())
                    .field("gpio170", &self.gpio170())
                    .field("gpio171", &self.gpio171())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src8 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src8 {{ gpio140: {=bool:?}, gpio143: {=bool:?}, gpio144: {=bool:?}, gpio145: {=bool:?}, gpio146: {=bool:?}, gpio147: {=bool:?}, gpio150: {=bool:?}, gpio156: {=bool:?}, gpio157: {=bool:?}, gpio163: {=bool:?}, gpio165: {=bool:?}, gpio166: {=bool:?}, gpio170: {=bool:?}, gpio171: {=bool:?} }}" , self . gpio140 () , self . gpio143 () , self . gpio144 () , self . gpio145 () , self . gpio146 () , self . gpio147 () , self . gpio150 () , self . gpio156 () , self . gpio157 () , self . gpio163 () , self . gpio165 () , self . gpio166 () , self . gpio170 () , self . gpio171 ())
            }
        }
        #[doc = "GIRQ9 SOURCE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src9(pub u32);
        impl Src9 {
            #[doc = "GPIO 104"]
            #[inline(always)]
            pub const fn gpio104(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 104"]
            #[inline(always)]
            pub fn set_gpio104(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "GPIO 105"]
            #[inline(always)]
            pub const fn gpio105(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 105"]
            #[inline(always)]
            pub fn set_gpio105(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO 106"]
            #[inline(always)]
            pub const fn gpio106(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 106"]
            #[inline(always)]
            pub fn set_gpio106(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "GPIO 107"]
            #[inline(always)]
            pub const fn gpio107(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 107"]
            #[inline(always)]
            pub fn set_gpio107(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "GPIO 112"]
            #[inline(always)]
            pub const fn gpio112(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 112"]
            #[inline(always)]
            pub fn set_gpio112(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "GPIO 113"]
            #[inline(always)]
            pub const fn gpio113(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 113"]
            #[inline(always)]
            pub fn set_gpio113(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "GPIO 120"]
            #[inline(always)]
            pub const fn gpio120(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 120"]
            #[inline(always)]
            pub fn set_gpio120(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPIO 121"]
            #[inline(always)]
            pub const fn gpio121(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 121"]
            #[inline(always)]
            pub fn set_gpio121(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "GPIO 122"]
            #[inline(always)]
            pub const fn gpio122(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 122"]
            #[inline(always)]
            pub fn set_gpio122(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "GPIO 123"]
            #[inline(always)]
            pub const fn gpio123(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 123"]
            #[inline(always)]
            pub fn set_gpio123(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "GPIO 124"]
            #[inline(always)]
            pub const fn gpio124(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 124"]
            #[inline(always)]
            pub fn set_gpio124(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "GPIO 125"]
            #[inline(always)]
            pub const fn gpio125(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 125"]
            #[inline(always)]
            pub fn set_gpio125(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "GPIO 126"]
            #[inline(always)]
            pub const fn gpio126(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 126"]
            #[inline(always)]
            pub fn set_gpio126(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "GPIO 127"]
            #[inline(always)]
            pub const fn gpio127(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 127"]
            #[inline(always)]
            pub fn set_gpio127(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "GPIO 130"]
            #[inline(always)]
            pub const fn gpio130(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 130"]
            #[inline(always)]
            pub fn set_gpio130(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "GPIO 131"]
            #[inline(always)]
            pub const fn gpio131(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 131"]
            #[inline(always)]
            pub fn set_gpio131(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "GPIO 132"]
            #[inline(always)]
            pub const fn gpio132(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO 132"]
            #[inline(always)]
            pub fn set_gpio132(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
        }
        impl Default for Src9 {
            #[inline(always)]
            fn default() -> Src9 {
                Src9(0)
            }
        }
        impl core::fmt::Debug for Src9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src9")
                    .field("gpio104", &self.gpio104())
                    .field("gpio105", &self.gpio105())
                    .field("gpio106", &self.gpio106())
                    .field("gpio107", &self.gpio107())
                    .field("gpio112", &self.gpio112())
                    .field("gpio113", &self.gpio113())
                    .field("gpio120", &self.gpio120())
                    .field("gpio121", &self.gpio121())
                    .field("gpio122", &self.gpio122())
                    .field("gpio123", &self.gpio123())
                    .field("gpio124", &self.gpio124())
                    .field("gpio125", &self.gpio125())
                    .field("gpio126", &self.gpio126())
                    .field("gpio127", &self.gpio127())
                    .field("gpio130", &self.gpio130())
                    .field("gpio131", &self.gpio131())
                    .field("gpio132", &self.gpio132())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src9 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Src9 {{ gpio104: {=bool:?}, gpio105: {=bool:?}, gpio106: {=bool:?}, gpio107: {=bool:?}, gpio112: {=bool:?}, gpio113: {=bool:?}, gpio120: {=bool:?}, gpio121: {=bool:?}, gpio122: {=bool:?}, gpio123: {=bool:?}, gpio124: {=bool:?}, gpio125: {=bool:?}, gpio126: {=bool:?}, gpio127: {=bool:?}, gpio130: {=bool:?}, gpio131: {=bool:?}, gpio132: {=bool:?} }}" , self . gpio104 () , self . gpio105 () , self . gpio106 () , self . gpio107 () , self . gpio112 () , self . gpio113 () , self . gpio120 () , self . gpio121 () , self . gpio122 () , self . gpio123 () , self . gpio124 () , self . gpio125 () , self . gpio126 () , self . gpio127 () , self . gpio130 () , self . gpio131 () , self . gpio132 ())
            }
        }
    }
}
pub mod env_mon {
    #[doc = "Environmental Monitor Block"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EnvMon {
        ptr: *mut u8,
    }
    unsafe impl Send for EnvMon {}
    unsafe impl Sync for EnvMon {}
    impl EnvMon {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "External Diode 1 Temp Register"]
        #[inline(always)]
        pub const fn ext1_temp(self) -> crate::common::Reg<regs::Ext1temp, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Internal Temp Register"]
        #[inline(always)]
        pub const fn int_temp(self) -> crate::common::Reg<regs::IntTemp, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "External Diode 2 Temp Register"]
        #[inline(always)]
        pub const fn ext2_temp(self) -> crate::common::Reg<regs::Ext2temp, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "External Diode 3 Temp Register"]
        #[inline(always)]
        pub const fn ext3_temp(self) -> crate::common::Reg<regs::Ext3temp, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "External Diode 4 Temp Register"]
        #[inline(always)]
        pub const fn ext4_temp(self) -> crate::common::Reg<regs::Ext4temp, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Stores the voltage Measured on VIN channel"]
        #[inline(always)]
        pub const fn vin_volt(self) -> crate::common::Reg<regs::VinVolt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Stores the fractional and integer data for External Diode 1A Register"]
        #[inline(always)]
        pub const fn ext1a_temp(self) -> crate::common::Reg<regs::Ext1aTemp, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "Stores the fractional and integer data for External Diode 2A Register"]
        #[inline(always)]
        pub const fn ext2a_temp(self) -> crate::common::Reg<regs::Ext2aTemp, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Stores the fractional and integer data for External Diode 3A Register"]
        #[inline(always)]
        pub const fn ext3a_temp(self) -> crate::common::Reg<regs::Ext3aTemp, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize) as _) }
        }
        #[doc = "Stores the fractional and integer data for External Diode 4A Register"]
        #[inline(always)]
        pub const fn ext4a_temp(self) -> crate::common::Reg<regs::Ext4aTemp, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Stores the VCP Voltage Monitor data"]
        #[inline(always)]
        pub const fn vcp_volt(self) -> crate::common::Reg<regs::VcpVolt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x21usize) as _) }
        }
        #[doc = "Stores the VTT Voltage Monitor data"]
        #[inline(always)]
        pub const fn vtt_volt(self) -> crate::common::Reg<regs::VttVolt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x23usize) as _) }
        }
        #[doc = "Controls temp sensing for external diodes"]
        #[inline(always)]
        pub const fn temp_cfg1(self) -> crate::common::Reg<regs::TempCfg1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2busize) as _) }
        }
        #[doc = "Controls temp sensing for external diodes"]
        #[inline(always)]
        pub const fn temp_cfg2(self) -> crate::common::Reg<regs::TempCfg2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Controls Voltage sensing for external voltages"]
        #[inline(always)]
        pub const fn volt_cfg(self) -> crate::common::Reg<regs::VoltCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2dusize) as _) }
        }
        #[doc = "Controls Thermistor or diodes Configuration"]
        #[inline(always)]
        pub const fn them_cfg(self) -> crate::common::Reg<regs::ThemCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2eusize) as _) }
        }
        #[doc = "Controls Temperature Conversion for the temperature channels"]
        #[inline(always)]
        pub const fn cnvr_cfg(self) -> crate::common::Reg<regs::CnvrCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2fusize) as _) }
        }
        #[doc = "Software Averaging Enable"]
        #[inline(always)]
        pub const fn avg_en(self) -> crate::common::Reg<regs::AvgEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Configure Beta compensation settings for External Diode1"]
        #[inline(always)]
        pub const fn bcomp1_en(self) -> crate::common::Reg<regs::Bcomp1en, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Configure Beta compensation settings for External Diode2"]
        #[inline(always)]
        pub const fn bcomp2_en(self) -> crate::common::Reg<regs::Bcomp2en, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x39usize) as _) }
        }
        #[doc = "Lock Start Register"]
        #[inline(always)]
        pub const fn lck_strt(self) -> crate::common::Reg<regs::LckStrt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Fault Interrupt Status Register"]
        #[inline(always)]
        pub const fn flt_intsts(self) -> crate::common::Reg<regs::FltIntsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x41usize) as _) }
        }
        #[doc = "Fault temperature Status Register"]
        #[inline(always)]
        pub const fn flt_tempsts(self) -> crate::common::Reg<regs::FltTempsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x42usize) as _) }
        }
        #[doc = "ThermTrip Pin Status Register"]
        #[inline(always)]
        pub const fn thrmtrp_sts(self) -> crate::common::Reg<regs::ThrmtrpSts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x43usize) as _) }
        }
        #[doc = "Temperature of Internal Diode Register"]
        #[inline(always)]
        pub const fn int_temp_sts(self) -> crate::common::Reg<regs::IntTempSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "Volt Interrupt Status Register"]
        #[inline(always)]
        pub const fn vlt_intsts(self) -> crate::common::Reg<regs::VltIntsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x45usize) as _) }
        }
        #[doc = "VCP Limit Register"]
        #[inline(always)]
        pub const fn vcp_limit(self) -> crate::common::Reg<regs::VcpLimit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x46usize) as _) }
        }
        #[doc = "VTR Limit Register"]
        #[inline(always)]
        pub const fn vtr_limit(self) -> crate::common::Reg<regs::VtrLimit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "VTT Limit Register"]
        #[inline(always)]
        pub const fn vtt_limit(self) -> crate::common::Reg<regs::VttLimit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4ausize) as _) }
        }
        #[doc = "VIN Limit Register"]
        #[inline(always)]
        pub const fn vin_limit(self) -> crate::common::Reg<regs::VinLimit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "Low limit for External Diode 1 Register"]
        #[inline(always)]
        pub const fn ext1_tmplo_lmt(self) -> crate::common::Reg<regs::Ext1tmploLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4eusize) as _) }
        }
        #[doc = "High limit for External Diode 1 Register"]
        #[inline(always)]
        pub const fn ext1_tmphi_lmt(self) -> crate::common::Reg<regs::Ext1tmphiLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4fusize) as _) }
        }
        #[doc = "Low limit for Internal Diode Register"]
        #[inline(always)]
        pub const fn int_tmplo_lmt(self) -> crate::common::Reg<regs::IntTmploLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "High limit for Internal Diode Register"]
        #[inline(always)]
        pub const fn int_tmphi_lmt(self) -> crate::common::Reg<regs::IntTmphiLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x51usize) as _) }
        }
        #[doc = "Low limit for External Diode 2 Register"]
        #[inline(always)]
        pub const fn ext2_tmplo_lmt(self) -> crate::common::Reg<regs::Ext2tmploLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x52usize) as _) }
        }
        #[doc = "High limit for External Diode 2 Register"]
        #[inline(always)]
        pub const fn ext2_tmphi_lmt(self) -> crate::common::Reg<regs::Ext2tmphiLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x53usize) as _) }
        }
        #[doc = "Low limit for External Diode 3 Register"]
        #[inline(always)]
        pub const fn ext3_tmplo_lmt(self) -> crate::common::Reg<regs::Ext3tmploLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "High limit for External Diode 3 Register"]
        #[inline(always)]
        pub const fn ext3_tmphi_lmt(self) -> crate::common::Reg<regs::Ext3tmphiLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x55usize) as _) }
        }
        #[doc = "Low limit for External Diode 4 Register"]
        #[inline(always)]
        pub const fn ext4_tmplo_lmt(self) -> crate::common::Reg<regs::Ext4tmploLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x56usize) as _) }
        }
        #[doc = "High limit for External Diode 4 Register"]
        #[inline(always)]
        pub const fn ext4_tmphi_lmt(self) -> crate::common::Reg<regs::Ext4tmphiLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x57usize) as _) }
        }
        #[doc = "Low limit for External Diode 1A Register"]
        #[inline(always)]
        pub const fn ext1a_tmplo_lmt(self) -> crate::common::Reg<regs::Ext1aTmploLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "High limit for External Diode 1A Register"]
        #[inline(always)]
        pub const fn ext1a_tmphi_lmt(self) -> crate::common::Reg<regs::Ext1aTmphiLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x59usize) as _) }
        }
        #[doc = "Low limit for External Diode 2A Register"]
        #[inline(always)]
        pub const fn ext2a_tmplo_lmt(self) -> crate::common::Reg<regs::Ext2aTmploLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5ausize) as _) }
        }
        #[doc = "High limit for External Diode 2A Register"]
        #[inline(always)]
        pub const fn ext2a_tmphi_lmt(self) -> crate::common::Reg<regs::Ext2aTmphiLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5busize) as _) }
        }
        #[doc = "Low limit for External Diode 3A Register"]
        #[inline(always)]
        pub const fn ext3a_tmplo_lmt(self) -> crate::common::Reg<regs::Ext3aTmploLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "High limit for External Diode 3A Register"]
        #[inline(always)]
        pub const fn ext3a_tmphi_lmt(self) -> crate::common::Reg<regs::Ext3aTmphiLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5dusize) as _) }
        }
        #[doc = "Low limit for External Diode 4A Register"]
        #[inline(always)]
        pub const fn ext4a_tmplo_lmt(self) -> crate::common::Reg<regs::Ext4aTmploLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5eusize) as _) }
        }
        #[doc = "High limit for External Diode 4A Register"]
        #[inline(always)]
        pub const fn ext4a_tmphi_lmt(self) -> crate::common::Reg<regs::Ext4aTmphiLmt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5fusize) as _) }
        }
        #[doc = "External Diode3 Beta compensation Register"]
        #[inline(always)]
        pub const fn bcomp3_en(self) -> crate::common::Reg<regs::Bcomp3en, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "External Diode4 Beta compensation Register"]
        #[inline(always)]
        pub const fn bcomp4_en(self) -> crate::common::Reg<regs::Bcomp4en, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x65usize) as _) }
        }
        #[doc = "Internal Diode Beta compensation Register"]
        #[inline(always)]
        pub const fn bcomp_intd_en(self) -> crate::common::Reg<regs::BcompIntdEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x67usize) as _) }
        }
        #[doc = "Conversion Seconds Rate Register"]
        #[inline(always)]
        pub const fn conv_srate(self) -> crate::common::Reg<regs::ConvSrate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6cusize) as _) }
        }
        #[doc = "Conversion Mode Register"]
        #[inline(always)]
        pub const fn conv_mod(self) -> crate::common::Reg<regs::ConvMod, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6eusize) as _) }
        }
        #[doc = "REC Enable Register"]
        #[inline(always)]
        pub const fn rec_en(self) -> crate::common::Reg<regs::RecEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "VSET Voltage Reading Register"]
        #[inline(always)]
        pub const fn vset_vlt(self) -> crate::common::Reg<regs::VsetVlt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x71usize) as _) }
        }
        #[doc = "Thermal Trip Temperature Diode 1 Register"]
        #[inline(always)]
        pub const fn therm1(self) -> crate::common::Reg<regs::Therm1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x75usize) as _) }
        }
        #[doc = "FailSafe Status Register"]
        #[inline(always)]
        pub const fn flsf_sts(self) -> crate::common::Reg<regs::FlsfSts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x76usize) as _) }
        }
        #[doc = "FailSafe Configuration Register"]
        #[inline(always)]
        pub const fn flsf_cfg(self) -> crate::common::Reg<regs::FlsfCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x77usize) as _) }
        }
        #[doc = "Shutdown Status Register"]
        #[inline(always)]
        pub const fn shdn_sts(self) -> crate::common::Reg<regs::ShdnSts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "Shutdown Configuration Register"]
        #[inline(always)]
        pub const fn shdn_cfg(self) -> crate::common::Reg<regs::ShdnCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x79usize) as _) }
        }
        #[doc = "Fault Interrupt Status Enable Register"]
        #[inline(always)]
        pub const fn flt_intsts_en(self) -> crate::common::Reg<regs::FltIntstsEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7ausize) as _) }
        }
        #[doc = "Temp Interrupt Status Enable Register"]
        #[inline(always)]
        pub const fn tmp_intsts(self) -> crate::common::Reg<regs::TmpIntsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7busize) as _) }
        }
        #[doc = "Special Function Register"]
        #[inline(always)]
        pub const fn spcl_fn(self) -> crate::common::Reg<regs::SpclFn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "Int Temp Interrupt Status Enable Register"]
        #[inline(always)]
        pub const fn inttmp_inten(self) -> crate::common::Reg<regs::InttmpInten, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7dusize) as _) }
        }
        #[doc = "Volt Interrupt Status Enable Register"]
        #[inline(always)]
        pub const fn vlt_inten(self) -> crate::common::Reg<regs::VltInten, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7eusize) as _) }
        }
        #[doc = "Thermal Trip Temperature Diode 2 Register"]
        #[inline(always)]
        pub const fn thrmtrp_tmp2(self) -> crate::common::Reg<regs::ThrmtrpTmp2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Thermal Trip Temperature Diode 3 Register"]
        #[inline(always)]
        pub const fn thrmtrp_tmp3(self) -> crate::common::Reg<regs::ThrmtrpTmp3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x81usize) as _) }
        }
        #[doc = "Thermal Trip Temperature Diode 4 Register"]
        #[inline(always)]
        pub const fn thrmtrp_tmp4(self) -> crate::common::Reg<regs::ThrmtrpTmp4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x82usize) as _) }
        }
        #[doc = "Thermal Trip Temperature Diode 1A Register"]
        #[inline(always)]
        pub const fn thrmtrp_tmp1a(self) -> crate::common::Reg<regs::ThrmtrpTmp1a, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x83usize) as _) }
        }
        #[doc = "Thermal Trip Temperature Diode 2A Register"]
        #[inline(always)]
        pub const fn thrmtrp_tmp2a(self) -> crate::common::Reg<regs::ThrmtrpTmp2a, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Thermal Trip Temperature Diode 3A Register"]
        #[inline(always)]
        pub const fn thrmtrp_tmp3a(self) -> crate::common::Reg<regs::ThrmtrpTmp3a, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x85usize) as _) }
        }
        #[doc = "Thermal Trip Temperature Diode 4A Register"]
        #[inline(always)]
        pub const fn thrmtrp_tmp4a(self) -> crate::common::Reg<regs::ThrmtrpTmp4a, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x86usize) as _) }
        }
        #[doc = "Adjusted Channel 1 Register"]
        #[inline(always)]
        pub const fn adj_ch1(self) -> crate::common::Reg<regs::AdjCh1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Adjusted Channel 2 Register"]
        #[inline(always)]
        pub const fn adj_ch2(self) -> crate::common::Reg<regs::AdjCh2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x89usize) as _) }
        }
        #[doc = "Adjusted Channel 3 Register"]
        #[inline(always)]
        pub const fn adj_ch3(self) -> crate::common::Reg<regs::AdjCh3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8ausize) as _) }
        }
        #[doc = "Adjusted Channel 4 Register"]
        #[inline(always)]
        pub const fn adj_ch4(self) -> crate::common::Reg<regs::AdjCh4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8busize) as _) }
        }
        #[doc = "Adjusted Channel 1A Register"]
        #[inline(always)]
        pub const fn adj_ch1a(self) -> crate::common::Reg<regs::AdjCh1a, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Adjusted Channel 2A Register"]
        #[inline(always)]
        pub const fn adj_ch2a(self) -> crate::common::Reg<regs::AdjCh2a, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8dusize) as _) }
        }
        #[doc = "Adjusted Channel 3A Register"]
        #[inline(always)]
        pub const fn adj_ch3a(self) -> crate::common::Reg<regs::AdjCh3a, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8eusize) as _) }
        }
        #[doc = "Adjusted Channel 4A Register"]
        #[inline(always)]
        pub const fn adj_ch4a(self) -> crate::common::Reg<regs::AdjCh4a, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8fusize) as _) }
        }
        #[doc = "Unlock Register"]
        #[inline(always)]
        pub const fn unlck(self) -> crate::common::Reg<regs::Unlck, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xfcusize) as _) }
        }
        #[doc = "System Shutdown Reset Register"]
        #[inline(always)]
        pub const fn sys_shdn_rst(self) -> crate::common::Reg<regs::SysShdnRst, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Adjusted Channel 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AdjCh1(pub u8);
        impl AdjCh1 {
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 1"]
            #[inline(always)]
            pub const fn adj_ch1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 1"]
            #[inline(always)]
            pub fn set_adj_ch1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AdjCh1 {
            #[inline(always)]
            fn default() -> AdjCh1 {
                AdjCh1(0)
            }
        }
        impl core::fmt::Debug for AdjCh1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AdjCh1").field("adj_ch1", &self.adj_ch1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AdjCh1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AdjCh1 {{ adj_ch1: {=u8:?} }}", self.adj_ch1())
            }
        }
        #[doc = "Adjusted Channel 1A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AdjCh1a(pub u8);
        impl AdjCh1a {
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 1A"]
            #[inline(always)]
            pub const fn adj_ch1a(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 1A"]
            #[inline(always)]
            pub fn set_adj_ch1a(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AdjCh1a {
            #[inline(always)]
            fn default() -> AdjCh1a {
                AdjCh1a(0)
            }
        }
        impl core::fmt::Debug for AdjCh1a {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AdjCh1a").field("adj_ch1a", &self.adj_ch1a()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AdjCh1a {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AdjCh1a {{ adj_ch1a: {=u8:?} }}", self.adj_ch1a())
            }
        }
        #[doc = "Adjusted Channel 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AdjCh2(pub u8);
        impl AdjCh2 {
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 2"]
            #[inline(always)]
            pub const fn adj_ch2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 2"]
            #[inline(always)]
            pub fn set_adj_ch2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AdjCh2 {
            #[inline(always)]
            fn default() -> AdjCh2 {
                AdjCh2(0)
            }
        }
        impl core::fmt::Debug for AdjCh2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AdjCh2").field("adj_ch2", &self.adj_ch2()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AdjCh2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AdjCh2 {{ adj_ch2: {=u8:?} }}", self.adj_ch2())
            }
        }
        #[doc = "Adjusted Channel 2A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AdjCh2a(pub u8);
        impl AdjCh2a {
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 2A"]
            #[inline(always)]
            pub const fn adj_ch2a(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 2A"]
            #[inline(always)]
            pub fn set_adj_ch2a(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AdjCh2a {
            #[inline(always)]
            fn default() -> AdjCh2a {
                AdjCh2a(0)
            }
        }
        impl core::fmt::Debug for AdjCh2a {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AdjCh2a").field("adj_ch2a", &self.adj_ch2a()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AdjCh2a {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AdjCh2a {{ adj_ch2a: {=u8:?} }}", self.adj_ch2a())
            }
        }
        #[doc = "Adjusted Channel 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AdjCh3(pub u8);
        impl AdjCh3 {
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 3"]
            #[inline(always)]
            pub const fn adj_ch3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 3"]
            #[inline(always)]
            pub fn set_adj_ch3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AdjCh3 {
            #[inline(always)]
            fn default() -> AdjCh3 {
                AdjCh3(0)
            }
        }
        impl core::fmt::Debug for AdjCh3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AdjCh3").field("adj_ch3", &self.adj_ch3()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AdjCh3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AdjCh3 {{ adj_ch3: {=u8:?} }}", self.adj_ch3())
            }
        }
        #[doc = "Adjusted Channel 3A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AdjCh3a(pub u8);
        impl AdjCh3a {
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 3A"]
            #[inline(always)]
            pub const fn adj_ch3a(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 3A"]
            #[inline(always)]
            pub fn set_adj_ch3a(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AdjCh3a {
            #[inline(always)]
            fn default() -> AdjCh3a {
                AdjCh3a(0)
            }
        }
        impl core::fmt::Debug for AdjCh3a {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AdjCh3a").field("adj_ch3a", &self.adj_ch3a()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AdjCh3a {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AdjCh3a {{ adj_ch3a: {=u8:?} }}", self.adj_ch3a())
            }
        }
        #[doc = "Adjusted Channel 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AdjCh4(pub u8);
        impl AdjCh4 {
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 4"]
            #[inline(always)]
            pub const fn adj_ch4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 4"]
            #[inline(always)]
            pub fn set_adj_ch4(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AdjCh4 {
            #[inline(always)]
            fn default() -> AdjCh4 {
                AdjCh4(0)
            }
        }
        impl core::fmt::Debug for AdjCh4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AdjCh4").field("adj_ch4", &self.adj_ch4()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AdjCh4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AdjCh4 {{ adj_ch4: {=u8:?} }}", self.adj_ch4())
            }
        }
        #[doc = "Adjusted Channel 4A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AdjCh4a(pub u8);
        impl AdjCh4a {
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 4A"]
            #[inline(always)]
            pub const fn adj_ch4a(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Contain EMC IP Trim Adjust values for External Channel 4A"]
            #[inline(always)]
            pub fn set_adj_ch4a(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AdjCh4a {
            #[inline(always)]
            fn default() -> AdjCh4a {
                AdjCh4a(0)
            }
        }
        impl core::fmt::Debug for AdjCh4a {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AdjCh4a").field("adj_ch4a", &self.adj_ch4a()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AdjCh4a {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AdjCh4a {{ adj_ch4a: {=u8:?} }}", self.adj_ch4a())
            }
        }
        #[doc = "Software Averaging Enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AvgEn(pub u8);
        impl AvgEn {
            #[doc = "Software Averaging Enable"]
            #[inline(always)]
            pub const fn avg_en(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Software Averaging Enable"]
            #[inline(always)]
            pub fn set_avg_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for AvgEn {
            #[inline(always)]
            fn default() -> AvgEn {
                AvgEn(0)
            }
        }
        impl core::fmt::Debug for AvgEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AvgEn").field("avg_en", &self.avg_en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AvgEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AvgEn {{ avg_en: {=u8:?} }}", self.avg_en())
            }
        }
        #[doc = "Configure Beta compensation settings for External Diode1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcomp1en(pub u8);
        impl Bcomp1en {
            #[doc = "Beta compensation settings for External Diode1 Enable"]
            #[inline(always)]
            pub const fn bcomp1_en(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Beta compensation settings for External Diode1 Enable"]
            #[inline(always)]
            pub fn set_bcomp1_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcomp1en {
            #[inline(always)]
            fn default() -> Bcomp1en {
                Bcomp1en(0)
            }
        }
        impl core::fmt::Debug for Bcomp1en {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcomp1en")
                    .field("bcomp1_en", &self.bcomp1_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcomp1en {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcomp1en {{ bcomp1_en: {=u8:?} }}", self.bcomp1_en())
            }
        }
        #[doc = "Configure Beta compensation settings for External Diode2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcomp2en(pub u8);
        impl Bcomp2en {
            #[doc = "Beta compensation settings for External Diode2 Enable"]
            #[inline(always)]
            pub const fn bcomp2_en(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Beta compensation settings for External Diode2 Enable"]
            #[inline(always)]
            pub fn set_bcomp2_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcomp2en {
            #[inline(always)]
            fn default() -> Bcomp2en {
                Bcomp2en(0)
            }
        }
        impl core::fmt::Debug for Bcomp2en {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcomp2en")
                    .field("bcomp2_en", &self.bcomp2_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcomp2en {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcomp2en {{ bcomp2_en: {=u8:?} }}", self.bcomp2_en())
            }
        }
        #[doc = "External Diode3 Beta compensation Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcomp3en(pub u8);
        impl Bcomp3en {
            #[doc = "Beta compensation settings for External Diode3 Enable"]
            #[inline(always)]
            pub const fn bcomp3_en(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Beta compensation settings for External Diode3 Enable"]
            #[inline(always)]
            pub fn set_bcomp3_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcomp3en {
            #[inline(always)]
            fn default() -> Bcomp3en {
                Bcomp3en(0)
            }
        }
        impl core::fmt::Debug for Bcomp3en {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcomp3en")
                    .field("bcomp3_en", &self.bcomp3_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcomp3en {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcomp3en {{ bcomp3_en: {=u8:?} }}", self.bcomp3_en())
            }
        }
        #[doc = "External Diode4 Beta compensation Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcomp4en(pub u8);
        impl Bcomp4en {
            #[doc = "Beta compensation settings for External Diode4 Enable"]
            #[inline(always)]
            pub const fn bcomp4_en(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Beta compensation settings for External Diode4 Enable"]
            #[inline(always)]
            pub fn set_bcomp4_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Bcomp4en {
            #[inline(always)]
            fn default() -> Bcomp4en {
                Bcomp4en(0)
            }
        }
        impl core::fmt::Debug for Bcomp4en {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcomp4en")
                    .field("bcomp4_en", &self.bcomp4_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcomp4en {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bcomp4en {{ bcomp4_en: {=u8:?} }}", self.bcomp4_en())
            }
        }
        #[doc = "Internal Diode Beta compensation Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BcompIntdEn(pub u8);
        impl BcompIntdEn {
            #[doc = "Beta compensation settings for internal Diode1 Enable"]
            #[inline(always)]
            pub const fn bcomp4_en(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Beta compensation settings for internal Diode1 Enable"]
            #[inline(always)]
            pub fn set_bcomp4_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for BcompIntdEn {
            #[inline(always)]
            fn default() -> BcompIntdEn {
                BcompIntdEn(0)
            }
        }
        impl core::fmt::Debug for BcompIntdEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BcompIntdEn")
                    .field("bcomp4_en", &self.bcomp4_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BcompIntdEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BcompIntdEn {{ bcomp4_en: {=u8:?} }}", self.bcomp4_en())
            }
        }
        #[doc = "Controls Temperature Conversion for the temperature channels"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CnvrCfg(pub u8);
        impl CnvrCfg {
            #[doc = "Controls Temperature Conversion for the temperature channels"]
            #[inline(always)]
            pub const fn cnvr_cfg(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Controls Temperature Conversion for the temperature channels"]
            #[inline(always)]
            pub fn set_cnvr_cfg(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for CnvrCfg {
            #[inline(always)]
            fn default() -> CnvrCfg {
                CnvrCfg(0)
            }
        }
        impl core::fmt::Debug for CnvrCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CnvrCfg").field("cnvr_cfg", &self.cnvr_cfg()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CnvrCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CnvrCfg {{ cnvr_cfg: {=u8:?} }}", self.cnvr_cfg())
            }
        }
        #[doc = "Conversion Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ConvMod(pub u8);
        impl ConvMod {
            #[doc = "Conversion Mode Register"]
            #[inline(always)]
            pub const fn conv_mod(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Conversion Mode Register"]
            #[inline(always)]
            pub fn set_conv_mod(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ConvMod {
            #[inline(always)]
            fn default() -> ConvMod {
                ConvMod(0)
            }
        }
        impl core::fmt::Debug for ConvMod {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ConvMod").field("conv_mod", &self.conv_mod()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ConvMod {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ConvMod {{ conv_mod: {=u8:?} }}", self.conv_mod())
            }
        }
        #[doc = "Conversion Seconds Rate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ConvSrate(pub u8);
        impl ConvSrate {
            #[doc = "Conversion Seconds Rate Register"]
            #[inline(always)]
            pub const fn conv_srate(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Conversion Seconds Rate Register"]
            #[inline(always)]
            pub fn set_conv_srate(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ConvSrate {
            #[inline(always)]
            fn default() -> ConvSrate {
                ConvSrate(0)
            }
        }
        impl core::fmt::Debug for ConvSrate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ConvSrate")
                    .field("conv_srate", &self.conv_srate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ConvSrate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ConvSrate {{ conv_srate: {=u8:?} }}", self.conv_srate())
            }
        }
        #[doc = "Stores the fractional and integer data for External Diode 1A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext1aTemp(pub u16);
        impl Ext1aTemp {
            #[doc = "Stores the fractional and integer data for External Diode 1A Register"]
            #[inline(always)]
            pub const fn diode1a_temp(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Stores the fractional and integer data for External Diode 1A Register"]
            #[inline(always)]
            pub fn set_diode1a_temp(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Ext1aTemp {
            #[inline(always)]
            fn default() -> Ext1aTemp {
                Ext1aTemp(0)
            }
        }
        impl core::fmt::Debug for Ext1aTemp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext1aTemp")
                    .field("diode1a_temp", &self.diode1a_temp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext1aTemp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext1aTemp {{ diode1a_temp: {=u16:?} }}", self.diode1a_temp())
            }
        }
        #[doc = "High limit for External Diode 1A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext1aTmphiLmt(pub u8);
        impl Ext1aTmphiLmt {
            #[doc = "High limit for External Diode 1A Register"]
            #[inline(always)]
            pub const fn tmphi1a_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "High limit for External Diode 1A Register"]
            #[inline(always)]
            pub fn set_tmphi1a_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext1aTmphiLmt {
            #[inline(always)]
            fn default() -> Ext1aTmphiLmt {
                Ext1aTmphiLmt(0)
            }
        }
        impl core::fmt::Debug for Ext1aTmphiLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext1aTmphiLmt")
                    .field("tmphi1a_limit", &self.tmphi1a_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext1aTmphiLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext1aTmphiLmt {{ tmphi1a_limit: {=u8:?} }}", self.tmphi1a_limit())
            }
        }
        #[doc = "Low limit for External Diode 1A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext1aTmploLmt(pub u8);
        impl Ext1aTmploLmt {
            #[doc = "Low limit for External Diode 1A Register"]
            #[inline(always)]
            pub const fn tmplo1a_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Low limit for External Diode 1A Register"]
            #[inline(always)]
            pub fn set_tmplo1a_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext1aTmploLmt {
            #[inline(always)]
            fn default() -> Ext1aTmploLmt {
                Ext1aTmploLmt(0)
            }
        }
        impl core::fmt::Debug for Ext1aTmploLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext1aTmploLmt")
                    .field("tmplo1a_limit", &self.tmplo1a_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext1aTmploLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext1aTmploLmt {{ tmplo1a_limit: {=u8:?} }}", self.tmplo1a_limit())
            }
        }
        #[doc = "External Diode 1 Temp Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext1temp(pub u16);
        impl Ext1temp {
            #[doc = "External Diode 1 Temp Byte Register"]
            #[inline(always)]
            pub const fn diode1_temp(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "External Diode 1 Temp Byte Register"]
            #[inline(always)]
            pub fn set_diode1_temp(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Ext1temp {
            #[inline(always)]
            fn default() -> Ext1temp {
                Ext1temp(0)
            }
        }
        impl core::fmt::Debug for Ext1temp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext1temp")
                    .field("diode1_temp", &self.diode1_temp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext1temp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext1temp {{ diode1_temp: {=u16:?} }}", self.diode1_temp())
            }
        }
        #[doc = "High limit for External Diode 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext1tmphiLmt(pub u8);
        impl Ext1tmphiLmt {
            #[doc = "High limit for External Diode 1 Register"]
            #[inline(always)]
            pub const fn tmphi1_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "High limit for External Diode 1 Register"]
            #[inline(always)]
            pub fn set_tmphi1_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext1tmphiLmt {
            #[inline(always)]
            fn default() -> Ext1tmphiLmt {
                Ext1tmphiLmt(0)
            }
        }
        impl core::fmt::Debug for Ext1tmphiLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext1tmphiLmt")
                    .field("tmphi1_limit", &self.tmphi1_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext1tmphiLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext1tmphiLmt {{ tmphi1_limit: {=u8:?} }}", self.tmphi1_limit())
            }
        }
        #[doc = "Low limit for External Diode 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext1tmploLmt(pub u8);
        impl Ext1tmploLmt {
            #[doc = "Low limit for External Diode 1 Register"]
            #[inline(always)]
            pub const fn tmplo1_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Low limit for External Diode 1 Register"]
            #[inline(always)]
            pub fn set_tmplo1_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext1tmploLmt {
            #[inline(always)]
            fn default() -> Ext1tmploLmt {
                Ext1tmploLmt(0)
            }
        }
        impl core::fmt::Debug for Ext1tmploLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext1tmploLmt")
                    .field("tmplo1_limit", &self.tmplo1_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext1tmploLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext1tmploLmt {{ tmplo1_limit: {=u8:?} }}", self.tmplo1_limit())
            }
        }
        #[doc = "Stores the fractional and integer data for External Diode 2A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext2aTemp(pub u16);
        impl Ext2aTemp {
            #[doc = "Stores the fractional and integer data for External Diode 2A Register"]
            #[inline(always)]
            pub const fn diode2a_temp(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Stores the fractional and integer data for External Diode 2A Register"]
            #[inline(always)]
            pub fn set_diode2a_temp(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Ext2aTemp {
            #[inline(always)]
            fn default() -> Ext2aTemp {
                Ext2aTemp(0)
            }
        }
        impl core::fmt::Debug for Ext2aTemp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext2aTemp")
                    .field("diode2a_temp", &self.diode2a_temp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext2aTemp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext2aTemp {{ diode2a_temp: {=u16:?} }}", self.diode2a_temp())
            }
        }
        #[doc = "High limit for External Diode 2A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext2aTmphiLmt(pub u8);
        impl Ext2aTmphiLmt {
            #[doc = "High limit for External Diode 2A Register"]
            #[inline(always)]
            pub const fn tmphi2a_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "High limit for External Diode 2A Register"]
            #[inline(always)]
            pub fn set_tmphi2a_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext2aTmphiLmt {
            #[inline(always)]
            fn default() -> Ext2aTmphiLmt {
                Ext2aTmphiLmt(0)
            }
        }
        impl core::fmt::Debug for Ext2aTmphiLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext2aTmphiLmt")
                    .field("tmphi2a_limit", &self.tmphi2a_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext2aTmphiLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext2aTmphiLmt {{ tmphi2a_limit: {=u8:?} }}", self.tmphi2a_limit())
            }
        }
        #[doc = "Low limit for External Diode 2A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext2aTmploLmt(pub u8);
        impl Ext2aTmploLmt {
            #[doc = "Low limit for External Diode 2A Register"]
            #[inline(always)]
            pub const fn tmplo2a_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Low limit for External Diode 2A Register"]
            #[inline(always)]
            pub fn set_tmplo2a_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext2aTmploLmt {
            #[inline(always)]
            fn default() -> Ext2aTmploLmt {
                Ext2aTmploLmt(0)
            }
        }
        impl core::fmt::Debug for Ext2aTmploLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext2aTmploLmt")
                    .field("tmplo2a_limit", &self.tmplo2a_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext2aTmploLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext2aTmploLmt {{ tmplo2a_limit: {=u8:?} }}", self.tmplo2a_limit())
            }
        }
        #[doc = "External Diode 2 Temp Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext2temp(pub u16);
        impl Ext2temp {
            #[doc = "External Diode 2 Temp Byte Register"]
            #[inline(always)]
            pub const fn diode2_temp(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "External Diode 2 Temp Byte Register"]
            #[inline(always)]
            pub fn set_diode2_temp(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Ext2temp {
            #[inline(always)]
            fn default() -> Ext2temp {
                Ext2temp(0)
            }
        }
        impl core::fmt::Debug for Ext2temp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext2temp")
                    .field("diode2_temp", &self.diode2_temp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext2temp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext2temp {{ diode2_temp: {=u16:?} }}", self.diode2_temp())
            }
        }
        #[doc = "High limit for External Diode 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext2tmphiLmt(pub u8);
        impl Ext2tmphiLmt {
            #[doc = "High limit for External Diode 2 Register"]
            #[inline(always)]
            pub const fn tmphi2_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "High limit for External Diode 2 Register"]
            #[inline(always)]
            pub fn set_tmphi2_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext2tmphiLmt {
            #[inline(always)]
            fn default() -> Ext2tmphiLmt {
                Ext2tmphiLmt(0)
            }
        }
        impl core::fmt::Debug for Ext2tmphiLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext2tmphiLmt")
                    .field("tmphi2_limit", &self.tmphi2_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext2tmphiLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext2tmphiLmt {{ tmphi2_limit: {=u8:?} }}", self.tmphi2_limit())
            }
        }
        #[doc = "Low limit for External Diode 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext2tmploLmt(pub u8);
        impl Ext2tmploLmt {
            #[doc = "Low limit for External Diode 2 Register"]
            #[inline(always)]
            pub const fn tmplo2_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Low limit for External Diode 2 Register"]
            #[inline(always)]
            pub fn set_tmplo2_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext2tmploLmt {
            #[inline(always)]
            fn default() -> Ext2tmploLmt {
                Ext2tmploLmt(0)
            }
        }
        impl core::fmt::Debug for Ext2tmploLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext2tmploLmt")
                    .field("tmplo2_limit", &self.tmplo2_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext2tmploLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext2tmploLmt {{ tmplo2_limit: {=u8:?} }}", self.tmplo2_limit())
            }
        }
        #[doc = "Stores the fractional and integer data for External Diode 3A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext3aTemp(pub u16);
        impl Ext3aTemp {
            #[doc = "Stores the fractional and integer data for External Diode 3A Register"]
            #[inline(always)]
            pub const fn diode3a_temp(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Stores the fractional and integer data for External Diode 3A Register"]
            #[inline(always)]
            pub fn set_diode3a_temp(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Ext3aTemp {
            #[inline(always)]
            fn default() -> Ext3aTemp {
                Ext3aTemp(0)
            }
        }
        impl core::fmt::Debug for Ext3aTemp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext3aTemp")
                    .field("diode3a_temp", &self.diode3a_temp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext3aTemp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext3aTemp {{ diode3a_temp: {=u16:?} }}", self.diode3a_temp())
            }
        }
        #[doc = "High limit for External Diode 3A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext3aTmphiLmt(pub u8);
        impl Ext3aTmphiLmt {
            #[doc = "High limit for External Diode 3A Register"]
            #[inline(always)]
            pub const fn tmphi3a_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "High limit for External Diode 3A Register"]
            #[inline(always)]
            pub fn set_tmphi3a_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext3aTmphiLmt {
            #[inline(always)]
            fn default() -> Ext3aTmphiLmt {
                Ext3aTmphiLmt(0)
            }
        }
        impl core::fmt::Debug for Ext3aTmphiLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext3aTmphiLmt")
                    .field("tmphi3a_limit", &self.tmphi3a_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext3aTmphiLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext3aTmphiLmt {{ tmphi3a_limit: {=u8:?} }}", self.tmphi3a_limit())
            }
        }
        #[doc = "Low limit for External Diode 3A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext3aTmploLmt(pub u8);
        impl Ext3aTmploLmt {
            #[doc = "Low limit for External Diode 3A Register"]
            #[inline(always)]
            pub const fn tmplo3a_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Low limit for External Diode 3A Register"]
            #[inline(always)]
            pub fn set_tmplo3a_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext3aTmploLmt {
            #[inline(always)]
            fn default() -> Ext3aTmploLmt {
                Ext3aTmploLmt(0)
            }
        }
        impl core::fmt::Debug for Ext3aTmploLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext3aTmploLmt")
                    .field("tmplo3a_limit", &self.tmplo3a_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext3aTmploLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext3aTmploLmt {{ tmplo3a_limit: {=u8:?} }}", self.tmplo3a_limit())
            }
        }
        #[doc = "External Diode 3 Temp Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext3temp(pub u16);
        impl Ext3temp {
            #[doc = "External Diode 3 Temp Byte Register"]
            #[inline(always)]
            pub const fn diode3_temp(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "External Diode 3 Temp Byte Register"]
            #[inline(always)]
            pub fn set_diode3_temp(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Ext3temp {
            #[inline(always)]
            fn default() -> Ext3temp {
                Ext3temp(0)
            }
        }
        impl core::fmt::Debug for Ext3temp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext3temp")
                    .field("diode3_temp", &self.diode3_temp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext3temp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext3temp {{ diode3_temp: {=u16:?} }}", self.diode3_temp())
            }
        }
        #[doc = "High limit for External Diode 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext3tmphiLmt(pub u8);
        impl Ext3tmphiLmt {
            #[doc = "High limit for External Diode 3 Register"]
            #[inline(always)]
            pub const fn tmphi3_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "High limit for External Diode 3 Register"]
            #[inline(always)]
            pub fn set_tmphi3_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext3tmphiLmt {
            #[inline(always)]
            fn default() -> Ext3tmphiLmt {
                Ext3tmphiLmt(0)
            }
        }
        impl core::fmt::Debug for Ext3tmphiLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext3tmphiLmt")
                    .field("tmphi3_limit", &self.tmphi3_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext3tmphiLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext3tmphiLmt {{ tmphi3_limit: {=u8:?} }}", self.tmphi3_limit())
            }
        }
        #[doc = "Low limit for External Diode 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext3tmploLmt(pub u8);
        impl Ext3tmploLmt {
            #[doc = "Low limit for External Diode 3 Register"]
            #[inline(always)]
            pub const fn tmplo3_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Low limit for External Diode 3 Register"]
            #[inline(always)]
            pub fn set_tmplo3_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext3tmploLmt {
            #[inline(always)]
            fn default() -> Ext3tmploLmt {
                Ext3tmploLmt(0)
            }
        }
        impl core::fmt::Debug for Ext3tmploLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext3tmploLmt")
                    .field("tmplo3_limit", &self.tmplo3_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext3tmploLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext3tmploLmt {{ tmplo3_limit: {=u8:?} }}", self.tmplo3_limit())
            }
        }
        #[doc = "Stores the fractional and integer data for External Diode 4A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext4aTemp(pub u16);
        impl Ext4aTemp {
            #[doc = "Stores the fractional and integerdata for External Diode 4A Register"]
            #[inline(always)]
            pub const fn diode4a_temp(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Stores the fractional and integerdata for External Diode 4A Register"]
            #[inline(always)]
            pub fn set_diode4a_temp(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Ext4aTemp {
            #[inline(always)]
            fn default() -> Ext4aTemp {
                Ext4aTemp(0)
            }
        }
        impl core::fmt::Debug for Ext4aTemp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext4aTemp")
                    .field("diode4a_temp", &self.diode4a_temp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext4aTemp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext4aTemp {{ diode4a_temp: {=u16:?} }}", self.diode4a_temp())
            }
        }
        #[doc = "High limit for External Diode 4A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext4aTmphiLmt(pub u8);
        impl Ext4aTmphiLmt {
            #[doc = "High limit for External Diode 4A Register"]
            #[inline(always)]
            pub const fn tmphi4a_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "High limit for External Diode 4A Register"]
            #[inline(always)]
            pub fn set_tmphi4a_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext4aTmphiLmt {
            #[inline(always)]
            fn default() -> Ext4aTmphiLmt {
                Ext4aTmphiLmt(0)
            }
        }
        impl core::fmt::Debug for Ext4aTmphiLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext4aTmphiLmt")
                    .field("tmphi4a_limit", &self.tmphi4a_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext4aTmphiLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext4aTmphiLmt {{ tmphi4a_limit: {=u8:?} }}", self.tmphi4a_limit())
            }
        }
        #[doc = "Low limit for External Diode 4A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext4aTmploLmt(pub u8);
        impl Ext4aTmploLmt {
            #[doc = "Low limit for External Diode 4A Register"]
            #[inline(always)]
            pub const fn tmplo4a_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Low limit for External Diode 4A Register"]
            #[inline(always)]
            pub fn set_tmplo4a_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext4aTmploLmt {
            #[inline(always)]
            fn default() -> Ext4aTmploLmt {
                Ext4aTmploLmt(0)
            }
        }
        impl core::fmt::Debug for Ext4aTmploLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext4aTmploLmt")
                    .field("tmplo4a_limit", &self.tmplo4a_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext4aTmploLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext4aTmploLmt {{ tmplo4a_limit: {=u8:?} }}", self.tmplo4a_limit())
            }
        }
        #[doc = "External Diode 4 Temp Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext4temp(pub u16);
        impl Ext4temp {
            #[doc = "External Diode 4 Temp Byte Register"]
            #[inline(always)]
            pub const fn diode4_temp(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "External Diode 4 Temp Byte Register"]
            #[inline(always)]
            pub fn set_diode4_temp(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Ext4temp {
            #[inline(always)]
            fn default() -> Ext4temp {
                Ext4temp(0)
            }
        }
        impl core::fmt::Debug for Ext4temp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext4temp")
                    .field("diode4_temp", &self.diode4_temp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext4temp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext4temp {{ diode4_temp: {=u16:?} }}", self.diode4_temp())
            }
        }
        #[doc = "High limit for External Diode 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext4tmphiLmt(pub u8);
        impl Ext4tmphiLmt {
            #[doc = "High limit for External Diode 4 Register"]
            #[inline(always)]
            pub const fn tmphi4_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "High limit for External Diode 4 Register"]
            #[inline(always)]
            pub fn set_tmphi4_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext4tmphiLmt {
            #[inline(always)]
            fn default() -> Ext4tmphiLmt {
                Ext4tmphiLmt(0)
            }
        }
        impl core::fmt::Debug for Ext4tmphiLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext4tmphiLmt")
                    .field("tmphi4_limit", &self.tmphi4_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext4tmphiLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext4tmphiLmt {{ tmphi4_limit: {=u8:?} }}", self.tmphi4_limit())
            }
        }
        #[doc = "Low limit for External Diode 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ext4tmploLmt(pub u8);
        impl Ext4tmploLmt {
            #[doc = "Low limit for External Diode 4 Register"]
            #[inline(always)]
            pub const fn tmplo4_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Low limit for External Diode 4 Register"]
            #[inline(always)]
            pub fn set_tmplo4_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Ext4tmploLmt {
            #[inline(always)]
            fn default() -> Ext4tmploLmt {
                Ext4tmploLmt(0)
            }
        }
        impl core::fmt::Debug for Ext4tmploLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ext4tmploLmt")
                    .field("tmplo4_limit", &self.tmplo4_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ext4tmploLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ext4tmploLmt {{ tmplo4_limit: {=u8:?} }}", self.tmplo4_limit())
            }
        }
        #[doc = "FailSafe Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlsfCfg(pub u8);
        impl FlsfCfg {
            #[doc = "Stores configuration bits that are retained over all power modes"]
            #[inline(always)]
            pub const fn flsf_cfg(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores configuration bits that are retained over all power modes"]
            #[inline(always)]
            pub fn set_flsf_cfg(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for FlsfCfg {
            #[inline(always)]
            fn default() -> FlsfCfg {
                FlsfCfg(0)
            }
        }
        impl core::fmt::Debug for FlsfCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlsfCfg").field("flsf_cfg", &self.flsf_cfg()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlsfCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FlsfCfg {{ flsf_cfg: {=u8:?} }}", self.flsf_cfg())
            }
        }
        #[doc = "FailSafe Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlsfSts(pub u8);
        impl FlsfSts {
            #[doc = "Stores the status indicate which ThermTrip input condition caused the SYS_SHDN# pin to be asserted."]
            #[inline(always)]
            pub const fn flsf_sts(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the status indicate which ThermTrip input condition caused the SYS_SHDN# pin to be asserted."]
            #[inline(always)]
            pub fn set_flsf_sts(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for FlsfSts {
            #[inline(always)]
            fn default() -> FlsfSts {
                FlsfSts(0)
            }
        }
        impl core::fmt::Debug for FlsfSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlsfSts").field("flsf_sts", &self.flsf_sts()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlsfSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FlsfSts {{ flsf_sts: {=u8:?} }}", self.flsf_sts())
            }
        }
        #[doc = "Fault Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FltIntsts(pub u8);
        impl FltIntsts {
            #[doc = "Stores the status of the External Diode Faults"]
            #[inline(always)]
            pub const fn flt_intsts(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the status of the External Diode Faults"]
            #[inline(always)]
            pub fn set_flt_intsts(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for FltIntsts {
            #[inline(always)]
            fn default() -> FltIntsts {
                FltIntsts(0)
            }
        }
        impl core::fmt::Debug for FltIntsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FltIntsts")
                    .field("flt_intsts", &self.flt_intsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FltIntsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FltIntsts {{ flt_intsts: {=u8:?} }}", self.flt_intsts())
            }
        }
        #[doc = "Fault Interrupt Status Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FltIntstsEn(pub u8);
        impl FltIntstsEn {
            #[doc = "Controls whether the External Diode Fault events generates interrupt if the associated status bit is 1."]
            #[inline(always)]
            pub const fn flt_intsts_en(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Controls whether the External Diode Fault events generates interrupt if the associated status bit is 1."]
            #[inline(always)]
            pub fn set_flt_intsts_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for FltIntstsEn {
            #[inline(always)]
            fn default() -> FltIntstsEn {
                FltIntstsEn(0)
            }
        }
        impl core::fmt::Debug for FltIntstsEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FltIntstsEn")
                    .field("flt_intsts_en", &self.flt_intsts_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FltIntstsEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FltIntstsEn {{ flt_intsts_en: {=u8:?} }}", self.flt_intsts_en())
            }
        }
        #[doc = "Fault temperature Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FltTempsts(pub u8);
        impl FltTempsts {
            #[doc = "Stores the status of the External Diode Faults"]
            #[inline(always)]
            pub const fn flt_tempsts(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the status of the External Diode Faults"]
            #[inline(always)]
            pub fn set_flt_tempsts(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for FltTempsts {
            #[inline(always)]
            fn default() -> FltTempsts {
                FltTempsts(0)
            }
        }
        impl core::fmt::Debug for FltTempsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FltTempsts")
                    .field("flt_tempsts", &self.flt_tempsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FltTempsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FltTempsts {{ flt_tempsts: {=u8:?} }}", self.flt_tempsts())
            }
        }
        #[doc = "Internal Temp Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntTemp(pub u16);
        impl IntTemp {
            #[doc = "Internal Temp Byte Register"]
            #[inline(always)]
            pub const fn int_temp(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Internal Temp Byte Register"]
            #[inline(always)]
            pub fn set_int_temp(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for IntTemp {
            #[inline(always)]
            fn default() -> IntTemp {
                IntTemp(0)
            }
        }
        impl core::fmt::Debug for IntTemp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntTemp").field("int_temp", &self.int_temp()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntTemp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IntTemp {{ int_temp: {=u16:?} }}", self.int_temp())
            }
        }
        #[doc = "Temperature of Internal Diode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntTempSts(pub u8);
        impl IntTempSts {
            #[doc = "Stores the status bits for the Internal Diode"]
            #[inline(always)]
            pub const fn temp_sts(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the status bits for the Internal Diode"]
            #[inline(always)]
            pub fn set_temp_sts(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for IntTempSts {
            #[inline(always)]
            fn default() -> IntTempSts {
                IntTempSts(0)
            }
        }
        impl core::fmt::Debug for IntTempSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntTempSts")
                    .field("temp_sts", &self.temp_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntTempSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IntTempSts {{ temp_sts: {=u8:?} }}", self.temp_sts())
            }
        }
        #[doc = "High limit for Internal Diode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntTmphiLmt(pub u8);
        impl IntTmphiLmt {
            #[doc = "High limit for internal Diode Register"]
            #[inline(always)]
            pub const fn tmphi_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "High limit for internal Diode Register"]
            #[inline(always)]
            pub fn set_tmphi_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for IntTmphiLmt {
            #[inline(always)]
            fn default() -> IntTmphiLmt {
                IntTmphiLmt(0)
            }
        }
        impl core::fmt::Debug for IntTmphiLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntTmphiLmt")
                    .field("tmphi_limit", &self.tmphi_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntTmphiLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IntTmphiLmt {{ tmphi_limit: {=u8:?} }}", self.tmphi_limit())
            }
        }
        #[doc = "Low limit for Internal Diode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntTmploLmt(pub u8);
        impl IntTmploLmt {
            #[doc = "Low limit for Internal Diode Register"]
            #[inline(always)]
            pub const fn tmplo_limit(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Low limit for Internal Diode Register"]
            #[inline(always)]
            pub fn set_tmplo_limit(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for IntTmploLmt {
            #[inline(always)]
            fn default() -> IntTmploLmt {
                IntTmploLmt(0)
            }
        }
        impl core::fmt::Debug for IntTmploLmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntTmploLmt")
                    .field("tmplo_limit", &self.tmplo_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntTmploLmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IntTmploLmt {{ tmplo_limit: {=u8:?} }}", self.tmplo_limit())
            }
        }
        #[doc = "Int Temp Interrupt Status Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct InttmpInten(pub u8);
        impl InttmpInten {
            #[doc = "Controls whether the Internal Diode event generate an interrupt if the associated status bit is set."]
            #[inline(always)]
            pub const fn inttmp_inten(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Controls whether the Internal Diode event generate an interrupt if the associated status bit is set."]
            #[inline(always)]
            pub fn set_inttmp_inten(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for InttmpInten {
            #[inline(always)]
            fn default() -> InttmpInten {
                InttmpInten(0)
            }
        }
        impl core::fmt::Debug for InttmpInten {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("InttmpInten")
                    .field("inttmp_inten", &self.inttmp_inten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for InttmpInten {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "InttmpInten {{ inttmp_inten: {=u8:?} }}", self.inttmp_inten())
            }
        }
        #[doc = "Lock Start Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LckStrt(pub u8);
        impl LckStrt {
            #[doc = "Enables the software lock and monitoring functionality"]
            #[inline(always)]
            pub const fn bcomp2_en(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Enables the software lock and monitoring functionality"]
            #[inline(always)]
            pub fn set_bcomp2_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for LckStrt {
            #[inline(always)]
            fn default() -> LckStrt {
                LckStrt(0)
            }
        }
        impl core::fmt::Debug for LckStrt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LckStrt").field("bcomp2_en", &self.bcomp2_en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LckStrt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LckStrt {{ bcomp2_en: {=u8:?} }}", self.bcomp2_en())
            }
        }
        #[doc = "REC Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RecEn(pub u8);
        impl RecEn {
            #[doc = "Enables REC for all external diode channels"]
            #[inline(always)]
            pub const fn rec_en(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Enables REC for all external diode channels"]
            #[inline(always)]
            pub fn set_rec_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for RecEn {
            #[inline(always)]
            fn default() -> RecEn {
                RecEn(0)
            }
        }
        impl core::fmt::Debug for RecEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RecEn").field("rec_en", &self.rec_en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RecEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RecEn {{ rec_en: {=u8:?} }}", self.rec_en())
            }
        }
        #[doc = "Shutdown Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ShdnCfg(pub u8);
        impl ShdnCfg {
            #[doc = "Stores configuration bits that are retained over all power modes"]
            #[inline(always)]
            pub const fn shdn_cfg(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores configuration bits that are retained over all power modes"]
            #[inline(always)]
            pub fn set_shdn_cfg(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ShdnCfg {
            #[inline(always)]
            fn default() -> ShdnCfg {
                ShdnCfg(0)
            }
        }
        impl core::fmt::Debug for ShdnCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ShdnCfg").field("shdn_cfg", &self.shdn_cfg()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ShdnCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ShdnCfg {{ shdn_cfg: {=u8:?} }}", self.shdn_cfg())
            }
        }
        #[doc = "Shutdown Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ShdnSts(pub u8);
        impl ShdnSts {
            #[doc = "Stores the status bits that indicate which diode caused the SYS_SHDN# output to assert."]
            #[inline(always)]
            pub const fn shdn_sts(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the status bits that indicate which diode caused the SYS_SHDN# output to assert."]
            #[inline(always)]
            pub fn set_shdn_sts(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ShdnSts {
            #[inline(always)]
            fn default() -> ShdnSts {
                ShdnSts(0)
            }
        }
        impl core::fmt::Debug for ShdnSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ShdnSts").field("shdn_sts", &self.shdn_sts()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ShdnSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ShdnSts {{ shdn_sts: {=u8:?} }}", self.shdn_sts())
            }
        }
        #[doc = "Special Function Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpclFn(pub u8);
        impl SpclFn {
            #[doc = "Controls the bit that resets the FailSafe Status Register"]
            #[inline(always)]
            pub const fn tmp_intsts(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Controls the bit that resets the FailSafe Status Register"]
            #[inline(always)]
            pub fn set_tmp_intsts(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for SpclFn {
            #[inline(always)]
            fn default() -> SpclFn {
                SpclFn(0)
            }
        }
        impl core::fmt::Debug for SpclFn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpclFn")
                    .field("tmp_intsts", &self.tmp_intsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpclFn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SpclFn {{ tmp_intsts: {=u8:?} }}", self.tmp_intsts())
            }
        }
        #[doc = "System Shutdown Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SysShdnRst(pub u8);
        impl SysShdnRst {
            #[doc = "Used to de-assert the SYS_SHDN# signal Register"]
            #[inline(always)]
            pub const fn sys_shdn_rst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Used to de-assert the SYS_SHDN# signal Register"]
            #[inline(always)]
            pub fn set_sys_shdn_rst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for SysShdnRst {
            #[inline(always)]
            fn default() -> SysShdnRst {
                SysShdnRst(0)
            }
        }
        impl core::fmt::Debug for SysShdnRst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SysShdnRst")
                    .field("sys_shdn_rst", &self.sys_shdn_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SysShdnRst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SysShdnRst {{ sys_shdn_rst: {=u8:?} }}", self.sys_shdn_rst())
            }
        }
        #[doc = "Controls temp sensing for external diodes"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TempCfg1(pub u8);
        impl TempCfg1 {
            #[doc = "Controls temp sensing for external diodes"]
            #[inline(always)]
            pub const fn temp_cfg1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Controls temp sensing for external diodes"]
            #[inline(always)]
            pub fn set_temp_cfg1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for TempCfg1 {
            #[inline(always)]
            fn default() -> TempCfg1 {
                TempCfg1(0)
            }
        }
        impl core::fmt::Debug for TempCfg1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TempCfg1")
                    .field("temp_cfg1", &self.temp_cfg1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TempCfg1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TempCfg1 {{ temp_cfg1: {=u8:?} }}", self.temp_cfg1())
            }
        }
        #[doc = "Controls temp sensing for external diodes"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TempCfg2(pub u8);
        impl TempCfg2 {
            #[doc = "Controls temp sensing for external diodes"]
            #[inline(always)]
            pub const fn temp_cfg2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Controls temp sensing for external diodes"]
            #[inline(always)]
            pub fn set_temp_cfg2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for TempCfg2 {
            #[inline(always)]
            fn default() -> TempCfg2 {
                TempCfg2(0)
            }
        }
        impl core::fmt::Debug for TempCfg2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TempCfg2")
                    .field("temp_cfg2", &self.temp_cfg2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TempCfg2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TempCfg2 {{ temp_cfg2: {=u8:?} }}", self.temp_cfg2())
            }
        }
        #[doc = "Controls Thermistor or diodes Configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ThemCfg(pub u8);
        impl ThemCfg {
            #[doc = "Controls Thermistor or diodes Configuration"]
            #[inline(always)]
            pub const fn them_cfg(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Controls Thermistor or diodes Configuration"]
            #[inline(always)]
            pub fn set_them_cfg(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ThemCfg {
            #[inline(always)]
            fn default() -> ThemCfg {
                ThemCfg(0)
            }
        }
        impl core::fmt::Debug for ThemCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ThemCfg").field("them_cfg", &self.them_cfg()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ThemCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ThemCfg {{ them_cfg: {=u8:?} }}", self.them_cfg())
            }
        }
        #[doc = "Thermal Trip Temperature Diode 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Therm1(pub u8);
        impl Therm1 {
            #[doc = "Stores the calculated ThermTrip temperature high limit derived from the voltage on VSET and compared against External Diode 1."]
            #[inline(always)]
            pub const fn therm1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the calculated ThermTrip temperature high limit derived from the voltage on VSET and compared against External Diode 1."]
            #[inline(always)]
            pub fn set_therm1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Therm1 {
            #[inline(always)]
            fn default() -> Therm1 {
                Therm1(0)
            }
        }
        impl core::fmt::Debug for Therm1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Therm1").field("therm1", &self.therm1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Therm1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Therm1 {{ therm1: {=u8:?} }}", self.therm1())
            }
        }
        #[doc = "ThermTrip Pin Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ThrmtrpSts(pub u8);
        impl ThrmtrpSts {
            #[doc = "Stores the pin state of the signals that affect the SYS_SHDN_n signal"]
            #[inline(always)]
            pub const fn thrmtrp_sts(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the pin state of the signals that affect the SYS_SHDN_n signal"]
            #[inline(always)]
            pub fn set_thrmtrp_sts(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ThrmtrpSts {
            #[inline(always)]
            fn default() -> ThrmtrpSts {
                ThrmtrpSts(0)
            }
        }
        impl core::fmt::Debug for ThrmtrpSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ThrmtrpSts")
                    .field("thrmtrp_sts", &self.thrmtrp_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ThrmtrpSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ThrmtrpSts {{ thrmtrp_sts: {=u8:?} }}", self.thrmtrp_sts())
            }
        }
        #[doc = "Thermal Trip Temperature Diode 1A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ThrmtrpTmp1a(pub u8);
        impl ThrmtrpTmp1a {
            #[doc = "ThermTrip temperature high limit compared against External Diode 1A"]
            #[inline(always)]
            pub const fn thrmtrp_tmp1a(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "ThermTrip temperature high limit compared against External Diode 1A"]
            #[inline(always)]
            pub fn set_thrmtrp_tmp1a(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ThrmtrpTmp1a {
            #[inline(always)]
            fn default() -> ThrmtrpTmp1a {
                ThrmtrpTmp1a(0)
            }
        }
        impl core::fmt::Debug for ThrmtrpTmp1a {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ThrmtrpTmp1a")
                    .field("thrmtrp_tmp1a", &self.thrmtrp_tmp1a())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ThrmtrpTmp1a {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ThrmtrpTmp1a {{ thrmtrp_tmp1a: {=u8:?} }}", self.thrmtrp_tmp1a())
            }
        }
        #[doc = "Thermal Trip Temperature Diode 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ThrmtrpTmp2(pub u8);
        impl ThrmtrpTmp2 {
            #[doc = "ThermTrip temperature high limit compared against External Diode 2"]
            #[inline(always)]
            pub const fn thrmtrp_tmp2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "ThermTrip temperature high limit compared against External Diode 2"]
            #[inline(always)]
            pub fn set_thrmtrp_tmp2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ThrmtrpTmp2 {
            #[inline(always)]
            fn default() -> ThrmtrpTmp2 {
                ThrmtrpTmp2(0)
            }
        }
        impl core::fmt::Debug for ThrmtrpTmp2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ThrmtrpTmp2")
                    .field("thrmtrp_tmp2", &self.thrmtrp_tmp2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ThrmtrpTmp2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ThrmtrpTmp2 {{ thrmtrp_tmp2: {=u8:?} }}", self.thrmtrp_tmp2())
            }
        }
        #[doc = "Thermal Trip Temperature Diode 2A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ThrmtrpTmp2a(pub u8);
        impl ThrmtrpTmp2a {
            #[doc = "ThermTrip temperature high limit compared against External Diode 2A"]
            #[inline(always)]
            pub const fn thrmtrp_tmp2a(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "ThermTrip temperature high limit compared against External Diode 2A"]
            #[inline(always)]
            pub fn set_thrmtrp_tmp2a(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ThrmtrpTmp2a {
            #[inline(always)]
            fn default() -> ThrmtrpTmp2a {
                ThrmtrpTmp2a(0)
            }
        }
        impl core::fmt::Debug for ThrmtrpTmp2a {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ThrmtrpTmp2a")
                    .field("thrmtrp_tmp2a", &self.thrmtrp_tmp2a())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ThrmtrpTmp2a {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ThrmtrpTmp2a {{ thrmtrp_tmp2a: {=u8:?} }}", self.thrmtrp_tmp2a())
            }
        }
        #[doc = "Thermal Trip Temperature Diode 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ThrmtrpTmp3(pub u8);
        impl ThrmtrpTmp3 {
            #[doc = "ThermTrip temperature high limit compared against External Diode 3"]
            #[inline(always)]
            pub const fn thrmtrp_tmp3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "ThermTrip temperature high limit compared against External Diode 3"]
            #[inline(always)]
            pub fn set_thrmtrp_tmp3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ThrmtrpTmp3 {
            #[inline(always)]
            fn default() -> ThrmtrpTmp3 {
                ThrmtrpTmp3(0)
            }
        }
        impl core::fmt::Debug for ThrmtrpTmp3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ThrmtrpTmp3")
                    .field("thrmtrp_tmp3", &self.thrmtrp_tmp3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ThrmtrpTmp3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ThrmtrpTmp3 {{ thrmtrp_tmp3: {=u8:?} }}", self.thrmtrp_tmp3())
            }
        }
        #[doc = "Thermal Trip Temperature Diode 3A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ThrmtrpTmp3a(pub u8);
        impl ThrmtrpTmp3a {
            #[doc = "ThermTrip temperature high limit compared against External Diode 3A"]
            #[inline(always)]
            pub const fn thrmtrp_tmp3a(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "ThermTrip temperature high limit compared against External Diode 3A"]
            #[inline(always)]
            pub fn set_thrmtrp_tmp3a(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ThrmtrpTmp3a {
            #[inline(always)]
            fn default() -> ThrmtrpTmp3a {
                ThrmtrpTmp3a(0)
            }
        }
        impl core::fmt::Debug for ThrmtrpTmp3a {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ThrmtrpTmp3a")
                    .field("thrmtrp_tmp3a", &self.thrmtrp_tmp3a())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ThrmtrpTmp3a {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ThrmtrpTmp3a {{ thrmtrp_tmp3a: {=u8:?} }}", self.thrmtrp_tmp3a())
            }
        }
        #[doc = "Thermal Trip Temperature Diode 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ThrmtrpTmp4(pub u8);
        impl ThrmtrpTmp4 {
            #[doc = "ThermTrip temperature high limit compared against External Diode 4"]
            #[inline(always)]
            pub const fn thrmtrp_tmp4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "ThermTrip temperature high limit compared against External Diode 4"]
            #[inline(always)]
            pub fn set_thrmtrp_tmp4(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ThrmtrpTmp4 {
            #[inline(always)]
            fn default() -> ThrmtrpTmp4 {
                ThrmtrpTmp4(0)
            }
        }
        impl core::fmt::Debug for ThrmtrpTmp4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ThrmtrpTmp4")
                    .field("thrmtrp_tmp4", &self.thrmtrp_tmp4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ThrmtrpTmp4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ThrmtrpTmp4 {{ thrmtrp_tmp4: {=u8:?} }}", self.thrmtrp_tmp4())
            }
        }
        #[doc = "Thermal Trip Temperature Diode 4A Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ThrmtrpTmp4a(pub u8);
        impl ThrmtrpTmp4a {
            #[doc = "ThermTrip temperature high limit compared against External Diode 4A"]
            #[inline(always)]
            pub const fn thrmtrp_tmp4a(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "ThermTrip temperature high limit compared against External Diode 4A"]
            #[inline(always)]
            pub fn set_thrmtrp_tmp4a(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ThrmtrpTmp4a {
            #[inline(always)]
            fn default() -> ThrmtrpTmp4a {
                ThrmtrpTmp4a(0)
            }
        }
        impl core::fmt::Debug for ThrmtrpTmp4a {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ThrmtrpTmp4a")
                    .field("thrmtrp_tmp4a", &self.thrmtrp_tmp4a())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ThrmtrpTmp4a {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ThrmtrpTmp4a {{ thrmtrp_tmp4a: {=u8:?} }}", self.thrmtrp_tmp4a())
            }
        }
        #[doc = "Temp Interrupt Status Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TmpIntsts(pub u8);
        impl TmpIntsts {
            #[doc = "Controls whether the External Diode events generate an interrupt if the associated status bit is set."]
            #[inline(always)]
            pub const fn tmp_intsts(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Controls whether the External Diode events generate an interrupt if the associated status bit is set."]
            #[inline(always)]
            pub fn set_tmp_intsts(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for TmpIntsts {
            #[inline(always)]
            fn default() -> TmpIntsts {
                TmpIntsts(0)
            }
        }
        impl core::fmt::Debug for TmpIntsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TmpIntsts")
                    .field("tmp_intsts", &self.tmp_intsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TmpIntsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TmpIntsts {{ tmp_intsts: {=u8:?} }}", self.tmp_intsts())
            }
        }
        #[doc = "Unlock Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Unlck(pub u8);
        impl Unlck {
            #[doc = "Unlock Register"]
            #[inline(always)]
            pub const fn unlck(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Unlock Register"]
            #[inline(always)]
            pub fn set_unlck(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Unlck {
            #[inline(always)]
            fn default() -> Unlck {
                Unlck(0)
            }
        }
        impl core::fmt::Debug for Unlck {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Unlck").field("unlck", &self.unlck()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Unlck {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Unlck {{ unlck: {=u8:?} }}", self.unlck())
            }
        }
        #[doc = "VCP Limit Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VcpLimit(pub u16);
        impl VcpLimit {
            #[doc = "Limit for VCP Voltage Monitor"]
            #[inline(always)]
            pub const fn vcp_limit(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Limit for VCP Voltage Monitor"]
            #[inline(always)]
            pub fn set_vcp_limit(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for VcpLimit {
            #[inline(always)]
            fn default() -> VcpLimit {
                VcpLimit(0)
            }
        }
        impl core::fmt::Debug for VcpLimit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VcpLimit")
                    .field("vcp_limit", &self.vcp_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VcpLimit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VcpLimit {{ vcp_limit: {=u16:?} }}", self.vcp_limit())
            }
        }
        #[doc = "Stores the VCP Voltage Monitor data"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VcpVolt(pub u8);
        impl VcpVolt {
            #[doc = "Stores the VCP Voltage Monitor data"]
            #[inline(always)]
            pub const fn vcp_volt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the VCP Voltage Monitor data"]
            #[inline(always)]
            pub fn set_vcp_volt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for VcpVolt {
            #[inline(always)]
            fn default() -> VcpVolt {
                VcpVolt(0)
            }
        }
        impl core::fmt::Debug for VcpVolt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VcpVolt").field("vcp_volt", &self.vcp_volt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VcpVolt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VcpVolt {{ vcp_volt: {=u8:?} }}", self.vcp_volt())
            }
        }
        #[doc = "VIN Limit Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VinLimit(pub u16);
        impl VinLimit {
            #[doc = "Limit for VIN Voltage Monitor"]
            #[inline(always)]
            pub const fn vtt_limit(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Limit for VIN Voltage Monitor"]
            #[inline(always)]
            pub fn set_vtt_limit(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for VinLimit {
            #[inline(always)]
            fn default() -> VinLimit {
                VinLimit(0)
            }
        }
        impl core::fmt::Debug for VinLimit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VinLimit")
                    .field("vtt_limit", &self.vtt_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VinLimit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VinLimit {{ vtt_limit: {=u16:?} }}", self.vtt_limit())
            }
        }
        #[doc = "Stores the voltage Measured on VIN channel"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VinVolt(pub u8);
        impl VinVolt {
            #[doc = "Stores the voltage Measured on VIN channel"]
            #[inline(always)]
            pub const fn vin_volt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the voltage Measured on VIN channel"]
            #[inline(always)]
            pub fn set_vin_volt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for VinVolt {
            #[inline(always)]
            fn default() -> VinVolt {
                VinVolt(0)
            }
        }
        impl core::fmt::Debug for VinVolt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VinVolt").field("vin_volt", &self.vin_volt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VinVolt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VinVolt {{ vin_volt: {=u8:?} }}", self.vin_volt())
            }
        }
        #[doc = "Volt Interrupt Status Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VltInten(pub u8);
        impl VltInten {
            #[doc = "Controls whether the Voltage event generate an interrupt if the associated status bit is set."]
            #[inline(always)]
            pub const fn vlt_inten(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Controls whether the Voltage event generate an interrupt if the associated status bit is set."]
            #[inline(always)]
            pub fn set_vlt_inten(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for VltInten {
            #[inline(always)]
            fn default() -> VltInten {
                VltInten(0)
            }
        }
        impl core::fmt::Debug for VltInten {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VltInten")
                    .field("vlt_inten", &self.vlt_inten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VltInten {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VltInten {{ vlt_inten: {=u8:?} }}", self.vlt_inten())
            }
        }
        #[doc = "Volt Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VltIntsts(pub u8);
        impl VltIntsts {
            #[doc = "Stores the status bits for voltage inputs"]
            #[inline(always)]
            pub const fn vltintsts(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the status bits for voltage inputs"]
            #[inline(always)]
            pub fn set_vltintsts(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for VltIntsts {
            #[inline(always)]
            fn default() -> VltIntsts {
                VltIntsts(0)
            }
        }
        impl core::fmt::Debug for VltIntsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VltIntsts")
                    .field("vltintsts", &self.vltintsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VltIntsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VltIntsts {{ vltintsts: {=u8:?} }}", self.vltintsts())
            }
        }
        #[doc = "Controls Voltage sensing for external voltages"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VoltCfg(pub u8);
        impl VoltCfg {
            #[doc = "Controls Voltage sensing for external voltages"]
            #[inline(always)]
            pub const fn volt_cfg(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Controls Voltage sensing for external voltages"]
            #[inline(always)]
            pub fn set_volt_cfg(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for VoltCfg {
            #[inline(always)]
            fn default() -> VoltCfg {
                VoltCfg(0)
            }
        }
        impl core::fmt::Debug for VoltCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VoltCfg").field("volt_cfg", &self.volt_cfg()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VoltCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VoltCfg {{ volt_cfg: {=u8:?} }}", self.volt_cfg())
            }
        }
        #[doc = "VSET Voltage Reading Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VsetVlt(pub u8);
        impl VsetVlt {
            #[doc = "Stores the VSET Voltage Monitor reading"]
            #[inline(always)]
            pub const fn vset_vlt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the VSET Voltage Monitor reading"]
            #[inline(always)]
            pub fn set_vset_vlt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for VsetVlt {
            #[inline(always)]
            fn default() -> VsetVlt {
                VsetVlt(0)
            }
        }
        impl core::fmt::Debug for VsetVlt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VsetVlt").field("vset_vlt", &self.vset_vlt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VsetVlt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VsetVlt {{ vset_vlt: {=u8:?} }}", self.vset_vlt())
            }
        }
        #[doc = "VTR Limit Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VtrLimit(pub u16);
        impl VtrLimit {
            #[doc = "Limit for VTR Voltage Monitor"]
            #[inline(always)]
            pub const fn vtr_limit(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Limit for VTR Voltage Monitor"]
            #[inline(always)]
            pub fn set_vtr_limit(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for VtrLimit {
            #[inline(always)]
            fn default() -> VtrLimit {
                VtrLimit(0)
            }
        }
        impl core::fmt::Debug for VtrLimit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VtrLimit")
                    .field("vtr_limit", &self.vtr_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VtrLimit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VtrLimit {{ vtr_limit: {=u16:?} }}", self.vtr_limit())
            }
        }
        #[doc = "VTT Limit Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VttLimit(pub u16);
        impl VttLimit {
            #[doc = "Limit for VTT Voltage Monitor"]
            #[inline(always)]
            pub const fn vtt_limit(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Limit for VTT Voltage Monitor"]
            #[inline(always)]
            pub fn set_vtt_limit(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for VttLimit {
            #[inline(always)]
            fn default() -> VttLimit {
                VttLimit(0)
            }
        }
        impl core::fmt::Debug for VttLimit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VttLimit")
                    .field("vtt_limit", &self.vtt_limit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VttLimit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VttLimit {{ vtt_limit: {=u16:?} }}", self.vtt_limit())
            }
        }
        #[doc = "Stores the VTT Voltage Monitor data"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VttVolt(pub u8);
        impl VttVolt {
            #[doc = "Stores the VTT Voltage Monitor data"]
            #[inline(always)]
            pub const fn vtt_volt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Stores the VTT Voltage Monitor data"]
            #[inline(always)]
            pub fn set_vtt_volt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for VttVolt {
            #[inline(always)]
            fn default() -> VttVolt {
                VttVolt(0)
            }
        }
        impl core::fmt::Debug for VttVolt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VttVolt").field("vtt_volt", &self.vtt_volt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VttVolt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "VttVolt {{ vtt_volt: {=u8:?} }}", self.vtt_volt())
            }
        }
    }
}
pub mod fpu {
    #[doc = "Floating Point Unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fpu {
        ptr: *mut u8,
    }
    unsafe impl Send for Fpu {}
    unsafe impl Sync for Fpu {}
    impl Fpu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Floating-Point Context Control Register"]
        #[inline(always)]
        pub const fn fpccr(self) -> crate::common::Reg<regs::Fpccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Floating-Point Context Address Register"]
        #[inline(always)]
        pub const fn fpcar(self) -> crate::common::Reg<regs::Fpcar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Floating-Point Default Status Control Register"]
        #[inline(always)]
        pub const fn fpdscr(self) -> crate::common::Reg<regs::Fpdscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Media and FP Feature Register 0"]
        #[inline(always)]
        pub const fn mvfr0(self) -> crate::common::Reg<regs::Mvfr0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Media and FP Feature Register 1"]
        #[inline(always)]
        pub const fn mvfr1(self) -> crate::common::Reg<regs::Mvfr1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Floating-Point Context Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpcar(pub u32);
        impl Fpcar {
            #[doc = "Address for FP registers in exception stack frame"]
            #[inline(always)]
            pub const fn address(&self) -> u32 {
                let val = (self.0 >> 3usize) & 0x1fff_ffff;
                val as u32
            }
            #[doc = "Address for FP registers in exception stack frame"]
            #[inline(always)]
            pub fn set_address(&mut self, val: u32) {
                self.0 = (self.0 & !(0x1fff_ffff << 3usize)) | (((val as u32) & 0x1fff_ffff) << 3usize);
            }
        }
        impl Default for Fpcar {
            #[inline(always)]
            fn default() -> Fpcar {
                Fpcar(0)
            }
        }
        impl core::fmt::Debug for Fpcar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpcar").field("address", &self.address()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpcar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fpcar {{ address: {=u32:?} }}", self.address())
            }
        }
        #[doc = "Floating-Point Context Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpccr(pub u32);
        impl Fpccr {
            #[inline(always)]
            pub const fn lspact(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_lspact(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[inline(always)]
            pub const fn user(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_user(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn thread(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_thread(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[inline(always)]
            pub const fn hfrdy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_hfrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn mmrdy(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_mmrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn bfrdy(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_bfrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[inline(always)]
            pub const fn monrdy(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_monrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[inline(always)]
            pub const fn lspen(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_lspen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[inline(always)]
            pub const fn aspen(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_aspen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Fpccr {
            #[inline(always)]
            fn default() -> Fpccr {
                Fpccr(0)
            }
        }
        impl core::fmt::Debug for Fpccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpccr")
                    .field("lspact", &self.lspact())
                    .field("user", &self.user())
                    .field("thread", &self.thread())
                    .field("hfrdy", &self.hfrdy())
                    .field("mmrdy", &self.mmrdy())
                    .field("bfrdy", &self.bfrdy())
                    .field("monrdy", &self.monrdy())
                    .field("lspen", &self.lspen())
                    .field("aspen", &self.aspen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpccr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Fpccr {{ lspact: {=bool:?}, user: {=bool:?}, thread: {=bool:?}, hfrdy: {=bool:?}, mmrdy: {=bool:?}, bfrdy: {=bool:?}, monrdy: {=bool:?}, lspen: {=bool:?}, aspen: {=bool:?} }}" , self . lspact () , self . user () , self . thread () , self . hfrdy () , self . mmrdy () , self . bfrdy () , self . monrdy () , self . lspen () , self . aspen ())
            }
        }
        #[doc = "Floating-Point Default Status Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpdscr(pub u32);
        impl Fpdscr {
            #[doc = "Default value for FPSCR.RMODE"]
            #[inline(always)]
            pub const fn rmode(&self) -> super::vals::Rmode {
                let val = (self.0 >> 22usize) & 0x03;
                super::vals::Rmode::from_bits(val as u8)
            }
            #[doc = "Default value for FPSCR.RMODE"]
            #[inline(always)]
            pub fn set_rmode(&mut self, val: super::vals::Rmode) {
                self.0 = (self.0 & !(0x03 << 22usize)) | (((val.to_bits() as u32) & 0x03) << 22usize);
            }
            #[doc = "Default value for FPSCR.FZ"]
            #[inline(always)]
            pub const fn fz(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Default value for FPSCR.FZ"]
            #[inline(always)]
            pub fn set_fz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Default value for FPSCR.DN"]
            #[inline(always)]
            pub const fn dn(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Default value for FPSCR.DN"]
            #[inline(always)]
            pub fn set_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Default value for FPSCR.AHP"]
            #[inline(always)]
            pub const fn ahp(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Default value for FPSCR.AHP"]
            #[inline(always)]
            pub fn set_ahp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
        }
        impl Default for Fpdscr {
            #[inline(always)]
            fn default() -> Fpdscr {
                Fpdscr(0)
            }
        }
        impl core::fmt::Debug for Fpdscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpdscr")
                    .field("rmode", &self.rmode())
                    .field("fz", &self.fz())
                    .field("dn", &self.dn())
                    .field("ahp", &self.ahp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpdscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fpdscr {{ rmode: {:?}, fz: {=bool:?}, dn: {=bool:?}, ahp: {=bool:?} }}",
                    self.rmode(),
                    self.fz(),
                    self.dn(),
                    self.ahp()
                )
            }
        }
        #[doc = "Media and FP Feature Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mvfr0(pub u32);
        impl Mvfr0 {
            #[inline(always)]
            pub const fn a_simd_registers(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_a_simd_registers(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[inline(always)]
            pub const fn single_precision(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_single_precision(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[inline(always)]
            pub const fn double_precision(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_double_precision(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[inline(always)]
            pub const fn fp_excep_trapping(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_fp_excep_trapping(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[inline(always)]
            pub const fn divide(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_divide(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[inline(always)]
            pub const fn square_root(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_square_root(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[inline(always)]
            pub const fn short_vectors(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_short_vectors(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[inline(always)]
            pub const fn fp_rounding_modes(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_fp_rounding_modes(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Mvfr0 {
            #[inline(always)]
            fn default() -> Mvfr0 {
                Mvfr0(0)
            }
        }
        impl core::fmt::Debug for Mvfr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mvfr0")
                    .field("a_simd_registers", &self.a_simd_registers())
                    .field("single_precision", &self.single_precision())
                    .field("double_precision", &self.double_precision())
                    .field("fp_excep_trapping", &self.fp_excep_trapping())
                    .field("divide", &self.divide())
                    .field("square_root", &self.square_root())
                    .field("short_vectors", &self.short_vectors())
                    .field("fp_rounding_modes", &self.fp_rounding_modes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mvfr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mvfr0 {{ a_simd_registers: {=u8:?}, single_precision: {=u8:?}, double_precision: {=u8:?}, fp_excep_trapping: {=u8:?}, divide: {=u8:?}, square_root: {=u8:?}, short_vectors: {=u8:?}, fp_rounding_modes: {=u8:?} }}" , self . a_simd_registers () , self . single_precision () , self . double_precision () , self . fp_excep_trapping () , self . divide () , self . square_root () , self . short_vectors () , self . fp_rounding_modes ())
            }
        }
        #[doc = "Media and FP Feature Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mvfr1(pub u32);
        impl Mvfr1 {
            #[inline(always)]
            pub const fn ft_z_mode(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_ft_z_mode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[inline(always)]
            pub const fn d_na_n_mode(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_d_na_n_mode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[inline(always)]
            pub const fn fp_hpfp(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_fp_hpfp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[inline(always)]
            pub const fn fp_fused_mac(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[inline(always)]
            pub fn set_fp_fused_mac(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Mvfr1 {
            #[inline(always)]
            fn default() -> Mvfr1 {
                Mvfr1(0)
            }
        }
        impl core::fmt::Debug for Mvfr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mvfr1")
                    .field("ft_z_mode", &self.ft_z_mode())
                    .field("d_na_n_mode", &self.d_na_n_mode())
                    .field("fp_hpfp", &self.fp_hpfp())
                    .field("fp_fused_mac", &self.fp_fused_mac())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mvfr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mvfr1 {{ ft_z_mode: {=u8:?}, d_na_n_mode: {=u8:?}, fp_hpfp: {=u8:?}, fp_fused_mac: {=u8:?} }}",
                    self.ft_z_mode(),
                    self.d_na_n_mode(),
                    self.fp_hpfp(),
                    self.fp_fused_mac()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rmode {
            #[doc = "Round to Nearest"]
            RN = 0x0,
            #[doc = "Round towards Positive Infinity"]
            RP = 0x01,
            #[doc = "Round towards Negative Infinity"]
            RM = 0x02,
            #[doc = "Round towards Zero"]
            RZ = 0x03,
        }
        impl Rmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rmode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rmode {
            #[inline(always)]
            fn from(val: u8) -> Rmode {
                Rmode::from_bits(val)
            }
        }
        impl From<Rmode> for u8 {
            #[inline(always)]
            fn from(val: Rmode) -> u8 {
                Rmode::to_bits(val)
            }
        }
    }
}
pub mod gcr {
    #[doc = "The Logical Device Configuration registers support motherboard designs in which the resources required by their components are known and assigned by the BIOS at POST."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gcr {
        ptr: *mut u8,
    }
    unsafe impl Send for Gcr {}
    unsafe impl Sync for Gcr {}
    impl Gcr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "A write to this register selects the current logical device. This allows access to the control and configuration registers for each logical device. Note: The Activate command operates only on the selected logical device."]
        #[inline(always)]
        pub const fn ldn(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "A read-only register which provides device revision information."]
        #[inline(always)]
        pub const fn dev_rev(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "A read-only register which provides device sub ID information."]
        #[inline(always)]
        pub const fn dev_subid(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1dusize) as _) }
        }
        #[doc = "A read-only register which provides device identification LSB."]
        #[inline(always)]
        pub const fn dev_id(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1eusize) as _) }
        }
        #[doc = "A read-only register which provides legacy device identification."]
        #[inline(always)]
        pub const fn leg_dev_id(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "A read-only register which provides legacy device revision information."]
        #[inline(always)]
        pub const fn leg_dev_rev(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x21usize) as _) }
        }
        #[doc = "A read-only register which provides OTP ID information."]
        #[inline(always)]
        pub const fn otp_id(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "A read-only register which provides Validation ID information."]
        #[inline(always)]
        pub const fn vld_id(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x25usize) as _) }
        }
        #[doc = "A read-only register which provides Boot ROM Revision ID information."]
        #[inline(always)]
        pub const fn br_rev_id(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x26usize) as _) }
        }
    }
}
pub mod gpio {
    #[doc = "GPIO Pin Control Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpio {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpio {}
    unsafe impl Sync for Gpio {}
    impl Gpio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[inline(always)]
        pub const fn port0(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[inline(always)]
        pub const fn port1(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[inline(always)]
        pub const fn port2(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[inline(always)]
        pub const fn port3(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[inline(always)]
        pub const fn port4(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[inline(always)]
        pub const fn port5(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[inline(always)]
        pub const fn port6(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[inline(always)]
        pub const fn port7(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0xe0usize) as _) }
        }
        #[inline(always)]
        pub const fn port10(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[inline(always)]
        pub const fn port11(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[inline(always)]
        pub const fn port12(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[inline(always)]
        pub const fn port13(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0160usize) as _) }
        }
        #[inline(always)]
        pub const fn port14(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[inline(always)]
        pub const fn port15(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x01a0usize) as _) }
        }
        #[inline(always)]
        pub const fn port16(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x01c0usize) as _) }
        }
        #[inline(always)]
        pub const fn port17(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x01e0usize) as _) }
        }
        #[inline(always)]
        pub const fn port20(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[inline(always)]
        pub const fn port21(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0220usize) as _) }
        }
        #[inline(always)]
        pub const fn port22(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0240usize) as _) }
        }
        #[inline(always)]
        pub const fn port23(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0260usize) as _) }
        }
        #[inline(always)]
        pub const fn port24(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x0280usize) as _) }
        }
        #[inline(always)]
        pub const fn port25(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x02a0usize) as _) }
        }
        #[inline(always)]
        pub const fn port26(self) -> Port {
            unsafe { Port::from_ptr(self.ptr.add(0x02c0usize) as _) }
        }
        #[doc = "The GPIO Input Registers."]
        #[inline(always)]
        pub const fn parin(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize + n * 4usize) as _) }
        }
        #[doc = "The GPIO Output Registers."]
        #[inline(always)]
        pub const fn parout(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0380usize + n * 4usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port {
        ptr: *mut u8,
    }
    unsafe impl Send for Port {}
    unsafe impl Sync for Port {}
    impl Port {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "GPIO Pin Control Register"]
        #[inline(always)]
        pub const fn ctrl1(self, n: usize) -> crate::common::Reg<regs::Ctrl1, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "The GPIO PIN_CTRL2 Registers"]
        #[inline(always)]
        pub const fn ctrl2(self, n: usize) -> crate::common::Reg<regs::Ctrl2, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "GPIO Pin Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl1(pub u32);
        impl Ctrl1 {
            #[doc = "These bits are used to enable an internal pull-up or pull-down resistor."]
            #[inline(always)]
            pub const fn pu_pd(&self) -> super::super::Pull {
                let val = (self.0 >> 0usize) & 0x03;
                super::super::Pull::from_bits(val as u8)
            }
            #[doc = "These bits are used to enable an internal pull-up or pull-down resistor."]
            #[inline(always)]
            pub fn set_pu_pd(&mut self, val: super::super::Pull) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "The GPIO pin will be tristated when the selected power well is off."]
            #[inline(always)]
            pub const fn pwr_gating(&self) -> super::super::Pgs {
                let val = (self.0 >> 2usize) & 0x03;
                super::super::Pgs::from_bits(val as u8)
            }
            #[doc = "The GPIO pin will be tristated when the selected power well is off."]
            #[inline(always)]
            pub fn set_pwr_gating(&mut self, val: super::super::Pgs) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Determines the interrupt capability of the GPIO input."]
            #[inline(always)]
            pub const fn intr_det(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "Determines the interrupt capability of the GPIO input."]
            #[inline(always)]
            pub fn set_intr_det(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
            }
            #[doc = "Determines the interrupt capability of the GPIO input."]
            #[inline(always)]
            pub const fn edge_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Determines the interrupt capability of the GPIO input."]
            #[inline(always)]
            pub fn set_edge_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "0 = Push-Pull, 1 = Open Drain"]
            #[inline(always)]
            pub const fn out_buff_type(&self) -> super::super::BufferType {
                let val = (self.0 >> 8usize) & 0x01;
                super::super::BufferType::from_bits(val as u8)
            }
            #[doc = "0 = Push-Pull, 1 = Open Drain"]
            #[inline(always)]
            pub fn set_out_buff_type(&mut self, val: super::super::BufferType) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"]
            #[inline(always)]
            pub const fn dir(&self) -> super::super::Dir {
                let val = (self.0 >> 9usize) & 0x01;
                super::super::Dir::from_bits(val as u8)
            }
            #[doc = "Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::super::Dir) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."]
            #[inline(always)]
            pub const fn out_sel(&self) -> super::super::Sel {
                let val = (self.0 >> 10usize) & 0x01;
                super::super::Sel::from_bits(val as u8)
            }
            #[doc = "GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register."]
            #[inline(always)]
            pub fn set_out_sel(&mut self, val: super::super::Sel) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "1=Inverted; 0=Non-inverted"]
            #[inline(always)]
            pub const fn pol(&self) -> super::super::Pol {
                let val = (self.0 >> 11usize) & 0x01;
                super::super::Pol::from_bits(val as u8)
            }
            #[doc = "1=Inverted; 0=Non-inverted"]
            #[inline(always)]
            pub fn set_pol(&mut self, val: super::super::Pol) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3."]
            #[inline(always)]
            pub const fn mux_ctrl(&self) -> super::super::Function {
                let val = (self.0 >> 12usize) & 0x07;
                super::super::Function::from_bits(val as u8)
            }
            #[doc = "00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3."]
            #[inline(always)]
            pub fn set_mux_ctrl(&mut self, val: super::super::Function) {
                self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
            }
            #[doc = "GPIO input disable"]
            #[inline(always)]
            pub const fn inp_dis(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO input disable"]
            #[inline(always)]
            pub fn set_inp_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "GPIO Alternate Data Register."]
            #[inline(always)]
            pub const fn alt_data(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO Alternate Data Register."]
            #[inline(always)]
            pub fn set_alt_data(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "GPIO input from pin, independent of the Mux selection for the pin or the Direction."]
            #[inline(always)]
            pub const fn inp(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO input from pin, independent of the Mux selection for the pin or the Direction."]
            #[inline(always)]
            pub fn set_inp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Ctrl1 {
            #[inline(always)]
            fn default() -> Ctrl1 {
                Ctrl1(0)
            }
        }
        impl core::fmt::Debug for Ctrl1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl1")
                    .field("pu_pd", &self.pu_pd())
                    .field("pwr_gating", &self.pwr_gating())
                    .field("intr_det", &self.intr_det())
                    .field("edge_en", &self.edge_en())
                    .field("out_buff_type", &self.out_buff_type())
                    .field("dir", &self.dir())
                    .field("out_sel", &self.out_sel())
                    .field("pol", &self.pol())
                    .field("mux_ctrl", &self.mux_ctrl())
                    .field("inp_dis", &self.inp_dis())
                    .field("alt_data", &self.alt_data())
                    .field("inp", &self.inp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl1 {{ pu_pd: {:?}, pwr_gating: {:?}, intr_det: {=u8:?}, edge_en: {=bool:?}, out_buff_type: {:?}, dir: {:?}, out_sel: {:?}, pol: {:?}, mux_ctrl: {:?}, inp_dis: {=bool:?}, alt_data: {=bool:?}, inp: {=bool:?} }}" , self . pu_pd () , self . pwr_gating () , self . intr_det () , self . edge_en () , self . out_buff_type () , self . dir () , self . out_sel () , self . pol () , self . mux_ctrl () , self . inp_dis () , self . alt_data () , self . inp ())
            }
        }
        #[doc = "The GPIO PIN_CTRL2 Registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl2(pub u32);
        impl Ctrl2 {
            #[doc = "Selects slew rate on the pin. 1=fast 0=slow"]
            #[inline(always)]
            pub const fn slew_ctrl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects slew rate on the pin. 1=fast 0=slow"]
            #[inline(always)]
            pub fn set_slew_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA"]
            #[inline(always)]
            pub const fn driv_stren(&self) -> super::vals::Ctrl2p0drivStren {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Ctrl2p0drivStren::from_bits(val as u8)
            }
            #[doc = "Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA"]
            #[inline(always)]
            pub fn set_driv_stren(&mut self, val: super::vals::Ctrl2p0drivStren) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
        }
        impl Default for Ctrl2 {
            #[inline(always)]
            fn default() -> Ctrl2 {
                Ctrl2(0)
            }
        }
        impl core::fmt::Debug for Ctrl2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl2")
                    .field("slew_ctrl", &self.slew_ctrl())
                    .field("driv_stren", &self.driv_stren())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl2 {{ slew_ctrl: {=bool:?}, driv_stren: {:?} }}",
                    self.slew_ctrl(),
                    self.driv_stren()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl0muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl0muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl0muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl0muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl0muxCtrl {
                Ctrl0muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl0muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl0muxCtrl) -> u8 {
                Ctrl0muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl0puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl0puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl0puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl0puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl0puPd {
                Ctrl0puPd::from_bits(val)
            }
        }
        impl From<Ctrl0puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl0puPd) -> u8 {
                Ctrl0puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl10muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl10muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl10muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl10muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl10muxCtrl {
                Ctrl10muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl10muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl10muxCtrl) -> u8 {
                Ctrl10muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl10puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl10puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl10puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl10puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl10puPd {
                Ctrl10puPd::from_bits(val)
            }
        }
        impl From<Ctrl10puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl10puPd) -> u8 {
                Ctrl10puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl11muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl11muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl11muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl11muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl11muxCtrl {
                Ctrl11muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl11muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl11muxCtrl) -> u8 {
                Ctrl11muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl11puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl11puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl11puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl11puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl11puPd {
                Ctrl11puPd::from_bits(val)
            }
        }
        impl From<Ctrl11puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl11puPd) -> u8 {
                Ctrl11puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl12muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl12muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl12muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl12muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl12muxCtrl {
                Ctrl12muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl12muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl12muxCtrl) -> u8 {
                Ctrl12muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl12puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl12puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl12puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl12puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl12puPd {
                Ctrl12puPd::from_bits(val)
            }
        }
        impl From<Ctrl12puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl12puPd) -> u8 {
                Ctrl12puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl13muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl13muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl13muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl13muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl13muxCtrl {
                Ctrl13muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl13muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl13muxCtrl) -> u8 {
                Ctrl13muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl13puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl13puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl13puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl13puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl13puPd {
                Ctrl13puPd::from_bits(val)
            }
        }
        impl From<Ctrl13puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl13puPd) -> u8 {
                Ctrl13puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl14muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl14muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl14muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl14muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl14muxCtrl {
                Ctrl14muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl14muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl14muxCtrl) -> u8 {
                Ctrl14muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl14puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl14puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl14puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl14puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl14puPd {
                Ctrl14puPd::from_bits(val)
            }
        }
        impl From<Ctrl14puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl14puPd) -> u8 {
                Ctrl14puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl15muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl15muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl15muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl15muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl15muxCtrl {
                Ctrl15muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl15muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl15muxCtrl) -> u8 {
                Ctrl15muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl15puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl15puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl15puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl15puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl15puPd {
                Ctrl15puPd::from_bits(val)
            }
        }
        impl From<Ctrl15puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl15puPd) -> u8 {
                Ctrl15puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl16muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl16muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl16muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl16muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl16muxCtrl {
                Ctrl16muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl16muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl16muxCtrl) -> u8 {
                Ctrl16muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl16puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl16puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl16puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl16puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl16puPd {
                Ctrl16puPd::from_bits(val)
            }
        }
        impl From<Ctrl16puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl16puPd) -> u8 {
                Ctrl16puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl17muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl17muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl17muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl17muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl17muxCtrl {
                Ctrl17muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl17muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl17muxCtrl) -> u8 {
                Ctrl17muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl17puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl17puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl17puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl17puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl17puPd {
                Ctrl17puPd::from_bits(val)
            }
        }
        impl From<Ctrl17puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl17puPd) -> u8 {
                Ctrl17puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl1muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl1muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl1muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl1muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl1muxCtrl {
                Ctrl1muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl1muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl1muxCtrl) -> u8 {
                Ctrl1muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl1puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl1puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl1puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl1puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl1puPd {
                Ctrl1puPd::from_bits(val)
            }
        }
        impl From<Ctrl1puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl1puPd) -> u8 {
                Ctrl1puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl20muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl20muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl20muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl20muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl20muxCtrl {
                Ctrl20muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl20muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl20muxCtrl) -> u8 {
                Ctrl20muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl20puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl20puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl20puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl20puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl20puPd {
                Ctrl20puPd::from_bits(val)
            }
        }
        impl From<Ctrl20puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl20puPd) -> u8 {
                Ctrl20puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl21muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl21muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl21muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl21muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl21muxCtrl {
                Ctrl21muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl21muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl21muxCtrl) -> u8 {
                Ctrl21muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl21puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl21puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl21puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl21puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl21puPd {
                Ctrl21puPd::from_bits(val)
            }
        }
        impl From<Ctrl21puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl21puPd) -> u8 {
                Ctrl21puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl22muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl22muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl22muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl22muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl22muxCtrl {
                Ctrl22muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl22muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl22muxCtrl) -> u8 {
                Ctrl22muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl22puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl22puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl22puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl22puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl22puPd {
                Ctrl22puPd::from_bits(val)
            }
        }
        impl From<Ctrl22puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl22puPd) -> u8 {
                Ctrl22puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl23muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl23muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl23muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl23muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl23muxCtrl {
                Ctrl23muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl23muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl23muxCtrl) -> u8 {
                Ctrl23muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl23puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl23puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl23puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl23puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl23puPd {
                Ctrl23puPd::from_bits(val)
            }
        }
        impl From<Ctrl23puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl23puPd) -> u8 {
                Ctrl23puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl24muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl24muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl24muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl24muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl24muxCtrl {
                Ctrl24muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl24muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl24muxCtrl) -> u8 {
                Ctrl24muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl24puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl24puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl24puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl24puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl24puPd {
                Ctrl24puPd::from_bits(val)
            }
        }
        impl From<Ctrl24puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl24puPd) -> u8 {
                Ctrl24puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl25muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl25muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl25muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl25muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl25muxCtrl {
                Ctrl25muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl25muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl25muxCtrl) -> u8 {
                Ctrl25muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl25puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl25puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl25puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl25puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl25puPd {
                Ctrl25puPd::from_bits(val)
            }
        }
        impl From<Ctrl25puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl25puPd) -> u8 {
                Ctrl25puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl26muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl26muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl26muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl26muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl26muxCtrl {
                Ctrl26muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl26muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl26muxCtrl) -> u8 {
                Ctrl26muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl26puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl26puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl26puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl26puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl26puPd {
                Ctrl26puPd::from_bits(val)
            }
        }
        impl From<Ctrl26puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl26puPd) -> u8 {
                Ctrl26puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl2muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2muxCtrl {
                Ctrl2muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl2muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2muxCtrl) -> u8 {
                Ctrl2muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p0drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p0drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p0drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p0drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p0drivStren {
                Ctrl2p0drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p0drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p0drivStren) -> u8 {
                Ctrl2p0drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p10drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p10drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p10drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p10drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p10drivStren {
                Ctrl2p10drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p10drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p10drivStren) -> u8 {
                Ctrl2p10drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p11drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p11drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p11drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p11drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p11drivStren {
                Ctrl2p11drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p11drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p11drivStren) -> u8 {
                Ctrl2p11drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p12drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p12drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p12drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p12drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p12drivStren {
                Ctrl2p12drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p12drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p12drivStren) -> u8 {
                Ctrl2p12drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p13drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p13drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p13drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p13drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p13drivStren {
                Ctrl2p13drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p13drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p13drivStren) -> u8 {
                Ctrl2p13drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p14drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p14drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p14drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p14drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p14drivStren {
                Ctrl2p14drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p14drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p14drivStren) -> u8 {
                Ctrl2p14drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p15drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p15drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p15drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p15drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p15drivStren {
                Ctrl2p15drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p15drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p15drivStren) -> u8 {
                Ctrl2p15drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p16drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p16drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p16drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p16drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p16drivStren {
                Ctrl2p16drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p16drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p16drivStren) -> u8 {
                Ctrl2p16drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p17drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p17drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p17drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p17drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p17drivStren {
                Ctrl2p17drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p17drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p17drivStren) -> u8 {
                Ctrl2p17drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p1drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p1drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p1drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p1drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p1drivStren {
                Ctrl2p1drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p1drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p1drivStren) -> u8 {
                Ctrl2p1drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p20drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p20drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p20drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p20drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p20drivStren {
                Ctrl2p20drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p20drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p20drivStren) -> u8 {
                Ctrl2p20drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p21drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p21drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p21drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p21drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p21drivStren {
                Ctrl2p21drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p21drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p21drivStren) -> u8 {
                Ctrl2p21drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p22drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p22drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p22drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p22drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p22drivStren {
                Ctrl2p22drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p22drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p22drivStren) -> u8 {
                Ctrl2p22drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p23drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p23drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p23drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p23drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p23drivStren {
                Ctrl2p23drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p23drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p23drivStren) -> u8 {
                Ctrl2p23drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p24drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p24drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p24drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p24drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p24drivStren {
                Ctrl2p24drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p24drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p24drivStren) -> u8 {
                Ctrl2p24drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p25drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p25drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p25drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p25drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p25drivStren {
                Ctrl2p25drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p25drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p25drivStren) -> u8 {
                Ctrl2p25drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p26drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p26drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p26drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p26drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p26drivStren {
                Ctrl2p26drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p26drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p26drivStren) -> u8 {
                Ctrl2p26drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p2drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p2drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p2drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p2drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p2drivStren {
                Ctrl2p2drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p2drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p2drivStren) -> u8 {
                Ctrl2p2drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p3drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p3drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p3drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p3drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p3drivStren {
                Ctrl2p3drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p3drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p3drivStren) -> u8 {
                Ctrl2p3drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p4drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p4drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p4drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p4drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p4drivStren {
                Ctrl2p4drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p4drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p4drivStren) -> u8 {
                Ctrl2p4drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p5drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p5drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p5drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p5drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p5drivStren {
                Ctrl2p5drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p5drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p5drivStren) -> u8 {
                Ctrl2p5drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p6drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p6drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p6drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p6drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p6drivStren {
                Ctrl2p6drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p6drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p6drivStren) -> u8 {
                Ctrl2p6drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2p7drivStren {
            #[doc = "For PIO12 = 2mA, PIO24 = 4mA"]
            LEVEL0 = 0x0,
            #[doc = "For PIO12 = 4mA, PIO24 = 8mA"]
            LEVEL1 = 0x01,
            #[doc = "For PIO12 = 8mA, PIO24 = 16mA"]
            LEVEL2 = 0x02,
            #[doc = "For PIO12 = 12mA, PIO24 = 24mA"]
            LEVEL3 = 0x03,
        }
        impl Ctrl2p7drivStren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2p7drivStren {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2p7drivStren {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2p7drivStren {
                Ctrl2p7drivStren::from_bits(val)
            }
        }
        impl From<Ctrl2p7drivStren> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2p7drivStren) -> u8 {
                Ctrl2p7drivStren::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl2puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl2puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl2puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl2puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl2puPd {
                Ctrl2puPd::from_bits(val)
            }
        }
        impl From<Ctrl2puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl2puPd) -> u8 {
                Ctrl2puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl3muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl3muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl3muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl3muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl3muxCtrl {
                Ctrl3muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl3muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl3muxCtrl) -> u8 {
                Ctrl3muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl3puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl3puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl3puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl3puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl3puPd {
                Ctrl3puPd::from_bits(val)
            }
        }
        impl From<Ctrl3puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl3puPd) -> u8 {
                Ctrl3puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl4muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl4muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl4muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl4muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl4muxCtrl {
                Ctrl4muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl4muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl4muxCtrl) -> u8 {
                Ctrl4muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl4puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl4puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl4puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl4puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl4puPd {
                Ctrl4puPd::from_bits(val)
            }
        }
        impl From<Ctrl4puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl4puPd) -> u8 {
                Ctrl4puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl5muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl5muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl5muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl5muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl5muxCtrl {
                Ctrl5muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl5muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl5muxCtrl) -> u8 {
                Ctrl5muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl5puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl5puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl5puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl5puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl5puPd {
                Ctrl5puPd::from_bits(val)
            }
        }
        impl From<Ctrl5puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl5puPd) -> u8 {
                Ctrl5puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl6muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl6muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl6muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl6muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl6muxCtrl {
                Ctrl6muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl6muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl6muxCtrl) -> u8 {
                Ctrl6muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl6puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl6puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl6puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl6puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl6puPd {
                Ctrl6puPd::from_bits(val)
            }
        }
        impl From<Ctrl6puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl6puPd) -> u8 {
                Ctrl6puPd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl7muxCtrl {
            #[doc = "GPIO function selected"]
            GPIO = 0x0,
            #[doc = "Signal function 1 selected"]
            FUNC1 = 0x01,
            #[doc = "Signal function 2 selected"]
            FUNC2 = 0x02,
            #[doc = "Signal function 3 selected"]
            FUNC3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrl7muxCtrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl7muxCtrl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl7muxCtrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl7muxCtrl {
                Ctrl7muxCtrl::from_bits(val)
            }
        }
        impl From<Ctrl7muxCtrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl7muxCtrl) -> u8 {
                Ctrl7muxCtrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl7puPd {
            #[doc = "None. Pin tristates when no active driver is present on the pin."]
            NONE = 0x0,
            #[doc = "Pull Up Enabled"]
            UP = 0x01,
            #[doc = "Pull Down Enabled"]
            DOWN = 0x02,
            #[doc = "Repeater mode. Pin is kept at previous voltage level when no active driver is present on the pin."]
            REPEATER = 0x03,
        }
        impl Ctrl7puPd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl7puPd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl7puPd {
            #[inline(always)]
            fn from(val: u8) -> Ctrl7puPd {
                Ctrl7puPd::from_bits(val)
            }
        }
        impl From<Ctrl7puPd> for u8 {
            #[inline(always)]
            fn from(val: Ctrl7puPd) -> u8 {
                Ctrl7puPd::to_bits(val)
            }
        }
    }
}
pub mod htm0 {
    #[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Htm0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Htm0 {}
    unsafe impl Sync for Htm0 {}
    impl Htm0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "15:0\\] This register is used to set the Hibernation Timer Preload value."]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "HTimer Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The current state of the Hibernation Timer."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "HTimer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u16);
        impl Ctrl {
            #[doc = "1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours. 0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds."]
            #[inline(always)]
            pub const fn ctrl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours. 0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds."]
            #[inline(always)]
            pub fn set_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl").field("ctrl", &self.ctrl()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctrl {{ ctrl: {=bool:?} }}", self.ctrl())
            }
        }
    }
}
pub mod imspi {
    #[doc = "Internal Master SPI."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Imspi {
        ptr: *mut u8,
    }
    unsafe impl Send for Imspi {}
    unsafe impl Sync for Imspi {}
    impl Imspi {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "IMSPI Mode Register"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "IMSPI Status Register"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "IMSPI Interrupt Enable Register"]
        #[inline(always)]
        pub const fn int_enable(self) -> crate::common::Reg<regs::IntEnable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "IMSPI Timeout Control Register"]
        #[inline(always)]
        pub const fn timeout_control(self) -> crate::common::Reg<regs::TimeoutControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "IMSPI Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntEnable(pub u32);
        impl IntEnable {
            #[doc = "Assert an IMSPI interrupt when the TIMEOUT status is asserted. 1=Enable Interrupt; 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn timeout_le(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Assert an IMSPI interrupt when the TIMEOUT status is asserted. 1=Enable Interrupt; 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_timeout_le(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Assert an EEPROM interrupt when the INVALID_RESPONSE status is asserted. 1=Enable Interrupt; 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn invalid_response_le(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Assert an EEPROM interrupt when the INVALID_RESPONSE status is asserted. 1=Enable Interrupt; 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_invalid_response_le(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for IntEnable {
            #[inline(always)]
            fn default() -> IntEnable {
                IntEnable(0)
            }
        }
        impl core::fmt::Debug for IntEnable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntEnable")
                    .field("timeout_le", &self.timeout_le())
                    .field("invalid_response_le", &self.invalid_response_le())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntEnable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "IntEnable {{ timeout_le: {=bool:?}, invalid_response_le: {=bool:?} }}",
                    self.timeout_le(),
                    self.invalid_response_le()
                )
            }
        }
        #[doc = "IMSPI Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "This bit enables the controller. 1=The controller is enabled; 0=The controller is disabled and placed in its lowest power state."]
            #[inline(always)]
            pub const fn activate(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the controller. 1=The controller is enabled; 0=The controller is disabled and placed in its lowest power state."]
            #[inline(always)]
            pub fn set_activate(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "A write of '1b' to this bit resets the controller. This bit is self-clearing."]
            #[inline(always)]
            pub const fn soft_reset(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "A write of '1b' to this bit resets the controller. This bit is self-clearing."]
            #[inline(always)]
            pub fn set_soft_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is routed to the DLY2_SUSB# pin function."]
            #[inline(always)]
            pub const fn dly2_susb(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is routed to the DLY2_SUSB# pin function."]
            #[inline(always)]
            pub fn set_dly2_susb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit corresponds to the Polarity control for the underlying SPI controller. It describes the default state of the SPI Clock signal. 1=The clock starts in a high state; 0=The clock starts in a low state."]
            #[inline(always)]
            pub const fn cpol(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit corresponds to the Polarity control for the underlying SPI controller. It describes the default state of the SPI Clock signal. 1=The clock starts in a high state; 0=The clock starts in a low state."]
            #[inline(always)]
            pub fn set_cpol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This field is the CPHA field of the underlying SPI controller which affects only the MOSI Data. This field changes determines the clock edge on which data are sent, in combination with the CPOL field. 1=If CPOL=0, data sent on Rising Edge; if CPOL=1, data sent on Falling Edge ; 0=If CPOL=0, data sent on Falling Edge; if CPOL=1, data sent on Rising Edge."]
            #[inline(always)]
            pub const fn cpha_mosi(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This field is the CPHA field of the underlying SPI controller which affects only the MOSI Data. This field changes determines the clock edge on which data are sent, in combination with the CPOL field. 1=If CPOL=0, data sent on Rising Edge; if CPOL=1, data sent on Falling Edge ; 0=If CPOL=0, data sent on Falling Edge; if CPOL=1, data sent on Rising Edge."]
            #[inline(always)]
            pub fn set_cpha_mosi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This field is the CPHA field of the underlying SPI controller which affects only the MISO Data. This field changes determines the clock edge on which data are captured, in combination with the CPOL field. For standard SPI Modes, this must be programmed with the same value as CPHA_MOSI. 1=If CPOL=0, data captured on Falling Edge; if CPOL=1, data captured on Rising Edge 0=If CPOL=0, data captured on Rising Edge; if CPOL=1, data captured on Falling Edge."]
            #[inline(always)]
            pub const fn cpha_miso(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This field is the CPHA field of the underlying SPI controller which affects only the MISO Data. This field changes determines the clock edge on which data are captured, in combination with the CPOL field. For standard SPI Modes, this must be programmed with the same value as CPHA_MOSI. 1=If CPOL=0, data captured on Falling Edge; if CPOL=1, data captured on Rising Edge 0=If CPOL=0, data captured on Rising Edge; if CPOL=1, data captured on Falling Edge."]
            #[inline(always)]
            pub fn set_cpha_miso(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This SPI clock divide in terms of the number of system clocks. 255:1=The SPI clock period is equal to this number of system clocks. 0=The SPI clock period is equal to 256 system clocks."]
            #[inline(always)]
            pub const fn clock_divide(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This SPI clock divide in terms of the number of system clocks. 255:1=The SPI clock period is equal to this number of system clocks. 0=The SPI clock period is equal to 256 system clocks."]
            #[inline(always)]
            pub fn set_clock_divide(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field sets the interface mode for the SPI controller. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single Mode."]
            #[inline(always)]
            pub const fn if_mode(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x03;
                val as u8
            }
            #[doc = "This field sets the interface mode for the SPI controller. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single Mode."]
            #[inline(always)]
            pub fn set_if_mode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("activate", &self.activate())
                    .field("soft_reset", &self.soft_reset())
                    .field("dly2_susb", &self.dly2_susb())
                    .field("cpol", &self.cpol())
                    .field("cpha_mosi", &self.cpha_mosi())
                    .field("cpha_miso", &self.cpha_miso())
                    .field("clock_divide", &self.clock_divide())
                    .field("if_mode", &self.if_mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mode {{ activate: {=bool:?}, soft_reset: {=bool:?}, dly2_susb: {=bool:?}, cpol: {=bool:?}, cpha_mosi: {=bool:?}, cpha_miso: {=bool:?}, clock_divide: {=u8:?}, if_mode: {=u8:?} }}" , self . activate () , self . soft_reset () , self . dly2_susb () , self . cpol () , self . cpha_mosi () , self . cpha_miso () , self . clock_divide () , self . if_mode ())
            }
        }
        #[doc = "IMSPI Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "This flags when a transfer has terminated due to timeout on the response phase. 1=A transfer error occurred due to an invalid response; 0=No error occurred. (R/WC)"]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This flags when a transfer has terminated due to timeout on the response phase. 1=A transfer error occurred due to an invalid response; 0=No error occurred. (R/WC)"]
            #[inline(always)]
            pub fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The IMSPI has detected an invalid response field and therefore is aborting the transfer in failure. 1=A transfer error occurred due to an invalid response; 0=No error occurred. (R/WC)"]
            #[inline(always)]
            pub const fn invalid_response(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The IMSPI has detected an invalid response field and therefore is aborting the transfer in failure. 1=A transfer error occurred due to an invalid response; 0=No error occurred. (R/WC)"]
            #[inline(always)]
            pub fn set_invalid_response(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("timeout", &self.timeout())
                    .field("invalid_response", &self.invalid_response())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Status {{ timeout: {=bool:?}, invalid_response: {=bool:?} }}",
                    self.timeout(),
                    self.invalid_response()
                )
            }
        }
        #[doc = "IMSPI Timeout Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TimeoutControl(pub u32);
        impl TimeoutControl {
            #[doc = "This field is the maximum number of response cycles the IMSPI will wait until flagging a timeout. A setting of 0 will disable the timeout feature."]
            #[inline(always)]
            pub const fn response_timeout(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "This field is the maximum number of response cycles the IMSPI will wait until flagging a timeout. A setting of 0 will disable the timeout feature."]
            #[inline(always)]
            pub fn set_response_timeout(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for TimeoutControl {
            #[inline(always)]
            fn default() -> TimeoutControl {
                TimeoutControl(0)
            }
        }
        impl core::fmt::Debug for TimeoutControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TimeoutControl")
                    .field("response_timeout", &self.response_timeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TimeoutControl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TimeoutControl {{ response_timeout: {=u8:?} }}",
                    self.response_timeout()
                )
            }
        }
    }
}
pub mod led0 {
    #[doc = "The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Led0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Led0 {}
    unsafe impl Sync for Led0 {}
    impl Led0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "LED Configuration"]
        #[inline(always)]
        pub const fn cfg(self) -> crate::common::Reg<regs::Cfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "LED Limits This register may be written at any time. Values written into the register are held in an holding register, which is transferred into the actual register at the end of a PWM period. The two byte fields may be written independently. Reads of this register return the current contents and not the value of the holding register."]
        #[inline(always)]
        pub const fn limit(self) -> crate::common::Reg<regs::Limit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "LED Delay"]
        #[inline(always)]
        pub const fn dly(self) -> crate::common::Reg<regs::Dly, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This register has eight segment fields which provide the amount the current duty cycle is adjusted at the end of every PWM period. Segment field selection is decoded based on the segment index. The segment index equation utilized depends on the SYMMETRY bit in the LED Configuration Register Register) . In Symmetric Mode the Segment_Index\\[2:0\\] = Duty Cycle Bits\\[7:5\\] . In Asymmetric Mode the Segment_Index\\[2:0\\] is the bit concatenation of following: Segment_Index\\[2\\] = (FALLING RAMP TIME in Figure 30-3, Clipping Example) and Segment_Index\\[1:0\\] = Duty Cycle Bits\\[7:6\\]."]
        #[inline(always)]
        pub const fn step(self) -> crate::common::Reg<regs::Step, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "LED Update Interval"]
        #[inline(always)]
        pub const fn intrvl(self) -> crate::common::Reg<regs::Intrvl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "LED Output Delay"]
        #[inline(always)]
        pub const fn outdly(self) -> crate::common::Reg<regs::Outdly, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "LED Configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfg(pub u32);
        impl Cfg {
            #[doc = "CONTROL 3=PWM is always on 2=LED blinking (standard PWM) 1=LED breathing configuration 0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated"]
            #[inline(always)]
            pub const fn ctrl(&self) -> super::vals::Ctrl {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Ctrl::from_bits(val as u8)
            }
            #[doc = "CONTROL 3=PWM is always on 2=LED blinking (standard PWM) 1=LED breathing configuration 0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated"]
            #[inline(always)]
            pub fn set_ctrl(&mut self, val: super::vals::Ctrl) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock"]
            #[inline(always)]
            pub const fn clk_src(&self) -> super::vals::ClkSrc {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ClkSrc::from_bits(val as u8)
            }
            #[doc = "1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock"]
            #[inline(always)]
            pub fn set_clk_src(&mut self, val: super::vals::ClkSrc) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "SYNCHRONIZE When this bit is '1', all counters for all LEDs are reset to their initial values. When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required."]
            #[inline(always)]
            pub const fn synch(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SYNCHRONIZE When this bit is '1', all counters for all LEDs are reset to their initial values. When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required."]
            #[inline(always)]
            pub fn set_synch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "PWM_SIZE This bit controls the behavior of PWM: 3=Reserved 2=PWM is configured as a 6-bit PWM 1=PWM is configured as a 7-bit PWM 0=PWM is configured as an 8-bit PWM"]
            #[inline(always)]
            pub const fn pwm_size(&self) -> super::vals::PwmSize {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::PwmSize::from_bits(val as u8)
            }
            #[doc = "PWM_SIZE This bit controls the behavior of PWM: 3=Reserved 2=PWM is configured as a 6-bit PWM 1=PWM is configured as a 7-bit PWM 0=PWM is configured as an 8-bit PWM"]
            #[inline(always)]
            pub fn set_pwm_size(&mut self, val: super::vals::PwmSize) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
            #[doc = "ENABLE_UPDATE This bit is set to 1 when written with a '1'. Writes of '0' have no effect. Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time."]
            #[inline(always)]
            pub const fn en_update(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "ENABLE_UPDATE This bit is set to 1 when written with a '1'. Writes of '0' have no effect. Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time."]
            #[inline(always)]
            pub fn set_en_update(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "RESET Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing. Writes of '0' to this bit have no effect."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "RESET Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing. Writes of '0' to this bit have no effect."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "WDT_RELOAD The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value."]
            #[inline(always)]
            pub const fn wdt_reload(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "WDT_RELOAD The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value."]
            #[inline(always)]
            pub fn set_wdt_reload(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "SYMMETRY 1=The rising and falling ramp times are in Asymmetric mode. 0=The rising and falling ramp times are in Symmetric mode."]
            #[inline(always)]
            pub const fn symmetry(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "SYMMETRY 1=The rising and falling ramp times are in Asymmetric mode. 0=The rising and falling ramp times are in Symmetric mode."]
            #[inline(always)]
            pub fn set_symmetry(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Cfg {
            #[inline(always)]
            fn default() -> Cfg {
                Cfg(0)
            }
        }
        impl core::fmt::Debug for Cfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfg")
                    .field("ctrl", &self.ctrl())
                    .field("clk_src", &self.clk_src())
                    .field("synch", &self.synch())
                    .field("pwm_size", &self.pwm_size())
                    .field("en_update", &self.en_update())
                    .field("rst", &self.rst())
                    .field("wdt_reload", &self.wdt_reload())
                    .field("symmetry", &self.symmetry())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cfg {{ ctrl: {:?}, clk_src: {:?}, synch: {=bool:?}, pwm_size: {:?}, en_update: {=bool:?}, rst: {=bool:?}, wdt_reload: {=u8:?}, symmetry: {=bool:?} }}" , self . ctrl () , self . clk_src () , self . synch () , self . pwm_size () , self . en_update () , self . rst () , self . wdt_reload () , self . symmetry ())
            }
        }
        #[doc = "LED Delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dly(pub u32);
        impl Dly {
            #[doc = "The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MIN in register LED_LIMIT."]
            #[inline(always)]
            pub const fn low_pulse(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MIN in register LED_LIMIT."]
            #[inline(always)]
            pub fn set_low_pulse(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MAX in register LED_LIMIT."]
            #[inline(always)]
            pub const fn high_pulse(&self) -> u16 {
                let val = (self.0 >> 12usize) & 0x0fff;
                val as u16
            }
            #[doc = "In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MAX in register LED_LIMIT."]
            #[inline(always)]
            pub fn set_high_pulse(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 12usize)) | (((val as u32) & 0x0fff) << 12usize);
            }
        }
        impl Default for Dly {
            #[inline(always)]
            fn default() -> Dly {
                Dly(0)
            }
        }
        impl core::fmt::Debug for Dly {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dly")
                    .field("low_pulse", &self.low_pulse())
                    .field("high_pulse", &self.high_pulse())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dly {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dly {{ low_pulse: {=u16:?}, high_pulse: {=u16:?} }}",
                    self.low_pulse(),
                    self.high_pulse()
                )
            }
        }
        #[doc = "LED Update Interval"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Intrvl(pub u32);
        impl Intrvl {
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b."]
            #[inline(always)]
            pub const fn i0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b."]
            #[inline(always)]
            pub fn set_i0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b."]
            #[inline(always)]
            pub const fn i1(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b."]
            #[inline(always)]
            pub fn set_i1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b."]
            #[inline(always)]
            pub const fn i2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b."]
            #[inline(always)]
            pub fn set_i2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b."]
            #[inline(always)]
            pub const fn i3(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b."]
            #[inline(always)]
            pub fn set_i3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b."]
            #[inline(always)]
            pub const fn i4(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b."]
            #[inline(always)]
            pub fn set_i4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b."]
            #[inline(always)]
            pub const fn i5(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b."]
            #[inline(always)]
            pub fn set_i5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b."]
            #[inline(always)]
            pub const fn i6(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b."]
            #[inline(always)]
            pub fn set_i6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b."]
            #[inline(always)]
            pub const fn i7(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b."]
            #[inline(always)]
            pub fn set_i7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Intrvl {
            #[inline(always)]
            fn default() -> Intrvl {
                Intrvl(0)
            }
        }
        impl core::fmt::Debug for Intrvl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Intrvl")
                    .field("i0", &self.i0())
                    .field("i1", &self.i1())
                    .field("i2", &self.i2())
                    .field("i3", &self.i3())
                    .field("i4", &self.i4())
                    .field("i5", &self.i5())
                    .field("i6", &self.i6())
                    .field("i7", &self.i7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Intrvl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Intrvl {{ i0: {=u8:?}, i1: {=u8:?}, i2: {=u8:?}, i3: {=u8:?}, i4: {=u8:?}, i5: {=u8:?}, i6: {=u8:?}, i7: {=u8:?} }}" , self . i0 () , self . i1 () , self . i2 () , self . i3 () , self . i4 () , self . i5 () , self . i6 () , self . i7 ())
            }
        }
        #[doc = "LED Limits This register may be written at any time. Values written into the register are held in an holding register, which is transferred into the actual register at the end of a PWM period. The two byte fields may be written independently. Reads of this register return the current contents and not the value of the holding register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Limit(pub u32);
        impl Limit {
            #[doc = "In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode, this field defines the duty cycle of the blink function."]
            #[inline(always)]
            pub const fn min(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode, this field defines the duty cycle of the blink function."]
            #[inline(always)]
            pub fn set_min(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle"]
            #[inline(always)]
            pub const fn max(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle"]
            #[inline(always)]
            pub fn set_max(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Limit {
            #[inline(always)]
            fn default() -> Limit {
                Limit(0)
            }
        }
        impl core::fmt::Debug for Limit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Limit")
                    .field("min", &self.min())
                    .field("max", &self.max())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Limit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Limit {{ min: {=u8:?}, max: {=u8:?} }}", self.min(), self.max())
            }
        }
        #[doc = "LED Output Delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outdly(pub u32);
        impl Outdly {
            #[doc = "The delay, in counts of the clock defined in Clock Source (CLKSRC), in which output transitions are delayed. When this field is 0, there is no added transition delay. When the LED is programmed to be Always On or Always Off, the Output Delay field has no effect."]
            #[inline(always)]
            pub const fn delay(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The delay, in counts of the clock defined in Clock Source (CLKSRC), in which output transitions are delayed. When this field is 0, there is no added transition delay. When the LED is programmed to be Always On or Always Off, the Output Delay field has no effect."]
            #[inline(always)]
            pub fn set_delay(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Outdly {
            #[inline(always)]
            fn default() -> Outdly {
                Outdly(0)
            }
        }
        impl core::fmt::Debug for Outdly {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outdly").field("delay", &self.delay()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outdly {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Outdly {{ delay: {=u8:?} }}", self.delay())
            }
        }
        #[doc = "This register has eight segment fields which provide the amount the current duty cycle is adjusted at the end of every PWM period. Segment field selection is decoded based on the segment index. The segment index equation utilized depends on the SYMMETRY bit in the LED Configuration Register Register) . In Symmetric Mode the Segment_Index\\[2:0\\] = Duty Cycle Bits\\[7:5\\] . In Asymmetric Mode the Segment_Index\\[2:0\\] is the bit concatenation of following: Segment_Index\\[2\\] = (FALLING RAMP TIME in Figure 30-3, Clipping Example) and Segment_Index\\[1:0\\] = Duty Cycle Bits\\[7:6\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Step(pub u32);
        impl Step {
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000."]
            #[inline(always)]
            pub const fn s0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000."]
            #[inline(always)]
            pub fn set_s0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001."]
            #[inline(always)]
            pub const fn s1(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001."]
            #[inline(always)]
            pub fn set_s1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010."]
            #[inline(always)]
            pub const fn s2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010."]
            #[inline(always)]
            pub fn set_s2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011."]
            #[inline(always)]
            pub const fn s3(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011."]
            #[inline(always)]
            pub fn set_s3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100."]
            #[inline(always)]
            pub const fn s4(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100."]
            #[inline(always)]
            pub fn set_s4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101"]
            #[inline(always)]
            pub const fn s5(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101"]
            #[inline(always)]
            pub fn set_s5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110."]
            #[inline(always)]
            pub const fn s6(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110."]
            #[inline(always)]
            pub fn set_s6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111."]
            #[inline(always)]
            pub const fn s7(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111."]
            #[inline(always)]
            pub fn set_s7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Step {
            #[inline(always)]
            fn default() -> Step {
                Step(0)
            }
        }
        impl core::fmt::Debug for Step {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Step")
                    .field("s0", &self.s0())
                    .field("s1", &self.s1())
                    .field("s2", &self.s2())
                    .field("s3", &self.s3())
                    .field("s4", &self.s4())
                    .field("s5", &self.s5())
                    .field("s6", &self.s6())
                    .field("s7", &self.s7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Step {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Step {{ s0: {=u8:?}, s1: {=u8:?}, s2: {=u8:?}, s3: {=u8:?}, s4: {=u8:?}, s5: {=u8:?}, s6: {=u8:?}, s7: {=u8:?} }}" , self . s0 () , self . s1 () , self . s2 () , self . s3 () , self . s4 () , self . s5 () , self . s6 () , self . s7 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClkSrc {
            #[doc = "32.768 KHz clock"]
            LED_CLK_SRC_32KHZ = 0x0,
            #[doc = "48 MHz clock"]
            LED_CLK_SRC_48MHZ = 0x01,
        }
        impl ClkSrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClkSrc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClkSrc {
            #[inline(always)]
            fn from(val: u8) -> ClkSrc {
                ClkSrc::from_bits(val)
            }
        }
        impl From<ClkSrc> for u8 {
            #[inline(always)]
            fn from(val: ClkSrc) -> u8 {
                ClkSrc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrl {
            #[doc = "PWM is always off"]
            PWM_ALWAYS_OFF = 0x0,
            #[doc = "LED Breathing"]
            LED_BREATHING = 0x01,
            #[doc = "LED Blinking"]
            LED_BLINKING = 0x02,
            #[doc = "PWM is always on"]
            PWM_ALWAYS_ON = 0x03,
        }
        impl Ctrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrl {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrl {
            #[inline(always)]
            fn from(val: u8) -> Ctrl {
                Ctrl::from_bits(val)
            }
        }
        impl From<Ctrl> for u8 {
            #[inline(always)]
            fn from(val: Ctrl) -> u8 {
                Ctrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PwmSize {
            #[doc = "PWM is configured as an 8-bit PWM"]
            PWM_SIZE_8BIT = 0x0,
            #[doc = "PWM is configured as an 7-bit PWM"]
            PWM_SIZE_7BIT = 0x01,
            #[doc = "PWM is configured as an 6-bit PWM"]
            PWM_SIZE_6BIT = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PwmSize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PwmSize {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PwmSize {
            #[inline(always)]
            fn from(val: u8) -> PwmSize {
                PwmSize::from_bits(val)
            }
        }
        impl From<PwmSize> for u8 {
            #[inline(always)]
            fn from(val: PwmSize) -> u8 {
                PwmSize::to_bits(val)
            }
        }
    }
}
pub mod otp {
    #[doc = "OTP Programming registers."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Otp {
        ptr: *mut u8,
    }
    unsafe impl Send for Otp {}
    unsafe impl Sync for Otp {}
    impl Otp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This is the Write Lock Register."]
        #[inline(always)]
        pub const fn wr_lock0(self) -> crate::common::Reg<regs::WrLock0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "This is the Write Lock Register."]
        #[inline(always)]
        pub const fn wr_lock1(self) -> crate::common::Reg<regs::WrLock1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x45usize) as _) }
        }
        #[doc = "This is the Write Lock Register."]
        #[inline(always)]
        pub const fn wr_lock2(self) -> crate::common::Reg<regs::WrLock2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x46usize) as _) }
        }
        #[doc = "This is the Write Lock Register."]
        #[inline(always)]
        pub const fn wr_lock3(self) -> crate::common::Reg<regs::WrLock3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x47usize) as _) }
        }
        #[doc = "This is the Read Lock Register."]
        #[inline(always)]
        pub const fn rd_lock0(self) -> crate::common::Reg<regs::RdLock0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "This is the Read Lock Register."]
        #[inline(always)]
        pub const fn rd_lock1(self) -> crate::common::Reg<regs::RdLock1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x49usize) as _) }
        }
        #[doc = "This is the Read Lock Register."]
        #[inline(always)]
        pub const fn rd_lock2(self) -> crate::common::Reg<regs::RdLock2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4ausize) as _) }
        }
        #[doc = "This is the Read Lock Register."]
        #[inline(always)]
        pub const fn rd_lock3(self) -> crate::common::Reg<regs::RdLock3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4busize) as _) }
        }
        #[doc = "This is the Write Fine Lock Register."]
        #[inline(always)]
        pub const fn wr_fine_lck(self) -> crate::common::Reg<regs::WrFineLck, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "This is the Read Fine Lock Register."]
        #[inline(always)]
        pub const fn rd_fine_lck(self) -> crate::common::Reg<regs::RdFineLck, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This is the Read Fine Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RdFineLck(pub u32);
        impl RdFineLck {
            #[doc = "Each bit locks read to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked."]
            #[inline(always)]
            pub const fn rd_fine_lck(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Each bit locks read to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked."]
            #[inline(always)]
            pub fn set_rd_fine_lck(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for RdFineLck {
            #[inline(always)]
            fn default() -> RdFineLck {
                RdFineLck(0)
            }
        }
        impl core::fmt::Debug for RdFineLck {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RdFineLck")
                    .field("rd_fine_lck", &self.rd_fine_lck())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RdFineLck {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RdFineLck {{ rd_fine_lck: {=u32:?} }}", self.rd_fine_lck())
            }
        }
        #[doc = "This is the Read Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RdLock0(pub u8);
        impl RdLock0 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub const fn rl0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub fn set_rl0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for RdLock0 {
            #[inline(always)]
            fn default() -> RdLock0 {
                RdLock0(0)
            }
        }
        impl core::fmt::Debug for RdLock0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RdLock0").field("rl0", &self.rl0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RdLock0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RdLock0 {{ rl0: {=u8:?} }}", self.rl0())
            }
        }
        #[doc = "This is the Read Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RdLock1(pub u8);
        impl RdLock1 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub const fn rl1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub fn set_rl1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for RdLock1 {
            #[inline(always)]
            fn default() -> RdLock1 {
                RdLock1(0)
            }
        }
        impl core::fmt::Debug for RdLock1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RdLock1").field("rl1", &self.rl1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RdLock1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RdLock1 {{ rl1: {=u8:?} }}", self.rl1())
            }
        }
        #[doc = "This is the Read Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RdLock2(pub u8);
        impl RdLock2 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub const fn rl2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub fn set_rl2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for RdLock2 {
            #[inline(always)]
            fn default() -> RdLock2 {
                RdLock2(0)
            }
        }
        impl core::fmt::Debug for RdLock2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RdLock2").field("rl2", &self.rl2()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RdLock2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RdLock2 {{ rl2: {=u8:?} }}", self.rl2())
            }
        }
        #[doc = "This is the Read Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RdLock3(pub u8);
        impl RdLock3 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub const fn rl3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not readable."]
            #[inline(always)]
            pub fn set_rl3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for RdLock3 {
            #[inline(always)]
            fn default() -> RdLock3 {
                RdLock3(0)
            }
        }
        impl core::fmt::Debug for RdLock3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RdLock3").field("rl3", &self.rl3()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RdLock3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RdLock3 {{ rl3: {=u8:?} }}", self.rl3())
            }
        }
        #[doc = "This is the Write Fine Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WrFineLck(pub u32);
        impl WrFineLck {
            #[doc = "Each bit locks write to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked."]
            #[inline(always)]
            pub const fn wr_fine_lck(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Each bit locks write to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked."]
            #[inline(always)]
            pub fn set_wr_fine_lck(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for WrFineLck {
            #[inline(always)]
            fn default() -> WrFineLck {
                WrFineLck(0)
            }
        }
        impl core::fmt::Debug for WrFineLck {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WrFineLck")
                    .field("wr_fine_lck", &self.wr_fine_lck())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WrFineLck {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WrFineLck {{ wr_fine_lck: {=u32:?} }}", self.wr_fine_lck())
            }
        }
        #[doc = "This is the Write Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WrLock0(pub u8);
        impl WrLock0 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub const fn wl0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub fn set_wl0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for WrLock0 {
            #[inline(always)]
            fn default() -> WrLock0 {
                WrLock0(0)
            }
        }
        impl core::fmt::Debug for WrLock0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WrLock0").field("wl0", &self.wl0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WrLock0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WrLock0 {{ wl0: {=u8:?} }}", self.wl0())
            }
        }
        #[doc = "This is the Write Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WrLock1(pub u8);
        impl WrLock1 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub const fn wl1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub fn set_wl1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for WrLock1 {
            #[inline(always)]
            fn default() -> WrLock1 {
                WrLock1(0)
            }
        }
        impl core::fmt::Debug for WrLock1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WrLock1").field("wl1", &self.wl1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WrLock1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WrLock1 {{ wl1: {=u8:?} }}", self.wl1())
            }
        }
        #[doc = "This is the Write Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WrLock2(pub u8);
        impl WrLock2 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub const fn wl2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub fn set_wl2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for WrLock2 {
            #[inline(always)]
            fn default() -> WrLock2 {
                WrLock2(0)
            }
        }
        impl core::fmt::Debug for WrLock2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WrLock2").field("wl2", &self.wl2()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WrLock2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WrLock2 {{ wl2: {=u8:?} }}", self.wl2())
            }
        }
        #[doc = "This is the Write Lock Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WrLock3(pub u8);
        impl WrLock3 {
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub const fn wl3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "When any of the bits are set, the corresponding 32byte range in the OTP is not writable."]
            #[inline(always)]
            pub fn set_wl3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for WrLock3 {
            #[inline(always)]
            fn default() -> WrLock3 {
                WrLock3(0)
            }
        }
        impl core::fmt::Debug for WrLock3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WrLock3").field("wl3", &self.wl3()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WrLock3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WrLock3 {{ wl3: {=u8:?} }}", self.wl3())
            }
        }
    }
}
pub mod pcr {
    #[doc = "The Power, Clocks, and Resets (PCR) Section identifies clock sources, and reset inputs to the chip."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pcr {
        ptr: *mut u8,
    }
    unsafe impl Send for Pcr {}
    unsafe impl Sync for Pcr {}
    impl Pcr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Processor Clock Control Register \\[7:0\\] Processor Clock Divide Value (PROC_DIV)"]
        #[inline(always)]
        pub const fn proc_clk_ctrl(self) -> crate::common::Reg<regs::ProcClkCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Configures the EC_CLK clock domain"]
        #[inline(always)]
        pub const fn slow_clk_ctrl(self) -> crate::common::Reg<regs::SlowClkCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Oscillator ID Register"]
        #[inline(always)]
        pub const fn osc_id(self) -> crate::common::Reg<regs::OscId, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "PCR Power Reset Status Register"]
        #[inline(always)]
        pub const fn pwr_rst_sts(self) -> crate::common::Reg<regs::PwrRstSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "System Reset Register"]
        #[inline(always)]
        pub const fn sys_rst(self) -> crate::common::Reg<regs::SysRst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Peripheral Privilege Register"]
        #[inline(always)]
        pub const fn priv_en_lock(self) -> crate::common::Reg<regs::PrivEnLock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Sleep Enable 0 Register"]
        #[inline(always)]
        pub const fn slp_en_0(self) -> crate::common::Reg<regs::SlpEn0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Sleep Enable 1 Register"]
        #[inline(always)]
        pub const fn slp_en_1(self) -> crate::common::Reg<regs::SlpEn1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Sleep Enable 3 Register"]
        #[inline(always)]
        pub const fn slp_en_3(self) -> crate::common::Reg<regs::SlpEn3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Sleep Enable 4 Register"]
        #[inline(always)]
        pub const fn slp_en_4(self) -> crate::common::Reg<regs::SlpEn4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Reset Enable 0 Register"]
        #[inline(always)]
        pub const fn rst_en_0(self) -> crate::common::Reg<regs::RstEn0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "Reset Enable 1 Register"]
        #[inline(always)]
        pub const fn rst_en_1(self) -> crate::common::Reg<regs::RstEn1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "Reset Enable 3 Register"]
        #[inline(always)]
        pub const fn rst_en_3(self) -> crate::common::Reg<regs::RstEn3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "Reset Enable 4 Register"]
        #[inline(always)]
        pub const fn rst_en_4(self) -> crate::common::Reg<regs::RstEn4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Peripheral Reset Lock Register"]
        #[inline(always)]
        pub const fn periph_rst_en_lock(self) -> crate::common::Reg<regs::PeriphRstEnLock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "EC Priviliges 0 Register"]
        #[inline(always)]
        pub const fn ec_priv_en0(self) -> crate::common::Reg<regs::EcPrivEn0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf0usize) as _) }
        }
        #[doc = "EC Priviliges 1 Register"]
        #[inline(always)]
        pub const fn ec_priv_en1(self) -> crate::common::Reg<regs::EcPrivEn1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf4usize) as _) }
        }
        #[doc = "EC Priviliges 3 Register"]
        #[inline(always)]
        pub const fn ec_priv_en3(self) -> crate::common::Reg<regs::EcPrivEn3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf8usize) as _) }
        }
        #[doc = "EC Priviliges 4 Register"]
        #[inline(always)]
        pub const fn ec_priv_en4(self) -> crate::common::Reg<regs::EcPrivEn4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xfcusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "EC Priviliges 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcPrivEn0(pub u32);
        impl EcPrivEn0 {
            #[doc = "OTP Privilege Enable."]
            #[inline(always)]
            pub const fn otp(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OTP Privilege Enable."]
            #[inline(always)]
            pub fn set_otp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Host Register Bank Privilege Enable."]
            #[inline(always)]
            pub const fn host_reg(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Host Register Bank Privilege Enable."]
            #[inline(always)]
            pub fn set_host_reg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Test SPI Privilege Enable."]
            #[inline(always)]
            pub const fn tst_spi(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Test SPI Privilege Enable."]
            #[inline(always)]
            pub fn set_tst_spi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO Privilege Enable."]
            #[inline(always)]
            pub const fn gpio(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO Privilege Enable."]
            #[inline(always)]
            pub fn set_gpio(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "PCR Privilege Enable."]
            #[inline(always)]
            pub const fn pcr(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "PCR Privilege Enable."]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for EcPrivEn0 {
            #[inline(always)]
            fn default() -> EcPrivEn0 {
                EcPrivEn0(0)
            }
        }
        impl core::fmt::Debug for EcPrivEn0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcPrivEn0")
                    .field("otp", &self.otp())
                    .field("host_reg", &self.host_reg())
                    .field("tst_spi", &self.tst_spi())
                    .field("gpio", &self.gpio())
                    .field("pcr", &self.pcr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcPrivEn0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcPrivEn0 {{ otp: {=bool:?}, host_reg: {=bool:?}, tst_spi: {=bool:?}, gpio: {=bool:?}, pcr: {=bool:?} }}" , self . otp () , self . host_reg () , self . tst_spi () , self . gpio () , self . pcr ())
            }
        }
        #[doc = "EC Priviliges 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcPrivEn1(pub u32);
        impl EcPrivEn1 {
            #[doc = "Interrupt Privilege Enable."]
            #[inline(always)]
            pub const fn intr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt Privilege Enable."]
            #[inline(always)]
            pub fn set_intr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PWM 0 Privilege Enable."]
            #[inline(always)]
            pub const fn pwm0(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PWM 0 Privilege Enable."]
            #[inline(always)]
            pub fn set_pwm0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "PMC Privilege Enable."]
            #[inline(always)]
            pub const fn pmc(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "PMC Privilege Enable."]
            #[inline(always)]
            pub fn set_pmc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "DMA Privilege Enable."]
            #[inline(always)]
            pub const fn dma(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA Privilege Enable."]
            #[inline(always)]
            pub fn set_dma(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "TFDP Privilege Enable."]
            #[inline(always)]
            pub const fn tfdp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "TFDP Privilege Enable."]
            #[inline(always)]
            pub fn set_tfdp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "WDT Privilege Enable."]
            #[inline(always)]
            pub const fn wdt(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "WDT Privilege Enable."]
            #[inline(always)]
            pub fn set_wdt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SMB I2C 0 Privilege Enable."]
            #[inline(always)]
            pub const fn smb_i2c0(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SMB I2C 0 Privilege Enable."]
            #[inline(always)]
            pub fn set_smb_i2c0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "EC Registers Privilege Enable."]
            #[inline(always)]
            pub const fn ec_regs(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "EC Registers Privilege Enable."]
            #[inline(always)]
            pub fn set_ec_regs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Basic Timer 0 Privilege Enable."]
            #[inline(always)]
            pub const fn basic_tmr0(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Basic Timer 0 Privilege Enable."]
            #[inline(always)]
            pub fn set_basic_tmr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Basic Timer 1 Privilege Enable."]
            #[inline(always)]
            pub const fn basic_tmr1(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Basic Timer 1 Privilege Enable."]
            #[inline(always)]
            pub fn set_basic_tmr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for EcPrivEn1 {
            #[inline(always)]
            fn default() -> EcPrivEn1 {
                EcPrivEn1(0)
            }
        }
        impl core::fmt::Debug for EcPrivEn1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcPrivEn1")
                    .field("intr", &self.intr())
                    .field("pwm0", &self.pwm0())
                    .field("pmc", &self.pmc())
                    .field("dma", &self.dma())
                    .field("tfdp", &self.tfdp())
                    .field("wdt", &self.wdt())
                    .field("smb_i2c0", &self.smb_i2c0())
                    .field("ec_regs", &self.ec_regs())
                    .field("basic_tmr0", &self.basic_tmr0())
                    .field("basic_tmr1", &self.basic_tmr1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcPrivEn1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcPrivEn1 {{ intr: {=bool:?}, pwm0: {=bool:?}, pmc: {=bool:?}, dma: {=bool:?}, tfdp: {=bool:?}, wdt: {=bool:?}, smb_i2c0: {=bool:?}, ec_regs: {=bool:?}, basic_tmr0: {=bool:?}, basic_tmr1: {=bool:?} }}" , self . intr () , self . pwm0 () , self . pmc () , self . dma () , self . tfdp () , self . wdt () , self . smb_i2c0 () , self . ec_regs () , self . basic_tmr0 () , self . basic_tmr1 ())
            }
        }
        #[doc = "EC Priviliges 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcPrivEn3(pub u32);
        impl EcPrivEn3 {
            #[doc = "Hibernation TIMER 0 Privilege Enable."]
            #[inline(always)]
            pub const fn hib_tim0(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation TIMER 0 Privilege Enable."]
            #[inline(always)]
            pub fn set_hib_tim0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "SMB I2C 1 Privilege Enable."]
            #[inline(always)]
            pub const fn smb_i2c1(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SMB I2C 1 Privilege Enable."]
            #[inline(always)]
            pub fn set_smb_i2c1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SMB I2C 2 Privilege Enable."]
            #[inline(always)]
            pub const fn smb_i2c2(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SMB I2C 2 Privilege Enable."]
            #[inline(always)]
            pub fn set_smb_i2c2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "SMB I2C 3 Privilege Enable."]
            #[inline(always)]
            pub const fn smb_i2c3(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "SMB I2C 3 Privilege Enable."]
            #[inline(always)]
            pub fn set_smb_i2c3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "LED 0 Privilege Enable."]
            #[inline(always)]
            pub const fn led0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LED 0 Privilege Enable."]
            #[inline(always)]
            pub fn set_led0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "LED 1 Privilege Enable."]
            #[inline(always)]
            pub const fn led1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "LED 1 Privilege Enable."]
            #[inline(always)]
            pub fn set_led1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "SMB I2C 4 Privilege Enable."]
            #[inline(always)]
            pub const fn smb_i2c4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "SMB I2C 4 Privilege Enable."]
            #[inline(always)]
            pub fn set_smb_i2c4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Crypto Privilege Enable."]
            #[inline(always)]
            pub const fn crypto(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Crypto Privilege Enable."]
            #[inline(always)]
            pub fn set_crypto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Hibernation Timer 1 Privilege Enable."]
            #[inline(always)]
            pub const fn hib_tim1(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation Timer 1 Privilege Enable."]
            #[inline(always)]
            pub fn set_hib_tim1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Capture Compare Timer Privilege Enable."]
            #[inline(always)]
            pub const fn cct0(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Capture Compare Timer Privilege Enable."]
            #[inline(always)]
            pub fn set_cct0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for EcPrivEn3 {
            #[inline(always)]
            fn default() -> EcPrivEn3 {
                EcPrivEn3(0)
            }
        }
        impl core::fmt::Debug for EcPrivEn3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcPrivEn3")
                    .field("hib_tim0", &self.hib_tim0())
                    .field("smb_i2c1", &self.smb_i2c1())
                    .field("smb_i2c2", &self.smb_i2c2())
                    .field("smb_i2c3", &self.smb_i2c3())
                    .field("led0", &self.led0())
                    .field("led1", &self.led1())
                    .field("smb_i2c4", &self.smb_i2c4())
                    .field("crypto", &self.crypto())
                    .field("hib_tim1", &self.hib_tim1())
                    .field("cct0", &self.cct0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcPrivEn3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcPrivEn3 {{ hib_tim0: {=bool:?}, smb_i2c1: {=bool:?}, smb_i2c2: {=bool:?}, smb_i2c3: {=bool:?}, led0: {=bool:?}, led1: {=bool:?}, smb_i2c4: {=bool:?}, crypto: {=bool:?}, hib_tim1: {=bool:?}, cct0: {=bool:?} }}" , self . hib_tim0 () , self . smb_i2c1 () , self . smb_i2c2 () , self . smb_i2c3 () , self . led0 () , self . led1 () , self . smb_i2c4 () , self . crypto () , self . hib_tim1 () , self . cct0 ())
            }
        }
        #[doc = "EC Priviliges 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcPrivEn4(pub u32);
        impl EcPrivEn4 {
            #[doc = "SPI Monitor 0 Privilege Enable."]
            #[inline(always)]
            pub const fn spimon0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Monitor 0 Privilege Enable."]
            #[inline(always)]
            pub fn set_spimon0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SPI Monitor 1 Privilege Enable."]
            #[inline(always)]
            pub const fn spimon1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Monitor 1 Privilege Enable."]
            #[inline(always)]
            pub fn set_spimon1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "RTOS Timer Privilege Enable."]
            #[inline(always)]
            pub const fn rtos_tim(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "RTOS Timer Privilege Enable."]
            #[inline(always)]
            pub fn set_rtos_tim(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "QMSPI 0 Privilege Enable."]
            #[inline(always)]
            pub const fn qmspi0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI 0 Privilege Enable."]
            #[inline(always)]
            pub fn set_qmspi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "UART 0 Privilege Enable."]
            #[inline(always)]
            pub const fn uart0(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "UART 0 Privilege Enable."]
            #[inline(always)]
            pub fn set_uart0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SPISLV 0 Privilege Enable."]
            #[inline(always)]
            pub const fn spislv0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "SPISLV 0 Privilege Enable."]
            #[inline(always)]
            pub fn set_spislv0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "SPISLV 1 Privilege Enable."]
            #[inline(always)]
            pub const fn spislv1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "SPISLV 1 Privilege Enable."]
            #[inline(always)]
            pub fn set_spislv1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "QMSPI 1 Privilege Enable."]
            #[inline(always)]
            pub const fn qmspi1(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI 1 Privilege Enable."]
            #[inline(always)]
            pub fn set_qmspi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "VBAT Register Privilege Enable."]
            #[inline(always)]
            pub const fn vbat_reg(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "VBAT Register Privilege Enable."]
            #[inline(always)]
            pub fn set_vbat_reg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for EcPrivEn4 {
            #[inline(always)]
            fn default() -> EcPrivEn4 {
                EcPrivEn4(0)
            }
        }
        impl core::fmt::Debug for EcPrivEn4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcPrivEn4")
                    .field("spimon0", &self.spimon0())
                    .field("spimon1", &self.spimon1())
                    .field("rtos_tim", &self.rtos_tim())
                    .field("qmspi0", &self.qmspi0())
                    .field("uart0", &self.uart0())
                    .field("spislv0", &self.spislv0())
                    .field("spislv1", &self.spislv1())
                    .field("qmspi1", &self.qmspi1())
                    .field("vbat_reg", &self.vbat_reg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcPrivEn4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcPrivEn4 {{ spimon0: {=bool:?}, spimon1: {=bool:?}, rtos_tim: {=bool:?}, qmspi0: {=bool:?}, uart0: {=bool:?}, spislv0: {=bool:?}, spislv1: {=bool:?}, qmspi1: {=bool:?}, vbat_reg: {=bool:?} }}" , self . spimon0 () , self . spimon1 () , self . rtos_tim () , self . qmspi0 () , self . uart0 () , self . spislv0 () , self . spislv1 () , self . qmspi1 () , self . vbat_reg ())
            }
        }
        #[doc = "Oscillator ID Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OscId(pub u32);
        impl OscId {
            #[doc = "Test bits"]
            #[inline(always)]
            pub const fn test(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Test bits"]
            #[inline(always)]
            pub fn set_test(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "PLL Lock Status"]
            #[inline(always)]
            pub const fn pll_lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "PLL Lock Status"]
            #[inline(always)]
            pub fn set_pll_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for OscId {
            #[inline(always)]
            fn default() -> OscId {
                OscId(0)
            }
        }
        impl core::fmt::Debug for OscId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OscId")
                    .field("test", &self.test())
                    .field("pll_lock", &self.pll_lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OscId {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "OscId {{ test: {=u8:?}, pll_lock: {=bool:?} }}",
                    self.test(),
                    self.pll_lock()
                )
            }
        }
        #[doc = "Peripheral Reset Lock Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PeriphRstEnLock(pub u32);
        impl PeriphRstEnLock {
            #[doc = "PCR Reset Enable Lock Register."]
            #[inline(always)]
            pub const fn en(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "PCR Reset Enable Lock Register."]
            #[inline(always)]
            pub fn set_en(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for PeriphRstEnLock {
            #[inline(always)]
            fn default() -> PeriphRstEnLock {
                PeriphRstEnLock(0)
            }
        }
        impl core::fmt::Debug for PeriphRstEnLock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PeriphRstEnLock").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PeriphRstEnLock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PeriphRstEnLock {{ en: {=u32:?} }}", self.en())
            }
        }
        #[doc = "Peripheral Privilege Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PrivEnLock(pub u32);
        impl PrivEnLock {
            #[doc = "Peripheral Privilege Lock Register. 1=Locked, 0=Unlocked. Locks Itself and CHIP_PRIV_EN, EC_PRIV_EN, EC_PRIV_EN2, EC_PRIV_EN3, HOST_PRIV_EN registers"]
            #[inline(always)]
            pub const fn lock_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Peripheral Privilege Lock Register. 1=Locked, 0=Unlocked. Locks Itself and CHIP_PRIV_EN, EC_PRIV_EN, EC_PRIV_EN2, EC_PRIV_EN3, HOST_PRIV_EN registers"]
            #[inline(always)]
            pub fn set_lock_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for PrivEnLock {
            #[inline(always)]
            fn default() -> PrivEnLock {
                PrivEnLock(0)
            }
        }
        impl core::fmt::Debug for PrivEnLock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PrivEnLock").field("lock_en", &self.lock_en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PrivEnLock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PrivEnLock {{ lock_en: {=bool:?} }}", self.lock_en())
            }
        }
        #[doc = "Processor Clock Control Register \\[7:0\\] Processor Clock Divide Value (PROC_DIV)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ProcClkCtrl(pub u32);
        impl ProcClkCtrl {
            #[doc = "Selects the EC clock rate"]
            #[inline(always)]
            pub const fn div(&self) -> super::vals::Div {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Div::from_bits(val as u8)
            }
            #[doc = "Selects the EC clock rate"]
            #[inline(always)]
            pub fn set_div(&mut self, val: super::vals::Div) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
            }
        }
        impl Default for ProcClkCtrl {
            #[inline(always)]
            fn default() -> ProcClkCtrl {
                ProcClkCtrl(0)
            }
        }
        impl core::fmt::Debug for ProcClkCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ProcClkCtrl").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ProcClkCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ProcClkCtrl {{ div: {:?} }}", self.div())
            }
        }
        #[doc = "PCR Power Reset Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PwrRstSts(pub u32);
        impl PwrRstSts {
            #[doc = "Indicates the status of VCC_PWRGD. 0 = PWRGD not asserted. 1 = PWRGD asserte."]
            #[inline(always)]
            pub const fn vcc_pwrgd_sts(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the status of VCC_PWRGD. 0 = PWRGD not asserted. 1 = PWRGD asserte."]
            #[inline(always)]
            pub fn set_vcc_pwrgd_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates the status of RESET_VCC. 0 = reset active. 1 = reset not active."]
            #[inline(always)]
            pub const fn rst_h_sts(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the status of RESET_VCC. 0 = reset active. 1 = reset not active."]
            #[inline(always)]
            pub fn set_rst_h_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates the status of RESET_VTR. 0 = reset active. 1 = reset not active.(R/W1C)"]
            #[inline(always)]
            pub const fn rst_vtr_sts(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the status of RESET_VTR. 0 = reset active. 1 = reset not active.(R/W1C)"]
            #[inline(always)]
            pub fn set_rst_vtr_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "VBAT reset status 0 = No reset occurred while VTR was off or since the last time this bit was cleared. 1 = A reset occurred.(R/WC)"]
            #[inline(always)]
            pub const fn vbat_rst_sts(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "VBAT reset status 0 = No reset occurred while VTR was off or since the last time this bit was cleared. 1 = A reset occurred.(R/WC)"]
            #[inline(always)]
            pub fn set_vbat_rst_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Indicates the status of RESET_SYS.(R/W1C) 0 = No reset occurred since the last time this bit was cleared. 1 = A reset occurred."]
            #[inline(always)]
            pub const fn rst_sys_sts(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the status of RESET_SYS.(R/W1C) 0 = No reset occurred since the last time this bit was cleared. 1 = A reset occurred."]
            #[inline(always)]
            pub fn set_rst_sys_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Indicates status of JTAG_TRST# pin. 0 = No JTAG reset occurred since the last time this bit was cleared. 1 = A reset occurred because of a JTAG command."]
            #[inline(always)]
            pub const fn jtag_rst_sts(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates status of JTAG_TRST# pin. 0 = No JTAG reset occurred since the last time this bit was cleared. 1 = A reset occurred because of a JTAG command."]
            #[inline(always)]
            pub fn set_jtag_rst_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates that a WDT_EVENT happened. (R/W1C) 0 = Not active. 1 = A WDT_EVENT occured."]
            #[inline(always)]
            pub const fn wdt_event(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates that a WDT_EVENT happened. (R/W1C) 0 = Not active. 1 = A WDT_EVENT occured."]
            #[inline(always)]
            pub fn set_wdt_event(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "32K ACTIVE (ACTIVE_32K)"]
            #[inline(always)]
            pub const fn active_32k(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "32K ACTIVE (ACTIVE_32K)"]
            #[inline(always)]
            pub fn set_active_32k(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "PCICLK_ACTIVE (PCICLK_ACTIVE)"]
            #[inline(always)]
            pub const fn pciclk_active(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "PCICLK_ACTIVE (PCICLK_ACTIVE)"]
            #[inline(always)]
            pub fn set_pciclk_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for PwrRstSts {
            #[inline(always)]
            fn default() -> PwrRstSts {
                PwrRstSts(0)
            }
        }
        impl core::fmt::Debug for PwrRstSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PwrRstSts")
                    .field("vcc_pwrgd_sts", &self.vcc_pwrgd_sts())
                    .field("rst_h_sts", &self.rst_h_sts())
                    .field("rst_vtr_sts", &self.rst_vtr_sts())
                    .field("vbat_rst_sts", &self.vbat_rst_sts())
                    .field("rst_sys_sts", &self.rst_sys_sts())
                    .field("jtag_rst_sts", &self.jtag_rst_sts())
                    .field("wdt_event", &self.wdt_event())
                    .field("active_32k", &self.active_32k())
                    .field("pciclk_active", &self.pciclk_active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PwrRstSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PwrRstSts {{ vcc_pwrgd_sts: {=bool:?}, rst_h_sts: {=bool:?}, rst_vtr_sts: {=bool:?}, vbat_rst_sts: {=bool:?}, rst_sys_sts: {=bool:?}, jtag_rst_sts: {=bool:?}, wdt_event: {=bool:?}, active_32k: {=bool:?}, pciclk_active: {=bool:?} }}" , self . vcc_pwrgd_sts () , self . rst_h_sts () , self . rst_vtr_sts () , self . vbat_rst_sts () , self . rst_sys_sts () , self . jtag_rst_sts () , self . wdt_event () , self . active_32k () , self . pciclk_active ())
            }
        }
        #[doc = "Reset Enable 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn0(pub u32);
        impl RstEn0 {
            #[doc = "JTAG STAP Enable"]
            #[inline(always)]
            pub const fn jtag_stap_clk_req(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "JTAG STAP Enable"]
            #[inline(always)]
            pub fn set_jtag_stap_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "OTP Reset Enable"]
            #[inline(always)]
            pub const fn otp_rst_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OTP Reset Enable"]
            #[inline(always)]
            pub fn set_otp_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Chip Test Reset Enable"]
            #[inline(always)]
            pub const fn chptst_rst_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Chip Test Reset Enable"]
            #[inline(always)]
            pub fn set_chptst_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Test SPI Reset Enable"]
            #[inline(always)]
            pub const fn tstspi_rst_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Test SPI Reset Enable"]
            #[inline(always)]
            pub fn set_tstspi_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO Reset Enable"]
            #[inline(always)]
            pub const fn gpio_rst_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO Reset Enable"]
            #[inline(always)]
            pub fn set_gpio_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "PCR Reset Enable"]
            #[inline(always)]
            pub const fn pcr_rst_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "PCR Reset Enable"]
            #[inline(always)]
            pub fn set_pcr_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for RstEn0 {
            #[inline(always)]
            fn default() -> RstEn0 {
                RstEn0(0)
            }
        }
        impl core::fmt::Debug for RstEn0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn0")
                    .field("jtag_stap_clk_req", &self.jtag_stap_clk_req())
                    .field("otp_rst_en", &self.otp_rst_en())
                    .field("chptst_rst_en", &self.chptst_rst_en())
                    .field("tstspi_rst_en", &self.tstspi_rst_en())
                    .field("gpio_rst_en", &self.gpio_rst_en())
                    .field("pcr_rst_en", &self.pcr_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn0 {{ jtag_stap_clk_req: {=bool:?}, otp_rst_en: {=bool:?}, chptst_rst_en: {=bool:?}, tstspi_rst_en: {=bool:?}, gpio_rst_en: {=bool:?}, pcr_rst_en: {=bool:?} }}" , self . jtag_stap_clk_req () , self . otp_rst_en () , self . chptst_rst_en () , self . tstspi_rst_en () , self . gpio_rst_en () , self . pcr_rst_en ())
            }
        }
        #[doc = "Reset Enable 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn1(pub u32);
        impl RstEn1 {
            #[doc = "Interrupt Reset Enable"]
            #[inline(always)]
            pub const fn int_rst_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt Reset Enable"]
            #[inline(always)]
            pub fn set_int_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PWM0 Reset Enable (PWM0_RST_EN)"]
            #[inline(always)]
            pub const fn pwm0_rst_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PWM0 Reset Enable (PWM0_RST_EN)"]
            #[inline(always)]
            pub fn set_pwm0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "DMA Reset Enable (DMA_RST_EN)"]
            #[inline(always)]
            pub const fn dma_rst_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA Reset Enable (DMA_RST_EN)"]
            #[inline(always)]
            pub fn set_dma_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "TFDP Reset Enable (TFDP_RST_EN)"]
            #[inline(always)]
            pub const fn tfdp_rst_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "TFDP Reset Enable (TFDP_RST_EN)"]
            #[inline(always)]
            pub fn set_tfdp_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "WDT Reset Enable (WDT_RST_EN)"]
            #[inline(always)]
            pub const fn wdt_rst_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "WDT Reset Enable (WDT_RST_EN)"]
            #[inline(always)]
            pub fn set_wdt_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SMB0 Reset Enable (SMB0_RST_EN)"]
            #[inline(always)]
            pub const fn smb0_rst_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SMB0 Reset Enable (SMB0_RST_EN)"]
            #[inline(always)]
            pub fn set_smb0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "TIMER32_0 Reset Enable (TIMER32_0_RST_EN)"]
            #[inline(always)]
            pub const fn tmr32_0_rst_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0 Reset Enable (TIMER32_0_RST_EN)"]
            #[inline(always)]
            pub fn set_tmr32_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "TIMER32_1 Reset Enable (TIMER32_1_RST_EN)"]
            #[inline(always)]
            pub const fn tmr32_1_rst_en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1 Reset Enable (TIMER32_1_RST_EN)"]
            #[inline(always)]
            pub fn set_tmr32_1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for RstEn1 {
            #[inline(always)]
            fn default() -> RstEn1 {
                RstEn1(0)
            }
        }
        impl core::fmt::Debug for RstEn1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn1")
                    .field("int_rst_en", &self.int_rst_en())
                    .field("pwm0_rst_en", &self.pwm0_rst_en())
                    .field("dma_rst_en", &self.dma_rst_en())
                    .field("tfdp_rst_en", &self.tfdp_rst_en())
                    .field("wdt_rst_en", &self.wdt_rst_en())
                    .field("smb0_rst_en", &self.smb0_rst_en())
                    .field("tmr32_0_rst_en", &self.tmr32_0_rst_en())
                    .field("tmr32_1_rst_en", &self.tmr32_1_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn1 {{ int_rst_en: {=bool:?}, pwm0_rst_en: {=bool:?}, dma_rst_en: {=bool:?}, tfdp_rst_en: {=bool:?}, wdt_rst_en: {=bool:?}, smb0_rst_en: {=bool:?}, tmr32_0_rst_en: {=bool:?}, tmr32_1_rst_en: {=bool:?} }}" , self . int_rst_en () , self . pwm0_rst_en () , self . dma_rst_en () , self . tfdp_rst_en () , self . wdt_rst_en () , self . smb0_rst_en () , self . tmr32_0_rst_en () , self . tmr32_1_rst_en ())
            }
        }
        #[doc = "Reset Enable 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn3(pub u32);
        impl RstEn3 {
            #[doc = "Hibernation TIMER 0 Reset Enable (HTM_0_RST_EN)"]
            #[inline(always)]
            pub const fn htm_0_rst_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation TIMER 0 Reset Enable (HTM_0_RST_EN)"]
            #[inline(always)]
            pub fn set_htm_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "SMB1 Reset Enable (SMB1_RST_EN)"]
            #[inline(always)]
            pub const fn smb1_rst_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SMB1 Reset Enable (SMB1_RST_EN)"]
            #[inline(always)]
            pub fn set_smb1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SMB2 Reset Enable (SMB2_RST_EN)"]
            #[inline(always)]
            pub const fn smb2_rst_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SMB2 Reset Enable (SMB2_RST_EN)"]
            #[inline(always)]
            pub fn set_smb2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "SMB3 Reset Enable (SMB3_RST_EN)"]
            #[inline(always)]
            pub const fn smb3_rst_en(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "SMB3 Reset Enable (SMB3_RST_EN)"]
            #[inline(always)]
            pub fn set_smb3_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "LED0 Reset Enable (LED0_RST_EN)"]
            #[inline(always)]
            pub const fn led0_rst_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LED0 Reset Enable (LED0_RST_EN)"]
            #[inline(always)]
            pub fn set_led0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "LED1 Reset Enable (LED1_RST_EN)"]
            #[inline(always)]
            pub const fn led1_rst_en(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "LED1 Reset Enable (LED1_RST_EN)"]
            #[inline(always)]
            pub fn set_led1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "SMB 4 Reset Enable (SMB_4_RST_EN)"]
            #[inline(always)]
            pub const fn smb_4_rst_en(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "SMB 4 Reset Enable (SMB_4_RST_EN)"]
            #[inline(always)]
            pub fn set_smb_4_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "CRYPTO Reset Enable"]
            #[inline(always)]
            pub const fn crypto_rst_en(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "CRYPTO Reset Enable"]
            #[inline(always)]
            pub fn set_crypto_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Hibernation TIMER 1 Reset Enable (HTM_1_RST_EN)"]
            #[inline(always)]
            pub const fn htm_1_rst_en(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation TIMER 1 Reset Enable (HTM_1_RST_EN)"]
            #[inline(always)]
            pub fn set_htm_1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Capture Compare Timer Reset Enable (CCTIMER_RST_EN)"]
            #[inline(always)]
            pub const fn cctimer_rst_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Capture Compare Timer Reset Enable (CCTIMER_RST_EN)"]
            #[inline(always)]
            pub fn set_cctimer_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for RstEn3 {
            #[inline(always)]
            fn default() -> RstEn3 {
                RstEn3(0)
            }
        }
        impl core::fmt::Debug for RstEn3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn3")
                    .field("htm_0_rst_en", &self.htm_0_rst_en())
                    .field("smb1_rst_en", &self.smb1_rst_en())
                    .field("smb2_rst_en", &self.smb2_rst_en())
                    .field("smb3_rst_en", &self.smb3_rst_en())
                    .field("led0_rst_en", &self.led0_rst_en())
                    .field("led1_rst_en", &self.led1_rst_en())
                    .field("smb_4_rst_en", &self.smb_4_rst_en())
                    .field("crypto_rst_en", &self.crypto_rst_en())
                    .field("htm_1_rst_en", &self.htm_1_rst_en())
                    .field("cctimer_rst_en", &self.cctimer_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn3 {{ htm_0_rst_en: {=bool:?}, smb1_rst_en: {=bool:?}, smb2_rst_en: {=bool:?}, smb3_rst_en: {=bool:?}, led0_rst_en: {=bool:?}, led1_rst_en: {=bool:?}, smb_4_rst_en: {=bool:?}, crypto_rst_en: {=bool:?}, htm_1_rst_en: {=bool:?}, cctimer_rst_en: {=bool:?} }}" , self . htm_0_rst_en () , self . smb1_rst_en () , self . smb2_rst_en () , self . smb3_rst_en () , self . led0_rst_en () , self . led1_rst_en () , self . smb_4_rst_en () , self . crypto_rst_en () , self . htm_1_rst_en () , self . cctimer_rst_en ())
            }
        }
        #[doc = "Reset Enable 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn4(pub u32);
        impl RstEn4 {
            #[doc = "SPI Monitor 0 Reset Enable (SECMON0_RST_EN)"]
            #[inline(always)]
            pub const fn secmon0_rst_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Monitor 0 Reset Enable (SECMON0_RST_EN)"]
            #[inline(always)]
            pub fn set_secmon0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SPI Monitor 1 Reset Enable (SECMON1_RST_EN)"]
            #[inline(always)]
            pub const fn secmon1_rst_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Monitor 1 Reset Enable (SECMON1_RST_EN)"]
            #[inline(always)]
            pub fn set_secmon1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "RTOS Reset Enable (RTOS_RST_EN)"]
            #[inline(always)]
            pub const fn rtos_rst_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "RTOS Reset Enable (RTOS_RST_EN)"]
            #[inline(always)]
            pub fn set_rtos_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Quad Master SPI 0 Reset Enable (QMSPI_1_RST_EN)"]
            #[inline(always)]
            pub const fn qmspi0_rst_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Quad Master SPI 0 Reset Enable (QMSPI_1_RST_EN)"]
            #[inline(always)]
            pub fn set_qmspi0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "UART0 Reset Enable (UART_0_RST_EN)"]
            #[inline(always)]
            pub const fn uart0_rst_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "UART0 Reset Enable (UART_0_RST_EN)"]
            #[inline(always)]
            pub fn set_uart0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SPI Peropheral 0 Reset Enable (SPIPER0_RST_EN)"]
            #[inline(always)]
            pub const fn spiper0_rst_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Peropheral 0 Reset Enable (SPIPER0_RST_EN)"]
            #[inline(always)]
            pub fn set_spiper0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "SPI Peropheral 1 Reset Enable (SPIPER1_RST_EN)"]
            #[inline(always)]
            pub const fn spiper1_rst_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Peropheral 1 Reset Enable (SPIPER1_RST_EN)"]
            #[inline(always)]
            pub fn set_spiper1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "QMSPI 1 Reset Enable (QMSPI_1_RST_EN)"]
            #[inline(always)]
            pub const fn qmspi_1_rst_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI 1 Reset Enable (QMSPI_1_RST_EN)"]
            #[inline(always)]
            pub fn set_qmspi_1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "VBAT REG Reset Enable (VBAT_REG_RST_EN)"]
            #[inline(always)]
            pub const fn vbat_reg_rst_en(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "VBAT REG Reset Enable (VBAT_REG_RST_EN)"]
            #[inline(always)]
            pub fn set_vbat_reg_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for RstEn4 {
            #[inline(always)]
            fn default() -> RstEn4 {
                RstEn4(0)
            }
        }
        impl core::fmt::Debug for RstEn4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn4")
                    .field("secmon0_rst_en", &self.secmon0_rst_en())
                    .field("secmon1_rst_en", &self.secmon1_rst_en())
                    .field("rtos_rst_en", &self.rtos_rst_en())
                    .field("qmspi0_rst_en", &self.qmspi0_rst_en())
                    .field("uart0_rst_en", &self.uart0_rst_en())
                    .field("spiper0_rst_en", &self.spiper0_rst_en())
                    .field("spiper1_rst_en", &self.spiper1_rst_en())
                    .field("qmspi_1_rst_en", &self.qmspi_1_rst_en())
                    .field("vbat_reg_rst_en", &self.vbat_reg_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn4 {{ secmon0_rst_en: {=bool:?}, secmon1_rst_en: {=bool:?}, rtos_rst_en: {=bool:?}, qmspi0_rst_en: {=bool:?}, uart0_rst_en: {=bool:?}, spiper0_rst_en: {=bool:?}, spiper1_rst_en: {=bool:?}, qmspi_1_rst_en: {=bool:?}, vbat_reg_rst_en: {=bool:?} }}" , self . secmon0_rst_en () , self . secmon1_rst_en () , self . rtos_rst_en () , self . qmspi0_rst_en () , self . uart0_rst_en () , self . spiper0_rst_en () , self . spiper1_rst_en () , self . qmspi_1_rst_en () , self . vbat_reg_rst_en ())
            }
        }
        #[doc = "Configures the EC_CLK clock domain"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlowClkCtrl(pub u32);
        impl SlowClkCtrl {
            #[doc = "SLOW_CLOCK_DIVIDE. n=Divide by n; 0=Clock off"]
            #[inline(always)]
            pub const fn div(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "SLOW_CLOCK_DIVIDE. n=Divide by n; 0=Clock off"]
            #[inline(always)]
            pub fn set_div(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for SlowClkCtrl {
            #[inline(always)]
            fn default() -> SlowClkCtrl {
                SlowClkCtrl(0)
            }
        }
        impl core::fmt::Debug for SlowClkCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlowClkCtrl").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlowClkCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SlowClkCtrl {{ div: {=u16:?} }}", self.div())
            }
        }
        #[doc = "Sleep Enable 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn0(pub u32);
        impl SlpEn0 {
            #[doc = "STAP Sleep Enable"]
            #[inline(always)]
            pub const fn stap_slp_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "STAP Sleep Enable"]
            #[inline(always)]
            pub fn set_stap_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "OTP Sleep Enable"]
            #[inline(always)]
            pub const fn otp_slp_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OTP Sleep Enable"]
            #[inline(always)]
            pub fn set_otp_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "IMSPI Sleep Enable"]
            #[inline(always)]
            pub const fn imspi_slp_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "IMSPI Sleep Enable"]
            #[inline(always)]
            pub fn set_imspi_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Chip Test Sleep Enable"]
            #[inline(always)]
            pub const fn chptst_slp_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Chip Test Sleep Enable"]
            #[inline(always)]
            pub fn set_chptst_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Host Register Bank Sleep Enable"]
            #[inline(always)]
            pub const fn hrbnk_slp_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Host Register Bank Sleep Enable"]
            #[inline(always)]
            pub fn set_hrbnk_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Test SPI Sleep Enable"]
            #[inline(always)]
            pub const fn tstspi_slp_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Test SPI Sleep Enable"]
            #[inline(always)]
            pub fn set_tstspi_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "GPIO Sleep Enable"]
            #[inline(always)]
            pub const fn gpio_slp_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO Sleep Enable"]
            #[inline(always)]
            pub fn set_gpio_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "PCR Sleep Enable"]
            #[inline(always)]
            pub const fn pcr_slp_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "PCR Sleep Enable"]
            #[inline(always)]
            pub fn set_pcr_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for SlpEn0 {
            #[inline(always)]
            fn default() -> SlpEn0 {
                SlpEn0(0)
            }
        }
        impl core::fmt::Debug for SlpEn0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn0")
                    .field("stap_slp_en", &self.stap_slp_en())
                    .field("otp_slp_en", &self.otp_slp_en())
                    .field("imspi_slp_en", &self.imspi_slp_en())
                    .field("chptst_slp_en", &self.chptst_slp_en())
                    .field("hrbnk_slp_en", &self.hrbnk_slp_en())
                    .field("tstspi_slp_en", &self.tstspi_slp_en())
                    .field("gpio_slp_en", &self.gpio_slp_en())
                    .field("pcr_slp_en", &self.pcr_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn0 {{ stap_slp_en: {=bool:?}, otp_slp_en: {=bool:?}, imspi_slp_en: {=bool:?}, chptst_slp_en: {=bool:?}, hrbnk_slp_en: {=bool:?}, tstspi_slp_en: {=bool:?}, gpio_slp_en: {=bool:?}, pcr_slp_en: {=bool:?} }}" , self . stap_slp_en () , self . otp_slp_en () , self . imspi_slp_en () , self . chptst_slp_en () , self . hrbnk_slp_en () , self . tstspi_slp_en () , self . gpio_slp_en () , self . pcr_slp_en ())
            }
        }
        #[doc = "Sleep Enable 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn1(pub u32);
        impl SlpEn1 {
            #[doc = "Interrupt Sleep Enable"]
            #[inline(always)]
            pub const fn int_slp_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt Sleep Enable"]
            #[inline(always)]
            pub fn set_int_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PWM0 Sleep Enable (PWM0_SLP_EN)"]
            #[inline(always)]
            pub const fn pwm0_slp_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PWM0 Sleep Enable (PWM0_SLP_EN)"]
            #[inline(always)]
            pub fn set_pwm0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "PMC Sleep Enable (PMC_SLP_EN)"]
            #[inline(always)]
            pub const fn pmc_slp_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "PMC Sleep Enable (PMC_SLP_EN)"]
            #[inline(always)]
            pub fn set_pmc_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "DMA Sleep Enable (DMA_SLP_EN)"]
            #[inline(always)]
            pub const fn dma_slp_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA Sleep Enable (DMA_SLP_EN)"]
            #[inline(always)]
            pub fn set_dma_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "TFDP Sleep Enable (TFDP_SLP_EN)"]
            #[inline(always)]
            pub const fn tfdp_slp_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "TFDP Sleep Enable (TFDP_SLP_EN)"]
            #[inline(always)]
            pub fn set_tfdp_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "PROCESSOR Sleep Enable (PROCESSOR_SLP_EN)"]
            #[inline(always)]
            pub const fn proc_slp_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "PROCESSOR Sleep Enable (PROCESSOR_SLP_EN)"]
            #[inline(always)]
            pub fn set_proc_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Watch Dog Sleep Enable (WDT_SLP_EN)"]
            #[inline(always)]
            pub const fn wdt_slp_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Watch Dog Sleep Enable (WDT_SLP_EN)"]
            #[inline(always)]
            pub fn set_wdt_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SMB0 Sleep Enable (SMB0_SLP_EN)"]
            #[inline(always)]
            pub const fn smb0_slp_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SMB0 Sleep Enable (SMB0_SLP_EN)"]
            #[inline(always)]
            pub fn set_smb0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "EC Register Bank Sleep Enable (EC_REG_BANK_SLP_EN)"]
            #[inline(always)]
            pub const fn ec_reg_bank_slp_en(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "EC Register Bank Sleep Enable (EC_REG_BANK_SLP_EN)"]
            #[inline(always)]
            pub fn set_ec_reg_bank_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "TIMER32_0 Sleep Enable (TIMER32_0_SLP_EN)"]
            #[inline(always)]
            pub const fn tmr32_0_slp_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0 Sleep Enable (TIMER32_0_SLP_EN)"]
            #[inline(always)]
            pub fn set_tmr32_0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "TIMER32_1 Sleep Enable (TIMER32_1_SLP_EN)"]
            #[inline(always)]
            pub const fn tmr32_1_slp_en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1 Sleep Enable (TIMER32_1_SLP_EN)"]
            #[inline(always)]
            pub fn set_tmr32_1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for SlpEn1 {
            #[inline(always)]
            fn default() -> SlpEn1 {
                SlpEn1(0)
            }
        }
        impl core::fmt::Debug for SlpEn1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn1")
                    .field("int_slp_en", &self.int_slp_en())
                    .field("pwm0_slp_en", &self.pwm0_slp_en())
                    .field("pmc_slp_en", &self.pmc_slp_en())
                    .field("dma_slp_en", &self.dma_slp_en())
                    .field("tfdp_slp_en", &self.tfdp_slp_en())
                    .field("proc_slp_en", &self.proc_slp_en())
                    .field("wdt_slp_en", &self.wdt_slp_en())
                    .field("smb0_slp_en", &self.smb0_slp_en())
                    .field("ec_reg_bank_slp_en", &self.ec_reg_bank_slp_en())
                    .field("tmr32_0_slp_en", &self.tmr32_0_slp_en())
                    .field("tmr32_1_slp_en", &self.tmr32_1_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn1 {{ int_slp_en: {=bool:?}, pwm0_slp_en: {=bool:?}, pmc_slp_en: {=bool:?}, dma_slp_en: {=bool:?}, tfdp_slp_en: {=bool:?}, proc_slp_en: {=bool:?}, wdt_slp_en: {=bool:?}, smb0_slp_en: {=bool:?}, ec_reg_bank_slp_en: {=bool:?}, tmr32_0_slp_en: {=bool:?}, tmr32_1_slp_en: {=bool:?} }}" , self . int_slp_en () , self . pwm0_slp_en () , self . pmc_slp_en () , self . dma_slp_en () , self . tfdp_slp_en () , self . proc_slp_en () , self . wdt_slp_en () , self . smb0_slp_en () , self . ec_reg_bank_slp_en () , self . tmr32_0_slp_en () , self . tmr32_1_slp_en ())
            }
        }
        #[doc = "Sleep Enable 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn3(pub u32);
        impl SlpEn3 {
            #[doc = "Hibernation Timer 0 Sleep Enable (HTM_0_SLP_EN)"]
            #[inline(always)]
            pub const fn htm_0_slp_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation Timer 0 Sleep Enable (HTM_0_SLP_EN)"]
            #[inline(always)]
            pub fn set_htm_0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "SMB1 Sleep Enable (SMB1_SLP_EN)"]
            #[inline(always)]
            pub const fn smb1_slp_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SMB1 Sleep Enable (SMB1_SLP_EN)"]
            #[inline(always)]
            pub fn set_smb1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SMB2 Sleep Enable (SMB2_SLP_EN)"]
            #[inline(always)]
            pub const fn smb2_slp_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SMB2 Sleep Enable (SMB2_SLP_EN)"]
            #[inline(always)]
            pub fn set_smb2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "SMB3 Sleep Enable (SMB3_SLP_EN)"]
            #[inline(always)]
            pub const fn smb3_slp_en(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "SMB3 Sleep Enable (SMB3_SLP_EN)"]
            #[inline(always)]
            pub fn set_smb3_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "LED0 Sleep Enable (LED0_SLP_EN)"]
            #[inline(always)]
            pub const fn led0_slp_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LED0 Sleep Enable (LED0_SLP_EN)"]
            #[inline(always)]
            pub fn set_led0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "LED1 Sleep Enable (LED1_SLP_EN)"]
            #[inline(always)]
            pub const fn led1_slp_en(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "LED1 Sleep Enable (LED1_SLP_EN)"]
            #[inline(always)]
            pub fn set_led1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "SMB4 Sleep Enable (SMB4_SLP_EN)"]
            #[inline(always)]
            pub const fn smb4_slp_en(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "SMB4 Sleep Enable (SMB4_SLP_EN)"]
            #[inline(always)]
            pub fn set_smb4_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "CRYPTO Sleep Enable"]
            #[inline(always)]
            pub const fn crypto_slp_en(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "CRYPTO Sleep Enable"]
            #[inline(always)]
            pub fn set_crypto_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Hibernation TIMER 1 Sleep Enable (HTM_1_SLP_EN)"]
            #[inline(always)]
            pub const fn htm_1_slp_en(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Hibernation TIMER 1 Sleep Enable (HTM_1_SLP_EN)"]
            #[inline(always)]
            pub fn set_htm_1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Capture Compare Timer Sleep Enable (CCTIMER_SLP_EN)"]
            #[inline(always)]
            pub const fn cct_slp_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Capture Compare Timer Sleep Enable (CCTIMER_SLP_EN)"]
            #[inline(always)]
            pub fn set_cct_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for SlpEn3 {
            #[inline(always)]
            fn default() -> SlpEn3 {
                SlpEn3(0)
            }
        }
        impl core::fmt::Debug for SlpEn3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn3")
                    .field("htm_0_slp_en", &self.htm_0_slp_en())
                    .field("smb1_slp_en", &self.smb1_slp_en())
                    .field("smb2_slp_en", &self.smb2_slp_en())
                    .field("smb3_slp_en", &self.smb3_slp_en())
                    .field("led0_slp_en", &self.led0_slp_en())
                    .field("led1_slp_en", &self.led1_slp_en())
                    .field("smb4_slp_en", &self.smb4_slp_en())
                    .field("crypto_slp_en", &self.crypto_slp_en())
                    .field("htm_1_slp_en", &self.htm_1_slp_en())
                    .field("cct_slp_en", &self.cct_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn3 {{ htm_0_slp_en: {=bool:?}, smb1_slp_en: {=bool:?}, smb2_slp_en: {=bool:?}, smb3_slp_en: {=bool:?}, led0_slp_en: {=bool:?}, led1_slp_en: {=bool:?}, smb4_slp_en: {=bool:?}, crypto_slp_en: {=bool:?}, htm_1_slp_en: {=bool:?}, cct_slp_en: {=bool:?} }}" , self . htm_0_slp_en () , self . smb1_slp_en () , self . smb2_slp_en () , self . smb3_slp_en () , self . led0_slp_en () , self . led1_slp_en () , self . smb4_slp_en () , self . crypto_slp_en () , self . htm_1_slp_en () , self . cct_slp_en ())
            }
        }
        #[doc = "Sleep Enable 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn4(pub u32);
        impl SlpEn4 {
            #[doc = "SPI Monitor 0 Sleep Enable (SECMON0_SLP_EN)"]
            #[inline(always)]
            pub const fn secmon0_slp_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Monitor 0 Sleep Enable (SECMON0_SLP_EN)"]
            #[inline(always)]
            pub fn set_secmon0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SPI Monitor 1 Sleep Enable (SECMON1_SLP_EN)"]
            #[inline(always)]
            pub const fn secmon1_slp_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Monitor 1 Sleep Enable (SECMON1_SLP_EN)"]
            #[inline(always)]
            pub fn set_secmon1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "RTOS Sleep Enable (RTOS_SLP_EN)"]
            #[inline(always)]
            pub const fn rtos_slp_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "RTOS Sleep Enable (RTOS_SLP_EN)"]
            #[inline(always)]
            pub fn set_rtos_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Quad Master SPI 0 Sleep Enable (QMSPI_1_SLP_EN)"]
            #[inline(always)]
            pub const fn qmspi0_slp_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Quad Master SPI 0 Sleep Enable (QMSPI_1_SLP_EN)"]
            #[inline(always)]
            pub fn set_qmspi0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "UART0 Sleep Enable (UART_1_SLP_EN)"]
            #[inline(always)]
            pub const fn uart0_slp_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "UART0 Sleep Enable (UART_1_SLP_EN)"]
            #[inline(always)]
            pub fn set_uart0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SPI Peropheral 0 Sleep Enable (SPIPER0_SLP_EN)"]
            #[inline(always)]
            pub const fn spiper0_slp_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Peropheral 0 Sleep Enable (SPIPER0_SLP_EN)"]
            #[inline(always)]
            pub fn set_spiper0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "SPI Peropheral 1 Sleep Enable (SPIPER1_SLP_EN)"]
            #[inline(always)]
            pub const fn spiper1_slp_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Peropheral 1 Sleep Enable (SPIPER1_SLP_EN)"]
            #[inline(always)]
            pub fn set_spiper1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "QMSPI 1 Sleep Enable (QMSPI_1_SLP_EN)"]
            #[inline(always)]
            pub const fn qmspi_1_slp_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "QMSPI 1 Sleep Enable (QMSPI_1_SLP_EN)"]
            #[inline(always)]
            pub fn set_qmspi_1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "VBAT REG Sleep Enable (VBAT_REG_SLP_EN)"]
            #[inline(always)]
            pub const fn vbat_reg_slp_en(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "VBAT REG Sleep Enable (VBAT_REG_SLP_EN)"]
            #[inline(always)]
            pub fn set_vbat_reg_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for SlpEn4 {
            #[inline(always)]
            fn default() -> SlpEn4 {
                SlpEn4(0)
            }
        }
        impl core::fmt::Debug for SlpEn4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn4")
                    .field("secmon0_slp_en", &self.secmon0_slp_en())
                    .field("secmon1_slp_en", &self.secmon1_slp_en())
                    .field("rtos_slp_en", &self.rtos_slp_en())
                    .field("qmspi0_slp_en", &self.qmspi0_slp_en())
                    .field("uart0_slp_en", &self.uart0_slp_en())
                    .field("spiper0_slp_en", &self.spiper0_slp_en())
                    .field("spiper1_slp_en", &self.spiper1_slp_en())
                    .field("qmspi_1_slp_en", &self.qmspi_1_slp_en())
                    .field("vbat_reg_slp_en", &self.vbat_reg_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn4 {{ secmon0_slp_en: {=bool:?}, secmon1_slp_en: {=bool:?}, rtos_slp_en: {=bool:?}, qmspi0_slp_en: {=bool:?}, uart0_slp_en: {=bool:?}, spiper0_slp_en: {=bool:?}, spiper1_slp_en: {=bool:?}, qmspi_1_slp_en: {=bool:?}, vbat_reg_slp_en: {=bool:?} }}" , self . secmon0_slp_en () , self . secmon1_slp_en () , self . rtos_slp_en () , self . qmspi0_slp_en () , self . uart0_slp_en () , self . spiper0_slp_en () , self . spiper1_slp_en () , self . qmspi_1_slp_en () , self . vbat_reg_slp_en ())
            }
        }
        #[doc = "System Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SysRst(pub u32);
        impl SysRst {
            #[doc = "A write of a 1 forces an assertion of the RESET_SYS reset signal, resetting the device. A write of 0 has no effect."]
            #[inline(always)]
            pub const fn soft_sys_rst(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 forces an assertion of the RESET_SYS reset signal, resetting the device. A write of 0 has no effect."]
            #[inline(always)]
            pub fn set_soft_sys_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for SysRst {
            #[inline(always)]
            fn default() -> SysRst {
                SysRst(0)
            }
        }
        impl core::fmt::Debug for SysRst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SysRst")
                    .field("soft_sys_rst", &self.soft_sys_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SysRst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SysRst {{ soft_sys_rst: {=bool:?} }}", self.soft_sys_rst())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Div(u8);
        impl Div {
            #[doc = "Divide 96 MHz clock by 1 (96 MHz Processor Clock)"]
            pub const DIVIDE_BY_1: Self = Self(0x01);
            #[doc = "Divide 96 MHz clock by 2 (48 MHz Processor Clock)"]
            pub const DIVIDE_BY_2: Self = Self(0x02);
            #[doc = "Divide 96 MHz clock by 4 (24 MHz Processor Clock)"]
            pub const DIVIDE_BY_4: Self = Self(0x04);
            #[doc = "Divide 96 MHz clock by 16 (6 MHz Processor Clock)"]
            pub const DIVIDE_BY_16: Self = Self(0x10);
            #[doc = "Divide 96 MHz clock by 48 (2 MHz Processor Clock)"]
            pub const DIVIDE_BY_48: Self = Self(0x30);
        }
        impl Div {
            pub const fn from_bits(val: u8) -> Div {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Div {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x01 => f.write_str("DIVIDE_BY_1"),
                    0x02 => f.write_str("DIVIDE_BY_2"),
                    0x04 => f.write_str("DIVIDE_BY_4"),
                    0x10 => f.write_str("DIVIDE_BY_16"),
                    0x30 => f.write_str("DIVIDE_BY_48"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Div {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x01 => defmt::write!(f, "DIVIDE_BY_1"),
                    0x02 => defmt::write!(f, "DIVIDE_BY_2"),
                    0x04 => defmt::write!(f, "DIVIDE_BY_4"),
                    0x10 => defmt::write!(f, "DIVIDE_BY_16"),
                    0x30 => defmt::write!(f, "DIVIDE_BY_48"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Div {
            #[inline(always)]
            fn from(val: u8) -> Div {
                Div::from_bits(val)
            }
        }
        impl From<Div> for u8 {
            #[inline(always)]
            fn from(val: Div) -> u8 {
                Div::to_bits(val)
            }
        }
    }
}
pub mod pwm0 {
    #[doc = "The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwm0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Pwm0 {}
    unsafe impl Sync for Pwm0 {}
    impl Pwm0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This field determines both the frequency and duty cycle of the PWM signal. Setting this field to a value of n will cause the On time of the PWM to be n+1 cycles of the PWM Clock Source. When this field is set to zero and the PWMX_COUNTER_OFF_TIME is not set to zero, the PWM_OUTPUT is held low (Full Off)."]
        #[inline(always)]
        pub const fn cnt_on(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This field determine both the frequency and duty cycle of the PWM signal. Setting this field to a value of n will cause the Off time of the PWM to be n+1 cycles of the PWM Clock Source. When this field is set to zero, the PWM_OUTPUT is held high (Full On)."]
        #[inline(always)]
        pub const fn cnt_off(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "PWMx CONFIGURATION REGISTER"]
        #[inline(always)]
        pub const fn cfg(self) -> crate::common::Reg<regs::Cfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "PWMx CONFIGURATION REGISTER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfg(pub u32);
        impl Cfg {
            #[doc = "When the PWM_ENABLE is set to 0 the internal counters are reset and the internal state machine is set to the OFF state. In addition, the PWM_OUTPUT signal is set to the inactive state as determined by the Invert bit. The PWMx Counter ON Time Register and PWMx Counter OFF Time Register are not affected by the PWM_ENABLE bit and may be read and written while the PWM enable bit is 0. 1=Enabled (default); 0=Disabled (gates clocks to save power)."]
            #[inline(always)]
            pub const fn pwm_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When the PWM_ENABLE is set to 0 the internal counters are reset and the internal state machine is set to the OFF state. In addition, the PWM_OUTPUT signal is set to the inactive state as determined by the Invert bit. The PWMx Counter ON Time Register and PWMx Counter OFF Time Register are not affected by the PWM_ENABLE bit and may be read and written while the PWM enable bit is 0. 1=Enabled (default); 0=Disabled (gates clocks to save power)."]
            #[inline(always)]
            pub fn set_pwm_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit determines the clock source used by the PWM duty cycle and frequency control logic. 1=CLOCK_LOW 0=CLOCK_HIGH"]
            #[inline(always)]
            pub const fn clk_sel(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit determines the clock source used by the PWM duty cycle and frequency control logic. 1=CLOCK_LOW 0=CLOCK_HIGH"]
            #[inline(always)]
            pub fn set_clk_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1= PWM_OUTPUT ON State is active low; 0=PWM_OUTPUT ON State is active high."]
            #[inline(always)]
            pub const fn inv(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1= PWM_OUTPUT ON State is active low; 0=PWM_OUTPUT ON State is active high."]
            #[inline(always)]
            pub fn set_inv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "The Clock source for the 16-bit down counter (see PWMx Counter ON Time Register and PWMx Counter OFF Time Register) is determined by bit D1 of this register. The Clock source is then divided by the value of Pre-Divider+1 and the resulting signal determines the rate at which the down counter will be decremented. For example, a Pre-Divider value of 1 divides the input clock by 2 and a value of 2 divides the input clock by 3. A Pre-Divider of 0 will disable the Pre-Divider option."]
            #[inline(always)]
            pub const fn clk_pre_div(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x0f;
                val as u8
            }
            #[doc = "The Clock source for the 16-bit down counter (see PWMx Counter ON Time Register and PWMx Counter OFF Time Register) is determined by bit D1 of this register. The Clock source is then divided by the value of Pre-Divider+1 and the resulting signal determines the rate at which the down counter will be decremented. For example, a Pre-Divider value of 1 divides the input clock by 2 and a value of 2 divides the input clock by 3. A Pre-Divider of 0 will disable the Pre-Divider option."]
            #[inline(always)]
            pub fn set_clk_pre_div(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 3usize)) | (((val as u32) & 0x0f) << 3usize);
            }
        }
        impl Default for Cfg {
            #[inline(always)]
            fn default() -> Cfg {
                Cfg(0)
            }
        }
        impl core::fmt::Debug for Cfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfg")
                    .field("pwm_en", &self.pwm_en())
                    .field("clk_sel", &self.clk_sel())
                    .field("inv", &self.inv())
                    .field("clk_pre_div", &self.clk_pre_div())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cfg {{ pwm_en: {=bool:?}, clk_sel: {=bool:?}, inv: {=bool:?}, clk_pre_div: {=u8:?} }}",
                    self.pwm_en(),
                    self.clk_sel(),
                    self.inv(),
                    self.clk_pre_div()
                )
            }
        }
    }
}
pub mod qmspi0 {
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct LdmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for LdmaRx {}
    unsafe impl Sync for LdmaRx {}
    impl LdmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "QMSPI RX Control Register"]
        #[inline(always)]
        pub const fn ldma_rxctrl(self) -> crate::common::Reg<regs::LdmaRxctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "QMSPI Local DMA Rx Start Address Register"]
        #[inline(always)]
        pub const fn ldma_rxstrt_addr(self) -> crate::common::Reg<regs::LdmaRxstrtAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "QMSPI Local DMA Rx Length Register"]
        #[inline(always)]
        pub const fn ldma_rx_len(self) -> crate::common::Reg<regs::LdmaRxLen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Reserved Register"]
        #[inline(always)]
        pub const fn rsvd(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct LdmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for LdmaTx {}
    unsafe impl Sync for LdmaTx {}
    impl LdmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "QMSPI TX Control Register"]
        #[inline(always)]
        pub const fn ldma_txctrl(self) -> crate::common::Reg<regs::LdmaTxctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "QMSPI Local DMA Tx Start Address Register"]
        #[inline(always)]
        pub const fn ldma_txstrt_addr(self) -> crate::common::Reg<regs::LdmaTxstrtAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "QMSPI Local DMA Tx Length Register"]
        #[inline(always)]
        pub const fn ldma_tx_len(self) -> crate::common::Reg<regs::LdmaTxLen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Reserved Register"]
        #[inline(always)]
        pub const fn rsvd(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Qmspi0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Qmspi0 {}
    unsafe impl Sync for Qmspi0 {}
    impl Qmspi0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "QMSPI Mode Register"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "QMSPI SPI Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "QMSPI Execute Register"]
        #[inline(always)]
        pub const fn exe(self) -> crate::common::Reg<regs::Exe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "QMSPI Interface Control Register"]
        #[inline(always)]
        pub const fn ifctrl(self) -> crate::common::Reg<regs::Ifctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "QMSPI Status Register"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "QMSPI Buffer Count Status Register"]
        #[inline(always)]
        pub const fn buf_cnt_sts(self) -> crate::common::Reg<regs::BufCntSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "QMSPI Interrupt Enable Register"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "QMSPI Buffer Count Trigger Register"]
        #[inline(always)]
        pub const fn buf_cnt_trig(self) -> crate::common::Reg<regs::BufCntTrig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "QMSPI Transmit Buffer Register"]
        #[inline(always)]
        pub const fn tx_fifo(self, n: usize) -> crate::common::Reg<regs::TxFifo, crate::common::RW> {
            assert!(n < 1usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 4usize) as _) }
        }
        #[doc = "QMSPI Receive Buffer Register"]
        #[inline(always)]
        pub const fn rx_fifo(self, n: usize) -> crate::common::Reg<regs::RxFifo, crate::common::RW> {
            assert!(n < 1usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize + n * 4usize) as _) }
        }
        #[doc = "QMSPI Chip Select Timing Register"]
        #[inline(always)]
        pub const fn cstm(self) -> crate::common::Reg<regs::Cstm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "QMSPI Description Buffer 0 Register"]
        #[inline(always)]
        pub const fn descr(self, n: usize) -> crate::common::Reg<regs::Descr, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize + n * 4usize) as _) }
        }
        #[doc = "QMSPI Alias Control Register"]
        #[inline(always)]
        pub const fn alias_ctrl(self) -> crate::common::Reg<regs::AliasCtrl, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb0usize) as _) }
        }
        #[doc = "QMSPI Mode Alternate 1 Register"]
        #[inline(always)]
        pub const fn mode_alt1(self) -> crate::common::Reg<regs::ModeAlt1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "QMSPI TAPs Register"]
        #[inline(always)]
        pub const fn taps(self) -> crate::common::Reg<regs::Taps, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd0usize) as _) }
        }
        #[doc = "QMSPI TAP Control Register"]
        #[inline(always)]
        pub const fn tap_adj(self) -> crate::common::Reg<regs::TapAdj, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd4usize) as _) }
        }
        #[doc = "QMSPI TAP Adjustment Register"]
        #[inline(always)]
        pub const fn tap_ctrl(self) -> crate::common::Reg<regs::TapCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd8usize) as _) }
        }
        #[doc = "QMSPI Descriptor Local DMA Rx Enable Register"]
        #[inline(always)]
        pub const fn desc_ldma_rxen(self) -> crate::common::Reg<regs::DescLdmaRxen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "QMSPI Descriptor Local DMA Tx Enable Register"]
        #[inline(always)]
        pub const fn desc_ldma_txen(self) -> crate::common::Reg<regs::DescLdmaTxen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[inline(always)]
        pub const fn ldma_rx(self, n: usize) -> LdmaRx {
            assert!(n < 3usize);
            unsafe { LdmaRx::from_ptr(self.ptr.add(0x0110usize + n * 16usize) as _) }
        }
        #[inline(always)]
        pub const fn ldma_tx(self, n: usize) -> LdmaTx {
            assert!(n < 3usize);
            unsafe { LdmaTx::from_ptr(self.ptr.add(0x0140usize + n * 16usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "QMSPI Alias Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AliasCtrl(pub u32);
        impl AliasCtrl {
            #[doc = "Alias for the QMSPI Execution:Start field."]
            #[inline(always)]
            pub const fn als_exec_strt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Alias for the QMSPI Execution:Start field."]
            #[inline(always)]
            pub fn set_als_exec_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable the CS1 Clock Divide to be active if CS1 is the interface in use."]
            #[inline(always)]
            pub const fn cls_altmode_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the CS1 Clock Divide to be active if CS1 is the interface in use."]
            #[inline(always)]
            pub fn set_cls_altmode_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Alias that triggers a write to the Tx Buffer of 1 Byte using data from Alias Tx Buffer Data in this register."]
            #[inline(always)]
            pub const fn als_wr_txbuf(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Alias that triggers a write to the Tx Buffer of 1 Byte using data from Alias Tx Buffer Data in this register."]
            #[inline(always)]
            pub fn set_als_wr_txbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Alias that triggers a write to the Description Buffer pointed to by Alias Description Buffer Select in this register to modify the Transfer Length field with the value of Alias Description Buffer Transfer Length in this register."]
            #[inline(always)]
            pub const fn als_wrdbuf_xfrlen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Alias that triggers a write to the Description Buffer pointed to by Alias Description Buffer Select in this register to modify the Transfer Length field with the value of Alias Description Buffer Transfer Length in this register."]
            #[inline(always)]
            pub fn set_als_wrdbuf_xfrlen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Alias for the QMSPI Mode:Chip Select field."]
            #[inline(always)]
            pub const fn als_mod_cs(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "Alias for the QMSPI Mode:Chip Select field."]
            #[inline(always)]
            pub fn set_als_mod_cs(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "Alias that overrides the value in all QMSPI Local DMA * \\[Tx/Rx\\] Control:Increment Address Enable fields w/ this value."]
            #[inline(always)]
            pub const fn als_ldma_incr_add(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Alias that overrides the value in all QMSPI Local DMA * \\[Tx/Rx\\] Control:Increment Address Enable fields w/ this value."]
            #[inline(always)]
            pub fn set_als_ldma_incr_add(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Alias for the QMSPI Control:Description Buffer Pointer field."]
            #[inline(always)]
            pub const fn als_ctrl_dbuf_ptr(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Alias for the QMSPI Control:Description Buffer Pointer field."]
            #[inline(always)]
            pub fn set_als_ctrl_dbuf_ptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Which Description Buffer will be modified by a write if Alias Write Description Buffer Transfer Length is set."]
            #[inline(always)]
            pub const fn als_dbuf_sel(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Which Description Buffer will be modified by a write if Alias Write Description Buffer Transfer Length is set."]
            #[inline(always)]
            pub fn set_als_dbuf_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "The value of the data written to the Description Buffers Transfer Length field, if the write is enabled."]
            #[inline(always)]
            pub const fn als_dbuf_xfr_len(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "The value of the data written to the Description Buffers Transfer Length field, if the write is enabled."]
            #[inline(always)]
            pub fn set_als_dbuf_xfr_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "The Byte of data written into the Tx Buffer if the write is enabled."]
            #[inline(always)]
            pub const fn als_txdbuf_data(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "The Byte of data written into the Tx Buffer if the write is enabled."]
            #[inline(always)]
            pub fn set_als_txdbuf_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for AliasCtrl {
            #[inline(always)]
            fn default() -> AliasCtrl {
                AliasCtrl(0)
            }
        }
        impl core::fmt::Debug for AliasCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AliasCtrl")
                    .field("als_exec_strt", &self.als_exec_strt())
                    .field("cls_altmode_en", &self.cls_altmode_en())
                    .field("als_wr_txbuf", &self.als_wr_txbuf())
                    .field("als_wrdbuf_xfrlen", &self.als_wrdbuf_xfrlen())
                    .field("als_mod_cs", &self.als_mod_cs())
                    .field("als_ldma_incr_add", &self.als_ldma_incr_add())
                    .field("als_ctrl_dbuf_ptr", &self.als_ctrl_dbuf_ptr())
                    .field("als_dbuf_sel", &self.als_dbuf_sel())
                    .field("als_dbuf_xfr_len", &self.als_dbuf_xfr_len())
                    .field("als_txdbuf_data", &self.als_txdbuf_data())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AliasCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "AliasCtrl {{ als_exec_strt: {=bool:?}, cls_altmode_en: {=bool:?}, als_wr_txbuf: {=bool:?}, als_wrdbuf_xfrlen: {=bool:?}, als_mod_cs: {=u8:?}, als_ldma_incr_add: {=bool:?}, als_ctrl_dbuf_ptr: {=u8:?}, als_dbuf_sel: {=u8:?}, als_dbuf_xfr_len: {=u8:?}, als_txdbuf_data: {=u8:?} }}" , self . als_exec_strt () , self . cls_altmode_en () , self . als_wr_txbuf () , self . als_wrdbuf_xfrlen () , self . als_mod_cs () , self . als_ldma_incr_add () , self . als_ctrl_dbuf_ptr () , self . als_dbuf_sel () , self . als_dbuf_xfr_len () , self . als_txdbuf_data ())
            }
        }
        #[doc = "QMSPI Buffer Count Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BufCntSts(pub u32);
        impl BufCntSts {
            #[doc = "This is a count of the number of bytes currently valid in the Transmit Buffer."]
            #[inline(always)]
            pub const fn tx_buff_cnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is a count of the number of bytes currently valid in the Transmit Buffer."]
            #[inline(always)]
            pub fn set_tx_buff_cnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "This is a count of the number of bytes currently valid in the Receive Buffer."]
            #[inline(always)]
            pub const fn rx_buff_cnt(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This is a count of the number of bytes currently valid in the Receive Buffer."]
            #[inline(always)]
            pub fn set_rx_buff_cnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for BufCntSts {
            #[inline(always)]
            fn default() -> BufCntSts {
                BufCntSts(0)
            }
        }
        impl core::fmt::Debug for BufCntSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BufCntSts")
                    .field("tx_buff_cnt", &self.tx_buff_cnt())
                    .field("rx_buff_cnt", &self.rx_buff_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BufCntSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BufCntSts {{ tx_buff_cnt: {=u16:?}, rx_buff_cnt: {=u16:?} }}",
                    self.tx_buff_cnt(),
                    self.rx_buff_cnt()
                )
            }
        }
        #[doc = "QMSPI Buffer Count Trigger Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BufCntTrig(pub u32);
        impl BufCntTrig {
            #[doc = "An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_trig(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_trig(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_trig(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_trig(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for BufCntTrig {
            #[inline(always)]
            fn default() -> BufCntTrig {
                BufCntTrig(0)
            }
        }
        impl core::fmt::Debug for BufCntTrig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BufCntTrig")
                    .field("tx_buf_trig", &self.tx_buf_trig())
                    .field("rx_buf_trig", &self.rx_buf_trig())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BufCntTrig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BufCntTrig {{ tx_buf_trig: {=u16:?}, rx_buf_trig: {=u16:?} }}",
                    self.tx_buf_trig(),
                    self.rx_buf_trig()
                )
            }
        }
        #[doc = "QMSPI Chip Select Timing Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cstm(pub u32);
        impl Cstm {
            #[doc = "This selects the number of system clock cycles between CS assertion to the start of the SPI Clock."]
            #[inline(always)]
            pub const fn dly_cs_on_to_clock_start(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This selects the number of system clock cycles between CS assertion to the start of the SPI Clock."]
            #[inline(always)]
            pub fn set_dly_cs_on_to_clock_start(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "This selects the number of system clock cycles between the last clock edge and the deassertion of CS."]
            #[inline(always)]
            pub const fn dly_clk_stop_to_cs_off(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "This selects the number of system clock cycles between the last clock edge and the deassertion of CS."]
            #[inline(always)]
            pub fn set_dly_clk_stop_to_cs_off(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD switching from input to output."]
            #[inline(always)]
            pub const fn dly_last_data_hold(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD switching from input to output."]
            #[inline(always)]
            pub fn set_dly_last_data_hold(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum pulse width of CS deassertion."]
            #[inline(always)]
            pub const fn dly_cs_off_to_cs_on(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum pulse width of CS deassertion."]
            #[inline(always)]
            pub fn set_dly_cs_off_to_cs_on(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cstm {
            #[inline(always)]
            fn default() -> Cstm {
                Cstm(0)
            }
        }
        impl core::fmt::Debug for Cstm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cstm")
                    .field("dly_cs_on_to_clock_start", &self.dly_cs_on_to_clock_start())
                    .field("dly_clk_stop_to_cs_off", &self.dly_clk_stop_to_cs_off())
                    .field("dly_last_data_hold", &self.dly_last_data_hold())
                    .field("dly_cs_off_to_cs_on", &self.dly_cs_off_to_cs_on())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cstm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cstm {{ dly_cs_on_to_clock_start: {=u8:?}, dly_clk_stop_to_cs_off: {=u8:?}, dly_last_data_hold: {=u8:?}, dly_cs_off_to_cs_on: {=u8:?} }}" , self . dly_cs_on_to_clock_start () , self . dly_clk_stop_to_cs_off () , self . dly_last_data_hold () , self . dly_cs_off_to_cs_on ())
            }
        }
        #[doc = "QMSPI SPI Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub const fn tx_mode(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub fn set_tx_mode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used. 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub const fn tx_trans_en(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used. 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub fn set_tx_trans_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes. 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware"]
            #[inline(always)]
            pub const fn tx_dma_en(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes. 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware"]
            #[inline(always)]
            pub fn set_tx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer 0=Receive is disabled"]
            #[inline(always)]
            pub const fn rx_trans_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer 0=Receive is disabled"]
            #[inline(always)]
            pub fn set_rx_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware"]
            #[inline(always)]
            pub const fn rx_dma_en(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware"]
            #[inline(always)]
            pub fn set_rx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 7usize)) | (((val as u32) & 0x03) << 7usize);
            }
            #[doc = "This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer. 1=The transaction is terminated 0=The transaction is not terminated"]
            #[inline(always)]
            pub const fn close_trans_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer. 1=The transaction is terminated 0=The transaction is not terminated"]
            #[inline(always)]
            pub fn set_close_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "3=TRANSFER_LENGTH defined in units of 16-byte segments 2=TRANSFER_LENGTH defined in units of 4-byte segments 1=TRANSFER_LENGTH defined in units of bytes 0=TRANSFER_LENGTH defined in units of bits."]
            #[inline(always)]
            pub const fn trans_units(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x03;
                val as u8
            }
            #[doc = "3=TRANSFER_LENGTH defined in units of 16-byte segments 2=TRANSFER_LENGTH defined in units of 4-byte segments 1=TRANSFER_LENGTH defined in units of bytes 0=TRANSFER_LENGTH defined in units of bits."]
            #[inline(always)]
            pub fn set_trans_units(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize);
            }
            #[doc = "This field selects the first buffer used if Description Buffers are enabled."]
            #[inline(always)]
            pub const fn descr_buff_ptr(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "This field selects the first buffer used if Description Buffers are enabled."]
            #[inline(always)]
            pub fn set_descr_buff_ptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This enables the Description Buffers to be used. 1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER 0=Description Buffers disabled."]
            #[inline(always)]
            pub const fn descr_buff_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the Description Buffers to be used. 1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER 0=Description Buffers disabled."]
            #[inline(always)]
            pub fn set_descr_buff_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub const fn trans_len(&self) -> u16 {
                let val = (self.0 >> 17usize) & 0x7fff;
                val as u16
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub fn set_trans_len(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 17usize)) | (((val as u32) & 0x7fff) << 17usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("tx_mode", &self.tx_mode())
                    .field("tx_trans_en", &self.tx_trans_en())
                    .field("tx_dma_en", &self.tx_dma_en())
                    .field("rx_trans_en", &self.rx_trans_en())
                    .field("rx_dma_en", &self.rx_dma_en())
                    .field("close_trans_en", &self.close_trans_en())
                    .field("trans_units", &self.trans_units())
                    .field("descr_buff_ptr", &self.descr_buff_ptr())
                    .field("descr_buff_en", &self.descr_buff_en())
                    .field("trans_len", &self.trans_len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ tx_mode: {=u8:?}, tx_trans_en: {=u8:?}, tx_dma_en: {=u8:?}, rx_trans_en: {=bool:?}, rx_dma_en: {=u8:?}, close_trans_en: {=bool:?}, trans_units: {=u8:?}, descr_buff_ptr: {=u8:?}, descr_buff_en: {=bool:?}, trans_len: {=u16:?} }}" , self . tx_mode () , self . tx_trans_en () , self . tx_dma_en () , self . rx_trans_en () , self . rx_dma_en () , self . close_trans_en () , self . trans_units () , self . descr_buff_ptr () , self . descr_buff_en () , self . trans_len ())
            }
        }
        #[doc = "QMSPI Descriptor Local DMA Rx Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DescLdmaRxen(pub u32);
        impl DescLdmaRxen {
            #[doc = "This enables the Local RX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."]
            #[inline(always)]
            pub const fn desc_ldma_rxen(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This enables the Local RX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."]
            #[inline(always)]
            pub fn set_desc_ldma_rxen(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for DescLdmaRxen {
            #[inline(always)]
            fn default() -> DescLdmaRxen {
                DescLdmaRxen(0)
            }
        }
        impl core::fmt::Debug for DescLdmaRxen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DescLdmaRxen")
                    .field("desc_ldma_rxen", &self.desc_ldma_rxen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DescLdmaRxen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DescLdmaRxen {{ desc_ldma_rxen: {=u16:?} }}", self.desc_ldma_rxen())
            }
        }
        #[doc = "QMSPI Descriptor Local DMA Tx Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DescLdmaTxen(pub u32);
        impl DescLdmaTxen {
            #[doc = "This enables the Local TX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."]
            #[inline(always)]
            pub const fn desc_ldma_txen(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This enables the Local TX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA."]
            #[inline(always)]
            pub fn set_desc_ldma_txen(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for DescLdmaTxen {
            #[inline(always)]
            fn default() -> DescLdmaTxen {
                DescLdmaTxen(0)
            }
        }
        impl core::fmt::Debug for DescLdmaTxen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DescLdmaTxen")
                    .field("desc_ldma_txen", &self.desc_ldma_txen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DescLdmaTxen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DescLdmaTxen {{ desc_ldma_txen: {=u16:?} }}", self.desc_ldma_txen())
            }
        }
        #[doc = "QMSPI Description Buffer 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Descr(pub u32);
        impl Descr {
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub const fn inface_mod(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub fn set_inface_mod(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub const fn tx_trans_en(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub fn set_tx_trans_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."]
            #[inline(always)]
            pub const fn tx_dma_en(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."]
            #[inline(always)]
            pub fn set_tx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."]
            #[inline(always)]
            pub const fn rx_trans_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."]
            #[inline(always)]
            pub fn set_rx_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."]
            #[inline(always)]
            pub const fn rx_dma_en(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."]
            #[inline(always)]
            pub fn set_rx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 7usize)) | (((val as u32) & 0x03) << 7usize);
            }
            #[doc = "This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer. 1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer. 0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"]
            #[inline(always)]
            pub const fn close_trans_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer. 1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer. 0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"]
            #[inline(always)]
            pub fn set_close_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "3=TRANSFER_LENGTH defined in units of 16-byte segments, 2=TRANSFER_LENGTH defined in units of 4-byte segments 1=TRANSFER_LENGTH defined in units of bytes, 0=TRANSFER_LENGTH defined in units of bits"]
            #[inline(always)]
            pub const fn trans_len(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x03;
                val as u8
            }
            #[doc = "3=TRANSFER_LENGTH defined in units of 16-byte segments, 2=TRANSFER_LENGTH defined in units of 4-byte segments 1=TRANSFER_LENGTH defined in units of bytes, 0=TRANSFER_LENGTH defined in units of bits"]
            #[inline(always)]
            pub fn set_trans_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize);
            }
            #[doc = "This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."]
            #[inline(always)]
            pub const fn descr_buf_nxt_ptr(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."]
            #[inline(always)]
            pub fn set_descr_buf_nxt_ptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."]
            #[inline(always)]
            pub const fn descr_buf_last(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer."]
            #[inline(always)]
            pub fn set_descr_buf_last(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub const fn tx_len(&self) -> u16 {
                let val = (self.0 >> 17usize) & 0x7fff;
                val as u16
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub fn set_tx_len(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 17usize)) | (((val as u32) & 0x7fff) << 17usize);
            }
        }
        impl Default for Descr {
            #[inline(always)]
            fn default() -> Descr {
                Descr(0)
            }
        }
        impl core::fmt::Debug for Descr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Descr")
                    .field("inface_mod", &self.inface_mod())
                    .field("tx_trans_en", &self.tx_trans_en())
                    .field("tx_dma_en", &self.tx_dma_en())
                    .field("rx_trans_en", &self.rx_trans_en())
                    .field("rx_dma_en", &self.rx_dma_en())
                    .field("close_trans_en", &self.close_trans_en())
                    .field("trans_len", &self.trans_len())
                    .field("descr_buf_nxt_ptr", &self.descr_buf_nxt_ptr())
                    .field("descr_buf_last", &self.descr_buf_last())
                    .field("tx_len", &self.tx_len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Descr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Descr {{ inface_mod: {=u8:?}, tx_trans_en: {=u8:?}, tx_dma_en: {=u8:?}, rx_trans_en: {=bool:?}, rx_dma_en: {=u8:?}, close_trans_en: {=bool:?}, trans_len: {=u8:?}, descr_buf_nxt_ptr: {=u8:?}, descr_buf_last: {=bool:?}, tx_len: {=u16:?} }}" , self . inface_mod () , self . tx_trans_en () , self . tx_dma_en () , self . rx_trans_en () , self . rx_dma_en () , self . close_trans_en () , self . trans_len () , self . descr_buf_nxt_ptr () , self . descr_buf_last () , self . tx_len ())
            }
        }
        #[doc = "QMSPI Execute Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Exe(pub u32);
        impl Exe {
            #[doc = "Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing. This bit must not be set to 1 if the field STOP in this register is set to 1."]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing. This bit must not be set to 1 if the field STOP in this register is set to 1."]
            #[inline(always)]
            pub fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect. This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1."]
            #[inline(always)]
            pub const fn stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect. This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1."]
            #[inline(always)]
            pub fn set_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset. Writing a 0 to this bit has no effect. This bit is self clearing."]
            #[inline(always)]
            pub const fn clr_dat_buff(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset. Writing a 0 to this bit has no effect. This bit is self clearing."]
            #[inline(always)]
            pub fn set_clr_dat_buff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Exe {
            #[inline(always)]
            fn default() -> Exe {
                Exe(0)
            }
        }
        impl core::fmt::Debug for Exe {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Exe")
                    .field("start", &self.start())
                    .field("stop", &self.stop())
                    .field("clr_dat_buff", &self.clr_dat_buff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Exe {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Exe {{ start: {=bool:?}, stop: {=bool:?}, clr_dat_buff: {=bool:?} }}",
                    self.start(),
                    self.stop(),
                    self.clr_dat_buff()
                )
            }
        }
        #[doc = "QMSPI Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u32);
        impl Ien {
            #[doc = "1=Enable an interrupt if TRANSFER_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn trans_compl_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSFER_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_trans_compl_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=Enable an interrupt if DMA_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn dma_compl_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if DMA_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_dma_compl_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_err_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_err_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_err_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_err_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "1=Enable an interrupt if PROGRAMMING_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn prgm_err_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if PROGRAMMING_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_prgm_err_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "1=Enable an interrupt if Local DMA RX Error is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn ldma_rxerrie(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if Local DMA RX Error is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_ldma_rxerrie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "1=Enable an interrupt if Local DMA TX Error is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn ldma_txerrie(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if Local DMA TX Error is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_ldma_txerrie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_full_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_full_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_empty_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_empty_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_req_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_req_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_ful_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_ful_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_empty_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_empty_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_req_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_req_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("trans_compl_en", &self.trans_compl_en())
                    .field("dma_compl_en", &self.dma_compl_en())
                    .field("tx_buf_err_en", &self.tx_buf_err_en())
                    .field("rx_buf_err_en", &self.rx_buf_err_en())
                    .field("prgm_err_en", &self.prgm_err_en())
                    .field("ldma_rxerrie", &self.ldma_rxerrie())
                    .field("ldma_txerrie", &self.ldma_txerrie())
                    .field("tx_buf_full_en", &self.tx_buf_full_en())
                    .field("tx_buf_empty_en", &self.tx_buf_empty_en())
                    .field("tx_buf_req_en", &self.tx_buf_req_en())
                    .field("rx_buf_ful_en", &self.rx_buf_ful_en())
                    .field("rx_buf_empty_en", &self.rx_buf_empty_en())
                    .field("rx_buf_req_en", &self.rx_buf_req_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ien {{ trans_compl_en: {=bool:?}, dma_compl_en: {=bool:?}, tx_buf_err_en: {=bool:?}, rx_buf_err_en: {=bool:?}, prgm_err_en: {=bool:?}, ldma_rxerrie: {=bool:?}, ldma_txerrie: {=bool:?}, tx_buf_full_en: {=bool:?}, tx_buf_empty_en: {=bool:?}, tx_buf_req_en: {=bool:?}, rx_buf_ful_en: {=bool:?}, rx_buf_empty_en: {=bool:?}, rx_buf_req_en: {=bool:?} }}" , self . trans_compl_en () , self . dma_compl_en () , self . tx_buf_err_en () , self . rx_buf_err_en () , self . prgm_err_en () , self . ldma_rxerrie () , self . ldma_txerrie () , self . tx_buf_full_en () , self . tx_buf_empty_en () , self . tx_buf_req_en () , self . rx_buf_ful_en () , self . rx_buf_empty_en () , self . rx_buf_req_en ())
            }
        }
        #[doc = "QMSPI Interface Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ifctrl(pub u32);
        impl Ifctrl {
            #[doc = "This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven. 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0"]
            #[inline(always)]
            pub const fn wr_prct_out_val(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven. 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0"]
            #[inline(always)]
            pub fn set_wr_prct_out_val(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=WRITE PROTECT SPI Output Port is driven 0=WRITE PROTECT SPI Output Port is not driven"]
            #[inline(always)]
            pub const fn wr_prct_out_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=WRITE PROTECT SPI Output Port is driven 0=WRITE PROTECT SPI Output Port is not driven"]
            #[inline(always)]
            pub fn set_wr_prct_out_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit sets the value on the HOLD SPI Output Port if it is driven. 1=HOLD is driven to 1; 0=HOLD is driven to 0."]
            #[inline(always)]
            pub const fn hld_out_val(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit sets the value on the HOLD SPI Output Port if it is driven. 1=HOLD is driven to 1; 0=HOLD is driven to 0."]
            #[inline(always)]
            pub fn set_hld_out_val(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=HOLD SPI Output Port is driven 0=HOLD SPI Output Port is not driven."]
            #[inline(always)]
            pub const fn hld_out_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=HOLD SPI Output Port is driven 0=HOLD SPI Output Port is not driven."]
            #[inline(always)]
            pub fn set_hld_out_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-down resistors enabled on Receive pins"]
            #[inline(always)]
            pub const fn pd_on_not_sel(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-down resistors enabled on Receive pins"]
            #[inline(always)]
            pub fn set_pd_on_not_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-up resistors enabled on Receive pins."]
            #[inline(always)]
            pub const fn pu_on_notsel(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-up resistors enabled on Receive pins."]
            #[inline(always)]
            pub fn set_pu_on_notsel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "1=Enable pull-down resistors on Transmit pins while the pins are not driven 0=No pull-down resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub const fn pd_on_notdriven(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-down resistors on Transmit pins while the pins are not driven 0=No pull-down resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub fn set_pd_on_notdriven(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "1=Enable pull-up resistors on Transmit pins while the pins are not driven 0=No pull-up resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub const fn pu_on_notdriven(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-up resistors on Transmit pins while the pins are not driven 0=No pull-up resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub fn set_pu_on_notdriven(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Ifctrl {
            #[inline(always)]
            fn default() -> Ifctrl {
                Ifctrl(0)
            }
        }
        impl core::fmt::Debug for Ifctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ifctrl")
                    .field("wr_prct_out_val", &self.wr_prct_out_val())
                    .field("wr_prct_out_en", &self.wr_prct_out_en())
                    .field("hld_out_val", &self.hld_out_val())
                    .field("hld_out_en", &self.hld_out_en())
                    .field("pd_on_not_sel", &self.pd_on_not_sel())
                    .field("pu_on_notsel", &self.pu_on_notsel())
                    .field("pd_on_notdriven", &self.pd_on_notdriven())
                    .field("pu_on_notdriven", &self.pu_on_notdriven())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ifctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ifctrl {{ wr_prct_out_val: {=bool:?}, wr_prct_out_en: {=bool:?}, hld_out_val: {=bool:?}, hld_out_en: {=bool:?}, pd_on_not_sel: {=bool:?}, pu_on_notsel: {=bool:?}, pd_on_notdriven: {=bool:?}, pu_on_notdriven: {=bool:?} }}" , self . wr_prct_out_val () , self . wr_prct_out_en () , self . hld_out_val () , self . hld_out_en () , self . pd_on_not_sel () , self . pu_on_notsel () , self . pd_on_notdriven () , self . pu_on_notdriven ())
            }
        }
        #[doc = "QMSPI Local DMA Rx Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaRxLen(pub u32);
        impl LdmaRxLen {
            #[doc = "This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."]
            #[inline(always)]
            pub const fn rx_len(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."]
            #[inline(always)]
            pub fn set_rx_len(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LdmaRxLen {
            #[inline(always)]
            fn default() -> LdmaRxLen {
                LdmaRxLen(0)
            }
        }
        impl core::fmt::Debug for LdmaRxLen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaRxLen").field("rx_len", &self.rx_len()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaRxLen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LdmaRxLen {{ rx_len: {=u32:?} }}", self.rx_len())
            }
        }
        #[doc = "QMSPI RX Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaRxctrl(pub u32);
        impl LdmaRxctrl {
            #[doc = "This enables the Local RX DMA Channel."]
            #[inline(always)]
            pub const fn ch_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the Local RX DMA Channel."]
            #[inline(always)]
            pub fn set_ch_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit automatically re-enables the Local DMA Channel after completion of previous transfer."]
            #[inline(always)]
            pub const fn rstrt_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit automatically re-enables the Local DMA Channel after completion of previous transfer."]
            #[inline(always)]
            pub fn set_rstrt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Address re-enable will automatically re-enables the same address upon completion previous transfer."]
            #[inline(always)]
            pub const fn buf_addr_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Address re-enable will automatically re-enables the same address upon completion previous transfer."]
            #[inline(always)]
            pub fn set_buf_addr_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."]
            #[inline(always)]
            pub const fn ovrd_len(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."]
            #[inline(always)]
            pub fn set_ovrd_len(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Access Size selects the AHB Access Size."]
            #[inline(always)]
            pub const fn acs_sz(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "Access Size selects the AHB Access Size."]
            #[inline(always)]
            pub fn set_acs_sz(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."]
            #[inline(always)]
            pub const fn inc_addr_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."]
            #[inline(always)]
            pub fn set_inc_addr_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for LdmaRxctrl {
            #[inline(always)]
            fn default() -> LdmaRxctrl {
                LdmaRxctrl(0)
            }
        }
        impl core::fmt::Debug for LdmaRxctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaRxctrl")
                    .field("ch_en", &self.ch_en())
                    .field("rstrt_en", &self.rstrt_en())
                    .field("buf_addr_en", &self.buf_addr_en())
                    .field("ovrd_len", &self.ovrd_len())
                    .field("acs_sz", &self.acs_sz())
                    .field("inc_addr_en", &self.inc_addr_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaRxctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "LdmaRxctrl {{ ch_en: {=bool:?}, rstrt_en: {=bool:?}, buf_addr_en: {=bool:?}, ovrd_len: {=bool:?}, acs_sz: {=u8:?}, inc_addr_en: {=bool:?} }}" , self . ch_en () , self . rstrt_en () , self . buf_addr_en () , self . ovrd_len () , self . acs_sz () , self . inc_addr_en ())
            }
        }
        #[doc = "QMSPI Local DMA Rx Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaRxstrtAddr(pub u32);
        impl LdmaRxstrtAddr {
            #[doc = "This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access."]
            #[inline(always)]
            pub const fn strt_addr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access."]
            #[inline(always)]
            pub fn set_strt_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LdmaRxstrtAddr {
            #[inline(always)]
            fn default() -> LdmaRxstrtAddr {
                LdmaRxstrtAddr(0)
            }
        }
        impl core::fmt::Debug for LdmaRxstrtAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaRxstrtAddr")
                    .field("strt_addr", &self.strt_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaRxstrtAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LdmaRxstrtAddr {{ strt_addr: {=u32:?} }}", self.strt_addr())
            }
        }
        #[doc = "QMSPI Local DMA Tx Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaTxLen(pub u32);
        impl LdmaTxLen {
            #[doc = "This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."]
            #[inline(always)]
            pub const fn tx_len(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to."]
            #[inline(always)]
            pub fn set_tx_len(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LdmaTxLen {
            #[inline(always)]
            fn default() -> LdmaTxLen {
                LdmaTxLen(0)
            }
        }
        impl core::fmt::Debug for LdmaTxLen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaTxLen").field("tx_len", &self.tx_len()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaTxLen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LdmaTxLen {{ tx_len: {=u32:?} }}", self.tx_len())
            }
        }
        #[doc = "QMSPI TX Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaTxctrl(pub u32);
        impl LdmaTxctrl {
            #[doc = "This enables the Local TX DMA Channel."]
            #[inline(always)]
            pub const fn ch_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the Local TX DMA Channel."]
            #[inline(always)]
            pub fn set_ch_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit automatically re-enables the Local DMA Channel after completion of previous transfer."]
            #[inline(always)]
            pub const fn rstrt_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit automatically re-enables the Local DMA Channel after completion of previous transfer."]
            #[inline(always)]
            pub fn set_rstrt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Address re-enable will automatically re-enables the same address upon completion previous transfer."]
            #[inline(always)]
            pub const fn buf_addr_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Address re-enable will automatically re-enables the same address upon completion previous transfer."]
            #[inline(always)]
            pub fn set_buf_addr_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."]
            #[inline(always)]
            pub const fn ovrd_len(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA."]
            #[inline(always)]
            pub fn set_ovrd_len(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Access Size selects the AHB Access Size."]
            #[inline(always)]
            pub const fn acs_sz(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "Access Size selects the AHB Access Size."]
            #[inline(always)]
            pub fn set_acs_sz(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."]
            #[inline(always)]
            pub const fn inc_addr_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment."]
            #[inline(always)]
            pub fn set_inc_addr_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for LdmaTxctrl {
            #[inline(always)]
            fn default() -> LdmaTxctrl {
                LdmaTxctrl(0)
            }
        }
        impl core::fmt::Debug for LdmaTxctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaTxctrl")
                    .field("ch_en", &self.ch_en())
                    .field("rstrt_en", &self.rstrt_en())
                    .field("buf_addr_en", &self.buf_addr_en())
                    .field("ovrd_len", &self.ovrd_len())
                    .field("acs_sz", &self.acs_sz())
                    .field("inc_addr_en", &self.inc_addr_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaTxctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "LdmaTxctrl {{ ch_en: {=bool:?}, rstrt_en: {=bool:?}, buf_addr_en: {=bool:?}, ovrd_len: {=bool:?}, acs_sz: {=u8:?}, inc_addr_en: {=bool:?} }}" , self . ch_en () , self . rstrt_en () , self . buf_addr_en () , self . ovrd_len () , self . acs_sz () , self . inc_addr_en ())
            }
        }
        #[doc = "QMSPI Local DMA Tx Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LdmaTxstrtAddr(pub u32);
        impl LdmaTxstrtAddr {
            #[doc = "This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access."]
            #[inline(always)]
            pub const fn strt_addr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access."]
            #[inline(always)]
            pub fn set_strt_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LdmaTxstrtAddr {
            #[inline(always)]
            fn default() -> LdmaTxstrtAddr {
                LdmaTxstrtAddr(0)
            }
        }
        impl core::fmt::Debug for LdmaTxstrtAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LdmaTxstrtAddr")
                    .field("strt_addr", &self.strt_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LdmaTxstrtAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LdmaTxstrtAddr {{ strt_addr: {=u32:?} }}", self.strt_addr())
            }
        }
        #[doc = "QMSPI Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "This bit is used to activate the QMSPI block. 1=Enabled. The block is fully operational 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to activate the QMSPI block. 1=Enabled. The block is fully operational 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing."]
            #[inline(always)]
            pub const fn soft_reset(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing."]
            #[inline(always)]
            pub fn set_soft_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "When enabled the DMA is allowed to operate w/ unaligned transfer lengths."]
            #[inline(always)]
            pub const fn dma_unlgnd_mod(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "When enabled the DMA is allowed to operate w/ unaligned transfer lengths."]
            #[inline(always)]
            pub fn set_dma_unlgnd_mod(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This enables the Local DMA RX usage (instead of the Central DMA) when the Control register enables the DMA."]
            #[inline(always)]
            pub const fn ldma_rxen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the Local DMA RX usage (instead of the Central DMA) when the Control register enables the DMA."]
            #[inline(always)]
            pub fn set_ldma_rxen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This enables the Local DMA TX usage (instead of the Central DMA) when the Control register enables the DMA."]
            #[inline(always)]
            pub const fn ldma_txen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the Local DMA TX usage (instead of the Central DMA) when the Control register enables the DMA."]
            #[inline(always)]
            pub fn set_ldma_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low."]
            #[inline(always)]
            pub const fn cpol(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low."]
            #[inline(always)]
            pub fn set_cpol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock"]
            #[inline(always)]
            pub const fn chpa_mosi(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock"]
            #[inline(always)]
            pub fn set_chpa_mosi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock"]
            #[inline(always)]
            pub const fn chpa_miso(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock"]
            #[inline(always)]
            pub fn set_chpa_miso(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This defines which Chip Select will be used by the H/W when doing a transfer."]
            #[inline(always)]
            pub const fn cs(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x03;
                val as u8
            }
            #[doc = "This defines which Chip Select will be used by the H/W when doing a transfer."]
            #[inline(always)]
            pub fn set_cs(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize);
            }
            #[doc = "The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256."]
            #[inline(always)]
            pub const fn clk_div(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256."]
            #[inline(always)]
            pub fn set_clk_div(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("act", &self.act())
                    .field("soft_reset", &self.soft_reset())
                    .field("dma_unlgnd_mod", &self.dma_unlgnd_mod())
                    .field("ldma_rxen", &self.ldma_rxen())
                    .field("ldma_txen", &self.ldma_txen())
                    .field("cpol", &self.cpol())
                    .field("chpa_mosi", &self.chpa_mosi())
                    .field("chpa_miso", &self.chpa_miso())
                    .field("cs", &self.cs())
                    .field("clk_div", &self.clk_div())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mode {{ act: {=bool:?}, soft_reset: {=bool:?}, dma_unlgnd_mod: {=bool:?}, ldma_rxen: {=bool:?}, ldma_txen: {=bool:?}, cpol: {=bool:?}, chpa_mosi: {=bool:?}, chpa_miso: {=bool:?}, cs: {=u8:?}, clk_div: {=u16:?} }}" , self . act () , self . soft_reset () , self . dma_unlgnd_mod () , self . ldma_rxen () , self . ldma_txen () , self . cpol () , self . chpa_mosi () , self . chpa_miso () , self . cs () , self . clk_div ())
            }
        }
        #[doc = "QMSPI Mode Alternate 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ModeAlt1(pub u32);
        impl ModeAlt1 {
            #[doc = "Enable the CS1 Clock Divide to be active if CS1 is the interface in use."]
            #[inline(always)]
            pub const fn cs1_altmod_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the CS1 Clock Divide to be active if CS1 is the interface in use."]
            #[inline(always)]
            pub fn set_cs1_altmod_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The SPI clock divide in number of system clocks when CS1 is in use and CS1 Alt Mode Enable is set."]
            #[inline(always)]
            pub const fn cs1_altclk_div(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "The SPI clock divide in number of system clocks when CS1 is in use and CS1 Alt Mode Enable is set."]
            #[inline(always)]
            pub fn set_cs1_altclk_div(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for ModeAlt1 {
            #[inline(always)]
            fn default() -> ModeAlt1 {
                ModeAlt1(0)
            }
        }
        impl core::fmt::Debug for ModeAlt1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ModeAlt1")
                    .field("cs1_altmod_en", &self.cs1_altmod_en())
                    .field("cs1_altclk_div", &self.cs1_altclk_div())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ModeAlt1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "ModeAlt1 {{ cs1_altmod_en: {=bool:?}, cs1_altclk_div: {=u16:?} }}",
                    self.cs1_altmod_en(),
                    self.cs1_altclk_div()
                )
            }
        }
        #[doc = "QMSPI Receive Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxFifo(pub u32);
        impl RxFifo {
            #[doc = "Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO. Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits \\[7:0\\] and a Word read will have data on bits \\[15:0\\]. It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error). Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."]
            #[inline(always)]
            pub const fn rx_buf(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO. Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits \\[7:0\\] and a Word read will have data on bits \\[15:0\\]. It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error). Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."]
            #[inline(always)]
            pub fn set_rx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for RxFifo {
            #[inline(always)]
            fn default() -> RxFifo {
                RxFifo(0)
            }
        }
        impl core::fmt::Debug for RxFifo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxFifo").field("rx_buf", &self.rx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxFifo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxFifo {{ rx_buf: {=u32:?} }}", self.rx_buf())
            }
        }
        #[doc = "QMSPI Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH. If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer. In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied. 1=Transfer completed; 0=Transfer not complete."]
            #[inline(always)]
            pub const fn trans_compl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH. If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer. In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied. 1=Transfer completed; 0=Transfer not complete."]
            #[inline(always)]
            pub fn set_trans_compl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller. This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously. This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode. 1=DMA completed; 0=DMA not completed."]
            #[inline(always)]
            pub const fn dma_compl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller. This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously. This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode. 1=DMA completed; 0=DMA not completed."]
            #[inline(always)]
            pub fn set_dma_compl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1=Overflow error occurred (attempt to write to a full Transmit Buffer) 0=No overflow occurred."]
            #[inline(always)]
            pub const fn tx_buff_err(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=Overflow error occurred (attempt to write to a full Transmit Buffer) 0=No overflow occurred."]
            #[inline(always)]
            pub fn set_tx_buff_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=Underflow error occurred (attempt to read from an empty Receive Buffer) 0=No underflow occurred."]
            #[inline(always)]
            pub const fn rx_buff_err(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=Underflow error occurred (attempt to read from an empty Receive Buffer) 0=No underflow occurred."]
            #[inline(always)]
            pub fn set_rx_buff_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit if a programming error is detected. 1=Programming Error detected; 0=No programming error detected."]
            #[inline(always)]
            pub const fn prgm_err(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit if a programming error is detected. 1=Programming Error detected; 0=No programming error detected."]
            #[inline(always)]
            pub fn set_prgm_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit is set if Local DMA Receive error is detected. 1=Local DMA RX Error detected; 0=No Local DMA RX detected."]
            #[inline(always)]
            pub const fn ldma_rxerr(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if Local DMA Receive error is detected. 1=Local DMA RX Error detected; 0=No Local DMA RX detected."]
            #[inline(always)]
            pub fn set_ldma_rxerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit is set if Local DMA Transmit error is detected. 1=Local DMA TX Error detected; 0=No Local DMA TX detected."]
            #[inline(always)]
            pub const fn ldma_txerr(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set if Local DMA Transmit error is detected. 1=Local DMA TX Error detected; 0=No Local DMA TX detected."]
            #[inline(always)]
            pub fn set_ldma_txerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "1=The Transmit Buffer is full 0=The Transmit Buffer is not full."]
            #[inline(always)]
            pub const fn tx_buff_full(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Transmit Buffer is full 0=The Transmit Buffer is not full."]
            #[inline(always)]
            pub fn set_tx_buff_full(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "1=The Transmit Buffer is empty 0=The Transmit Buffer is not empty."]
            #[inline(always)]
            pub const fn tx_buff_emp(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Transmit Buffer is empty 0=The Transmit Buffer is not empty."]
            #[inline(always)]
            pub fn set_tx_buff_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field. 1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER."]
            #[inline(always)]
            pub const fn tx_buff_req(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field. 1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER."]
            #[inline(always)]
            pub fn set_tx_buff_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub const fn tx_buff_stall(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub fn set_tx_buff_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "1=The Receive Buffer is full 0=The Receive Buffer is not full."]
            #[inline(always)]
            pub const fn rx_buff_full(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Receive Buffer is full 0=The Receive Buffer is not full."]
            #[inline(always)]
            pub fn set_rx_buff_full(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "1=The Receive Buffer is empty 0=The Receive Buffer is not empty."]
            #[inline(always)]
            pub const fn rx_buff_emp(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Receive Buffer is empty 0=The Receive Buffer is not empty."]
            #[inline(always)]
            pub fn set_rx_buff_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field. 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER."]
            #[inline(always)]
            pub const fn rx_buff_req(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field. 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER."]
            #[inline(always)]
            pub fn set_rx_buff_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub const fn rx_buff_stall(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub fn set_rx_buff_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "1=A transfer is currently executing 0=No transfer currently in progress."]
            #[inline(always)]
            pub const fn trans_activ(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=A transfer is currently executing 0=No transfer currently in progress."]
            #[inline(always)]
            pub fn set_trans_activ(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled."]
            #[inline(always)]
            pub const fn cur_descr_buf(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled."]
            #[inline(always)]
            pub fn set_cur_descr_buf(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("trans_compl", &self.trans_compl())
                    .field("dma_compl", &self.dma_compl())
                    .field("tx_buff_err", &self.tx_buff_err())
                    .field("rx_buff_err", &self.rx_buff_err())
                    .field("prgm_err", &self.prgm_err())
                    .field("ldma_rxerr", &self.ldma_rxerr())
                    .field("ldma_txerr", &self.ldma_txerr())
                    .field("tx_buff_full", &self.tx_buff_full())
                    .field("tx_buff_emp", &self.tx_buff_emp())
                    .field("tx_buff_req", &self.tx_buff_req())
                    .field("tx_buff_stall", &self.tx_buff_stall())
                    .field("rx_buff_full", &self.rx_buff_full())
                    .field("rx_buff_emp", &self.rx_buff_emp())
                    .field("rx_buff_req", &self.rx_buff_req())
                    .field("rx_buff_stall", &self.rx_buff_stall())
                    .field("trans_activ", &self.trans_activ())
                    .field("cur_descr_buf", &self.cur_descr_buf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sts {{ trans_compl: {=bool:?}, dma_compl: {=bool:?}, tx_buff_err: {=bool:?}, rx_buff_err: {=bool:?}, prgm_err: {=bool:?}, ldma_rxerr: {=bool:?}, ldma_txerr: {=bool:?}, tx_buff_full: {=bool:?}, tx_buff_emp: {=bool:?}, tx_buff_req: {=bool:?}, tx_buff_stall: {=bool:?}, rx_buff_full: {=bool:?}, rx_buff_emp: {=bool:?}, rx_buff_req: {=bool:?}, rx_buff_stall: {=bool:?}, trans_activ: {=bool:?}, cur_descr_buf: {=u8:?} }}" , self . trans_compl () , self . dma_compl () , self . tx_buff_err () , self . rx_buff_err () , self . prgm_err () , self . ldma_rxerr () , self . ldma_txerr () , self . tx_buff_full () , self . tx_buff_emp () , self . tx_buff_req () , self . tx_buff_stall () , self . rx_buff_full () , self . rx_buff_emp () , self . rx_buff_req () , self . rx_buff_stall () , self . trans_activ () , self . cur_descr_buf ())
            }
        }
        #[doc = "QMSPI TAP Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TapAdj(pub u32);
        impl TapAdj {
            #[doc = "This is a signed value that will be added to the Select SCK Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub const fn sck_adj(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This is a signed value that will be added to the Select SCK Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub fn set_sck_adj(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub const fn ctrl_adj(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub fn set_ctrl_adj(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for TapAdj {
            #[inline(always)]
            fn default() -> TapAdj {
                TapAdj(0)
            }
        }
        impl core::fmt::Debug for TapAdj {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TapAdj")
                    .field("sck_adj", &self.sck_adj())
                    .field("ctrl_adj", &self.ctrl_adj())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TapAdj {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TapAdj {{ sck_adj: {=u8:?}, ctrl_adj: {=u8:?} }}",
                    self.sck_adj(),
                    self.ctrl_adj()
                )
            }
        }
        #[doc = "QMSPI TAP Adjustment Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TapCtrl(pub u32);
        impl TapCtrl {
            #[doc = "This enables the automatic H/W trim of the Tap."]
            #[inline(always)]
            pub const fn auto_mod(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This enables the automatic H/W trim of the Tap."]
            #[inline(always)]
            pub fn set_auto_mod(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub const fn ctrl(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay."]
            #[inline(always)]
            pub fn set_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This will force the auto-trim H/W to run and find a new trim value."]
            #[inline(always)]
            pub const fn fw_go(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This will force the auto-trim H/W to run and find a new trim value."]
            #[inline(always)]
            pub fn set_fw_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This will multiply the target delay value the Auto-trim H/W will search for."]
            #[inline(always)]
            pub const fn auto_mult(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "This will multiply the target delay value the Auto-trim H/W will search for."]
            #[inline(always)]
            pub fn set_auto_mult(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
        }
        impl Default for TapCtrl {
            #[inline(always)]
            fn default() -> TapCtrl {
                TapCtrl(0)
            }
        }
        impl core::fmt::Debug for TapCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TapCtrl")
                    .field("auto_mod", &self.auto_mod())
                    .field("ctrl", &self.ctrl())
                    .field("fw_go", &self.fw_go())
                    .field("auto_mult", &self.auto_mult())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TapCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TapCtrl {{ auto_mod: {=u8:?}, ctrl: {=bool:?}, fw_go: {=bool:?}, auto_mult: {=u8:?} }}",
                    self.auto_mod(),
                    self.ctrl(),
                    self.fw_go(),
                    self.auto_mult()
                )
            }
        }
        #[doc = "QMSPI TAPs Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Taps(pub u32);
        impl Taps {
            #[doc = "This will select the tap point for the feed-back SCK."]
            #[inline(always)]
            pub const fn sck_tap(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This will select the tap point for the feed-back SCK."]
            #[inline(always)]
            pub fn set_sck_tap(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This will select the tap point for signals that go from the System Domain."]
            #[inline(always)]
            pub const fn ctrl_tap(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This will select the tap point for signals that go from the System Domain."]
            #[inline(always)]
            pub fn set_ctrl_tap(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Taps {
            #[inline(always)]
            fn default() -> Taps {
                Taps(0)
            }
        }
        impl core::fmt::Debug for Taps {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Taps")
                    .field("sck_tap", &self.sck_tap())
                    .field("ctrl_tap", &self.ctrl_tap())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Taps {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Taps {{ sck_tap: {=u8:?}, ctrl_tap: {=u8:?} }}",
                    self.sck_tap(),
                    self.ctrl_tap()
                )
            }
        }
        #[doc = "QMSPI Transmit Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxFifo(pub u32);
        impl TxFifo {
            #[doc = "Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave. Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes. The data must always be aligned to the bottom most byte (so 1 byte write is on bits \\[7:0\\] and Word write is on \\[15:0\\]). An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."]
            #[inline(always)]
            pub const fn tx_buf(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave. Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes. The data must always be aligned to the bottom most byte (so 1 byte write is on bits \\[7:0\\] and Word write is on \\[15:0\\]). An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."]
            #[inline(always)]
            pub fn set_tx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for TxFifo {
            #[inline(always)]
            fn default() -> TxFifo {
                TxFifo(0)
            }
        }
        impl core::fmt::Debug for TxFifo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxFifo").field("tx_buf", &self.tx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxFifo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxFifo {{ tx_buf: {=u32:?} }}", self.tx_buf())
            }
        }
    }
}
pub mod rtos {
    #[doc = "RTOS is a 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtos {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtos {}
    unsafe impl Sync for Rtos {}
    impl Rtos {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RTOS Timer Count Register."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<regs::Cnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "RTOS Timer Preload Register"]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<regs::Prld, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "RTOS Timer Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Soft Interrupt Register"]
        #[inline(always)]
        pub const fn softirq(self) -> crate::common::Reg<regs::Softirq, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "RTOS Timer Count Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cnt(pub u32);
        impl Cnt {
            #[doc = "This register contains the current value of the RTOS Timer counter. This register should be read as a DWORD. There is no latching mechanism of the upper bytes implemented if the register is accessed as a byte or word. Reading the register with byte or word operations may give incorrect results."]
            #[inline(always)]
            pub const fn cntr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register contains the current value of the RTOS Timer counter. This register should be read as a DWORD. There is no latching mechanism of the upper bytes implemented if the register is accessed as a byte or word. Reading the register with byte or word operations may give incorrect results."]
            #[inline(always)]
            pub fn set_cntr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cnt {
            #[inline(always)]
            fn default() -> Cnt {
                Cnt(0)
            }
        }
        impl core::fmt::Debug for Cnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cnt").field("cntr", &self.cntr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cnt {{ cntr: {=u32:?} }}", self.cntr())
            }
        }
        #[doc = "RTOS Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "1=RTOS timer counter is enabled 0=RTOS timer disabled. All register bits are reset to their default state"]
            #[inline(always)]
            pub const fn blk_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=RTOS timer counter is enabled 0=RTOS timer disabled. All register bits are reset to their default state"]
            #[inline(always)]
            pub fn set_blk_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=The the RTOS Timer Preload Register is loaded into the timer counter and the counter is restarted when the counter transitions from 1 to 0 0=The timer counter halts when it transitions from 1 to 0 and will not restart."]
            #[inline(always)]
            pub const fn au_reload(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=The the RTOS Timer Preload Register is loaded into the timer counter and the counter is restarted when the counter transitions from 1 to 0 0=The timer counter halts when it transitions from 1 to 0 and will not restart."]
            #[inline(always)]
            pub fn set_au_reload(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Writing a 1 to this bit will load the timer counter with the RTOS Timer Preload Register and start counting. If the Preload Register is 0, counting will not start and this bit will be cleared to 0. Writing a 0 to this bit will halt the counter and clear its contents to 0. The RTOS timer interrupt will not be generated. This bit is automatically cleared if the AUTO_RELOAD bit is 0 and the timer counter transitions from 1 to 0."]
            #[inline(always)]
            pub const fn tmr_strt(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will load the timer counter with the RTOS Timer Preload Register and start counting. If the Preload Register is 0, counting will not start and this bit will be cleared to 0. Writing a 0 to this bit will halt the counter and clear its contents to 0. The RTOS timer interrupt will not be generated. This bit is automatically cleared if the AUTO_RELOAD bit is 0 and the timer counter transitions from 1 to 0."]
            #[inline(always)]
            pub fn set_tmr_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=The timer counter is halted when the external HALT signal is asserted. Counting is always enabled if HALT is de-asserted. 0=The HALT signal does not affect the RTOS Timer"]
            #[inline(always)]
            pub const fn ext_hw_halt_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=The timer counter is halted when the external HALT signal is asserted. Counting is always enabled if HALT is de-asserted. 0=The HALT signal does not affect the RTOS Timer"]
            #[inline(always)]
            pub fn set_ext_hw_halt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "1=The timer counter is halted. If the counter was running, clearing this bit will restart the counter from the value at which it halted 0=The timer counter, if enabled, will continue to run"]
            #[inline(always)]
            pub const fn fw_tmr_halt(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "1=The timer counter is halted. If the counter was running, clearing this bit will restart the counter from the value at which it halted 0=The timer counter, if enabled, will continue to run"]
            #[inline(always)]
            pub fn set_fw_tmr_halt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("blk_en", &self.blk_en())
                    .field("au_reload", &self.au_reload())
                    .field("tmr_strt", &self.tmr_strt())
                    .field("ext_hw_halt_en", &self.ext_hw_halt_en())
                    .field("fw_tmr_halt", &self.fw_tmr_halt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ blk_en: {=bool:?}, au_reload: {=bool:?}, tmr_strt: {=bool:?}, ext_hw_halt_en: {=bool:?}, fw_tmr_halt: {=bool:?} }}" , self . blk_en () , self . au_reload () , self . tmr_strt () , self . ext_hw_halt_en () , self . fw_tmr_halt ())
            }
        }
        #[doc = "RTOS Timer Preload Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prld(pub u32);
        impl Prld {
            #[doc = "The this register is loaded into the RTOS Timer counter either when the TIMER_START bit is written with a 1, or when the timer counter counts down to 0 and the AUTO_RELOAD bit is 1. This register must be programmed with a new count value before the TIMER_START bit is set to 1. If this register is updated while the counter is operating, the new count value will only take effect if the counter transitions form 1 to 0 while the AUTO_RELOAD bit is set."]
            #[inline(always)]
            pub const fn preload(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "The this register is loaded into the RTOS Timer counter either when the TIMER_START bit is written with a 1, or when the timer counter counts down to 0 and the AUTO_RELOAD bit is 1. This register must be programmed with a new count value before the TIMER_START bit is set to 1. If this register is updated while the counter is operating, the new count value will only take effect if the counter transitions form 1 to 0 while the AUTO_RELOAD bit is set."]
            #[inline(always)]
            pub fn set_preload(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Prld {
            #[inline(always)]
            fn default() -> Prld {
                Prld(0)
            }
        }
        impl core::fmt::Debug for Prld {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prld").field("preload", &self.preload()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prld {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prld {{ preload: {=u32:?} }}", self.preload())
            }
        }
        #[doc = "Soft Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Softirq(pub u32);
        impl Softirq {
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Softirq {
            #[inline(always)]
            fn default() -> Softirq {
                Softirq(0)
            }
        }
        impl core::fmt::Debug for Softirq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Softirq")
                    .field("swi0", &self.swi0())
                    .field("swi1", &self.swi1())
                    .field("swi2", &self.swi2())
                    .field("swi3", &self.swi3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Softirq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Softirq {{ swi0: {=bool:?}, swi1: {=bool:?}, swi2: {=bool:?}, swi3: {=bool:?} }}",
                    self.swi0(),
                    self.swi1(),
                    self.swi2(),
                    self.swi3()
                )
            }
        }
    }
}
pub mod smb0 {
    #[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Smb0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Smb0 {}
    unsafe impl Sync for Smb0 {}
    impl Smb0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Status Register"]
        #[inline(always)]
        pub const fn rsts(self) -> crate::common::Reg<regs::Rsts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Control Register"]
        #[inline(always)]
        pub const fn wctrl(self) -> crate::common::Reg<regs::Wctrl, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Own Address Register Note that the Data Register and Own Address fields are offset by one bit, so that programming Own Address 1 with a value of 55h will result in the value AAh being recognized as the SMB Controller Core slave address."]
        #[inline(always)]
        pub const fn own_addr(self) -> crate::common::Reg<regs::OwnAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This register holds the data that are either shifted out to or shifted in from the I2C port."]
        #[inline(always)]
        pub const fn i2cdata(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Reserved"]
        #[inline(always)]
        pub const fn rsvd1(self, n: usize) -> crate::common::Reg<u8, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize + n * 1usize) as _) }
        }
        #[doc = "SMBus Master Command Register"]
        #[inline(always)]
        pub const fn mcmd(self, n: usize) -> crate::common::Reg<regs::Mcmd, crate::common::RW> {
            assert!(n < 1usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
        #[doc = "SMBus Slave Command Register"]
        #[inline(always)]
        pub const fn scmd(self, n: usize) -> crate::common::Reg<regs::Scmd, crate::common::RW> {
            assert!(n < 1usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
        #[doc = "Packet Error Check (PEC) Register"]
        #[inline(always)]
        pub const fn pec(self) -> crate::common::Reg<regs::Pec, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Repeated Start Hold Time Register"]
        #[inline(always)]
        pub const fn rshtm(self) -> crate::common::Reg<regs::Rshtm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Extended Length Register"]
        #[inline(always)]
        pub const fn extnd_len(self) -> crate::common::Reg<regs::ExtndLen, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Completion Register"]
        #[inline(always)]
        pub const fn compl(self, n: usize) -> crate::common::Reg<regs::Compl, crate::common::RW> {
            assert!(n < 1usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 4usize) as _) }
        }
        #[doc = "Idle Scaling Register"]
        #[inline(always)]
        pub const fn idlsc(self) -> crate::common::Reg<regs::Idlsc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Configuration Register"]
        #[inline(always)]
        pub const fn cfg(self, n: usize) -> crate::common::Reg<regs::Cfg, crate::common::RW> {
            assert!(n < 1usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize + n * 4usize) as _) }
        }
        #[doc = "Bus Clock Register"]
        #[inline(always)]
        pub const fn busclk(self) -> crate::common::Reg<regs::Busclk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Block ID Register"]
        #[inline(always)]
        pub const fn blkid(self) -> crate::common::Reg<regs::Blkid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Revision Register"]
        #[inline(always)]
        pub const fn blkrev(self) -> crate::common::Reg<regs::Blkrev, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Bit-Bang Control Register"]
        #[inline(always)]
        pub const fn bbctrl(self) -> crate::common::Reg<regs::Bbctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Test"]
        #[inline(always)]
        pub const fn test(self) -> crate::common::Reg<regs::Test, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Data Timing Register"]
        #[inline(always)]
        pub const fn datatm(self) -> crate::common::Reg<regs::Datatm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Time-Out Scaling Register"]
        #[inline(always)]
        pub const fn tmoutsc(self) -> crate::common::Reg<regs::Tmoutsc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "SMBus Slave Transmit Buffer Register"]
        #[inline(always)]
        pub const fn slv_txb(self) -> crate::common::Reg<regs::SlvTxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "SMBus Slave Receive Buffer Register"]
        #[inline(always)]
        pub const fn slv_rxb(self) -> crate::common::Reg<regs::SlvRxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "SMBus Master Transmit Buffer Register"]
        #[inline(always)]
        pub const fn mtr_txb(self) -> crate::common::Reg<regs::MtrTxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "SMBus Master Receive Buffer Register"]
        #[inline(always)]
        pub const fn mtr_rxb(self) -> crate::common::Reg<regs::MtrRxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "WAKE STATUS Register"]
        #[inline(always)]
        pub const fn wake_sts(self) -> crate::common::Reg<regs::WakeSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "WAKE ENABLE Register"]
        #[inline(always)]
        pub const fn wake_en(self) -> crate::common::Reg<regs::WakeEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "This is the Slave Address Register"]
        #[inline(always)]
        pub const fn slv_addr(self) -> crate::common::Reg<regs::SlvAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6cusize) as _) }
        }
        #[doc = "This is the Promiscuous Interrupt Register"]
        #[inline(always)]
        pub const fn prm_sts(self) -> crate::common::Reg<regs::PrmSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "This is the Promiscuous Interrupt Enable Register"]
        #[inline(always)]
        pub const fn prm_ien(self) -> crate::common::Reg<regs::PrmIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "This is the Promiscuous Control Register"]
        #[inline(always)]
        pub const fn prm_ctrl(self) -> crate::common::Reg<regs::PrmCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "This is the I2C Shadow Data Register"]
        #[inline(always)]
        pub const fn shdw_data(self) -> crate::common::Reg<regs::ShdwData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Bit-Bang Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bbctrl(pub u32);
        impl Bbctrl {
            #[doc = "Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled"]
            #[inline(always)]
            pub const fn bben(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled"]
            #[inline(always)]
            pub fn set_bben(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output"]
            #[inline(always)]
            pub const fn cldir(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output"]
            #[inline(always)]
            pub fn set_cldir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output"]
            #[inline(always)]
            pub const fn dadir(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output"]
            #[inline(always)]
            pub fn set_dadir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'"]
            #[inline(always)]
            pub const fn bbclk(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'"]
            #[inline(always)]
            pub fn set_bbclk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'"]
            #[inline(always)]
            pub const fn bbdat(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'"]
            #[inline(always)]
            pub fn set_bbdat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK."]
            #[inline(always)]
            pub const fn bbclki(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK."]
            #[inline(always)]
            pub fn set_bbclki(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Bit-Bang Data In. The BBDATI bit always returns the state of SDAT"]
            #[inline(always)]
            pub const fn bbdati(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Data In. The BBDATI bit always returns the state of SDAT"]
            #[inline(always)]
            pub fn set_bbdati(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Bbctrl {
            #[inline(always)]
            fn default() -> Bbctrl {
                Bbctrl(0)
            }
        }
        impl core::fmt::Debug for Bbctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bbctrl")
                    .field("bben", &self.bben())
                    .field("cldir", &self.cldir())
                    .field("dadir", &self.dadir())
                    .field("bbclk", &self.bbclk())
                    .field("bbdat", &self.bbdat())
                    .field("bbclki", &self.bbclki())
                    .field("bbdati", &self.bbdati())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bbctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bbctrl {{ bben: {=bool:?}, cldir: {=bool:?}, dadir: {=bool:?}, bbclk: {=bool:?}, bbdat: {=bool:?}, bbclki: {=bool:?}, bbdati: {=bool:?} }}" , self . bben () , self . cldir () , self . dadir () , self . bbclk () , self . bbdat () , self . bbclki () , self . bbdati ())
            }
        }
        #[doc = "Block ID Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Blkid(pub u8);
        impl Blkid {
            #[doc = "Block ID."]
            #[inline(always)]
            pub const fn id(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Block ID."]
            #[inline(always)]
            pub fn set_id(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Blkid {
            #[inline(always)]
            fn default() -> Blkid {
                Blkid(0)
            }
        }
        impl core::fmt::Debug for Blkid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Blkid").field("id", &self.id()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Blkid {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Blkid {{ id: {=u8:?} }}", self.id())
            }
        }
        #[doc = "Revision Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Blkrev(pub u8);
        impl Blkrev {
            #[doc = "Block Revision Number"]
            #[inline(always)]
            pub const fn rev(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Block Revision Number"]
            #[inline(always)]
            pub fn set_rev(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Blkrev {
            #[inline(always)]
            fn default() -> Blkrev {
                Blkrev(0)
            }
        }
        impl core::fmt::Debug for Blkrev {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Blkrev").field("rev", &self.rev()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Blkrev {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Blkrev {{ rev: {=u8:?} }}", self.rev())
            }
        }
        #[doc = "Bus Clock Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busclk(pub u32);
        impl Busclk {
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub const fn low_per(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub fn set_low_per(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub const fn high_per(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub fn set_high_per(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Busclk {
            #[inline(always)]
            fn default() -> Busclk {
                Busclk(0)
            }
        }
        impl core::fmt::Debug for Busclk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busclk")
                    .field("low_per", &self.low_per())
                    .field("high_per", &self.high_per())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busclk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Busclk {{ low_per: {=u8:?}, high_per: {=u8:?} }}",
                    self.low_per(),
                    self.high_per()
                )
            }
        }
        #[doc = "Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfg(pub u32);
        impl Cfg {
            #[doc = "The PORT SEL \\[3:0\\] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."]
            #[inline(always)]
            pub const fn port_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The PORT SEL \\[3:0\\] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."]
            #[inline(always)]
            pub fn set_port_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"]
            #[inline(always)]
            pub const fn tcen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"]
            #[inline(always)]
            pub fn set_tcen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."]
            #[inline(always)]
            pub const fn slow_clk(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."]
            #[inline(always)]
            pub fn set_slow_clk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"]
            #[inline(always)]
            pub const fn pecen(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"]
            #[inline(always)]
            pub fn set_pecen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available. 1=Input filtering is enabled; 0=Input filtering is disabled."]
            #[inline(always)]
            pub const fn fen(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available. 1=Input filtering is enabled; 0=Input filtering is disabled."]
            #[inline(always)]
            pub fn set_fen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State). The ENAB bit must be asserted ('1') for normal operation."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State). The ENAB bit must be asserted ('1') for normal operation."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"]
            #[inline(always)]
            pub const fn dsa(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"]
            #[inline(always)]
            pub fn set_dsa(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "If this bit is 1, the MCTP Fairness protocol is in effect."]
            #[inline(always)]
            pub const fn fair(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the MCTP Fairness protocol is in effect."]
            #[inline(always)]
            pub fn set_fair(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub const fn test0(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub fn set_test0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "This is the General Call Disable bit. 0: the response to the General Call address as a slave is enabled 1: the response to the General Call address as a slave is disabled."]
            #[inline(always)]
            pub const fn gc_dis(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "This is the General Call Disable bit. 0: the response to the General Call address as a slave is enabled 1: the response to the General Call address as a slave is disabled."]
            #[inline(always)]
            pub fn set_gc_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "This bit define the Mode of SM Bus Controler Mode of operation. 0= Normal Operation. 1= Promiscuous Mode Enable."]
            #[inline(always)]
            pub const fn cfg_promis(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "This bit define the Mode of SM Bus Controler Mode of operation. 0= Normal Operation. 1= Promiscuous Mode Enable."]
            #[inline(always)]
            pub fn set_cfg_promis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_sxbuf(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_sxbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_srbuf(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_srbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_mxbuf(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_mxbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_mrbuf(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_mrbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "0: Disable the AAS, 1: Enable the AAS Interrupt"]
            #[inline(always)]
            pub const fn en_aas(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "0: Disable the AAS, 1: Enable the AAS Interrupt"]
            #[inline(always)]
            pub fn set_en_aas(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."]
            #[inline(always)]
            pub const fn enidi(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."]
            #[inline(always)]
            pub fn set_enidi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."]
            #[inline(always)]
            pub const fn enmi(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."]
            #[inline(always)]
            pub fn set_enmi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"]
            #[inline(always)]
            pub const fn ensi(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"]
            #[inline(always)]
            pub fn set_ensi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Cfg {
            #[inline(always)]
            fn default() -> Cfg {
                Cfg(0)
            }
        }
        impl core::fmt::Debug for Cfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfg")
                    .field("port_sel", &self.port_sel())
                    .field("tcen", &self.tcen())
                    .field("slow_clk", &self.slow_clk())
                    .field("test", &self.test())
                    .field("pecen", &self.pecen())
                    .field("fen", &self.fen())
                    .field("rst", &self.rst())
                    .field("en", &self.en())
                    .field("dsa", &self.dsa())
                    .field("fair", &self.fair())
                    .field("test0", &self.test0())
                    .field("gc_dis", &self.gc_dis())
                    .field("cfg_promis", &self.cfg_promis())
                    .field("flush_sxbuf", &self.flush_sxbuf())
                    .field("flush_srbuf", &self.flush_srbuf())
                    .field("flush_mxbuf", &self.flush_mxbuf())
                    .field("flush_mrbuf", &self.flush_mrbuf())
                    .field("en_aas", &self.en_aas())
                    .field("enidi", &self.enidi())
                    .field("enmi", &self.enmi())
                    .field("ensi", &self.ensi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cfg {{ port_sel: {=u8:?}, tcen: {=bool:?}, slow_clk: {=bool:?}, test: {=bool:?}, pecen: {=bool:?}, fen: {=bool:?}, rst: {=bool:?}, en: {=bool:?}, dsa: {=bool:?}, fair: {=bool:?}, test0: {=bool:?}, gc_dis: {=bool:?}, cfg_promis: {=bool:?}, flush_sxbuf: {=bool:?}, flush_srbuf: {=bool:?}, flush_mxbuf: {=bool:?}, flush_mrbuf: {=bool:?}, en_aas: {=bool:?}, enidi: {=bool:?}, enmi: {=bool:?}, ensi: {=bool:?} }}" , self . port_sel () , self . tcen () , self . slow_clk () , self . test () , self . pecen () , self . fen () , self . rst () , self . en () , self . dsa () , self . fair () , self . test0 () , self . gc_dis () , self . cfg_promis () , self . flush_sxbuf () , self . flush_srbuf () , self . flush_mxbuf () , self . flush_mrbuf () , self . en_aas () , self . enidi () , self . enmi () , self . ensi ())
            }
        }
        #[doc = "Completion Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Compl(pub u32);
        impl Compl {
            #[doc = "When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."]
            #[inline(always)]
            pub const fn dten(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."]
            #[inline(always)]
            pub fn set_dten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn mcen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_mcen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn scen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_scen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn biden(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_biden(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."]
            #[inline(always)]
            pub const fn timerr(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."]
            #[inline(always)]
            pub fn set_timerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "DTO is the Device Time-out bit. (R/WC)"]
            #[inline(always)]
            pub const fn dto(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "DTO is the Device Time-out bit. (R/WC)"]
            #[inline(always)]
            pub fn set_dto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "MCTO is the Master Cumulative Time-out bit. (R/WC)"]
            #[inline(always)]
            pub const fn mcto(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "MCTO is the Master Cumulative Time-out bit. (R/WC)"]
            #[inline(always)]
            pub fn set_mcto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SCTO is the Slave Cumulative Time-out bit(R/WC)"]
            #[inline(always)]
            pub const fn scto(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SCTO is the Slave Cumulative Time-out bit(R/WC)"]
            #[inline(always)]
            pub fn set_scto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "CHDL is the clock high time-out detect bit(R/WC)"]
            #[inline(always)]
            pub const fn chdl(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "CHDL is the clock high time-out detect bit(R/WC)"]
            #[inline(always)]
            pub fn set_chdl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "CHDH is the bus idle time-out detect bit(R/WC)"]
            #[inline(always)]
            pub const fn chdh(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "CHDH is the bus idle time-out detect bit(R/WC)"]
            #[inline(always)]
            pub fn set_chdh(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub const fn ber(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub fn set_ber(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub const fn lab(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub fn set_lab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."]
            #[inline(always)]
            pub const fn snakr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."]
            #[inline(always)]
            pub fn set_snakr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "0: Slave has just finished the receive phase of a transaction. 1: Slave has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub const fn str(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "0: Slave has just finished the receive phase of a transaction. 1: Slave has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub fn set_str(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "If this bit is 1, the WriteCount\\[7:0\\] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."]
            #[inline(always)]
            pub const fn sprot(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the WriteCount\\[7:0\\] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."]
            #[inline(always)]
            pub fn set_sprot(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."]
            #[inline(always)]
            pub const fn rep_rd(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."]
            #[inline(always)]
            pub fn set_rep_rd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."]
            #[inline(always)]
            pub const fn rep_wr(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."]
            #[inline(always)]
            pub fn set_rep_wr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"]
            #[inline(always)]
            pub const fn mnakx(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"]
            #[inline(always)]
            pub fn set_mnakx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "0: Master has just finished the receive phase of a transaction. 1: Master has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub const fn mtr(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "0: Master has just finished the receive phase of a transaction. 1: Master has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub fn set_mtr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"]
            #[inline(always)]
            pub const fn idle(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"]
            #[inline(always)]
            pub fn set_idle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn mdone(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_mdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"]
            #[inline(always)]
            pub const fn sdone(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"]
            #[inline(always)]
            pub fn set_sdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Compl {
            #[inline(always)]
            fn default() -> Compl {
                Compl(0)
            }
        }
        impl core::fmt::Debug for Compl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Compl")
                    .field("dten", &self.dten())
                    .field("mcen", &self.mcen())
                    .field("scen", &self.scen())
                    .field("biden", &self.biden())
                    .field("timerr", &self.timerr())
                    .field("dto", &self.dto())
                    .field("mcto", &self.mcto())
                    .field("scto", &self.scto())
                    .field("chdl", &self.chdl())
                    .field("chdh", &self.chdh())
                    .field("ber", &self.ber())
                    .field("lab", &self.lab())
                    .field("snakr", &self.snakr())
                    .field("str", &self.str())
                    .field("sprot", &self.sprot())
                    .field("rep_rd", &self.rep_rd())
                    .field("rep_wr", &self.rep_wr())
                    .field("mnakx", &self.mnakx())
                    .field("mtr", &self.mtr())
                    .field("idle", &self.idle())
                    .field("mdone", &self.mdone())
                    .field("sdone", &self.sdone())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Compl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Compl {{ dten: {=bool:?}, mcen: {=bool:?}, scen: {=bool:?}, biden: {=bool:?}, timerr: {=bool:?}, dto: {=bool:?}, mcto: {=bool:?}, scto: {=bool:?}, chdl: {=bool:?}, chdh: {=bool:?}, ber: {=bool:?}, lab: {=bool:?}, snakr: {=bool:?}, str: {=bool:?}, sprot: {=bool:?}, rep_rd: {=bool:?}, rep_wr: {=bool:?}, mnakx: {=bool:?}, mtr: {=bool:?}, idle: {=bool:?}, mdone: {=bool:?}, sdone: {=bool:?} }}" , self . dten () , self . mcen () , self . scen () , self . biden () , self . timerr () , self . dto () , self . mcto () , self . scto () , self . chdl () , self . chdh () , self . ber () , self . lab () , self . snakr () , self . str () , self . sprot () , self . rep_rd () , self . rep_wr () , self . mnakx () , self . mtr () , self . idle () , self . mdone () , self . sdone ())
            }
        }
        #[doc = "Data Timing Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Datatm(pub u32);
        impl Datatm {
            #[doc = "The Data Hold \\[7:0\\] timer determines the SDAT hold time following SCLK driven low."]
            #[inline(always)]
            pub const fn data_hold(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Data Hold \\[7:0\\] timer determines the SDAT hold time following SCLK driven low."]
            #[inline(always)]
            pub fn set_data_hold(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "The Restart Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition."]
            #[inline(always)]
            pub const fn restart_setup(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "The Restart Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition."]
            #[inline(always)]
            pub fn set_restart_setup(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "The Stop Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition."]
            #[inline(always)]
            pub const fn stop_setup(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "The Stop Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition."]
            #[inline(always)]
            pub fn set_stop_setup(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register."]
            #[inline(always)]
            pub const fn first_start_hold(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register."]
            #[inline(always)]
            pub fn set_first_start_hold(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Datatm {
            #[inline(always)]
            fn default() -> Datatm {
                Datatm(0)
            }
        }
        impl core::fmt::Debug for Datatm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Datatm")
                    .field("data_hold", &self.data_hold())
                    .field("restart_setup", &self.restart_setup())
                    .field("stop_setup", &self.stop_setup())
                    .field("first_start_hold", &self.first_start_hold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Datatm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Datatm {{ data_hold: {=u8:?}, restart_setup: {=u8:?}, stop_setup: {=u8:?}, first_start_hold: {=u8:?} }}" , self . data_hold () , self . restart_setup () , self . stop_setup () , self . first_start_hold ())
            }
        }
        #[doc = "Extended Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ExtndLen(pub u32);
        impl ExtndLen {
            #[doc = "Extended Length Register adds 8 MSB bits to the SMBUS Master/Slave Tx/Rx Length fields."]
            #[inline(always)]
            pub const fn extnd_len(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Extended Length Register adds 8 MSB bits to the SMBUS Master/Slave Tx/Rx Length fields."]
            #[inline(always)]
            pub fn set_extnd_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for ExtndLen {
            #[inline(always)]
            fn default() -> ExtndLen {
                ExtndLen(0)
            }
        }
        impl core::fmt::Debug for ExtndLen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ExtndLen")
                    .field("extnd_len", &self.extnd_len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtndLen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ExtndLen {{ extnd_len: {=u8:?} }}", self.extnd_len())
            }
        }
        #[doc = "Idle Scaling Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Idlsc(pub u32);
        impl Idlsc {
            #[doc = "This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub const fn fair_bus_idl_min(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub fn set_fair_bus_idl_min(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub const fn fair_idl_dly(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x0fff;
                val as u16
            }
            #[doc = "This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub fn set_fair_idl_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 16usize)) | (((val as u32) & 0x0fff) << 16usize);
            }
        }
        impl Default for Idlsc {
            #[inline(always)]
            fn default() -> Idlsc {
                Idlsc(0)
            }
        }
        impl core::fmt::Debug for Idlsc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Idlsc")
                    .field("fair_bus_idl_min", &self.fair_bus_idl_min())
                    .field("fair_idl_dly", &self.fair_idl_dly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Idlsc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Idlsc {{ fair_bus_idl_min: {=u16:?}, fair_idl_dly: {=u16:?} }}",
                    self.fair_bus_idl_min(),
                    self.fair_idl_dly()
                )
            }
        }
        #[doc = "SMBus Master Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mcmd(pub u32);
        impl Mcmd {
            #[doc = "While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."]
            #[inline(always)]
            pub const fn mrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."]
            #[inline(always)]
            pub fn set_mrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."]
            #[inline(always)]
            pub const fn mproceed(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."]
            #[inline(always)]
            pub fn set_mproceed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub const fn start0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub fn set_start0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub const fn startn(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub fn set_startn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "If this bit is 1, send a Stop bit after the transaction completes."]
            #[inline(always)]
            pub const fn stop(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Stop bit after the transaction completes."]
            #[inline(always)]
            pub fn set_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."]
            #[inline(always)]
            pub const fn pec_term(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."]
            #[inline(always)]
            pub fn set_pec_term(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount\\[7:0\\] is 1. After ReadCount\\[7:0\\] is updated, this bit is cleared to 0."]
            #[inline(always)]
            pub const fn readm(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount\\[7:0\\] is 1. After ReadCount\\[7:0\\] is updated, this bit is cleared to 0."]
            #[inline(always)]
            pub fn set_readm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."]
            #[inline(always)]
            pub const fn read_pec(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."]
            #[inline(always)]
            pub fn set_read_pec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."]
            #[inline(always)]
            pub const fn wr_cnt(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."]
            #[inline(always)]
            pub fn set_wr_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."]
            #[inline(always)]
            pub const fn rd_cnt(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."]
            #[inline(always)]
            pub fn set_rd_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Mcmd {
            #[inline(always)]
            fn default() -> Mcmd {
                Mcmd(0)
            }
        }
        impl core::fmt::Debug for Mcmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mcmd")
                    .field("mrun", &self.mrun())
                    .field("mproceed", &self.mproceed())
                    .field("start0", &self.start0())
                    .field("startn", &self.startn())
                    .field("stop", &self.stop())
                    .field("pec_term", &self.pec_term())
                    .field("readm", &self.readm())
                    .field("read_pec", &self.read_pec())
                    .field("wr_cnt", &self.wr_cnt())
                    .field("rd_cnt", &self.rd_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mcmd {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mcmd {{ mrun: {=bool:?}, mproceed: {=bool:?}, start0: {=bool:?}, startn: {=bool:?}, stop: {=bool:?}, pec_term: {=bool:?}, readm: {=bool:?}, read_pec: {=bool:?}, wr_cnt: {=u8:?}, rd_cnt: {=u8:?} }}" , self . mrun () , self . mproceed () , self . start0 () , self . startn () , self . stop () , self . pec_term () , self . readm () , self . read_pec () , self . wr_cnt () , self . rd_cnt ())
            }
        }
        #[doc = "SMBus Master Receive Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtrRxb(pub u32);
        impl MtrRxb {
            #[doc = "MASTER_RECEIVE_BUFFER"]
            #[inline(always)]
            pub const fn mrxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MASTER_RECEIVE_BUFFER"]
            #[inline(always)]
            pub fn set_mrxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for MtrRxb {
            #[inline(always)]
            fn default() -> MtrRxb {
                MtrRxb(0)
            }
        }
        impl core::fmt::Debug for MtrRxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtrRxb").field("mrxb", &self.mrxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtrRxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MtrRxb {{ mrxb: {=u8:?} }}", self.mrxb())
            }
        }
        #[doc = "SMBus Master Transmit Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtrTxb(pub u32);
        impl MtrTxb {
            #[doc = "MASTER_TRANSMIT_BUFFER"]
            #[inline(always)]
            pub const fn mtxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MASTER_TRANSMIT_BUFFER"]
            #[inline(always)]
            pub fn set_mtxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for MtrTxb {
            #[inline(always)]
            fn default() -> MtrTxb {
                MtrTxb(0)
            }
        }
        impl core::fmt::Debug for MtrTxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtrTxb").field("mtxb", &self.mtxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtrTxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MtrTxb {{ mtxb: {=u8:?} }}", self.mtxb())
            }
        }
        #[doc = "Own Address Register Note that the Data Register and Own Address fields are offset by one bit, so that programming Own Address 1 with a value of 55h will result in the value AAh being recognized as the SMB Controller Core slave address."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OwnAddr(pub u32);
        impl OwnAddr {
            #[doc = "The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub const fn addr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub fn set_addr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub const fn addr2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x7f;
                val as u8
            }
            #[doc = "The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub fn set_addr2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 8usize)) | (((val as u32) & 0x7f) << 8usize);
            }
        }
        impl Default for OwnAddr {
            #[inline(always)]
            fn default() -> OwnAddr {
                OwnAddr(0)
            }
        }
        impl core::fmt::Debug for OwnAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OwnAddr")
                    .field("addr1", &self.addr1())
                    .field("addr2", &self.addr2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OwnAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "OwnAddr {{ addr1: {=u8:?}, addr2: {=u8:?} }}",
                    self.addr1(),
                    self.addr2()
                )
            }
        }
        #[doc = "Packet Error Check (PEC) Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pec(pub u32);
        impl Pec {
            #[doc = "The SMBus Packet Error Check (PEC) byte."]
            #[inline(always)]
            pub const fn pec(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The SMBus Packet Error Check (PEC) byte."]
            #[inline(always)]
            pub fn set_pec(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Pec {
            #[inline(always)]
            fn default() -> Pec {
                Pec(0)
            }
        }
        impl core::fmt::Debug for Pec {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pec").field("pec", &self.pec()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pec {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pec {{ pec: {=u8:?} }}", self.pec())
            }
        }
        #[doc = "This is the Promiscuous Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PrmCtrl(pub u8);
        impl PrmCtrl {
            #[doc = "This is the Promiscuous ACK / NAK response register. 1= ACK. 0= NAK."]
            #[inline(always)]
            pub const fn ack_nak(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the Promiscuous ACK / NAK response register. 1= ACK. 0= NAK."]
            #[inline(always)]
            pub fn set_ack_nak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for PrmCtrl {
            #[inline(always)]
            fn default() -> PrmCtrl {
                PrmCtrl(0)
            }
        }
        impl core::fmt::Debug for PrmCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PrmCtrl").field("ack_nak", &self.ack_nak()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PrmCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PrmCtrl {{ ack_nak: {=bool:?} }}", self.ack_nak())
            }
        }
        #[doc = "This is the Promiscuous Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PrmIen(pub u8);
        impl PrmIen {
            #[doc = "This is the Promiscuous interrupt enable register. 1= Interrupt Enable. 0= Interrupt Disabled."]
            #[inline(always)]
            pub const fn addr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the Promiscuous interrupt enable register. 1= Interrupt Enable. 0= Interrupt Disabled."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for PrmIen {
            #[inline(always)]
            fn default() -> PrmIen {
                PrmIen(0)
            }
        }
        impl core::fmt::Debug for PrmIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PrmIen").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PrmIen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PrmIen {{ addr: {=bool:?} }}", self.addr())
            }
        }
        #[doc = "This is the Promiscuous Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PrmSts(pub u8);
        impl PrmSts {
            #[doc = "This is the Promiscuous Address Status interrupt and is set on the 8th clock of the I2C Address. This bit will hold the Clock line low till this register bit is cleared. This is Write 1 to clear. R/W1C."]
            #[inline(always)]
            pub const fn addr_intr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the Promiscuous Address Status interrupt and is set on the 8th clock of the I2C Address. This bit will hold the Clock line low till this register bit is cleared. This is Write 1 to clear. R/W1C."]
            #[inline(always)]
            pub fn set_addr_intr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for PrmSts {
            #[inline(always)]
            fn default() -> PrmSts {
                PrmSts(0)
            }
        }
        impl core::fmt::Debug for PrmSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PrmSts").field("addr_intr", &self.addr_intr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PrmSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PrmSts {{ addr_intr: {=bool:?} }}", self.addr_intr())
            }
        }
        #[doc = "Repeated Start Hold Time Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rshtm(pub u32);
        impl Rshtm {
            #[doc = "This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold the clock until the Hold Time for the repeated Start Bit has been satisfied."]
            #[inline(always)]
            pub const fn rshtm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold the clock until the Hold Time for the repeated Start Bit has been satisfied."]
            #[inline(always)]
            pub fn set_rshtm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Rshtm {
            #[inline(always)]
            fn default() -> Rshtm {
                Rshtm(0)
            }
        }
        impl core::fmt::Debug for Rshtm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rshtm").field("rshtm", &self.rshtm()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rshtm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rshtm {{ rshtm: {=u8:?} }}", self.rshtm())
            }
        }
        #[doc = "Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rsts(pub u32);
        impl Rsts {
            #[doc = "The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible."]
            #[inline(always)]
            pub const fn nbb(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible."]
            #[inline(always)]
            pub fn set_nbb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus"]
            #[inline(always)]
            pub const fn lab(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus"]
            #[inline(always)]
            pub fn set_lab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received"]
            #[inline(always)]
            pub const fn aas(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received"]
            #[inline(always)]
            pub fn set_aas(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "The Last Received Bit or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0'). When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus. When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave."]
            #[inline(always)]
            pub const fn lrb_ad0(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "The Last Received Bit or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0'). When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus. When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave."]
            #[inline(always)]
            pub fn set_lrb_ad0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected."]
            #[inline(always)]
            pub const fn ber(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected."]
            #[inline(always)]
            pub fn set_ber(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode."]
            #[inline(always)]
            pub const fn sts(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode."]
            #[inline(always)]
            pub fn set_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "SMBus Address Decoded (SAD)"]
            #[inline(always)]
            pub const fn sad(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "SMBus Address Decoded (SAD)"]
            #[inline(always)]
            pub fn set_sad(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Pending Interrupt bit"]
            #[inline(always)]
            pub const fn pin(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Pending Interrupt bit"]
            #[inline(always)]
            pub fn set_pin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Rsts {
            #[inline(always)]
            fn default() -> Rsts {
                Rsts(0)
            }
        }
        impl core::fmt::Debug for Rsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rsts")
                    .field("nbb", &self.nbb())
                    .field("lab", &self.lab())
                    .field("aas", &self.aas())
                    .field("lrb_ad0", &self.lrb_ad0())
                    .field("ber", &self.ber())
                    .field("sts", &self.sts())
                    .field("sad", &self.sad())
                    .field("pin", &self.pin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rsts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rsts {{ nbb: {=bool:?}, lab: {=bool:?}, aas: {=bool:?}, lrb_ad0: {=bool:?}, ber: {=bool:?}, sts: {=bool:?}, sad: {=bool:?}, pin: {=bool:?} }}" , self . nbb () , self . lab () , self . aas () , self . lrb_ad0 () , self . ber () , self . sts () , self . sad () , self . pin ())
            }
        }
        #[doc = "SMBus Slave Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scmd(pub u32);
        impl Scmd {
            #[doc = "Setting this bit to 1 enables the Slave State Machine to operate."]
            #[inline(always)]
            pub const fn srun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting this bit to 1 enables the Slave State Machine to operate."]
            #[inline(always)]
            pub fn set_srun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."]
            #[inline(always)]
            pub const fn sproceed(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."]
            #[inline(always)]
            pub fn set_sproceed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."]
            #[inline(always)]
            pub const fn pec(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."]
            #[inline(always)]
            pub fn set_pec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This field is set to the number of bytes software expects to send to the Master."]
            #[inline(always)]
            pub const fn wr_cnt(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field is set to the number of bytes software expects to send to the Master."]
            #[inline(always)]
            pub fn set_wr_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."]
            #[inline(always)]
            pub const fn rd_cnt(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."]
            #[inline(always)]
            pub fn set_rd_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for Scmd {
            #[inline(always)]
            fn default() -> Scmd {
                Scmd(0)
            }
        }
        impl core::fmt::Debug for Scmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scmd")
                    .field("srun", &self.srun())
                    .field("sproceed", &self.sproceed())
                    .field("pec", &self.pec())
                    .field("wr_cnt", &self.wr_cnt())
                    .field("rd_cnt", &self.rd_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Scmd {{ srun: {=bool:?}, sproceed: {=bool:?}, pec: {=bool:?}, wr_cnt: {=u8:?}, rd_cnt: {=u8:?} }}",
                    self.srun(),
                    self.sproceed(),
                    self.pec(),
                    self.wr_cnt(),
                    self.rd_cnt()
                )
            }
        }
        #[doc = "This is the I2C Shadow Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ShdwData(pub u8);
        impl ShdwData {
            #[doc = "This is the I2C Shadow Data Register"]
            #[inline(always)]
            pub const fn shdw_data(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This is the I2C Shadow Data Register"]
            #[inline(always)]
            pub fn set_shdw_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ShdwData {
            #[inline(always)]
            fn default() -> ShdwData {
                ShdwData(0)
            }
        }
        impl core::fmt::Debug for ShdwData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ShdwData")
                    .field("shdw_data", &self.shdw_data())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ShdwData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ShdwData {{ shdw_data: {=u8:?} }}", self.shdw_data())
            }
        }
        #[doc = "This is the Slave Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlvAddr(pub u8);
        impl SlvAddr {
            #[doc = "This register stores value of address + LSB direction after the 8th clock of the Address Byte."]
            #[inline(always)]
            pub const fn saddr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This register stores value of address + LSB direction after the 8th clock of the Address Byte."]
            #[inline(always)]
            pub fn set_saddr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for SlvAddr {
            #[inline(always)]
            fn default() -> SlvAddr {
                SlvAddr(0)
            }
        }
        impl core::fmt::Debug for SlvAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlvAddr").field("saddr", &self.saddr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlvAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SlvAddr {{ saddr: {=u8:?} }}", self.saddr())
            }
        }
        #[doc = "SMBus Slave Receive Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlvRxb(pub u32);
        impl SlvRxb {
            #[doc = "SLAVE_RECEIVE_BUFFER"]
            #[inline(always)]
            pub const fn srxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "SLAVE_RECEIVE_BUFFER"]
            #[inline(always)]
            pub fn set_srxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for SlvRxb {
            #[inline(always)]
            fn default() -> SlvRxb {
                SlvRxb(0)
            }
        }
        impl core::fmt::Debug for SlvRxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlvRxb").field("srxb", &self.srxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlvRxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SlvRxb {{ srxb: {=u8:?} }}", self.srxb())
            }
        }
        #[doc = "SMBus Slave Transmit Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlvTxb(pub u32);
        impl SlvTxb {
            #[doc = "SLAVE_TRANSMIT_BUFFER"]
            #[inline(always)]
            pub const fn stxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "SLAVE_TRANSMIT_BUFFER"]
            #[inline(always)]
            pub fn set_stxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for SlvTxb {
            #[inline(always)]
            fn default() -> SlvTxb {
                SlvTxb(0)
            }
        }
        impl core::fmt::Debug for SlvTxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlvTxb").field("stxb", &self.stxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlvTxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SlvTxb {{ stxb: {=u8:?} }}", self.stxb())
            }
        }
        #[doc = "Test"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Test(pub u8);
        impl Test {
            #[doc = "This register must not be written, or undesirable results may occur."]
            #[inline(always)]
            pub const fn test(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This register must not be written, or undesirable results may occur."]
            #[inline(always)]
            pub fn set_test(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Test {
            #[inline(always)]
            fn default() -> Test {
                Test(0)
            }
        }
        impl core::fmt::Debug for Test {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Test").field("test", &self.test()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Test {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Test {{ test: {=u8:?} }}", self.test())
            }
        }
        #[doc = "Time-Out Scaling Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmoutsc(pub u32);
        impl Tmoutsc {
            #[doc = "Clock High time out period = Clock High Time-Out \\[7:0\\] x Baud_Clock_Period x 2"]
            #[inline(always)]
            pub const fn clk_high_tim_out(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Clock High time out period = Clock High Time-Out \\[7:0\\] x Baud_Clock_Period x 2"]
            #[inline(always)]
            pub fn set_clk_high_tim_out(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Slave Cumulative Time-Out duration = Slave Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 1024"]
            #[inline(always)]
            pub const fn slv_cum_tim_out(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Slave Cumulative Time-Out duration = Slave Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 1024"]
            #[inline(always)]
            pub fn set_slv_cum_tim_out(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Master Cumulative Time-Out duration = Master Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 512"]
            #[inline(always)]
            pub const fn mast_cum_tim_out(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Master Cumulative Time-Out duration = Master Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 512"]
            #[inline(always)]
            pub fn set_mast_cum_tim_out(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Bus Idle Minimum time = Bus Idle Min \\[7:0\\] x Baud_Clock_Period"]
            #[inline(always)]
            pub const fn bus_idle_min(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Bus Idle Minimum time = Bus Idle Min \\[7:0\\] x Baud_Clock_Period"]
            #[inline(always)]
            pub fn set_bus_idle_min(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tmoutsc {
            #[inline(always)]
            fn default() -> Tmoutsc {
                Tmoutsc(0)
            }
        }
        impl core::fmt::Debug for Tmoutsc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmoutsc")
                    .field("clk_high_tim_out", &self.clk_high_tim_out())
                    .field("slv_cum_tim_out", &self.slv_cum_tim_out())
                    .field("mast_cum_tim_out", &self.mast_cum_tim_out())
                    .field("bus_idle_min", &self.bus_idle_min())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmoutsc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tmoutsc {{ clk_high_tim_out: {=u8:?}, slv_cum_tim_out: {=u8:?}, mast_cum_tim_out: {=u8:?}, bus_idle_min: {=u8:?} }}" , self . clk_high_tim_out () , self . slv_cum_tim_out () , self . mast_cum_tim_out () , self . bus_idle_min ())
            }
        }
        #[doc = "WAKE ENABLE Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WakeEn(pub u32);
        impl WakeEn {
            #[doc = "Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable. 1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled"]
            #[inline(always)]
            pub const fn start_det_int_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable. 1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled"]
            #[inline(always)]
            pub fn set_start_det_int_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for WakeEn {
            #[inline(always)]
            fn default() -> WakeEn {
                WakeEn(0)
            }
        }
        impl core::fmt::Debug for WakeEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WakeEn")
                    .field("start_det_int_en", &self.start_det_int_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WakeEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WakeEn {{ start_det_int_en: {=bool:?} }}", self.start_det_int_en())
            }
        }
        #[doc = "WAKE STATUS Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WakeSts(pub u32);
        impl WakeSts {
            #[doc = "This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when written with a '1'. Writes of '0' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn start_bit_det(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when written with a '1'. Writes of '0' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_start_bit_det(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for WakeSts {
            #[inline(always)]
            fn default() -> WakeSts {
                WakeSts(0)
            }
        }
        impl core::fmt::Debug for WakeSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WakeSts")
                    .field("start_bit_det", &self.start_bit_det())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WakeSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WakeSts {{ start_bit_det: {=bool:?} }}", self.start_bit_det())
            }
        }
        #[doc = "Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wctrl(pub u32);
        impl Wctrl {
            #[doc = "The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device."]
            #[inline(always)]
            pub const fn ack(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device."]
            #[inline(always)]
            pub fn set_ack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "See STA description"]
            #[inline(always)]
            pub const fn sto(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "See STA description"]
            #[inline(always)]
            pub fn set_sto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition"]
            #[inline(always)]
            pub const fn sta(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition"]
            #[inline(always)]
            pub fn set_sta(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable Interrupt bit (ENI) controls the Interrupt Interface"]
            #[inline(always)]
            pub const fn eni(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Interrupt bit (ENI) controls the Interrupt Interface"]
            #[inline(always)]
            pub fn set_eni(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)"]
            #[inline(always)]
            pub const fn eso(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)"]
            #[inline(always)]
            pub fn set_eso(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect."]
            #[inline(always)]
            pub const fn pin(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect."]
            #[inline(always)]
            pub fn set_pin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Wctrl {
            #[inline(always)]
            fn default() -> Wctrl {
                Wctrl(0)
            }
        }
        impl core::fmt::Debug for Wctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wctrl")
                    .field("ack", &self.ack())
                    .field("sto", &self.sto())
                    .field("sta", &self.sta())
                    .field("eni", &self.eni())
                    .field("eso", &self.eso())
                    .field("pin", &self.pin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Wctrl {{ ack: {=bool:?}, sto: {=bool:?}, sta: {=bool:?}, eni: {=bool:?}, eso: {=bool:?}, pin: {=bool:?} }}" , self . ack () , self . sto () , self . sta () , self . eni () , self . eso () , self . pin ())
            }
        }
    }
}
pub mod spi_mon0 {
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct FlashSet {
        ptr: *mut u8,
    }
    unsafe impl Send for FlashSet {}
    unsafe impl Sync for FlashSet {}
    impl FlashSet {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Permit Address Register"]
        #[inline(always)]
        pub const fn op_prmt(self, n: usize) -> crate::common::Reg<regs::OpPrmt, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Kill Address Register"]
        #[inline(always)]
        pub const fn op_killmd(self, n: usize) -> crate::common::Reg<regs::OpKillmd, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 4usize) as _) }
        }
        #[doc = "Write Protect Address Register"]
        #[inline(always)]
        pub const fn op_wprot(self, n: usize) -> crate::common::Reg<regs::OpWprot, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize + n * 4usize) as _) }
        }
        #[doc = "Lock Address Register"]
        #[inline(always)]
        pub const fn op_lock(self, n: usize) -> crate::common::Reg<regs::OpLock, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize + n * 4usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct LtMon {
        ptr: *mut u8,
    }
    unsafe impl Send for LtMon {}
    unsafe impl Sync for LtMon {}
    impl LtMon {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Loadtime Monitor Control/Status Register"]
        #[inline(always)]
        pub const fn lm_ctrlsts(self) -> crate::common::Reg<regs::LmCtrlsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Loadtime Monitor Channel Control Register"]
        #[inline(always)]
        pub const fn lm_chn_ctrl(self) -> crate::common::Reg<regs::LmChnCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Loadtime Monitor Channel Begin Register"]
        #[inline(always)]
        pub const fn lm_begin(self) -> crate::common::Reg<regs::LmBegin, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Loadtime Monitor Channel End Register"]
        #[inline(always)]
        pub const fn lm_end(self) -> crate::common::Reg<regs::LmEnd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Loadtime Monitor Channel Count Register"]
        #[inline(always)]
        pub const fn lm_count(self) -> crate::common::Reg<regs::LmCount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Loadtime Monitor Channel Digest Register"]
        #[inline(always)]
        pub const fn lm_digest(self) -> crate::common::Reg<regs::LmDigest, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MtMon {
        ptr: *mut u8,
    }
    unsafe impl Send for MtMon {}
    unsafe impl Sync for MtMon {}
    impl MtMon {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Match Monitor Region Begin Register"]
        #[inline(always)]
        pub const fn mtmon_begin(self) -> crate::common::Reg<regs::MtmonBegin, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Match Monitor Region End Register"]
        #[inline(always)]
        pub const fn mtmon_end(self) -> crate::common::Reg<regs::MtmonEnd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Match Monitor Region Map Register"]
        #[inline(always)]
        pub const fn map(self) -> crate::common::Reg<regs::Map, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct RnTm {
        ptr: *mut u8,
    }
    unsafe impl Send for RnTm {}
    unsafe impl Sync for RnTm {}
    impl RnTm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Runtime Monitoring Start Register"]
        #[inline(always)]
        pub const fn rt_start(self) -> crate::common::Reg<regs::RtStart, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Runtime Monitoring Limit Register"]
        #[inline(always)]
        pub const fn rt_limit(self) -> crate::common::Reg<regs::RtLimit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "SPI Monitor Block"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SpiMon0 {
        ptr: *mut u8,
    }
    unsafe impl Send for SpiMon0 {}
    unsafe impl Sync for SpiMon0 {}
    impl SpiMon0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SPI Monitor Control Register"]
        #[inline(always)]
        pub const fn mntr_ctrl(self) -> crate::common::Reg<regs::MntrCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SPI Configuration Status Register"]
        #[inline(always)]
        pub const fn cfg_sts(self) -> crate::common::Reg<regs::CfgSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Monitor Configuration 2 Register"]
        #[inline(always)]
        pub const fn spicfg2(self) -> crate::common::Reg<regs::Spicfg2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Violation IRQ Control/Status Register"]
        #[inline(always)]
        pub const fn vioctrlsts(self) -> crate::common::Reg<regs::Vioctrlsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SPI Intervention Status Register"]
        #[inline(always)]
        pub const fn ivn_sts(self) -> crate::common::Reg<regs::IvnSts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "SPI Intervention Recovery Register"]
        #[inline(always)]
        pub const fn ivn_rec(self) -> crate::common::Reg<regs::IvnRec, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x11usize) as _) }
        }
        #[doc = "Violation Log Register"]
        #[inline(always)]
        pub const fn vio_sts(self) -> crate::common::Reg<regs::VioSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Error Byte Address Register"]
        #[inline(always)]
        pub const fn err_addr(self) -> crate::common::Reg<regs::ErrAddr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[inline(always)]
        pub const fn flash_set(self, n: usize) -> FlashSet {
            assert!(n < 2usize);
            unsafe { FlashSet::from_ptr(self.ptr.add(0x20usize + n * 128usize) as _) }
        }
        #[inline(always)]
        pub const fn rn_tm(self, n: usize) -> RnTm {
            assert!(n < 16usize);
            unsafe { RnTm::from_ptr(self.ptr.add(0x0120usize + n * 8usize) as _) }
        }
        #[doc = "Match Monitor Control/Status Register"]
        #[inline(always)]
        pub const fn mtmon_ctrlsts(self) -> crate::common::Reg<regs::MtmonCtrlsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d0usize) as _) }
        }
        #[doc = "Match Monitor Enable/Mode Register"]
        #[inline(always)]
        pub const fn mtmon_enmd(self) -> crate::common::Reg<regs::MtmonEnmd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d4usize) as _) }
        }
        #[doc = "Match Fetch Timeout Control Register"]
        #[inline(always)]
        pub const fn mtmon_tctrl(self) -> crate::common::Reg<regs::MtmonTctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d8usize) as _) }
        }
        #[inline(always)]
        pub const fn mt_mon(self, n: usize) -> MtMon {
            assert!(n < 8usize);
            unsafe { MtMon::from_ptr(self.ptr.add(0x01e0usize + n * 12usize) as _) }
        }
        #[doc = "Match Monitor Violation Log Register"]
        #[inline(always)]
        pub const fn mtmon_viosts(self) -> crate::common::Reg<regs::MtmonViosts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0240usize) as _) }
        }
        #[doc = "Match Monitor Violation Address Register"]
        #[inline(always)]
        pub const fn mtmon_vioaddr(self) -> crate::common::Reg<regs::MtmonVioaddr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0244usize) as _) }
        }
        #[doc = "Loadtime (Hash) IRQ Aggregation Register"]
        #[inline(always)]
        pub const fn ltmon_aggr(self) -> crate::common::Reg<regs::LtmonAggr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0250usize) as _) }
        }
        #[inline(always)]
        pub const fn lt_mon(self, n: usize) -> LtMon {
            assert!(n < 8usize);
            unsafe { LtMon::from_ptr(self.ptr.add(0x0254usize + n * 24usize) as _) }
        }
        #[doc = "Load Monitor Control/Status Register"]
        #[inline(always)]
        pub const fn ltmon_ctrlsts(self) -> crate::common::Reg<regs::LtmonCtrlsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0314usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "SPI Configuration Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CfgSts(pub u32);
        impl CfgSts {
            #[doc = "Flash Intervention Mode. 0 = Power-Off (POR), 1 = RESET# Pulse"]
            #[inline(always)]
            pub const fn imd(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Flash Intervention Mode. 0 = Power-Off (POR), 1 = RESET# Pulse"]
            #[inline(always)]
            pub fn set_imd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "RESET# to CS# High Delay. 2^n x 20us, 00h=20us, 1Fh= 1.3sec. IRQ triggers at this point also."]
            #[inline(always)]
            pub const fn rst2csh(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x1f;
                val as u8
            }
            #[doc = "RESET# to CS# High Delay. 2^n x 20us, 00h=20us, 1Fh= 1.3sec. IRQ triggers at this point also."]
            #[inline(always)]
            pub fn set_rst2csh(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 1usize)) | (((val as u32) & 0x1f) << 1usize);
            }
            #[doc = "Quad Bus Disable, 1 = Half Bus Mode, 0 = IO\\[3:0\\] are all controlled by EQS."]
            #[inline(always)]
            pub const fn qbd(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Quad Bus Disable, 1 = Half Bus Mode, 0 = IO\\[3:0\\] are all controlled by EQS."]
            #[inline(always)]
            pub fn set_qbd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Cross-Over Q-Switch status. (BMC->CPU). RO image of Interbus bit which as 1 overrides EQS bit at both SPI buses without changing their states."]
            #[inline(always)]
            pub const fn xqs(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Cross-Over Q-Switch status. (BMC->CPU). RO image of Interbus bit which as 1 overrides EQS bit at both SPI buses without changing their states."]
            #[inline(always)]
            pub fn set_xqs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable Q-Switch (Isolator) to Host. 0 = Disable, 1 = Enable."]
            #[inline(always)]
            pub const fn eqs(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Q-Switch (Isolator) to Host. 0 = Disable, 1 = Enable."]
            #[inline(always)]
            pub fn set_eqs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Chip Select Routing. 000 = Both CSn#_In pass directly to CSn# Out, both enabled out. 001 = CS1n_In passes to CS1# Output, but CS0# Output is disabled (floats high). 010 = CS0n_In passes to CS0# Output, but CS1# Output is disabled (floats high). 100 = Swap CS1#/CS0#_In to CS0#/CS1# Out respectively, both enabled out. 101 = CS0n_In passes to CS1# Out, and CS0# Output is disabled (floats high). 110 = CS1n_In passes to CS0# Out, and CS1# Output is disabled (floats high). x11 = CS0n/CS1n Outputs are both disabled (floating high) regardless of inputs."]
            #[inline(always)]
            pub const fn csrt(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x07;
                val as u8
            }
            #[doc = "Chip Select Routing. 000 = Both CSn#_In pass directly to CSn# Out, both enabled out. 001 = CS1n_In passes to CS1# Output, but CS0# Output is disabled (floats high). 010 = CS0n_In passes to CS0# Output, but CS1# Output is disabled (floats high). 100 = Swap CS1#/CS0#_In to CS0#/CS1# Out respectively, both enabled out. 101 = CS0n_In passes to CS1# Out, and CS0# Output is disabled (floats high). 110 = CS1n_In passes to CS0# Out, and CS1# Output is disabled (floats high). x11 = CS0n/CS1n Outputs are both disabled (floating high) regardless of inputs."]
            #[inline(always)]
            pub fn set_csrt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 9usize)) | (((val as u32) & 0x07) << 9usize);
            }
            #[doc = "Enable following of Address Mode. (SPI Snooping) for each Flash. 0=Disable, 1=Enable"]
            #[inline(always)]
            pub const fn f0f(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable following of Address Mode. (SPI Snooping) for each Flash. 0=Disable, 1=Enable"]
            #[inline(always)]
            pub fn set_f0f(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable following of Address Mode. (SPI Snooping) for each Flash. 0=Disable, 1=Enable"]
            #[inline(always)]
            pub const fn f1f(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable following of Address Mode. (SPI Snooping) for each Flash. 0=Disable, 1=Enable"]
            #[inline(always)]
            pub fn set_f1f(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Set 3B/4B Address Mode for Flash 0. 0=3B Address Mode, 1=4B Address Mode"]
            #[inline(always)]
            pub const fn f0a(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Set 3B/4B Address Mode for Flash 0. 0=3B Address Mode, 1=4B Address Mode"]
            #[inline(always)]
            pub fn set_f0a(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Set 3B/4B Address Mode for Flash 1. 0=3B Address Mode, 1=4B Address Mode"]
            #[inline(always)]
            pub const fn f1a(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Set 3B/4B Address Mode for Flash 1. 0=3B Address Mode, 1=4B Address Mode"]
            #[inline(always)]
            pub fn set_f1a(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Flash 0 Size. Flash sizes are expressed in bytes as a power of 2, matching a Flash Get-ID convention. For the most common cases: 17h = 23d => 2^23 = 8MByte 18h = 24d => 2^24 = 16MByte 19h = 25d => 2^25 = 32MByte 1Ah = 26d => 2^26 = 64MByte"]
            #[inline(always)]
            pub const fn f0size(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x1f;
                val as u8
            }
            #[doc = "Flash 0 Size. Flash sizes are expressed in bytes as a power of 2, matching a Flash Get-ID convention. For the most common cases: 17h = 23d => 2^23 = 8MByte 18h = 24d => 2^24 = 16MByte 19h = 25d => 2^25 = 32MByte 1Ah = 26d => 2^26 = 64MByte"]
            #[inline(always)]
            pub fn set_f0size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
            }
            #[doc = "Enable Wrap Detection. 0=Disable, 1=Enable."]
            #[inline(always)]
            pub const fn e0w(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Wrap Detection. 0=Disable, 1=Enable."]
            #[inline(always)]
            pub fn set_e0w(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Flash 0 Present. 0=Not Present, 1=Present"]
            #[inline(always)]
            pub const fn f0p(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Flash 0 Present. 0=Not Present, 1=Present"]
            #[inline(always)]
            pub fn set_f0p(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Flash 1 Size. Flash sizes are expressed in bytes as a power of 2, matching a Flash Get-ID convention. For the most common cases: 17h = 23d => 2^23 = 8MByte 18h = 24d => 2^24 = 16MByte 19h = 25d => 2^25 = 32MByte 1Ah = 26d => 2^26 = 64MByte"]
            #[inline(always)]
            pub const fn f1size(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Flash 1 Size. Flash sizes are expressed in bytes as a power of 2, matching a Flash Get-ID convention. For the most common cases: 17h = 23d => 2^23 = 8MByte 18h = 24d => 2^24 = 16MByte 19h = 25d => 2^25 = 32MByte 1Ah = 26d => 2^26 = 64MByte"]
            #[inline(always)]
            pub fn set_f1size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
            #[doc = "Enable Wrap Detection. 0=Disable, 1=Enable"]
            #[inline(always)]
            pub const fn e1w(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Wrap Detection. 0=Disable, 1=Enable"]
            #[inline(always)]
            pub fn set_e1w(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Flash 1 Present. 0=Not Present, 1=Present"]
            #[inline(always)]
            pub const fn f1p(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Flash 1 Present. 0=Not Present, 1=Present"]
            #[inline(always)]
            pub fn set_f1p(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for CfgSts {
            #[inline(always)]
            fn default() -> CfgSts {
                CfgSts(0)
            }
        }
        impl core::fmt::Debug for CfgSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CfgSts")
                    .field("imd", &self.imd())
                    .field("rst2csh", &self.rst2csh())
                    .field("qbd", &self.qbd())
                    .field("xqs", &self.xqs())
                    .field("eqs", &self.eqs())
                    .field("csrt", &self.csrt())
                    .field("f0f", &self.f0f())
                    .field("f1f", &self.f1f())
                    .field("f0a", &self.f0a())
                    .field("f1a", &self.f1a())
                    .field("f0size", &self.f0size())
                    .field("e0w", &self.e0w())
                    .field("f0p", &self.f0p())
                    .field("f1size", &self.f1size())
                    .field("e1w", &self.e1w())
                    .field("f1p", &self.f1p())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CfgSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CfgSts {{ imd: {=bool:?}, rst2csh: {=u8:?}, qbd: {=bool:?}, xqs: {=bool:?}, eqs: {=bool:?}, csrt: {=u8:?}, f0f: {=bool:?}, f1f: {=bool:?}, f0a: {=bool:?}, f1a: {=bool:?}, f0size: {=u8:?}, e0w: {=bool:?}, f0p: {=bool:?}, f1size: {=u8:?}, e1w: {=bool:?}, f1p: {=bool:?} }}" , self . imd () , self . rst2csh () , self . qbd () , self . xqs () , self . eqs () , self . csrt () , self . f0f () , self . f1f () , self . f0a () , self . f1a () , self . f0size () , self . e0w () , self . f0p () , self . f1size () , self . e1w () , self . f1p ())
            }
        }
        #[doc = "Error Byte Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ErrAddr(pub u32);
        impl ErrAddr {
            #[doc = "Byte address at which the error occurred, within the designated Flash"]
            #[inline(always)]
            pub const fn addr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Byte address at which the error occurred, within the designated Flash"]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ErrAddr {
            #[inline(always)]
            fn default() -> ErrAddr {
                ErrAddr(0)
            }
        }
        impl core::fmt::Debug for ErrAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ErrAddr").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ErrAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ErrAddr {{ addr: {=u32:?} }}", self.addr())
            }
        }
        #[doc = "SPI Intervention Recovery Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IvnRec(pub u8);
        impl IvnRec {
            #[doc = "Write 1 to clear FCS Flash Chip Selects forced high and bus forced low."]
            #[inline(always)]
            pub const fn fcc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write 1 to clear FCS Flash Chip Selects forced high and bus forced low."]
            #[inline(always)]
            pub fn set_fcc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Write 1 to clear FPO Flash Power or RESET# Activated."]
            #[inline(always)]
            pub const fn fpc(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write 1 to clear FPO Flash Power or RESET# Activated."]
            #[inline(always)]
            pub fn set_fpc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Write 1 to clear HRS Host held in Reset"]
            #[inline(always)]
            pub const fn hrc(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write 1 to clear HRS Host held in Reset"]
            #[inline(always)]
            pub fn set_hrc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Write 1 to clear HIS Host held Isolated"]
            #[inline(always)]
            pub const fn hic(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Write 1 to clear HIS Host held Isolated"]
            #[inline(always)]
            pub fn set_hic(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
        }
        impl Default for IvnRec {
            #[inline(always)]
            fn default() -> IvnRec {
                IvnRec(0)
            }
        }
        impl core::fmt::Debug for IvnRec {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IvnRec")
                    .field("fcc", &self.fcc())
                    .field("fpc", &self.fpc())
                    .field("hrc", &self.hrc())
                    .field("hic", &self.hic())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IvnRec {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "IvnRec {{ fcc: {=bool:?}, fpc: {=bool:?}, hrc: {=bool:?}, hic: {=bool:?} }}",
                    self.fcc(),
                    self.fpc(),
                    self.hrc(),
                    self.hic()
                )
            }
        }
        #[doc = "SPI Intervention Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IvnSts(pub u8);
        impl IvnSts {
            #[doc = "Flash Chip Selects forced high and bus forced low."]
            #[inline(always)]
            pub const fn fcs(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Flash Chip Selects forced high and bus forced low."]
            #[inline(always)]
            pub fn set_fcs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Flash Power or RESET# Activated."]
            #[inline(always)]
            pub const fn fpo(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Flash Power or RESET# Activated."]
            #[inline(always)]
            pub fn set_fpo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Host held in Reset"]
            #[inline(always)]
            pub const fn hrs(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Host held in Reset"]
            #[inline(always)]
            pub fn set_hrs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Host held Isolated"]
            #[inline(always)]
            pub const fn his(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Host held Isolated"]
            #[inline(always)]
            pub fn set_his(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
        }
        impl Default for IvnSts {
            #[inline(always)]
            fn default() -> IvnSts {
                IvnSts(0)
            }
        }
        impl core::fmt::Debug for IvnSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IvnSts")
                    .field("fcs", &self.fcs())
                    .field("fpo", &self.fpo())
                    .field("hrs", &self.hrs())
                    .field("his", &self.his())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IvnSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "IvnSts {{ fcs: {=bool:?}, fpo: {=bool:?}, hrs: {=bool:?}, his: {=bool:?} }}",
                    self.fcs(),
                    self.fpo(),
                    self.hrs(),
                    self.his()
                )
            }
        }
        #[doc = "Loadtime Monitor Channel Begin Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LmBegin(pub u32);
        impl LmBegin {
            #[doc = "A byte address within the designated Flash, specifying the first byte of the load image."]
            #[inline(always)]
            pub const fn baddr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "A byte address within the designated Flash, specifying the first byte of the load image."]
            #[inline(always)]
            pub fn set_baddr(&mut self, val: u32) {
                self.0 = (self.0 & !(0x7fff_ffff << 0usize)) | (((val as u32) & 0x7fff_ffff) << 0usize);
            }
            #[doc = "Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"]
            #[inline(always)]
            pub const fn dv(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Flash Device number, applying to both Begin and End fields. 0 = CS0#, 1 = CS1#"]
            #[inline(always)]
            pub fn set_dv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for LmBegin {
            #[inline(always)]
            fn default() -> LmBegin {
                LmBegin(0)
            }
        }
        impl core::fmt::Debug for LmBegin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LmBegin")
                    .field("baddr", &self.baddr())
                    .field("dv", &self.dv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LmBegin {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "LmBegin {{ baddr: {=u32:?}, dv: {=bool:?} }}",
                    self.baddr(),
                    self.dv()
                )
            }
        }
        #[doc = "Loadtime Monitor Channel Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LmChnCtrl(pub u32);
        impl LmChnCtrl {
            #[doc = "GO: Run the Load Monitor for this channel"]
            #[inline(always)]
            pub const fn go(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "GO: Run the Load Monitor for this channel"]
            #[inline(always)]
            pub fn set_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "RST: Stop and Reset calculation for this channel when set to 1"]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RST: Stop and Reset calculation for this channel when set to 1"]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "RSF: Reset just Result FIFO pointer when this bit is set to 1"]
            #[inline(always)]
            pub const fn rsf(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RSF: Reset just Result FIFO pointer when this bit is set to 1"]
            #[inline(always)]
            pub fn set_rsf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"]
            #[inline(always)]
            pub const fn fptr(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "FPTR: Result FIFO pointer. In 32Bit. Ranges: 0 to 11 for SHA-384 result 0 to 7 for SHA-256 result"]
            #[inline(always)]
            pub fn set_fptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for LmChnCtrl {
            #[inline(always)]
            fn default() -> LmChnCtrl {
                LmChnCtrl(0)
            }
        }
        impl core::fmt::Debug for LmChnCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LmChnCtrl")
                    .field("go", &self.go())
                    .field("rst", &self.rst())
                    .field("rsf", &self.rsf())
                    .field("fptr", &self.fptr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LmChnCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "LmChnCtrl {{ go: {=bool:?}, rst: {=bool:?}, rsf: {=bool:?}, fptr: {=u8:?} }}",
                    self.go(),
                    self.rst(),
                    self.rsf(),
                    self.fptr()
                )
            }
        }
        #[doc = "Loadtime Monitor Channel Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LmCount(pub u32);
        impl LmCount {
            #[doc = "A Read-Only count of bytes processed."]
            #[inline(always)]
            pub const fn cnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A Read-Only count of bytes processed."]
            #[inline(always)]
            pub fn set_cnt(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LmCount {
            #[inline(always)]
            fn default() -> LmCount {
                LmCount(0)
            }
        }
        impl core::fmt::Debug for LmCount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LmCount").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LmCount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LmCount {{ cnt: {=u32:?} }}", self.cnt())
            }
        }
        #[doc = "Loadtime Monitor Control/Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LmCtrlsts(pub u32);
        impl LmCtrlsts {
            #[doc = "Waiting"]
            #[inline(always)]
            pub const fn w(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Waiting"]
            #[inline(always)]
            pub fn set_w(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Begin Byte seen"]
            #[inline(always)]
            pub const fn b(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Begin Byte seen"]
            #[inline(always)]
            pub fn set_b(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "End Byte seen"]
            #[inline(always)]
            pub const fn e(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "End Byte seen"]
            #[inline(always)]
            pub fn set_e(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Finalized and result ready"]
            #[inline(always)]
            pub const fn f(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Finalized and result ready"]
            #[inline(always)]
            pub fn set_f(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable Waiting Interrupt"]
            #[inline(always)]
            pub const fn w_inten(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Waiting Interrupt"]
            #[inline(always)]
            pub fn set_w_inten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable Begin Byte seen Interrupt"]
            #[inline(always)]
            pub const fn b_inten(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Begin Byte seen Interrupt"]
            #[inline(always)]
            pub fn set_b_inten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable End Byte seen Interrupt"]
            #[inline(always)]
            pub const fn e_inten(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable End Byte seen Interrupt"]
            #[inline(always)]
            pub fn set_e_inten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable Finalized and result ready Interrupt"]
            #[inline(always)]
            pub const fn f_inten(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Finalized and result ready Interrupt"]
            #[inline(always)]
            pub fn set_f_inten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for LmCtrlsts {
            #[inline(always)]
            fn default() -> LmCtrlsts {
                LmCtrlsts(0)
            }
        }
        impl core::fmt::Debug for LmCtrlsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LmCtrlsts")
                    .field("w", &self.w())
                    .field("b", &self.b())
                    .field("e", &self.e())
                    .field("f", &self.f())
                    .field("w_inten", &self.w_inten())
                    .field("b_inten", &self.b_inten())
                    .field("e_inten", &self.e_inten())
                    .field("f_inten", &self.f_inten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LmCtrlsts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "LmCtrlsts {{ w: {=bool:?}, b: {=bool:?}, e: {=bool:?}, f: {=bool:?}, w_inten: {=bool:?}, b_inten: {=bool:?}, e_inten: {=bool:?}, f_inten: {=bool:?} }}" , self . w () , self . b () , self . e () , self . f () , self . w_inten () , self . b_inten () , self . e_inten () , self . f_inten ())
            }
        }
        #[doc = "Loadtime Monitor Channel Digest Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LmDigest(pub u32);
        impl LmDigest {
            #[doc = "A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."]
            #[inline(always)]
            pub const fn dgst(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A Read-Only FIFO Portal to Hash digest result. 12 or 8 Dwords depending on algorithm."]
            #[inline(always)]
            pub fn set_dgst(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LmDigest {
            #[inline(always)]
            fn default() -> LmDigest {
                LmDigest(0)
            }
        }
        impl core::fmt::Debug for LmDigest {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LmDigest").field("dgst", &self.dgst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LmDigest {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LmDigest {{ dgst: {=u32:?} }}", self.dgst())
            }
        }
        #[doc = "Loadtime Monitor Channel End Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LmEnd(pub u32);
        impl LmEnd {
            #[doc = "A byte address within the designated Flash, specifying the last byte of the load image."]
            #[inline(always)]
            pub const fn eaddr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A byte address within the designated Flash, specifying the last byte of the load image."]
            #[inline(always)]
            pub fn set_eaddr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for LmEnd {
            #[inline(always)]
            fn default() -> LmEnd {
                LmEnd(0)
            }
        }
        impl core::fmt::Debug for LmEnd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LmEnd").field("eaddr", &self.eaddr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LmEnd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LmEnd {{ eaddr: {=u32:?} }}", self.eaddr())
            }
        }
        #[doc = "Loadtime (Hash) IRQ Aggregation Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LtmonAggr(pub u32);
        impl LtmonAggr {
            #[doc = "Load 0 Interrupt"]
            #[inline(always)]
            pub const fn irq0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Load 0 Interrupt"]
            #[inline(always)]
            pub fn set_irq0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Load 1 Interrupt"]
            #[inline(always)]
            pub const fn irq1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Load 1 Interrupt"]
            #[inline(always)]
            pub fn set_irq1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Load 2 Interrupt"]
            #[inline(always)]
            pub const fn irq2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Load 2 Interrupt"]
            #[inline(always)]
            pub fn set_irq2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Load 3 Interrupt"]
            #[inline(always)]
            pub const fn irq3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Load 3 Interrupt"]
            #[inline(always)]
            pub fn set_irq3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Load 4 Interrupt"]
            #[inline(always)]
            pub const fn irq4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Load 4 Interrupt"]
            #[inline(always)]
            pub fn set_irq4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Load 5 Interrupt"]
            #[inline(always)]
            pub const fn irq5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Load 5 Interrupt"]
            #[inline(always)]
            pub fn set_irq5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Load 6 Interrupt"]
            #[inline(always)]
            pub const fn irq6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Load 6 Interrupt"]
            #[inline(always)]
            pub fn set_irq6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Load 7 Interrupt"]
            #[inline(always)]
            pub const fn irq7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Load 7 Interrupt"]
            #[inline(always)]
            pub fn set_irq7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable Load 0 Interrupt"]
            #[inline(always)]
            pub const fn en_irq0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Load 0 Interrupt"]
            #[inline(always)]
            pub fn set_en_irq0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable Load 1 Interrupt"]
            #[inline(always)]
            pub const fn en_irq1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Load 1 Interrupt"]
            #[inline(always)]
            pub fn set_en_irq1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable Load 2 Interrupt"]
            #[inline(always)]
            pub const fn en_irq2(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Load 2 Interrupt"]
            #[inline(always)]
            pub fn set_en_irq2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable Load 3 Interrupt"]
            #[inline(always)]
            pub const fn en_irq3(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Load 3 Interrupt"]
            #[inline(always)]
            pub fn set_en_irq3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable Load 4 Interrupt"]
            #[inline(always)]
            pub const fn en_irq4(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Load 4 Interrupt"]
            #[inline(always)]
            pub fn set_en_irq4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable Load 5 Interrupt"]
            #[inline(always)]
            pub const fn en_irq5(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Load 5 Interrupt"]
            #[inline(always)]
            pub fn set_en_irq5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable Load 6 Interrupt"]
            #[inline(always)]
            pub const fn en_irq6(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Load 6 Interrupt"]
            #[inline(always)]
            pub fn set_en_irq6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable Load 7 Interrupt"]
            #[inline(always)]
            pub const fn en_irq7(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Load 7 Interrupt"]
            #[inline(always)]
            pub fn set_en_irq7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for LtmonAggr {
            #[inline(always)]
            fn default() -> LtmonAggr {
                LtmonAggr(0)
            }
        }
        impl core::fmt::Debug for LtmonAggr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LtmonAggr")
                    .field("irq0", &self.irq0())
                    .field("irq1", &self.irq1())
                    .field("irq2", &self.irq2())
                    .field("irq3", &self.irq3())
                    .field("irq4", &self.irq4())
                    .field("irq5", &self.irq5())
                    .field("irq6", &self.irq6())
                    .field("irq7", &self.irq7())
                    .field("en_irq0", &self.en_irq0())
                    .field("en_irq1", &self.en_irq1())
                    .field("en_irq2", &self.en_irq2())
                    .field("en_irq3", &self.en_irq3())
                    .field("en_irq4", &self.en_irq4())
                    .field("en_irq5", &self.en_irq5())
                    .field("en_irq6", &self.en_irq6())
                    .field("en_irq7", &self.en_irq7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LtmonAggr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "LtmonAggr {{ irq0: {=bool:?}, irq1: {=bool:?}, irq2: {=bool:?}, irq3: {=bool:?}, irq4: {=bool:?}, irq5: {=bool:?}, irq6: {=bool:?}, irq7: {=bool:?}, en_irq0: {=bool:?}, en_irq1: {=bool:?}, en_irq2: {=bool:?}, en_irq3: {=bool:?}, en_irq4: {=bool:?}, en_irq5: {=bool:?}, en_irq6: {=bool:?}, en_irq7: {=bool:?} }}" , self . irq0 () , self . irq1 () , self . irq2 () , self . irq3 () , self . irq4 () , self . irq5 () , self . irq6 () , self . irq7 () , self . en_irq0 () , self . en_irq1 () , self . en_irq2 () , self . en_irq3 () , self . en_irq4 () , self . en_irq5 () , self . en_irq6 () , self . en_irq7 ())
            }
        }
        #[doc = "Load Monitor Control/Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LtmonCtrlsts(pub u32);
        impl LtmonCtrlsts {
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub const fn fifo_mty(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub fn set_fifo_mty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "FIFO Full"]
            #[inline(always)]
            pub const fn fifo_ful(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO Full"]
            #[inline(always)]
            pub fn set_fifo_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "FIFO Overflow"]
            #[inline(always)]
            pub const fn fifo_ovrf(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO Overflow"]
            #[inline(always)]
            pub fn set_fifo_ovrf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "FIFO Underflow"]
            #[inline(always)]
            pub const fn fifo_udrf(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO Underflow"]
            #[inline(always)]
            pub fn set_fifo_udrf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Clear FIFO"]
            #[inline(always)]
            pub const fn clr_fifo(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Clear FIFO"]
            #[inline(always)]
            pub fn set_clr_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for LtmonCtrlsts {
            #[inline(always)]
            fn default() -> LtmonCtrlsts {
                LtmonCtrlsts(0)
            }
        }
        impl core::fmt::Debug for LtmonCtrlsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LtmonCtrlsts")
                    .field("fifo_mty", &self.fifo_mty())
                    .field("fifo_ful", &self.fifo_ful())
                    .field("fifo_ovrf", &self.fifo_ovrf())
                    .field("fifo_udrf", &self.fifo_udrf())
                    .field("clr_fifo", &self.clr_fifo())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LtmonCtrlsts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "LtmonCtrlsts {{ fifo_mty: {=bool:?}, fifo_ful: {=bool:?}, fifo_ovrf: {=bool:?}, fifo_udrf: {=bool:?}, clr_fifo: {=bool:?} }}" , self . fifo_mty () , self . fifo_ful () , self . fifo_ovrf () , self . fifo_udrf () , self . clr_fifo ())
            }
        }
        #[doc = "Match Monitor Region Map Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Map(pub u32);
        impl Map {
            #[doc = "The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."]
            #[inline(always)]
            pub const fn map(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."]
            #[inline(always)]
            pub fn set_map(&mut self, val: u32) {
                self.0 = (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Match Enable for individual Region R"]
            #[inline(always)]
            pub const fn me(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Match Enable for individual Region R"]
            #[inline(always)]
            pub fn set_me(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Map {
            #[inline(always)]
            fn default() -> Map {
                Map(0)
            }
        }
        impl core::fmt::Debug for Map {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Map")
                    .field("map", &self.map())
                    .field("me", &self.me())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Map {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Map {{ map: {=u32:?}, me: {=bool:?} }}", self.map(), self.me())
            }
        }
        #[doc = "SPI Monitor Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MntrCtrl(pub u32);
        impl MntrCtrl {
            #[doc = "Activate 1= Activate, 0= De-activate"]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Activate 1= Activate, 0= De-activate"]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock Activate 1= Activate field Locked, 0= Activate field unlocked"]
            #[inline(always)]
            pub const fn lck_act(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Activate 1= Activate field Locked, 0= Activate field unlocked"]
            #[inline(always)]
            pub fn set_lck_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Soft Reset. This field is auto cleared by hardware. 1= Soft Reset SPI Monitor, 0 = No Effect"]
            #[inline(always)]
            pub const fn sft_rst(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Soft Reset. This field is auto cleared by hardware. 1= Soft Reset SPI Monitor, 0 = No Effect"]
            #[inline(always)]
            pub fn set_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "CPTR_CLK_TAP_SEL selects which 0.5ns delay tap to have the capture clock on. 00h = 0 ns delay (or if TAP_EN = 0). 01h = 0.5ns nom delay; +/- 50% 02h = 1.0ns 03h = 1.5ns 04h = 2.0ns etc. 1Fh = 15.5ns"]
            #[inline(always)]
            pub const fn tap_sel(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x1f;
                val as u8
            }
            #[doc = "CPTR_CLK_TAP_SEL selects which 0.5ns delay tap to have the capture clock on. 00h = 0 ns delay (or if TAP_EN = 0). 01h = 0.5ns nom delay; +/- 50% 02h = 1.0ns 03h = 1.5ns 04h = 2.0ns etc. 1Fh = 15.5ns"]
            #[inline(always)]
            pub fn set_tap_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
            }
            #[doc = "CPTR_CLK_TAP_EN enable the delay taps. It is recommended that a customer set the TAP_EN bit to 1, and the TAP_SEL field to 04h."]
            #[inline(always)]
            pub const fn tap_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "CPTR_CLK_TAP_EN enable the delay taps. It is recommended that a customer set the TAP_EN bit to 1, and the TAP_SEL field to 04h."]
            #[inline(always)]
            pub fn set_tap_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
        }
        impl Default for MntrCtrl {
            #[inline(always)]
            fn default() -> MntrCtrl {
                MntrCtrl(0)
            }
        }
        impl core::fmt::Debug for MntrCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MntrCtrl")
                    .field("act", &self.act())
                    .field("lck_act", &self.lck_act())
                    .field("sft_rst", &self.sft_rst())
                    .field("tap_sel", &self.tap_sel())
                    .field("tap_en", &self.tap_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MntrCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MntrCtrl {{ act: {=bool:?}, lck_act: {=bool:?}, sft_rst: {=bool:?}, tap_sel: {=u8:?}, tap_en: {=bool:?} }}" , self . act () , self . lck_act () , self . sft_rst () , self . tap_sel () , self . tap_en ())
            }
        }
        #[doc = "Match Monitor Region Begin Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtmonBegin(pub u32);
        impl MtmonBegin {
            #[doc = "The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."]
            #[inline(always)]
            pub const fn bgn(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."]
            #[inline(always)]
            pub fn set_bgn(&mut self, val: u32) {
                self.0 = (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"]
            #[inline(always)]
            pub const fn dv(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Flash Device number, applying to both Begin and End fields 0 = CS0#, 1 = CS1#"]
            #[inline(always)]
            pub fn set_dv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for MtmonBegin {
            #[inline(always)]
            fn default() -> MtmonBegin {
                MtmonBegin(0)
            }
        }
        impl core::fmt::Debug for MtmonBegin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtmonBegin")
                    .field("bgn", &self.bgn())
                    .field("dv", &self.dv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtmonBegin {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "MtmonBegin {{ bgn: {=u32:?}, dv: {=bool:?} }}",
                    self.bgn(),
                    self.dv()
                )
            }
        }
        #[doc = "Match Monitor Control/Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtmonCtrlsts(pub u32);
        impl MtmonCtrlsts {
            #[doc = "Timeout"]
            #[inline(always)]
            pub const fn t(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout"]
            #[inline(always)]
            pub fn set_t(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "First Fetch in any Match region"]
            #[inline(always)]
            pub const fn f(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "First Fetch in any Match region"]
            #[inline(always)]
            pub fn set_f(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Set to 1 on a 3B/4B Address Mode switch on either Flash."]
            #[inline(always)]
            pub const fn am(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Set to 1 on a 3B/4B Address Mode switch on either Flash."]
            #[inline(always)]
            pub fn set_am(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable Timeout Interrupt"]
            #[inline(always)]
            pub const fn et_irq(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Timeout Interrupt"]
            #[inline(always)]
            pub fn set_et_irq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable First Fetch in any Match region Interrupt"]
            #[inline(always)]
            pub const fn ef_irq(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable First Fetch in any Match region Interrupt"]
            #[inline(always)]
            pub fn set_ef_irq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable 3B/4B Address Mode switch on either Flash Interrupt"]
            #[inline(always)]
            pub const fn am_irq(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable 3B/4B Address Mode switch on either Flash Interrupt"]
            #[inline(always)]
            pub fn set_am_irq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub const fn fifo_mty(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub fn set_fifo_mty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "FIFO Full"]
            #[inline(always)]
            pub const fn fifo_ful(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO Full"]
            #[inline(always)]
            pub fn set_fifo_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "FIFO Overflow"]
            #[inline(always)]
            pub const fn fifo_ovrf(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO Overflow"]
            #[inline(always)]
            pub fn set_fifo_ovrf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "FIFO Underflow"]
            #[inline(always)]
            pub const fn fifo_udrf(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO Underflow"]
            #[inline(always)]
            pub fn set_fifo_udrf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Clear FIFO. This field is autocleared by hardware"]
            #[inline(always)]
            pub const fn clr_fifo(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Clear FIFO. This field is autocleared by hardware"]
            #[inline(always)]
            pub fn set_clr_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for MtmonCtrlsts {
            #[inline(always)]
            fn default() -> MtmonCtrlsts {
                MtmonCtrlsts(0)
            }
        }
        impl core::fmt::Debug for MtmonCtrlsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtmonCtrlsts")
                    .field("t", &self.t())
                    .field("f", &self.f())
                    .field("am", &self.am())
                    .field("et_irq", &self.et_irq())
                    .field("ef_irq", &self.ef_irq())
                    .field("am_irq", &self.am_irq())
                    .field("fifo_mty", &self.fifo_mty())
                    .field("fifo_ful", &self.fifo_ful())
                    .field("fifo_ovrf", &self.fifo_ovrf())
                    .field("fifo_udrf", &self.fifo_udrf())
                    .field("clr_fifo", &self.clr_fifo())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtmonCtrlsts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MtmonCtrlsts {{ t: {=bool:?}, f: {=bool:?}, am: {=bool:?}, et_irq: {=bool:?}, ef_irq: {=bool:?}, am_irq: {=bool:?}, fifo_mty: {=bool:?}, fifo_ful: {=bool:?}, fifo_ovrf: {=bool:?}, fifo_udrf: {=bool:?}, clr_fifo: {=bool:?} }}" , self . t () , self . f () , self . am () , self . et_irq () , self . ef_irq () , self . am_irq () , self . fifo_mty () , self . fifo_ful () , self . fifo_ovrf () , self . fifo_udrf () , self . clr_fifo ())
            }
        }
        #[doc = "Match Monitor Region End Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtmonEnd(pub u32);
        impl MtmonEnd {
            #[doc = "The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."]
            #[inline(always)]
            pub const fn end(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "The 19 bits of base address within the designated SPI Flash, specifying the last aligned 8K block."]
            #[inline(always)]
            pub fn set_end(&mut self, val: u32) {
                self.0 = (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
        }
        impl Default for MtmonEnd {
            #[inline(always)]
            fn default() -> MtmonEnd {
                MtmonEnd(0)
            }
        }
        impl core::fmt::Debug for MtmonEnd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtmonEnd").field("end", &self.end()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtmonEnd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MtmonEnd {{ end: {=u32:?} }}", self.end())
            }
        }
        #[doc = "Match Monitor Enable/Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtmonEnmd(pub u32);
        impl MtmonEnmd {
            #[doc = "Enable Data Matching. 0 = Disabled, 1 = Enabled"]
            #[inline(always)]
            pub const fn mon_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Data Matching. 0 = Disabled, 1 = Enabled"]
            #[inline(always)]
            pub fn set_mon_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Match Pattern Source Mode: 0 = SRAM, 1 = Internal Flash."]
            #[inline(always)]
            pub const fn mon_ms(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Match Pattern Source Mode: 0 = SRAM, 1 = Internal Flash."]
            #[inline(always)]
            pub fn set_mon_ms(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for MtmonEnmd {
            #[inline(always)]
            fn default() -> MtmonEnmd {
                MtmonEnmd(0)
            }
        }
        impl core::fmt::Debug for MtmonEnmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtmonEnmd")
                    .field("mon_en", &self.mon_en())
                    .field("mon_ms", &self.mon_ms())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtmonEnmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "MtmonEnmd {{ mon_en: {=bool:?}, mon_ms: {=bool:?} }}",
                    self.mon_en(),
                    self.mon_ms()
                )
            }
        }
        #[doc = "Match Fetch Timeout Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtmonTctrl(pub u32);
        impl MtmonTctrl {
            #[doc = "Start Timeout Counter"]
            #[inline(always)]
            pub const fn st(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Start Timeout Counter"]
            #[inline(always)]
            pub fn set_st(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Timeout Value 0 to 32"]
            #[inline(always)]
            pub const fn tv(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x1f;
                val as u8
            }
            #[doc = "Timeout Value 0 to 32"]
            #[inline(always)]
            pub fn set_tv(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
            }
            #[doc = "Timeout Unit 00 = none (off), 01 = 32ms, 10 = 128ms, 11 = 1sec"]
            #[inline(always)]
            pub const fn tu(&self) -> u8 {
                let val = (self.0 >> 21usize) & 0x03;
                val as u8
            }
            #[doc = "Timeout Unit 00 = none (off), 01 = 32ms, 10 = 128ms, 11 = 1sec"]
            #[inline(always)]
            pub fn set_tu(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 21usize)) | (((val as u32) & 0x03) << 21usize);
            }
        }
        impl Default for MtmonTctrl {
            #[inline(always)]
            fn default() -> MtmonTctrl {
                MtmonTctrl(0)
            }
        }
        impl core::fmt::Debug for MtmonTctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtmonTctrl")
                    .field("st", &self.st())
                    .field("tv", &self.tv())
                    .field("tu", &self.tu())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtmonTctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "MtmonTctrl {{ st: {=bool:?}, tv: {=u8:?}, tu: {=u8:?} }}",
                    self.st(),
                    self.tv(),
                    self.tu()
                )
            }
        }
        #[doc = "Match Monitor Violation Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtmonVioaddr(pub u32);
        impl MtmonVioaddr {
            #[doc = "Byte address at which the error occurred, within the designated Flash"]
            #[inline(always)]
            pub const fn addr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Byte address at which the error occurred, within the designated Flash"]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for MtmonVioaddr {
            #[inline(always)]
            fn default() -> MtmonVioaddr {
                MtmonVioaddr(0)
            }
        }
        impl core::fmt::Debug for MtmonVioaddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtmonVioaddr").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtmonVioaddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MtmonVioaddr {{ addr: {=u32:?} }}", self.addr())
            }
        }
        #[doc = "Match Monitor Violation Log Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtmonViosts(pub u32);
        impl MtmonViosts {
            #[doc = "Match Monitor Timeout. This is read-Only bit."]
            #[inline(always)]
            pub const fn mto(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Match Monitor Timeout. This is read-Only bit."]
            #[inline(always)]
            pub fn set_mto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Device Number. This is read-Only bit. 0 = CS0, 1 = CS1."]
            #[inline(always)]
            pub const fn dv(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Device Number. This is read-Only bit. 0 = CS0, 1 = CS1."]
            #[inline(always)]
            pub fn set_dv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Region. This is read-Only bit. Shows which of 8 Match regions \\[7:0\\] got the mismatch."]
            #[inline(always)]
            pub const fn rgn(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x1f;
                val as u8
            }
            #[doc = "Region. This is read-Only bit. Shows which of 8 Match regions \\[7:0\\] got the mismatch."]
            #[inline(always)]
            pub fn set_rgn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 7usize)) | (((val as u32) & 0x1f) << 7usize);
            }
            #[doc = "Flash Address Mode 0 = 3-byte, 1 = 4-byte"]
            #[inline(always)]
            pub const fn am(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Flash Address Mode 0 = 3-byte, 1 = 4-byte"]
            #[inline(always)]
            pub fn set_am(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Clear Register RW1C. This bit is auto clearing"]
            #[inline(always)]
            pub const fn clr(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Clear Register RW1C. This bit is auto clearing"]
            #[inline(always)]
            pub fn set_clr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Flash Opcode"]
            #[inline(always)]
            pub const fn opcod(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Flash Opcode"]
            #[inline(always)]
            pub fn set_opcod(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "SPI Data Byte"]
            #[inline(always)]
            pub const fn data(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "SPI Data Byte"]
            #[inline(always)]
            pub fn set_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for MtmonViosts {
            #[inline(always)]
            fn default() -> MtmonViosts {
                MtmonViosts(0)
            }
        }
        impl core::fmt::Debug for MtmonViosts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtmonViosts")
                    .field("mto", &self.mto())
                    .field("dv", &self.dv())
                    .field("rgn", &self.rgn())
                    .field("am", &self.am())
                    .field("clr", &self.clr())
                    .field("opcod", &self.opcod())
                    .field("data", &self.data())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtmonViosts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MtmonViosts {{ mto: {=bool:?}, dv: {=bool:?}, rgn: {=u8:?}, am: {=bool:?}, clr: {=bool:?}, opcod: {=u8:?}, data: {=u8:?} }}" , self . mto () , self . dv () , self . rgn () , self . am () , self . clr () , self . opcod () , self . data ())
            }
        }
        #[doc = "Kill Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OpKillmd(pub u32);
        impl OpKillmd {
            #[doc = "Kill. Each array organized into 8 32-bit registers set per Flash device. 1 = If Killed, then kill as a Write: Holding CS# low. 0 = If Killed, then kill as a Read: Force CS# high first."]
            #[inline(always)]
            pub const fn kill(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Kill. Each array organized into 8 32-bit registers set per Flash device. 1 = If Killed, then kill as a Write: Holding CS# low. 0 = If Killed, then kill as a Read: Force CS# high first."]
            #[inline(always)]
            pub fn set_kill(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for OpKillmd {
            #[inline(always)]
            fn default() -> OpKillmd {
                OpKillmd(0)
            }
        }
        impl core::fmt::Debug for OpKillmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OpKillmd").field("kill", &self.kill()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OpKillmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "OpKillmd {{ kill: {=u32:?} }}", self.kill())
            }
        }
        #[doc = "Lock Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OpLock(pub u32);
        impl OpLock {
            #[doc = "Lock. Each array organized into 8 32-bit registers set per Flash device. 1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked. 0 = Corresponding bits are R/W or RO, as determined by the Wprot register."]
            #[inline(always)]
            pub const fn lock(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Lock. Each array organized into 8 32-bit registers set per Flash device. 1 = Make the corresponding bits RO in Permit and Killmd regs, overriding the Wprot register. Any 1 bit in this register is locked. 0 = Corresponding bits are R/W or RO, as determined by the Wprot register."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for OpLock {
            #[inline(always)]
            fn default() -> OpLock {
                OpLock(0)
            }
        }
        impl core::fmt::Debug for OpLock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OpLock").field("lock", &self.lock()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OpLock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "OpLock {{ lock: {=u32:?} }}", self.lock())
            }
        }
        #[doc = "Permit Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OpPrmt(pub u32);
        impl OpPrmt {
            #[doc = "Permit. Each array organized into 8 32-bit registers set per Flash device. 1 = Permit, and if not recognized then ignore. 0 = Kill immediately upon seeing this opcode."]
            #[inline(always)]
            pub const fn prmt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Permit. Each array organized into 8 32-bit registers set per Flash device. 1 = Permit, and if not recognized then ignore. 0 = Kill immediately upon seeing this opcode."]
            #[inline(always)]
            pub fn set_prmt(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for OpPrmt {
            #[inline(always)]
            fn default() -> OpPrmt {
                OpPrmt(0)
            }
        }
        impl core::fmt::Debug for OpPrmt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OpPrmt").field("prmt", &self.prmt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OpPrmt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "OpPrmt {{ prmt: {=u32:?} }}", self.prmt())
            }
        }
        #[doc = "Write Protect Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OpWprot(pub u32);
        impl OpWprot {
            #[doc = "Write Protect. Each array organized into 8 32-bit registers set per Flash device. 1 = Make the corresponding bits RO in Permit and Killmd regs. 0 = Corresponding bits are R/W."]
            #[inline(always)]
            pub const fn wprot(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Write Protect. Each array organized into 8 32-bit registers set per Flash device. 1 = Make the corresponding bits RO in Permit and Killmd regs. 0 = Corresponding bits are R/W."]
            #[inline(always)]
            pub fn set_wprot(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for OpWprot {
            #[inline(always)]
            fn default() -> OpWprot {
                OpWprot(0)
            }
        }
        impl core::fmt::Debug for OpWprot {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OpWprot").field("wprot", &self.wprot()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OpWprot {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "OpWprot {{ wprot: {=u32:?} }}", self.wprot())
            }
        }
        #[doc = "Runtime Monitoring Limit Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtLimit(pub u32);
        impl RtLimit {
            #[doc = "Limit Register"]
            #[inline(always)]
            pub const fn lmt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "Limit Register"]
            #[inline(always)]
            pub fn set_lmt(&mut self, val: u32) {
                self.0 = (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
        }
        impl Default for RtLimit {
            #[inline(always)]
            fn default() -> RtLimit {
                RtLimit(0)
            }
        }
        impl core::fmt::Debug for RtLimit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtLimit").field("lmt", &self.lmt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtLimit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RtLimit {{ lmt: {=u32:?} }}", self.lmt())
            }
        }
        #[doc = "Runtime Monitoring Start Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RtStart(pub u32);
        impl RtStart {
            #[doc = "A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"]
            #[inline(always)]
            pub const fn strt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "A Flash address shifted by 12 (4K byte units). Bottom 12 address bits are 000h"]
            #[inline(always)]
            pub fn set_strt(&mut self, val: u32) {
                self.0 = (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
            #[doc = "Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub const fn e32(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable 32KByte Erase opcode for this region. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub fn set_e32(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub const fn e64(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable 64KByte Erase opcode for this region. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub fn set_e64(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Flash Device 0 = CS0#, 1 = CS1#."]
            #[inline(always)]
            pub const fn dv(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Flash Device 0 = CS0#, 1 = CS1#."]
            #[inline(always)]
            pub fn set_dv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Read Allowed for Region. 0 = No, 1 = Yes"]
            #[inline(always)]
            pub const fn rd(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Read Allowed for Region. 0 = No, 1 = Yes"]
            #[inline(always)]
            pub fn set_rd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Write Allowed for Region. 0 = No, 1 = Yes"]
            #[inline(always)]
            pub const fn wr(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Write Allowed for Region. 0 = No, 1 = Yes"]
            #[inline(always)]
            pub fn set_wr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Enable Register Pair for Monitoring. 0 = No, 1 = Yes"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Register Pair for Monitoring. 0 = No, 1 = Yes"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for RtStart {
            #[inline(always)]
            fn default() -> RtStart {
                RtStart(0)
            }
        }
        impl core::fmt::Debug for RtStart {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RtStart")
                    .field("strt", &self.strt())
                    .field("e32", &self.e32())
                    .field("e64", &self.e64())
                    .field("dv", &self.dv())
                    .field("rd", &self.rd())
                    .field("wr", &self.wr())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RtStart {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RtStart {{ strt: {=u32:?}, e32: {=bool:?}, e64: {=bool:?}, dv: {=bool:?}, rd: {=bool:?}, wr: {=bool:?}, en: {=bool:?} }}" , self . strt () , self . e32 () , self . e64 () , self . dv () , self . rd () , self . wr () , self . en ())
            }
        }
        #[doc = "SPI Monitor Configuration 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spicfg2(pub u32);
        impl Spicfg2 {
            #[doc = "Host Reset Mode. 0 = APn_RESET#, 1 = Pin."]
            #[inline(always)]
            pub const fn hrm(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Host Reset Mode. 0 = APn_RESET#, 1 = Pin."]
            #[inline(always)]
            pub fn set_hrm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "HRM Bit Lock. 0 = Unlocked, 1 = Locked."]
            #[inline(always)]
            pub const fn hrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "HRM Bit Lock. 0 = Unlocked, 1 = Locked."]
            #[inline(always)]
            pub fn set_hrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Disable Inter Vention. 1 = IRQ-only Mode."]
            #[inline(always)]
            pub const fn div(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Disable Inter Vention. 1 = IRQ-only Mode."]
            #[inline(always)]
            pub fn set_div(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "DIV Bit Lock. 0 = Unlocked, 1 = Locked."]
            #[inline(always)]
            pub const fn dil(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "DIV Bit Lock. 0 = Unlocked, 1 = Locked."]
            #[inline(always)]
            pub fn set_dil(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Special Region InterVention Mode. If DIV=1 then RIV is ignored. If DIV=0 and RIV=1 then: Reads that are forbidden by the Runtime Region register set are only cancelled by gating off CSn# for that SPI command, and setting the IRQ. No system shutdown results, and subsequent legal Reads are allowed."]
            #[inline(always)]
            pub const fn riv(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Special Region InterVention Mode. If DIV=1 then RIV is ignored. If DIV=0 and RIV=1 then: Reads that are forbidden by the Runtime Region register set are only cancelled by gating off CSn# for that SPI command, and setting the IRQ. No system shutdown results, and subsequent legal Reads are allowed."]
            #[inline(always)]
            pub fn set_riv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "RIV Bit Lock. 0 = Unlocked, 1 = Locked."]
            #[inline(always)]
            pub const fn ril(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "RIV Bit Lock. 0 = Unlocked, 1 = Locked."]
            #[inline(always)]
            pub fn set_ril(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Hash Algorithm Mode. 0 = SHA-384, 1 = Reserved"]
            #[inline(always)]
            pub const fn alg(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Hash Algorithm Mode. 0 = SHA-384, 1 = Reserved"]
            #[inline(always)]
            pub fn set_alg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "ALG Bit Lock. 0 = Unlocked, 1 = Locked."]
            #[inline(always)]
            pub const fn all(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "ALG Bit Lock. 0 = Unlocked, 1 = Locked."]
            #[inline(always)]
            pub fn set_all(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Spicfg2 {
            #[inline(always)]
            fn default() -> Spicfg2 {
                Spicfg2(0)
            }
        }
        impl core::fmt::Debug for Spicfg2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spicfg2")
                    .field("hrm", &self.hrm())
                    .field("hrl", &self.hrl())
                    .field("div", &self.div())
                    .field("dil", &self.dil())
                    .field("riv", &self.riv())
                    .field("ril", &self.ril())
                    .field("alg", &self.alg())
                    .field("all", &self.all())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spicfg2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spicfg2 {{ hrm: {=bool:?}, hrl: {=bool:?}, div: {=bool:?}, dil: {=bool:?}, riv: {=bool:?}, ril: {=bool:?}, alg: {=bool:?}, all: {=bool:?} }}" , self . hrm () , self . hrl () , self . div () , self . dil () , self . riv () , self . ril () , self . alg () , self . all ())
            }
        }
        #[doc = "Violation Log Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VioSts(pub u32);
        impl VioSts {
            #[doc = "Opcode Violation"]
            #[inline(always)]
            pub const fn op(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Opcode Violation"]
            #[inline(always)]
            pub fn set_op(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Region Failure, Out of Bounds"]
            #[inline(always)]
            pub const fn rob(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Region Failure, Out of Bounds"]
            #[inline(always)]
            pub fn set_rob(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Runtime Region Violation"]
            #[inline(always)]
            pub const fn reg(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Runtime Region Violation"]
            #[inline(always)]
            pub fn set_reg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Address Wrap"]
            #[inline(always)]
            pub const fn awp(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Address Wrap"]
            #[inline(always)]
            pub fn set_awp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Device Number"]
            #[inline(always)]
            pub const fn dv(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Device Number"]
            #[inline(always)]
            pub fn set_dv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Region Number"]
            #[inline(always)]
            pub const fn region(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x1f;
                val as u8
            }
            #[doc = "Region Number"]
            #[inline(always)]
            pub fn set_region(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 7usize)) | (((val as u32) & 0x1f) << 7usize);
            }
            #[doc = "Killed as a Read"]
            #[inline(always)]
            pub const fn rd(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Killed as a Read"]
            #[inline(always)]
            pub fn set_rd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Killed as a Program or Erase"]
            #[inline(always)]
            pub const fn pe(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Killed as a Program or Erase"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Flash Address Mode"]
            #[inline(always)]
            pub const fn am(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Flash Address Mode"]
            #[inline(always)]
            pub fn set_am(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Clear Register RW1C. This bit is auto clearing"]
            #[inline(always)]
            pub const fn clr(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Clear Register RW1C. This bit is auto clearing"]
            #[inline(always)]
            pub fn set_clr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Flash Opcode"]
            #[inline(always)]
            pub const fn opcod(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Flash Opcode"]
            #[inline(always)]
            pub fn set_opcod(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "SPI Data Byte"]
            #[inline(always)]
            pub const fn dat(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "SPI Data Byte"]
            #[inline(always)]
            pub fn set_dat(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for VioSts {
            #[inline(always)]
            fn default() -> VioSts {
                VioSts(0)
            }
        }
        impl core::fmt::Debug for VioSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VioSts")
                    .field("op", &self.op())
                    .field("rob", &self.rob())
                    .field("reg", &self.reg())
                    .field("awp", &self.awp())
                    .field("dv", &self.dv())
                    .field("region", &self.region())
                    .field("rd", &self.rd())
                    .field("pe", &self.pe())
                    .field("am", &self.am())
                    .field("clr", &self.clr())
                    .field("opcod", &self.opcod())
                    .field("dat", &self.dat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VioSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "VioSts {{ op: {=bool:?}, rob: {=bool:?}, reg: {=bool:?}, awp: {=bool:?}, dv: {=bool:?}, region: {=u8:?}, rd: {=bool:?}, pe: {=bool:?}, am: {=bool:?}, clr: {=bool:?}, opcod: {=u8:?}, dat: {=u8:?} }}" , self . op () , self . rob () , self . reg () , self . awp () , self . dv () , self . region () , self . rd () , self . pe () , self . am () , self . clr () , self . opcod () , self . dat ())
            }
        }
        #[doc = "Violation IRQ Control/Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vioctrlsts(pub u32);
        impl Vioctrlsts {
            #[doc = "Opcode Violation"]
            #[inline(always)]
            pub const fn op(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Opcode Violation"]
            #[inline(always)]
            pub fn set_op(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Data Mismatch Violation"]
            #[inline(always)]
            pub const fn mc(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Data Mismatch Violation"]
            #[inline(always)]
            pub fn set_mc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Out of Bounds. Outside all Runtime Regions"]
            #[inline(always)]
            pub const fn ob(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Out of Bounds. Outside all Runtime Regions"]
            #[inline(always)]
            pub fn set_ob(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Runtime Region R/W Permission Violation"]
            #[inline(always)]
            pub const fn rg(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Runtime Region R/W Permission Violation"]
            #[inline(always)]
            pub fn set_rg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Timeout in Match Phase"]
            #[inline(always)]
            pub const fn mt(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout in Match Phase"]
            #[inline(always)]
            pub fn set_mt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Address Wrap within a Flash device."]
            #[inline(always)]
            pub const fn aw(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Address Wrap within a Flash device."]
            #[inline(always)]
            pub fn set_aw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable Opcode Violation Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub const fn eop(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Opcode Violation Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub fn set_eop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable Data Mismatch Violation Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub const fn emc(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Data Mismatch Violation Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub fn set_emc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable Out of Bounds Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub const fn eob(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Out of Bounds Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub fn set_eob(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable Runtime Region R/W Permission Violation Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub const fn erg(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Runtime Region R/W Permission Violation Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub fn set_erg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable Timeout in Match Phase Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub const fn emt(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Timeout in Match Phase Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub fn set_emt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable Address Wrap within a Flash device Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub const fn eaw(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Address Wrap within a Flash device Interrupt. 0 = Disable, 1 = Enable"]
            #[inline(always)]
            pub fn set_eaw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Vioctrlsts {
            #[inline(always)]
            fn default() -> Vioctrlsts {
                Vioctrlsts(0)
            }
        }
        impl core::fmt::Debug for Vioctrlsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vioctrlsts")
                    .field("op", &self.op())
                    .field("mc", &self.mc())
                    .field("ob", &self.ob())
                    .field("rg", &self.rg())
                    .field("mt", &self.mt())
                    .field("aw", &self.aw())
                    .field("eop", &self.eop())
                    .field("emc", &self.emc())
                    .field("eob", &self.eob())
                    .field("erg", &self.erg())
                    .field("emt", &self.emt())
                    .field("eaw", &self.eaw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vioctrlsts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Vioctrlsts {{ op: {=bool:?}, mc: {=bool:?}, ob: {=bool:?}, rg: {=bool:?}, mt: {=bool:?}, aw: {=bool:?}, eop: {=bool:?}, emc: {=bool:?}, eob: {=bool:?}, erg: {=bool:?}, emt: {=bool:?}, eaw: {=bool:?} }}" , self . op () , self . mc () , self . ob () , self . rg () , self . mt () , self . aw () , self . eop () , self . emc () , self . eob () , self . erg () , self . emt () , self . eaw ())
            }
        }
    }
}
pub mod spt0 {
    #[doc = "SPI Peripheral Target Register."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spt0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Spt0 {}
    unsafe impl Sync for Spt0 {}
    impl Spt0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SPI Peripheral Target Communication Configuration Register."]
        #[inline(always)]
        pub const fn spi_cfg(self) -> crate::common::Reg<regs::SpiCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SPI Peripheral Target Status Register."]
        #[inline(always)]
        pub const fn spi_sts(self) -> crate::common::Reg<regs::SpiSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Peripheral Target EC Status Register."]
        #[inline(always)]
        pub const fn spi_ec_sts(self) -> crate::common::Reg<regs::SpiEcSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "SPI Peripheral Target Interrupt Enable Register."]
        #[inline(always)]
        pub const fn spi_ien(self) -> crate::common::Reg<regs::SpiIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SPI Peripheral Target EC Interrupt Enable Register."]
        #[inline(always)]
        pub const fn ec_ien(self) -> crate::common::Reg<regs::EcIen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "SPI Peripheral Target Memory Configuration Register."]
        #[inline(always)]
        pub const fn mem_cfg(self) -> crate::common::Reg<regs::MemCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "SPI Peripheral Target Memory Base Address0 Register."]
        #[inline(always)]
        pub const fn mem_bar0(self) -> crate::common::Reg<regs::MemBar0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "SPI Peripheral Target Memory Write LIMIT 0 Register."]
        #[inline(always)]
        pub const fn mem_wr_lim0(self) -> crate::common::Reg<regs::MemWrLim0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "SPI Peripheral Target Memory Read LIMIT 0 Register."]
        #[inline(always)]
        pub const fn mem_rd_lim0(self) -> crate::common::Reg<regs::MemRdLim0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "SPI Peripheral Target Memory Base Address1 Register."]
        #[inline(always)]
        pub const fn mem_bar1(self) -> crate::common::Reg<regs::MemBar1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "SPI Peripheral Target Memory Write LIMIT 1 Register."]
        #[inline(always)]
        pub const fn mem_wr_lim1(self) -> crate::common::Reg<regs::MemWrLim1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "SPI Peripheral Target Memory Read LIMIT 1 Register."]
        #[inline(always)]
        pub const fn mem_rd_lim1(self) -> crate::common::Reg<regs::MemRdLim1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "SPI Peripheral Target RX FIFO Host Bar Register."]
        #[inline(always)]
        pub const fn rxf_host_bar(self) -> crate::common::Reg<regs::RxfHostBar, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "SPI Peripheral Target RX FIFO Byte Counter Register."]
        #[inline(always)]
        pub const fn rxf_byte_cnt(self) -> crate::common::Reg<regs::RxfByteCnt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "SPI Peripheral Target TX FIFO Host Bar Register."]
        #[inline(always)]
        pub const fn txf_host_bar(self) -> crate::common::Reg<regs::TxfHostBar, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "SPI Peripheral Target TX FIFO Byte Counter Register."]
        #[inline(always)]
        pub const fn txf_byte_cnt(self) -> crate::common::Reg<regs::TxfByteCnt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "SPI Peripheral Target System Configuration Register."]
        #[inline(always)]
        pub const fn sys_cfg(self) -> crate::common::Reg<regs::SysCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "SPI Peripheral Target Master to EC Mailbox Register."]
        #[inline(always)]
        pub const fn spim2ec_mbx(self) -> crate::common::Reg<regs::Spim2ecMbx, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "SPI Peripheral Target Master to EC Mailbox Register."]
        #[inline(always)]
        pub const fn ec2spim_mbx(self) -> crate::common::Reg<regs::Ec2spimMbx, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "SPI Peripheral Target Master to EC Mailbox Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ec2spimMbx(pub u32);
        impl Ec2spimMbx {
            #[doc = "Read only register for the Host. When data is written to this register the OBF Flag is set. Host can read the data and writes of 0xFFFF_FFFF will clear this register, also clearing the flag. Any form of read will clear the flag for this register"]
            #[inline(always)]
            pub const fn ec2m(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Read only register for the Host. When data is written to this register the OBF Flag is set. Host can read the data and writes of 0xFFFF_FFFF will clear this register, also clearing the flag. Any form of read will clear the flag for this register"]
            #[inline(always)]
            pub fn set_ec2m(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Ec2spimMbx {
            #[inline(always)]
            fn default() -> Ec2spimMbx {
                Ec2spimMbx(0)
            }
        }
        impl core::fmt::Debug for Ec2spimMbx {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ec2spimMbx").field("ec2m", &self.ec2m()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ec2spimMbx {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ec2spimMbx {{ ec2m: {=u32:?} }}", self.ec2m())
            }
        }
        #[doc = "SPI Peripheral Target EC Interrupt Enable Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EcIen(pub u32);
        impl EcIen {
            #[doc = "Enable Memory Write Done Interrupt to EC."]
            #[inline(always)]
            pub const fn mem_wr_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Write Done Interrupt to EC."]
            #[inline(always)]
            pub fn set_mem_wr_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable Memory Read Done Interrupt to EC."]
            #[inline(always)]
            pub const fn mem_rd_done(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Read Done Interrupt to EC."]
            #[inline(always)]
            pub fn set_mem_rd_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable Memory Write Busy Interrupt to EC."]
            #[inline(always)]
            pub const fn mem_wr_busy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Write Busy Interrupt to EC."]
            #[inline(always)]
            pub fn set_mem_wr_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable Memory Read Busy Interrupt to EC."]
            #[inline(always)]
            pub const fn mem_rd_busy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Read Busy Interrupt to EC."]
            #[inline(always)]
            pub fn set_mem_rd_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable SREG Trans Busy Interrupt to EC."]
            #[inline(always)]
            pub const fn sreg_trans(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SREG Trans Busy Interrupt to EC."]
            #[inline(always)]
            pub fn set_sreg_trans(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable Poll High Request Interrupt to EC."]
            #[inline(always)]
            pub const fn poll_hi(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Poll High Request Interrupt to EC."]
            #[inline(always)]
            pub fn set_poll_hi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable SREG RX FIFO Empty Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_emp(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SREG RX FIFO Empty Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable RX FIFO Full Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_ful(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Full Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable TX FIFO Empty Interrupt to EC."]
            #[inline(always)]
            pub const fn txf_emp(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Empty Interrupt to EC."]
            #[inline(always)]
            pub fn set_txf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable TX FIFI FULL Interrupt to EC."]
            #[inline(always)]
            pub const fn txf_ful(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFI FULL Interrupt to EC."]
            #[inline(always)]
            pub fn set_txf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable Test Mode SPI Clock Count Error Interrupt to EC."]
            #[inline(always)]
            pub const fn tmclk_cnt_err(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Test Mode SPI Clock Count Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_tmclk_cnt_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable Input Buffer Signaling Interrupt to EC."]
            #[inline(always)]
            pub const fn ibf_flg(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Input Buffer Signaling Interrupt to EC."]
            #[inline(always)]
            pub fn set_ibf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable Output Buffer signaling Interrupt to EC."]
            #[inline(always)]
            pub const fn obf_flg(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Output Buffer signaling Interrupt to EC."]
            #[inline(always)]
            pub fn set_obf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Enable SPI Master Request Reset Interrupt to EC."]
            #[inline(always)]
            pub const fn spim_rst_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SPI Master Request Reset Interrupt to EC."]
            #[inline(always)]
            pub fn set_spim_rst_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Enable RX FIFO Reset Done Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_rst_dn(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Reset Done Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Enable TX FIFO Reset Done Interrupt to EC."]
            #[inline(always)]
            pub const fn txf_rst_dn(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Reset Done Interrupt to EC."]
            #[inline(always)]
            pub fn set_txf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enable Out Of Limit 0 Error Interrupt to EC."]
            #[inline(always)]
            pub const fn ool0_err(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Out Of Limit 0 Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_ool0_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable Out Of Limit 1 Error Interrupt to EC."]
            #[inline(always)]
            pub const fn ool1_err(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Out Of Limit 1 Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_ool1_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable AHB BUS Error Interrupt to EC."]
            #[inline(always)]
            pub const fn armbus_err(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable AHB BUS Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_armbus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable Undefined Command Error Interrupt to EC."]
            #[inline(always)]
            pub const fn undef_cmd_err(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Undefined Command Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_undef_cmd_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable Device Busy Interrupt to EC."]
            #[inline(always)]
            pub const fn dv_busy(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Device Busy Interrupt to EC."]
            #[inline(always)]
            pub fn set_dv_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable RX FIFO SIZE Error Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_size_err(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO SIZE Error Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_size_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable TX FIFO Underflow Interrupt to EC."]
            #[inline(always)]
            pub const fn txf_unflw(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Underflow Interrupt to EC."]
            #[inline(always)]
            pub fn set_txf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable TX FIFO Overflow Interrupt to EC."]
            #[inline(always)]
            pub const fn txf_ovrflw(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Overflow Interrupt to EC."]
            #[inline(always)]
            pub fn set_txf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable RX FIFO Underflow Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_unflw(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Underflow Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable RX FIFO Overflow Interrupt to EC."]
            #[inline(always)]
            pub const fn rxf_ovrflw(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Overflow Interrupt to EC."]
            #[inline(always)]
            pub fn set_rxf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for EcIen {
            #[inline(always)]
            fn default() -> EcIen {
                EcIen(0)
            }
        }
        impl core::fmt::Debug for EcIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EcIen")
                    .field("mem_wr_done", &self.mem_wr_done())
                    .field("mem_rd_done", &self.mem_rd_done())
                    .field("mem_wr_busy", &self.mem_wr_busy())
                    .field("mem_rd_busy", &self.mem_rd_busy())
                    .field("sreg_trans", &self.sreg_trans())
                    .field("poll_hi", &self.poll_hi())
                    .field("rxf_emp", &self.rxf_emp())
                    .field("rxf_ful", &self.rxf_ful())
                    .field("txf_emp", &self.txf_emp())
                    .field("txf_ful", &self.txf_ful())
                    .field("tmclk_cnt_err", &self.tmclk_cnt_err())
                    .field("ibf_flg", &self.ibf_flg())
                    .field("obf_flg", &self.obf_flg())
                    .field("spim_rst_req", &self.spim_rst_req())
                    .field("rxf_rst_dn", &self.rxf_rst_dn())
                    .field("txf_rst_dn", &self.txf_rst_dn())
                    .field("ool0_err", &self.ool0_err())
                    .field("ool1_err", &self.ool1_err())
                    .field("armbus_err", &self.armbus_err())
                    .field("undef_cmd_err", &self.undef_cmd_err())
                    .field("dv_busy", &self.dv_busy())
                    .field("rxf_size_err", &self.rxf_size_err())
                    .field("txf_unflw", &self.txf_unflw())
                    .field("txf_ovrflw", &self.txf_ovrflw())
                    .field("rxf_unflw", &self.rxf_unflw())
                    .field("rxf_ovrflw", &self.rxf_ovrflw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EcIen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EcIen {{ mem_wr_done: {=bool:?}, mem_rd_done: {=bool:?}, mem_wr_busy: {=bool:?}, mem_rd_busy: {=bool:?}, sreg_trans: {=bool:?}, poll_hi: {=bool:?}, rxf_emp: {=bool:?}, rxf_ful: {=bool:?}, txf_emp: {=bool:?}, txf_ful: {=bool:?}, tmclk_cnt_err: {=bool:?}, ibf_flg: {=bool:?}, obf_flg: {=bool:?}, spim_rst_req: {=bool:?}, rxf_rst_dn: {=bool:?}, txf_rst_dn: {=bool:?}, ool0_err: {=bool:?}, ool1_err: {=bool:?}, armbus_err: {=bool:?}, undef_cmd_err: {=bool:?}, dv_busy: {=bool:?}, rxf_size_err: {=bool:?}, txf_unflw: {=bool:?}, txf_ovrflw: {=bool:?}, rxf_unflw: {=bool:?}, rxf_ovrflw: {=bool:?} }}" , self . mem_wr_done () , self . mem_rd_done () , self . mem_wr_busy () , self . mem_rd_busy () , self . sreg_trans () , self . poll_hi () , self . rxf_emp () , self . rxf_ful () , self . txf_emp () , self . txf_ful () , self . tmclk_cnt_err () , self . ibf_flg () , self . obf_flg () , self . spim_rst_req () , self . rxf_rst_dn () , self . txf_rst_dn () , self . ool0_err () , self . ool1_err () , self . armbus_err () , self . undef_cmd_err () , self . dv_busy () , self . rxf_size_err () , self . txf_unflw () , self . txf_ovrflw () , self . rxf_unflw () , self . rxf_ovrflw ())
            }
        }
        #[doc = "SPI Peripheral Target Memory Base Address0 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemBar0(pub u32);
        impl MemBar0 {
            #[doc = "Base Address for Region 0."]
            #[inline(always)]
            pub const fn bas_add0(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Base Address for Region 0."]
            #[inline(always)]
            pub fn set_bas_add0(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for MemBar0 {
            #[inline(always)]
            fn default() -> MemBar0 {
                MemBar0(0)
            }
        }
        impl core::fmt::Debug for MemBar0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemBar0").field("bas_add0", &self.bas_add0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemBar0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemBar0 {{ bas_add0: {=u32:?} }}", self.bas_add0())
            }
        }
        #[doc = "SPI Peripheral Target Memory Base Address1 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemBar1(pub u32);
        impl MemBar1 {
            #[doc = "Base Address for Region 1."]
            #[inline(always)]
            pub const fn add1(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Base Address for Region 1."]
            #[inline(always)]
            pub fn set_add1(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for MemBar1 {
            #[inline(always)]
            fn default() -> MemBar1 {
                MemBar1(0)
            }
        }
        impl core::fmt::Debug for MemBar1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemBar1").field("add1", &self.add1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemBar1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemBar1 {{ add1: {=u32:?} }}", self.add1())
            }
        }
        #[doc = "SPI Peripheral Target Memory Configuration Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemCfg(pub u32);
        impl MemCfg {
            #[doc = "Enables Region 0 operation. 0 = Disable Region 0. 1 = Enable Region 0."]
            #[inline(always)]
            pub const fn bar_en0_sel(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables Region 0 operation. 0 = Disable Region 0. 1 = Enable Region 0."]
            #[inline(always)]
            pub fn set_bar_en0_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enables Region 1 operation. 0 = Disable Region 1. 1 = Enable Region 1."]
            #[inline(always)]
            pub const fn bar_en1_sel(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enables Region 1 operation. 0 = Disable Region 1. 1 = Enable Region 1."]
            #[inline(always)]
            pub fn set_bar_en1_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for MemCfg {
            #[inline(always)]
            fn default() -> MemCfg {
                MemCfg(0)
            }
        }
        impl core::fmt::Debug for MemCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemCfg")
                    .field("bar_en0_sel", &self.bar_en0_sel())
                    .field("bar_en1_sel", &self.bar_en1_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "MemCfg {{ bar_en0_sel: {=bool:?}, bar_en1_sel: {=bool:?} }}",
                    self.bar_en0_sel(),
                    self.bar_en1_sel()
                )
            }
        }
        #[doc = "SPI Peripheral Target Memory Read LIMIT 0 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemRdLim0(pub u32);
        impl MemRdLim0 {
            #[doc = "Read Limit for Region 0."]
            #[inline(always)]
            pub const fn lmt0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Read Limit for Region 0."]
            #[inline(always)]
            pub fn set_lmt0(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for MemRdLim0 {
            #[inline(always)]
            fn default() -> MemRdLim0 {
                MemRdLim0(0)
            }
        }
        impl core::fmt::Debug for MemRdLim0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemRdLim0").field("lmt0", &self.lmt0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemRdLim0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemRdLim0 {{ lmt0: {=u16:?} }}", self.lmt0())
            }
        }
        #[doc = "SPI Peripheral Target Memory Read LIMIT 1 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemRdLim1(pub u32);
        impl MemRdLim1 {
            #[doc = "Read Limit for Region 1."]
            #[inline(always)]
            pub const fn lmt1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Read Limit for Region 1."]
            #[inline(always)]
            pub fn set_lmt1(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for MemRdLim1 {
            #[inline(always)]
            fn default() -> MemRdLim1 {
                MemRdLim1(0)
            }
        }
        impl core::fmt::Debug for MemRdLim1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemRdLim1").field("lmt1", &self.lmt1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemRdLim1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemRdLim1 {{ lmt1: {=u16:?} }}", self.lmt1())
            }
        }
        #[doc = "SPI Peripheral Target Memory Write LIMIT 0 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemWrLim0(pub u32);
        impl MemWrLim0 {
            #[doc = "Write Limit for Region 0."]
            #[inline(always)]
            pub const fn lmt0(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Write Limit for Region 0."]
            #[inline(always)]
            pub fn set_lmt0(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for MemWrLim0 {
            #[inline(always)]
            fn default() -> MemWrLim0 {
                MemWrLim0(0)
            }
        }
        impl core::fmt::Debug for MemWrLim0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemWrLim0").field("lmt0", &self.lmt0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemWrLim0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemWrLim0 {{ lmt0: {=u16:?} }}", self.lmt0())
            }
        }
        #[doc = "SPI Peripheral Target Memory Write LIMIT 1 Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemWrLim1(pub u32);
        impl MemWrLim1 {
            #[doc = "Write Limit for Region 1."]
            #[inline(always)]
            pub const fn lmt1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Write Limit for Region 1."]
            #[inline(always)]
            pub fn set_lmt1(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for MemWrLim1 {
            #[inline(always)]
            fn default() -> MemWrLim1 {
                MemWrLim1(0)
            }
        }
        impl core::fmt::Debug for MemWrLim1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemWrLim1").field("lmt1", &self.lmt1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemWrLim1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemWrLim1 {{ lmt1: {=u16:?} }}", self.lmt1())
            }
        }
        #[doc = "SPI Peripheral Target RX FIFO Byte Counter Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxfByteCnt(pub u32);
        impl RxfByteCnt {
            #[doc = "RX FIFO Byte Count Register."]
            #[inline(always)]
            pub const fn bcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "RX FIFO Byte Count Register."]
            #[inline(always)]
            pub fn set_bcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for RxfByteCnt {
            #[inline(always)]
            fn default() -> RxfByteCnt {
                RxfByteCnt(0)
            }
        }
        impl core::fmt::Debug for RxfByteCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxfByteCnt").field("bcnt", &self.bcnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxfByteCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxfByteCnt {{ bcnt: {=u16:?} }}", self.bcnt())
            }
        }
        #[doc = "SPI Peripheral Target RX FIFO Host Bar Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxfHostBar(pub u32);
        impl RxfHostBar {
            #[doc = "RX FIFO Host Bar Register."]
            #[inline(always)]
            pub const fn bar(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "RX FIFO Host Bar Register."]
            #[inline(always)]
            pub fn set_bar(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxfHostBar {
            #[inline(always)]
            fn default() -> RxfHostBar {
                RxfHostBar(0)
            }
        }
        impl core::fmt::Debug for RxfHostBar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxfHostBar").field("bar", &self.bar()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxfHostBar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxfHostBar {{ bar: {=u16:?} }}", self.bar())
            }
        }
        #[doc = "SPI Peripheral Target Communication Configuration Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpiCfg(pub u32);
        impl SpiCfg {
            #[doc = "This field defines the Single / Quad Wire mode of operation for SPI Peripheral Target block. 0 = Single Wire Slave SPI block operation. 1 = Quad Wire Slave SPI block operation."]
            #[inline(always)]
            pub const fn sng_qud_sel(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This field defines the Single / Quad Wire mode of operation for SPI Peripheral Target block. 0 = Single Wire Slave SPI block operation. 1 = Quad Wire Slave SPI block operation."]
            #[inline(always)]
            pub fn set_sng_qud_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Turn Around Time select for Quad wire mode. 0h = 1 cycle. 1h = 2 cycles. 2h = 4 cycles. 3h = 8 cycles. Other values are reserved."]
            #[inline(always)]
            pub const fn tar_tim_sel(&self) -> super::vals::TarTimSel {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::TarTimSel::from_bits(val as u8)
            }
            #[doc = "Turn Around Time select for Quad wire mode. 0h = 1 cycle. 1h = 2 cycles. 2h = 4 cycles. 3h = 8 cycles. Other values are reserved."]
            #[inline(always)]
            pub fn set_tar_tim_sel(&mut self, val: super::vals::TarTimSel) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "These bits set the amount of wait time in cycles before transmitting data back to master. During this wait time status bits will be transmitted"]
            #[inline(always)]
            pub const fn wait_time(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "These bits set the amount of wait time in cycles before transmitting data back to master. During this wait time status bits will be transmitted"]
            #[inline(always)]
            pub fn set_wait_time(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for SpiCfg {
            #[inline(always)]
            fn default() -> SpiCfg {
                SpiCfg(0)
            }
        }
        impl core::fmt::Debug for SpiCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpiCfg")
                    .field("sng_qud_sel", &self.sng_qud_sel())
                    .field("tar_tim_sel", &self.tar_tim_sel())
                    .field("wait_time", &self.wait_time())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpiCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SpiCfg {{ sng_qud_sel: {=bool:?}, tar_tim_sel: {:?}, wait_time: {=u8:?} }}",
                    self.sng_qud_sel(),
                    self.tar_tim_sel(),
                    self.wait_time()
                )
            }
        }
        #[doc = "SPI Peripheral Target EC Status Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpiEcSts(pub u32);
        impl SpiEcSts {
            #[doc = "When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to Memory for Posted Writes .- clear with new Write request."]
            #[inline(always)]
            pub const fn mem_wr_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to Memory for Posted Writes .- clear with new Write request."]
            #[inline(always)]
            pub fn set_mem_wr_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data read from Memory for Posted Reads. - cleared with new Read request."]
            #[inline(always)]
            pub const fn mem_rd_done(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data read from Memory for Posted Reads. - cleared with new Read request."]
            #[inline(always)]
            pub fn set_mem_rd_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "When an Memory Write transaction is currently being processed."]
            #[inline(always)]
            pub const fn mem_wr_busy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "When an Memory Write transaction is currently being processed."]
            #[inline(always)]
            pub fn set_mem_wr_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "When an Memory Read transaction is currently being processed."]
            #[inline(always)]
            pub const fn mem_rd_busy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When an Memory Read transaction is currently being processed."]
            #[inline(always)]
            pub fn set_mem_rd_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When an SREG transaction is currently being processed."]
            #[inline(always)]
            pub const fn sreg_trans(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When an SREG transaction is currently being processed."]
            #[inline(always)]
            pub fn set_sreg_trans(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "If this bit is set, then something in the high 16-bit of status register is set and needs to be checked. SPI Master should take action to clear this."]
            #[inline(always)]
            pub const fn poll_hi(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is set, then something in the high 16-bit of status register is set and needs to be checked. SPI Master should take action to clear this."]
            #[inline(always)]
            pub fn set_poll_hi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Signifies all Memory write transactions for the SPI Masters requested size have been performed. New transactions are allowed."]
            #[inline(always)]
            pub const fn rxf_emp(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Signifies all Memory write transactions for the SPI Masters requested size have been performed. New transactions are allowed."]
            #[inline(always)]
            pub fn set_rxf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "The RX FIFO is full of data to be written to Memory."]
            #[inline(always)]
            pub const fn rxf_ful(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "The RX FIFO is full of data to be written to Memory."]
            #[inline(always)]
            pub fn set_rxf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Signifies SPI Master has read the data requested from Memory. Can be used to show there is data the SPI Master has requested and not been read yet. New read transactions will be aligned."]
            #[inline(always)]
            pub const fn txf_emp(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Signifies SPI Master has read the data requested from Memory. Can be used to show there is data the SPI Master has requested and not been read yet. New read transactions will be aligned."]
            #[inline(always)]
            pub fn set_txf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "The TX FIFO is full of data that was read from Memory."]
            #[inline(always)]
            pub const fn txf_ful(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "The TX FIFO is full of data that was read from Memory."]
            #[inline(always)]
            pub fn set_txf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."]
            #[inline(always)]
            pub const fn tmclk_cnt_err(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."]
            #[inline(always)]
            pub fn set_tmclk_cnt_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Set when the Host writes to the Input Buffer signaling there is data for the EC to read."]
            #[inline(always)]
            pub const fn ibf_flg(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the Host writes to the Input Buffer signaling there is data for the EC to read."]
            #[inline(always)]
            pub fn set_ibf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Set when the EC writes to the Output Buffer signaling there is data for the Host to read."]
            #[inline(always)]
            pub const fn obf_flg(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the EC writes to the Output Buffer signaling there is data for the Host to read."]
            #[inline(always)]
            pub fn set_obf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Set when the SPI Master Requested a Configuration Reset."]
            #[inline(always)]
            pub const fn spim_rst_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the SPI Master Requested a Configuration Reset."]
            #[inline(always)]
            pub fn set_spim_rst_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub const fn rxf_rst_dn(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub fn set_rxf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub const fn txf_rst_dn(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub fn set_txf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."]
            #[inline(always)]
            pub const fn ool0_err(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."]
            #[inline(always)]
            pub fn set_ool0_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."]
            #[inline(always)]
            pub const fn ool1_err(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."]
            #[inline(always)]
            pub fn set_ool1_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "ARM Bus Error returned for the curren data transfer."]
            #[inline(always)]
            pub const fn armbus_err(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "ARM Bus Error returned for the curren data transfer."]
            #[inline(always)]
            pub fn set_armbus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Undefined Command Error: The command received from the master isn't defined."]
            #[inline(always)]
            pub const fn undef_cmd_err(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Undefined Command Error: The command received from the master isn't defined."]
            #[inline(always)]
            pub fn set_undef_cmd_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "If the Master requested a transaction whose destination is busy the request is ignored. Should use the poll or wait for interrupts."]
            #[inline(always)]
            pub const fn dv_busy(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "If the Master requested a transaction whose destination is busy the request is ignored. Should use the poll or wait for interrupts."]
            #[inline(always)]
            pub fn set_dv_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "If size requested is more than what Master provided and the Master terminates early error flag shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and continue transaction, may be taking in garbage."]
            #[inline(always)]
            pub const fn rxf_size_err(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "If size requested is more than what Master provided and the Master terminates early error flag shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and continue transaction, may be taking in garbage."]
            #[inline(always)]
            pub fn set_rxf_size_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned will just be the last valid pointer value."]
            #[inline(always)]
            pub const fn txf_unflw(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned will just be the last valid pointer value."]
            #[inline(always)]
            pub fn set_txf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "If Master doesn't read all of the data it requested from the posted read block cycle, than data will still be left in the FIFO. This will cause misalignment with the following transactions and a new read cycle can cause overflow."]
            #[inline(always)]
            pub const fn txf_ovrflw(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "If Master doesn't read all of the data it requested from the posted read block cycle, than data will still be left in the FIFO. This will cause misalignment with the following transactions and a new read cycle can cause overflow."]
            #[inline(always)]
            pub fn set_txf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "If the SPI Peripheral Target reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition will never happen under normal situation."]
            #[inline(always)]
            pub const fn rxf_unflw(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "If the SPI Peripheral Target reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition will never happen under normal situation."]
            #[inline(always)]
            pub fn set_rxf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data will not be stored."]
            #[inline(always)]
            pub const fn rxf_ovrflw(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data will not be stored."]
            #[inline(always)]
            pub fn set_rxf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for SpiEcSts {
            #[inline(always)]
            fn default() -> SpiEcSts {
                SpiEcSts(0)
            }
        }
        impl core::fmt::Debug for SpiEcSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpiEcSts")
                    .field("mem_wr_done", &self.mem_wr_done())
                    .field("mem_rd_done", &self.mem_rd_done())
                    .field("mem_wr_busy", &self.mem_wr_busy())
                    .field("mem_rd_busy", &self.mem_rd_busy())
                    .field("sreg_trans", &self.sreg_trans())
                    .field("poll_hi", &self.poll_hi())
                    .field("rxf_emp", &self.rxf_emp())
                    .field("rxf_ful", &self.rxf_ful())
                    .field("txf_emp", &self.txf_emp())
                    .field("txf_ful", &self.txf_ful())
                    .field("tmclk_cnt_err", &self.tmclk_cnt_err())
                    .field("ibf_flg", &self.ibf_flg())
                    .field("obf_flg", &self.obf_flg())
                    .field("spim_rst_req", &self.spim_rst_req())
                    .field("rxf_rst_dn", &self.rxf_rst_dn())
                    .field("txf_rst_dn", &self.txf_rst_dn())
                    .field("ool0_err", &self.ool0_err())
                    .field("ool1_err", &self.ool1_err())
                    .field("armbus_err", &self.armbus_err())
                    .field("undef_cmd_err", &self.undef_cmd_err())
                    .field("dv_busy", &self.dv_busy())
                    .field("rxf_size_err", &self.rxf_size_err())
                    .field("txf_unflw", &self.txf_unflw())
                    .field("txf_ovrflw", &self.txf_ovrflw())
                    .field("rxf_unflw", &self.rxf_unflw())
                    .field("rxf_ovrflw", &self.rxf_ovrflw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpiEcSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SpiEcSts {{ mem_wr_done: {=bool:?}, mem_rd_done: {=bool:?}, mem_wr_busy: {=bool:?}, mem_rd_busy: {=bool:?}, sreg_trans: {=bool:?}, poll_hi: {=bool:?}, rxf_emp: {=bool:?}, rxf_ful: {=bool:?}, txf_emp: {=bool:?}, txf_ful: {=bool:?}, tmclk_cnt_err: {=bool:?}, ibf_flg: {=bool:?}, obf_flg: {=bool:?}, spim_rst_req: {=bool:?}, rxf_rst_dn: {=bool:?}, txf_rst_dn: {=bool:?}, ool0_err: {=bool:?}, ool1_err: {=bool:?}, armbus_err: {=bool:?}, undef_cmd_err: {=bool:?}, dv_busy: {=bool:?}, rxf_size_err: {=bool:?}, txf_unflw: {=bool:?}, txf_ovrflw: {=bool:?}, rxf_unflw: {=bool:?}, rxf_ovrflw: {=bool:?} }}" , self . mem_wr_done () , self . mem_rd_done () , self . mem_wr_busy () , self . mem_rd_busy () , self . sreg_trans () , self . poll_hi () , self . rxf_emp () , self . rxf_ful () , self . txf_emp () , self . txf_ful () , self . tmclk_cnt_err () , self . ibf_flg () , self . obf_flg () , self . spim_rst_req () , self . rxf_rst_dn () , self . txf_rst_dn () , self . ool0_err () , self . ool1_err () , self . armbus_err () , self . undef_cmd_err () , self . dv_busy () , self . rxf_size_err () , self . txf_unflw () , self . txf_ovrflw () , self . rxf_unflw () , self . rxf_ovrflw ())
            }
        }
        #[doc = "SPI Peripheral Target Interrupt Enable Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpiIen(pub u32);
        impl SpiIen {
            #[doc = "Enable Memory Write Done Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn mem_wr_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Write Done Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_mem_wr_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable Memory Read Done Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn mem_rd_done(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Read Done Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_mem_rd_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable Memory Write Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn mem_wr_busy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Write Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_mem_wr_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable Memory Read Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn mem_rd_busy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Memory Read Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_mem_rd_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable SREG Trans Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn sreg_trans(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SREG Trans Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_sreg_trans(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable Poll High Request Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn poll_hi(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Poll High Request Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_poll_hi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable SREG RX FIFO Empty Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_emp(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SREG RX FIFO Empty Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable RX FIFO Full Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_ful(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Full Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable TX FIFO Empty Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn txf_emp(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Empty Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_txf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable TX FIFI FULL Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn txf_ful(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFI FULL Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_txf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable Test Mode SPI Clock Count Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn tmclk_cnt_err(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Test Mode SPI Clock Count Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_tmclk_cnt_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable Input Buffer Signaling Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn ibf_flg(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Input Buffer Signaling Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_ibf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable Output Buffer signaling Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn obf_flg(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Output Buffer signaling Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_obf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Enable SPI Master Request Reset Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn spim_rst_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SPI Master Request Reset Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_spim_rst_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Enable RX FIFO Reset Done Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_rst_dn(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Reset Done Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Enable TX FIFO Reset Done Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn txf_rst_dn(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Reset Done Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_txf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enable Out Of Limit 0 Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn ool0_err(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Out Of Limit 0 Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_ool0_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable Out Of Limit 1 Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn ool1_err(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Out Of Limit 1 Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_ool1_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable AHB BUS Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn armbus_err(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable AHB BUS Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_armbus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable Undefined Command Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn undef_cmd_err(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Undefined Command Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_undef_cmd_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable Device Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn dv_busy(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Device Busy Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_dv_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable RX FIFO SIZE Error Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_size_err(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO SIZE Error Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_size_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable TX FIFO Underflow Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn txf_unflw(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Underflow Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_txf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable TX FIFO Overflow Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn txf_ovrflow(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TX FIFO Overflow Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_txf_ovrflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable RX FIFO Underflow Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_unflw(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Underflow Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable RX FIFO Overflow Interrupt to SPI Master."]
            #[inline(always)]
            pub const fn rxf_ovrflw(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RX FIFO Overflow Interrupt to SPI Master."]
            #[inline(always)]
            pub fn set_rxf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for SpiIen {
            #[inline(always)]
            fn default() -> SpiIen {
                SpiIen(0)
            }
        }
        impl core::fmt::Debug for SpiIen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpiIen")
                    .field("mem_wr_done", &self.mem_wr_done())
                    .field("mem_rd_done", &self.mem_rd_done())
                    .field("mem_wr_busy", &self.mem_wr_busy())
                    .field("mem_rd_busy", &self.mem_rd_busy())
                    .field("sreg_trans", &self.sreg_trans())
                    .field("poll_hi", &self.poll_hi())
                    .field("rxf_emp", &self.rxf_emp())
                    .field("rxf_ful", &self.rxf_ful())
                    .field("txf_emp", &self.txf_emp())
                    .field("txf_ful", &self.txf_ful())
                    .field("tmclk_cnt_err", &self.tmclk_cnt_err())
                    .field("ibf_flg", &self.ibf_flg())
                    .field("obf_flg", &self.obf_flg())
                    .field("spim_rst_req", &self.spim_rst_req())
                    .field("rxf_rst_dn", &self.rxf_rst_dn())
                    .field("txf_rst_dn", &self.txf_rst_dn())
                    .field("ool0_err", &self.ool0_err())
                    .field("ool1_err", &self.ool1_err())
                    .field("armbus_err", &self.armbus_err())
                    .field("undef_cmd_err", &self.undef_cmd_err())
                    .field("dv_busy", &self.dv_busy())
                    .field("rxf_size_err", &self.rxf_size_err())
                    .field("txf_unflw", &self.txf_unflw())
                    .field("txf_ovrflow", &self.txf_ovrflow())
                    .field("rxf_unflw", &self.rxf_unflw())
                    .field("rxf_ovrflw", &self.rxf_ovrflw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpiIen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SpiIen {{ mem_wr_done: {=bool:?}, mem_rd_done: {=bool:?}, mem_wr_busy: {=bool:?}, mem_rd_busy: {=bool:?}, sreg_trans: {=bool:?}, poll_hi: {=bool:?}, rxf_emp: {=bool:?}, rxf_ful: {=bool:?}, txf_emp: {=bool:?}, txf_ful: {=bool:?}, tmclk_cnt_err: {=bool:?}, ibf_flg: {=bool:?}, obf_flg: {=bool:?}, spim_rst_req: {=bool:?}, rxf_rst_dn: {=bool:?}, txf_rst_dn: {=bool:?}, ool0_err: {=bool:?}, ool1_err: {=bool:?}, armbus_err: {=bool:?}, undef_cmd_err: {=bool:?}, dv_busy: {=bool:?}, rxf_size_err: {=bool:?}, txf_unflw: {=bool:?}, txf_ovrflow: {=bool:?}, rxf_unflw: {=bool:?}, rxf_ovrflw: {=bool:?} }}" , self . mem_wr_done () , self . mem_rd_done () , self . mem_wr_busy () , self . mem_rd_busy () , self . sreg_trans () , self . poll_hi () , self . rxf_emp () , self . rxf_ful () , self . txf_emp () , self . txf_ful () , self . tmclk_cnt_err () , self . ibf_flg () , self . obf_flg () , self . spim_rst_req () , self . rxf_rst_dn () , self . txf_rst_dn () , self . ool0_err () , self . ool1_err () , self . armbus_err () , self . undef_cmd_err () , self . dv_busy () , self . rxf_size_err () , self . txf_unflw () , self . txf_ovrflow () , self . rxf_unflw () , self . rxf_ovrflw ())
            }
        }
        #[doc = "SPI Peripheral Target Status Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpiSts(pub u32);
        impl SpiSts {
            #[doc = "When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to Memory for Posted Writes . Clear with new Write request."]
            #[inline(always)]
            pub const fn mem_wr_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to Memory for Posted Writes . Clear with new Write request."]
            #[inline(always)]
            pub fn set_mem_wr_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data read from Memory for Posted Reads. - cleared with new Read request."]
            #[inline(always)]
            pub const fn mem_rd_done(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data read from Memory for Posted Reads. - cleared with new Read request."]
            #[inline(always)]
            pub fn set_mem_rd_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "When an Memory Write transaction is currently being processed."]
            #[inline(always)]
            pub const fn mem_wr_busy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "When an Memory Write transaction is currently being processed."]
            #[inline(always)]
            pub fn set_mem_wr_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "When an Memory Read transaction is currently being processed."]
            #[inline(always)]
            pub const fn mem_rd_busy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When an Memory Read transaction is currently being processed."]
            #[inline(always)]
            pub fn set_mem_rd_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When an SREG transaction is currently being processed."]
            #[inline(always)]
            pub const fn sreg_trans(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When an SREG transaction is currently being processed."]
            #[inline(always)]
            pub fn set_sreg_trans(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "If this bit is set, then something in the high 16-bit of status register is set and needs to be checked. SPI Master should take action to clear this."]
            #[inline(always)]
            pub const fn poll_high(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is set, then something in the high 16-bit of status register is set and needs to be checked. SPI Master should take action to clear this."]
            #[inline(always)]
            pub fn set_poll_high(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Signifies all Memory write transactions for the SPI Masters requested size have been performed. New transactions are allowed."]
            #[inline(always)]
            pub const fn rxf_emp(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Signifies all Memory write transactions for the SPI Masters requested size have been performed. New transactions are allowed."]
            #[inline(always)]
            pub fn set_rxf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "The RX FIFO is full of data to be written to Memory."]
            #[inline(always)]
            pub const fn rxf_ful(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "The RX FIFO is full of data to be written to Memory."]
            #[inline(always)]
            pub fn set_rxf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Signifies SPI Master has read the data requested from Memory. Can be used to show there is data the SPI Master has requested and not been read yet. New read transactions will be aligned."]
            #[inline(always)]
            pub const fn txf_emp(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Signifies SPI Master has read the data requested from Memory. Can be used to show there is data the SPI Master has requested and not been read yet. New read transactions will be aligned."]
            #[inline(always)]
            pub fn set_txf_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "The TX FIFO is full of data that was read from Memory."]
            #[inline(always)]
            pub const fn txf_ful(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "The TX FIFO is full of data that was read from Memory."]
            #[inline(always)]
            pub fn set_txf_ful(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."]
            #[inline(always)]
            pub const fn tmclk_cnt_err(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks."]
            #[inline(always)]
            pub fn set_tmclk_cnt_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Set when the Host writes to the Input Buffer signaling there is data for the EC to read."]
            #[inline(always)]
            pub const fn ibf_flg(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the Host writes to the Input Buffer signaling there is data for the EC to read."]
            #[inline(always)]
            pub fn set_ibf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Set when the EC writes to the Output Buffer signaling there is data for the Host to read."]
            #[inline(always)]
            pub const fn obf_flg(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the EC writes to the Output Buffer signaling there is data for the Host to read."]
            #[inline(always)]
            pub fn set_obf_flg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Set when the SPI Master Requested a Configuration Reset."]
            #[inline(always)]
            pub const fn spim_rst_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Set when the SPI Master Requested a Configuration Reset."]
            #[inline(always)]
            pub fn set_spim_rst_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub const fn rxf_rst_dn(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub fn set_rxf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub const fn txf_rst_dn(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared."]
            #[inline(always)]
            pub fn set_txf_rst_dn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."]
            #[inline(always)]
            pub const fn ool0_err(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled."]
            #[inline(always)]
            pub fn set_ool0_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."]
            #[inline(always)]
            pub const fn ool1_err(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled."]
            #[inline(always)]
            pub fn set_ool1_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "ARM Bus Error returned for the curren data transfer."]
            #[inline(always)]
            pub const fn armbus_err(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "ARM Bus Error returned for the curren data transfer."]
            #[inline(always)]
            pub fn set_armbus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Undefined Command Error: The command received from the master isn't defined."]
            #[inline(always)]
            pub const fn undef_cmd_err(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Undefined Command Error: The command received from the master isn't defined."]
            #[inline(always)]
            pub fn set_undef_cmd_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "If the Master requested a transaction whose destination is busy the request is ignored. Should use the poll or wait for interrupts."]
            #[inline(always)]
            pub const fn dv_busy(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "If the Master requested a transaction whose destination is busy the request is ignored. Should use the poll or wait for interrupts."]
            #[inline(always)]
            pub fn set_dv_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "If size requested is more than what Master provided and the Master terminates early error flag shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and continue transaction, may be taking in garbage."]
            #[inline(always)]
            pub const fn rxf_size_err(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "If size requested is more than what Master provided and the Master terminates early error flag shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and continue transaction, may be taking in garbage."]
            #[inline(always)]
            pub fn set_rxf_size_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned will just be the last valid pointer value."]
            #[inline(always)]
            pub const fn txf_unflw(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned will just be the last valid pointer value."]
            #[inline(always)]
            pub fn set_txf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "If Master doesn't read all of the data it requested from the posted read block cycle, than data will still be left in the FIFO. This will cause misalignment with the following transactions and a new read cycle can cause overflow."]
            #[inline(always)]
            pub const fn txf_ovrflw(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "If Master doesn't read all of the data it requested from the posted read block cycle, than data will still be left in the FIFO. This will cause misalignment with the following transactions and a new read cycle can cause overflow."]
            #[inline(always)]
            pub fn set_txf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "If the SPI Peripheral Target reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition will never happen under normal situation."]
            #[inline(always)]
            pub const fn rxf_unflw(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "If the SPI Peripheral Target reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition will never happen under normal situation."]
            #[inline(always)]
            pub fn set_rxf_unflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data will not be stored."]
            #[inline(always)]
            pub const fn rxf_ovrflw(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data will not be stored."]
            #[inline(always)]
            pub fn set_rxf_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for SpiSts {
            #[inline(always)]
            fn default() -> SpiSts {
                SpiSts(0)
            }
        }
        impl core::fmt::Debug for SpiSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpiSts")
                    .field("mem_wr_done", &self.mem_wr_done())
                    .field("mem_rd_done", &self.mem_rd_done())
                    .field("mem_wr_busy", &self.mem_wr_busy())
                    .field("mem_rd_busy", &self.mem_rd_busy())
                    .field("sreg_trans", &self.sreg_trans())
                    .field("poll_high", &self.poll_high())
                    .field("rxf_emp", &self.rxf_emp())
                    .field("rxf_ful", &self.rxf_ful())
                    .field("txf_emp", &self.txf_emp())
                    .field("txf_ful", &self.txf_ful())
                    .field("tmclk_cnt_err", &self.tmclk_cnt_err())
                    .field("ibf_flg", &self.ibf_flg())
                    .field("obf_flg", &self.obf_flg())
                    .field("spim_rst_req", &self.spim_rst_req())
                    .field("rxf_rst_dn", &self.rxf_rst_dn())
                    .field("txf_rst_dn", &self.txf_rst_dn())
                    .field("ool0_err", &self.ool0_err())
                    .field("ool1_err", &self.ool1_err())
                    .field("armbus_err", &self.armbus_err())
                    .field("undef_cmd_err", &self.undef_cmd_err())
                    .field("dv_busy", &self.dv_busy())
                    .field("rxf_size_err", &self.rxf_size_err())
                    .field("txf_unflw", &self.txf_unflw())
                    .field("txf_ovrflw", &self.txf_ovrflw())
                    .field("rxf_unflw", &self.rxf_unflw())
                    .field("rxf_ovrflw", &self.rxf_ovrflw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpiSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SpiSts {{ mem_wr_done: {=bool:?}, mem_rd_done: {=bool:?}, mem_wr_busy: {=bool:?}, mem_rd_busy: {=bool:?}, sreg_trans: {=bool:?}, poll_high: {=bool:?}, rxf_emp: {=bool:?}, rxf_ful: {=bool:?}, txf_emp: {=bool:?}, txf_ful: {=bool:?}, tmclk_cnt_err: {=bool:?}, ibf_flg: {=bool:?}, obf_flg: {=bool:?}, spim_rst_req: {=bool:?}, rxf_rst_dn: {=bool:?}, txf_rst_dn: {=bool:?}, ool0_err: {=bool:?}, ool1_err: {=bool:?}, armbus_err: {=bool:?}, undef_cmd_err: {=bool:?}, dv_busy: {=bool:?}, rxf_size_err: {=bool:?}, txf_unflw: {=bool:?}, txf_ovrflw: {=bool:?}, rxf_unflw: {=bool:?}, rxf_ovrflw: {=bool:?} }}" , self . mem_wr_done () , self . mem_rd_done () , self . mem_wr_busy () , self . mem_rd_busy () , self . sreg_trans () , self . poll_high () , self . rxf_emp () , self . rxf_ful () , self . txf_emp () , self . txf_ful () , self . tmclk_cnt_err () , self . ibf_flg () , self . obf_flg () , self . spim_rst_req () , self . rxf_rst_dn () , self . txf_rst_dn () , self . ool0_err () , self . ool1_err () , self . armbus_err () , self . undef_cmd_err () , self . dv_busy () , self . rxf_size_err () , self . txf_unflw () , self . txf_ovrflw () , self . rxf_unflw () , self . rxf_ovrflw ())
            }
        }
        #[doc = "SPI Peripheral Target Master to EC Mailbox Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spim2ecMbx(pub u32);
        impl Spim2ecMbx {
            #[doc = "Write only register for the Host. When data is written to this register the IBF Flag is set. EC can read the data and writes of 0xFFFF will clear this register. Any form of read will clear the flag for this register."]
            #[inline(always)]
            pub const fn m2ec(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Write only register for the Host. When data is written to this register the IBF Flag is set. EC can read the data and writes of 0xFFFF will clear this register. Any form of read will clear the flag for this register."]
            #[inline(always)]
            pub fn set_m2ec(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Spim2ecMbx {
            #[inline(always)]
            fn default() -> Spim2ecMbx {
                Spim2ecMbx(0)
            }
        }
        impl core::fmt::Debug for Spim2ecMbx {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spim2ecMbx").field("m2ec", &self.m2ec()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spim2ecMbx {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Spim2ecMbx {{ m2ec: {=u32:?} }}", self.m2ec())
            }
        }
        #[doc = "SPI Peripheral Target System Configuration Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SysCfg(pub u32);
        impl SysCfg {
            #[doc = "Soft reset for entire SPI Peripheral Target Block. This bit is self clearing."]
            #[inline(always)]
            pub const fn soft_rst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Soft reset for entire SPI Peripheral Target Block. This bit is self clearing."]
            #[inline(always)]
            pub fn set_soft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock Quad / Single Write Mode bit, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_quad_sngl_wrmod(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Quad / Single Write Mode bit, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_quad_sngl_wrmod(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Lock Tar Time bit, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_tar_time(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Tar Time bit, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_tar_time(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Lock Wait Cycle bits, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_wait_cycl(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Wait Cycle bits, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_wait_cycl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Lock Memory Configuration register, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_mem_cfg(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Memory Configuration register, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_mem_cfg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Lock SPI Interrupt Enable register, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_spiint_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Lock SPI Interrupt Enable register, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_spiint_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Lock Memory Bar 0 register, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_mem_bar0(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Memory Bar 0 register, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_mem_bar0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Lock Memory Bar 1 register, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_mem_bar1(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Memory Bar 1 register, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_mem_bar1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Lock TEST Mode register, write access from SPI Master."]
            #[inline(always)]
            pub const fn lock_test_mode(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Lock TEST Mode register, write access from SPI Master."]
            #[inline(always)]
            pub fn set_lock_test_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable / Disable SPI Peripheral Target Block. 0 = Disable SPI Peripheral Target module. 1 = Enable SPI Peripheral Target module."]
            #[inline(always)]
            pub const fn spi_slv_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable / Disable SPI Peripheral Target Block. 0 = Disable SPI Peripheral Target module. 1 = Enable SPI Peripheral Target module."]
            #[inline(always)]
            pub fn set_spi_slv_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Fixed in hardware to 1"]
            #[inline(always)]
            pub const fn mas_ecreg(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Fixed in hardware to 1"]
            #[inline(always)]
            pub fn set_mas_ecreg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Enable SPI Peripheral Target Simple Mode operation."]
            #[inline(always)]
            pub const fn sim_en(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SPI Peripheral Target Simple Mode operation."]
            #[inline(always)]
            pub fn set_sim_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Notification to TX FIFO Engine that data is available for AHB Transfer. This register but is cleared by Hardware at the end of the transaction, with SPI_CS_N de-assertion. (R/WC)."]
            #[inline(always)]
            pub const fn ecdatl(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Notification to TX FIFO Engine that data is available for AHB Transfer. This register but is cleared by Hardware at the end of the transaction, with SPI_CS_N de-assertion. (R/WC)."]
            #[inline(always)]
            pub fn set_ecdatl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for SysCfg {
            #[inline(always)]
            fn default() -> SysCfg {
                SysCfg(0)
            }
        }
        impl core::fmt::Debug for SysCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SysCfg")
                    .field("soft_rst", &self.soft_rst())
                    .field("lock_quad_sngl_wrmod", &self.lock_quad_sngl_wrmod())
                    .field("lock_tar_time", &self.lock_tar_time())
                    .field("lock_wait_cycl", &self.lock_wait_cycl())
                    .field("lock_mem_cfg", &self.lock_mem_cfg())
                    .field("lock_spiint_en", &self.lock_spiint_en())
                    .field("lock_mem_bar0", &self.lock_mem_bar0())
                    .field("lock_mem_bar1", &self.lock_mem_bar1())
                    .field("lock_test_mode", &self.lock_test_mode())
                    .field("spi_slv_en", &self.spi_slv_en())
                    .field("mas_ecreg", &self.mas_ecreg())
                    .field("sim_en", &self.sim_en())
                    .field("ecdatl", &self.ecdatl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SysCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SysCfg {{ soft_rst: {=bool:?}, lock_quad_sngl_wrmod: {=bool:?}, lock_tar_time: {=bool:?}, lock_wait_cycl: {=bool:?}, lock_mem_cfg: {=bool:?}, lock_spiint_en: {=bool:?}, lock_mem_bar0: {=bool:?}, lock_mem_bar1: {=bool:?}, lock_test_mode: {=bool:?}, spi_slv_en: {=bool:?}, mas_ecreg: {=bool:?}, sim_en: {=bool:?}, ecdatl: {=bool:?} }}" , self . soft_rst () , self . lock_quad_sngl_wrmod () , self . lock_tar_time () , self . lock_wait_cycl () , self . lock_mem_cfg () , self . lock_spiint_en () , self . lock_mem_bar0 () , self . lock_mem_bar1 () , self . lock_test_mode () , self . spi_slv_en () , self . mas_ecreg () , self . sim_en () , self . ecdatl ())
            }
        }
        #[doc = "SPI Peripheral Target TX FIFO Byte Counter Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxfByteCnt(pub u32);
        impl TxfByteCnt {
            #[doc = "TX FIFO Byte Count Register."]
            #[inline(always)]
            pub const fn bcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "TX FIFO Byte Count Register."]
            #[inline(always)]
            pub fn set_bcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for TxfByteCnt {
            #[inline(always)]
            fn default() -> TxfByteCnt {
                TxfByteCnt(0)
            }
        }
        impl core::fmt::Debug for TxfByteCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxfByteCnt").field("bcnt", &self.bcnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxfByteCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxfByteCnt {{ bcnt: {=u16:?} }}", self.bcnt())
            }
        }
        #[doc = "SPI Peripheral Target TX FIFO Host Bar Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxfHostBar(pub u32);
        impl TxfHostBar {
            #[doc = "TX FIFO Host Bar Register."]
            #[inline(always)]
            pub const fn bar(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "TX FIFO Host Bar Register."]
            #[inline(always)]
            pub fn set_bar(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxfHostBar {
            #[inline(always)]
            fn default() -> TxfHostBar {
                TxfHostBar(0)
            }
        }
        impl core::fmt::Debug for TxfHostBar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxfHostBar").field("bar", &self.bar()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxfHostBar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxfHostBar {{ bar: {=u16:?} }}", self.bar())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TarTimSel {
            #[doc = "1 cycle"]
            TAR_TIME_1_CYCLE = 0x0,
            #[doc = "2 cycle"]
            TAR_TIME_2_CYCLE = 0x01,
            #[doc = "4 cycle"]
            TAR_TIME_4_CYCLE = 0x02,
            #[doc = "8 cycle"]
            TAR_TIME_8_CYCLE = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl TarTimSel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> TarTimSel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for TarTimSel {
            #[inline(always)]
            fn from(val: u8) -> TarTimSel {
                TarTimSel::from_bits(val)
            }
        }
        impl From<TarTimSel> for u8 {
            #[inline(always)]
            fn from(val: TarTimSel) -> u8 {
                TarTimSel::to_bits(val)
            }
        }
    }
}
pub mod tfdp {
    #[doc = "The TFDP serially transmits EC-originated diagnostic vectors to an external debug trace system."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tfdp {
        ptr: *mut u8,
    }
    unsafe impl Send for Tfdp {}
    unsafe impl Sync for Tfdp {}
    impl Tfdp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Debug data to be shifted out on the TFDP Debug port. While data is being shifted out, the Host Interface will 'hold-off' additional writes to the data register until the transfer is complete."]
        #[inline(always)]
        pub const fn msdata(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Debug Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Debug Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u8);
        impl Ctrl {
            #[doc = "Enable. 1=Clock enabled, 0=Clock is disabled (Default)"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable. 1=Clock enabled, 0=Clock is disabled (Default)"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "1= Data is shifted out on the falling edge of the debug clock, 0= Data is shifted out on the rising edge of the debug clock (Default)"]
            #[inline(always)]
            pub const fn edge_sel(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1= Data is shifted out on the falling edge of the debug clock, 0= Data is shifted out on the rising edge of the debug clock (Default)"]
            #[inline(always)]
            pub fn set_edge_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Clock Divider Select."]
            #[inline(always)]
            pub const fn divsel(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "Clock Divider Select."]
            #[inline(always)]
            pub fn set_divsel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "Inter-packet Delay. The delay is in terms of TFDP Debug output clocks."]
            #[inline(always)]
            pub const fn ip_dly(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "Inter-packet Delay. The delay is in terms of TFDP Debug output clocks."]
            #[inline(always)]
            pub fn set_ip_dly(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("en", &self.en())
                    .field("edge_sel", &self.edge_sel())
                    .field("divsel", &self.divsel())
                    .field("ip_dly", &self.ip_dly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl {{ en: {=bool:?}, edge_sel: {=bool:?}, divsel: {=u8:?}, ip_dly: {=u8:?} }}",
                    self.en(),
                    self.edge_sel(),
                    self.divsel(),
                    self.ip_dly()
                )
            }
        }
    }
}
pub mod timer32_0 {
    #[doc = "This 32-bit timer block offers a simple mechanism for firmware to maintain a time base."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Timer320 {
        ptr: *mut u8,
    }
    unsafe impl Send for Timer320 {}
    unsafe impl Sync for Timer320 {}
    impl Timer320 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This is the value of the Timer counter. This is updated by Hardware but may be set by Firmware."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the value of the Timer pre-load for the counter. This is used by H/W when the counter is to be restarted automatically; this will become the new value of the counter upon restart."]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the interrupt status that fires when the timer reaches its limit"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Timer Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This enables the block for operation. 1=This block will function normally; 0=This block will gate its clock and go into its lowest power state"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the block for operation. 1=This block will function normally; 0=This block will gate its clock and go into its lowest power state"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment; 0=The counter will decrement"]
            #[inline(always)]
            pub const fn cnt_up(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment; 0=The counter will decrement"]
            #[inline(always)]
            pub fn set_cnt_up(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This will select the action taken upon completing a count. 1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register. The interrupt will be set in edge mode 0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."]
            #[inline(always)]
            pub const fn au_restrt(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This will select the action taken upon completing a count. 1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register. The interrupt will be set in edge mode 0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."]
            #[inline(always)]
            pub fn set_au_restrt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need to wait before reconfiguring the Basic Timer following soft reset."]
            #[inline(always)]
            pub const fn sft_rst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need to wait before reconfiguring the Basic Timer following soft reset."]
            #[inline(always)]
            pub fn set_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so this bit will never clear. Clearing this bit will halt the timer counter."]
            #[inline(always)]
            pub const fn strt(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so this bit will never clear. Clearing this bit will halt the timer counter."]
            #[inline(always)]
            pub fn set_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit reloads the counter without interrupting it operation. This will not function if the timer has already completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an event occurs. Usage while the timer is off may result in erroneous behaviour."]
            #[inline(always)]
            pub const fn rld(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reloads the counter without interrupting it operation. This will not function if the timer has already completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an event occurs. Usage while the timer is off may result in erroneous behaviour."]
            #[inline(always)]
            pub fn set_rld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."]
            #[inline(always)]
            pub const fn hlt(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."]
            #[inline(always)]
            pub fn set_hlt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts. The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1 runs at half speed."]
            #[inline(always)]
            pub const fn prescale(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts. The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1 runs at half speed."]
            #[inline(always)]
            pub fn set_prescale(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("en", &self.en())
                    .field("cnt_up", &self.cnt_up())
                    .field("au_restrt", &self.au_restrt())
                    .field("sft_rst", &self.sft_rst())
                    .field("strt", &self.strt())
                    .field("rld", &self.rld())
                    .field("hlt", &self.hlt())
                    .field("prescale", &self.prescale())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ en: {=bool:?}, cnt_up: {=bool:?}, au_restrt: {=bool:?}, sft_rst: {=bool:?}, strt: {=bool:?}, rld: {=bool:?}, hlt: {=bool:?}, prescale: {=u16:?} }}" , self . en () , self . cnt_up () , self . au_restrt () , self . sft_rst () , self . strt () , self . rld () , self . hlt () , self . prescale ())
            }
        }
        #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u32);
        impl Ien {
            #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ien {{ en: {=bool:?} }}", self.en())
            }
        }
        #[doc = "This is the interrupt status that fires when the timer reaches its limit"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)"]
            #[inline(always)]
            pub const fn evt_int(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)"]
            #[inline(always)]
            pub fn set_evt_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts").field("evt_int", &self.evt_int()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sts {{ evt_int: {=bool:?} }}", self.evt_int())
            }
        }
    }
}
pub mod uart0 {
    #[doc = "UART when DLAB=0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Data {
        ptr: *mut u8,
    }
    unsafe impl Send for Data {}
    unsafe impl Sync for Data {}
    impl Data {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "UART Receive (Read) Buffer Register (DLAB=0)"]
        #[inline(always)]
        pub const fn rx_dat(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART Transmit (Write) Buffer Register (DLAB=0)"]
        #[inline(always)]
        pub const fn tx_dat(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART Interrupt Enable Register (DLAB=0)"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "UART FIFO Control Register"]
        #[inline(always)]
        pub const fn fifo_cr(self) -> crate::common::Reg<regs::DataFifoCr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[inline(always)]
        pub const fn int_id(self) -> crate::common::Reg<regs::DataIntId, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Line Control Register"]
        #[inline(always)]
        pub const fn lcr(self) -> crate::common::Reg<regs::DataLcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "UART Modem Control Register"]
        #[inline(always)]
        pub const fn mcr(self) -> crate::common::Reg<regs::DataMcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "UART Line Status Register"]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::DataLsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "UART Modem Status Register"]
        #[inline(always)]
        pub const fn msr(self) -> crate::common::Reg<regs::DataMsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "UART Scratchpad Register This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily."]
        #[inline(always)]
        pub const fn scr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "UART Activate Register. \\[0:0\\] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "UART Config Select Register"]
        #[inline(always)]
        pub const fn cfg_sel(self) -> crate::common::Reg<regs::DataCfgSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03f0usize) as _) }
        }
    }
    #[doc = "UART when DLAB=1"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dlab {
        ptr: *mut u8,
    }
    unsafe impl Send for Dlab {}
    unsafe impl Sync for Dlab {}
    impl Dlab {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "UART Programmable BAUD Rate Generator (LSB) Register (DLAB=1)"]
        #[inline(always)]
        pub const fn baudrt_lsb(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART Programmable BAUD Rate Generator (MSB) Register (DLAB=1). \\[6:0\\] BAUD_RATE_DIVISOR_MSB, \\[7:7\\] BAUD_CLK_SEL 1=If CLK_SRC is '0', the baud clock is derived from the 1.8432MHz_Clk. If CLK_SRC is '1', this bit has no effect 0=If CLK_SRC is '0', the baud clock is derived from the 24MHz_Clk. If CLK_SRC is '1', this bit has no effect"]
        #[inline(always)]
        pub const fn baudrt_msb(self) -> crate::common::Reg<regs::BaudrtMsb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "UART FIFO Control Register"]
        #[inline(always)]
        pub const fn fifo_cr(self) -> crate::common::Reg<regs::DlabFifoCr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[inline(always)]
        pub const fn int_id(self) -> crate::common::Reg<regs::DlabIntId, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Line Control Register"]
        #[inline(always)]
        pub const fn lcr(self) -> crate::common::Reg<regs::DlabLcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "UART Modem Control Register"]
        #[inline(always)]
        pub const fn mcr(self) -> crate::common::Reg<regs::DlabMcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "UART Line Status Register"]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::DlabLsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "UART Modem Status Register"]
        #[inline(always)]
        pub const fn msr(self) -> crate::common::Reg<regs::DlabMsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "UART Scratchpad Register This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily."]
        #[inline(always)]
        pub const fn scr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "UART Activate Register. \\[0:0\\] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "UART Config Select Register"]
        #[inline(always)]
        pub const fn cfg_sel(self) -> crate::common::Reg<regs::DlabCfgSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03f0usize) as _) }
        }
    }
    #[doc = "The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uart0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Uart0 {}
    unsafe impl Sync for Uart0 {}
    impl Uart0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "UART when DLAB=0"]
        #[inline(always)]
        pub const fn data(self) -> Data {
            unsafe { Data::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART when DLAB=1"]
        #[inline(always)]
        pub const fn dlab(self) -> Dlab {
            unsafe { Dlab::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "UART Programmable BAUD Rate Generator (MSB) Register (DLAB=1). \\[6:0\\] BAUD_RATE_DIVISOR_MSB, \\[7:7\\] BAUD_CLK_SEL 1=If CLK_SRC is '0', the baud clock is derived from the 1.8432MHz_Clk. If CLK_SRC is '1', this bit has no effect 0=If CLK_SRC is '0', the baud clock is derived from the 24MHz_Clk. If CLK_SRC is '1', this bit has no effect"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BaudrtMsb(pub u8);
        impl BaudrtMsb {
            #[doc = "Baud Rate divisor (MSB)."]
            #[inline(always)]
            pub const fn baudrt_div_msb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Baud Rate divisor (MSB)."]
            #[inline(always)]
            pub fn set_baudrt_div_msb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u8) & 0x7f) << 0usize);
            }
            #[doc = "Baud Clock Selection"]
            #[inline(always)]
            pub const fn baud_clk_sel(&self) -> super::vals::BaudClkSel {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::BaudClkSel::from_bits(val as u8)
            }
            #[doc = "Baud Clock Selection"]
            #[inline(always)]
            pub fn set_baud_clk_sel(&mut self, val: super::vals::BaudClkSel) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for BaudrtMsb {
            #[inline(always)]
            fn default() -> BaudrtMsb {
                BaudrtMsb(0)
            }
        }
        impl core::fmt::Debug for BaudrtMsb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BaudrtMsb")
                    .field("baudrt_div_msb", &self.baudrt_div_msb())
                    .field("baud_clk_sel", &self.baud_clk_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BaudrtMsb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BaudrtMsb {{ baudrt_div_msb: {=u8:?}, baud_clk_sel: {:?} }}",
                    self.baudrt_div_msb(),
                    self.baud_clk_sel()
                )
            }
        }
        #[doc = "UART Config Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataCfgSel(pub u8);
        impl DataCfgSel {
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub const fn clk_src(&self) -> super::vals::DataCfgSelClkSrc {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DataCfgSelClkSrc::from_bits(val as u8)
            }
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub fn set_clk_src(&mut self, val: super::vals::DataCfgSelClkSrc) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub const fn pwr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub fn set_pwr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub const fn polar(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub fn set_polar(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for DataCfgSel {
            #[inline(always)]
            fn default() -> DataCfgSel {
                DataCfgSel(0)
            }
        }
        impl core::fmt::Debug for DataCfgSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataCfgSel")
                    .field("clk_src", &self.clk_src())
                    .field("pwr", &self.pwr())
                    .field("polar", &self.polar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataCfgSel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DataCfgSel {{ clk_src: {:?}, pwr: {=bool:?}, polar: {=bool:?} }}",
                    self.clk_src(),
                    self.pwr(),
                    self.polar()
                )
            }
        }
        #[doc = "UART FIFO Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataFifoCr(pub u8);
        impl DataFifoCr {
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub const fn exrf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub fn set_exrf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub const fn clr_recv_fifo(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub fn set_clr_recv_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub const fn clr_xmit_fifo(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub fn set_clr_xmit_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub const fn dma_mode_sel(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub fn set_dma_mode_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub const fn recv_fifo_trig_lvl(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub fn set_recv_fifo_trig_lvl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DataFifoCr {
            #[inline(always)]
            fn default() -> DataFifoCr {
                DataFifoCr(0)
            }
        }
        impl core::fmt::Debug for DataFifoCr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataFifoCr")
                    .field("exrf", &self.exrf())
                    .field("clr_recv_fifo", &self.clr_recv_fifo())
                    .field("clr_xmit_fifo", &self.clr_xmit_fifo())
                    .field("dma_mode_sel", &self.dma_mode_sel())
                    .field("recv_fifo_trig_lvl", &self.recv_fifo_trig_lvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataFifoCr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataFifoCr {{ exrf: {=bool:?}, clr_recv_fifo: {=bool:?}, clr_xmit_fifo: {=bool:?}, dma_mode_sel: {=bool:?}, recv_fifo_trig_lvl: {=u8:?} }}" , self . exrf () , self . clr_recv_fifo () , self . clr_xmit_fifo () , self . dma_mode_sel () , self . recv_fifo_trig_lvl ())
            }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataIntId(pub u8);
        impl DataIntId {
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub const fn ipend(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub fn set_ipend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub const fn intid(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub fn set_intid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u8) & 0x07) << 1usize);
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub const fn fifo_en(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub fn set_fifo_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DataIntId {
            #[inline(always)]
            fn default() -> DataIntId {
                DataIntId(0)
            }
        }
        impl core::fmt::Debug for DataIntId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataIntId")
                    .field("ipend", &self.ipend())
                    .field("intid", &self.intid())
                    .field("fifo_en", &self.fifo_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataIntId {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DataIntId {{ ipend: {=bool:?}, intid: {=u8:?}, fifo_en: {=u8:?} }}",
                    self.ipend(),
                    self.intid(),
                    self.fifo_en()
                )
            }
        }
        #[doc = "UART Line Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataLcr(pub u8);
        impl DataLcr {
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn word_len(&self) -> super::vals::DataLcrWordLen {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::DataLcrWordLen::from_bits(val as u8)
            }
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_word_len(&mut self, val: super::vals::DataLcrWordLen) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn stop_bits(&self) -> super::vals::DataLcrStopBits {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::DataLcrStopBits::from_bits(val as u8)
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_stop_bits(&mut self, val: super::vals::DataLcrStopBits) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub const fn en_par(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub fn set_en_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub const fn par_sel(&self) -> super::vals::DataLcrParSel {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::DataLcrParSel::from_bits(val as u8)
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub fn set_par_sel(&mut self, val: super::vals::DataLcrParSel) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub const fn stick_par(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub fn set_stick_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub const fn brk_ctrl(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub fn set_brk_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub const fn dlab(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub fn set_dlab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DataLcr {
            #[inline(always)]
            fn default() -> DataLcr {
                DataLcr(0)
            }
        }
        impl core::fmt::Debug for DataLcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataLcr")
                    .field("word_len", &self.word_len())
                    .field("stop_bits", &self.stop_bits())
                    .field("en_par", &self.en_par())
                    .field("par_sel", &self.par_sel())
                    .field("stick_par", &self.stick_par())
                    .field("brk_ctrl", &self.brk_ctrl())
                    .field("dlab", &self.dlab())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataLcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataLcr {{ word_len: {:?}, stop_bits: {:?}, en_par: {=bool:?}, par_sel: {:?}, stick_par: {=bool:?}, brk_ctrl: {=bool:?}, dlab: {=bool:?} }}" , self . word_len () , self . stop_bits () , self . en_par () , self . par_sel () , self . stick_par () , self . brk_ctrl () , self . dlab ())
            }
        }
        #[doc = "UART Line Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataLsr(pub u8);
        impl DataLsr {
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub const fn data_ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub fn set_data_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub const fn pe(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub fn set_pe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub const fn frame_err(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub fn set_frame_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub const fn brk_intr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub fn set_brk_intr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub const fn trans_empty(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub fn set_trans_empty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub const fn trans_err(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub fn set_trans_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub const fn fifo_err(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub fn set_fifo_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DataLsr {
            #[inline(always)]
            fn default() -> DataLsr {
                DataLsr(0)
            }
        }
        impl core::fmt::Debug for DataLsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataLsr")
                    .field("data_ready", &self.data_ready())
                    .field("overrun", &self.overrun())
                    .field("pe", &self.pe())
                    .field("frame_err", &self.frame_err())
                    .field("brk_intr", &self.brk_intr())
                    .field("trans_empty", &self.trans_empty())
                    .field("trans_err", &self.trans_err())
                    .field("fifo_err", &self.fifo_err())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataLsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataLsr {{ data_ready: {=bool:?}, overrun: {=bool:?}, pe: {=bool:?}, frame_err: {=bool:?}, brk_intr: {=bool:?}, trans_empty: {=bool:?}, trans_err: {=bool:?}, fifo_err: {=bool:?} }}" , self . data_ready () , self . overrun () , self . pe () , self . frame_err () , self . brk_intr () , self . trans_empty () , self . trans_err () , self . fifo_err ())
            }
        }
        #[doc = "UART Modem Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataMcr(pub u8);
        impl DataMcr {
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub const fn dtr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub fn set_dtr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub const fn rts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub fn set_rts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub const fn out1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub fn set_out1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub const fn out2(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub fn set_out2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub const fn loopback(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub fn set_loopback(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for DataMcr {
            #[inline(always)]
            fn default() -> DataMcr {
                DataMcr(0)
            }
        }
        impl core::fmt::Debug for DataMcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataMcr")
                    .field("dtr", &self.dtr())
                    .field("rts", &self.rts())
                    .field("out1", &self.out1())
                    .field("out2", &self.out2())
                    .field("loopback", &self.loopback())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataMcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataMcr {{ dtr: {=bool:?}, rts: {=bool:?}, out1: {=bool:?}, out2: {=bool:?}, loopback: {=bool:?} }}" , self . dtr () , self . rts () , self . out1 () , self . out2 () , self . loopback ())
            }
        }
        #[doc = "UART Modem Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataMsr(pub u8);
        impl DataMsr {
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub const fn cts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub fn set_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub const fn dsr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub fn set_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub const fn ri(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub fn set_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub const fn dcd(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub fn set_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub const fn n_cts(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub fn set_n_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub const fn n_dsr(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub fn set_n_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub const fn n_ri(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub fn set_n_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub const fn n_dcd(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub fn set_n_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DataMsr {
            #[inline(always)]
            fn default() -> DataMsr {
                DataMsr(0)
            }
        }
        impl core::fmt::Debug for DataMsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataMsr")
                    .field("cts", &self.cts())
                    .field("dsr", &self.dsr())
                    .field("ri", &self.ri())
                    .field("dcd", &self.dcd())
                    .field("n_cts", &self.n_cts())
                    .field("n_dsr", &self.n_dsr())
                    .field("n_ri", &self.n_ri())
                    .field("n_dcd", &self.n_dcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataMsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataMsr {{ cts: {=bool:?}, dsr: {=bool:?}, ri: {=bool:?}, dcd: {=bool:?}, n_cts: {=bool:?}, n_dsr: {=bool:?}, n_ri: {=bool:?}, n_dcd: {=bool:?} }}" , self . cts () , self . dsr () , self . ri () , self . dcd () , self . n_cts () , self . n_dsr () , self . n_ri () , self . n_dcd ())
            }
        }
        #[doc = "UART Config Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabCfgSel(pub u8);
        impl DlabCfgSel {
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub const fn clk_src(&self) -> super::vals::DlabCfgSelClkSrc {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DlabCfgSelClkSrc::from_bits(val as u8)
            }
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub fn set_clk_src(&mut self, val: super::vals::DlabCfgSelClkSrc) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub const fn pwr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub fn set_pwr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub const fn polar(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub fn set_polar(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for DlabCfgSel {
            #[inline(always)]
            fn default() -> DlabCfgSel {
                DlabCfgSel(0)
            }
        }
        impl core::fmt::Debug for DlabCfgSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabCfgSel")
                    .field("clk_src", &self.clk_src())
                    .field("pwr", &self.pwr())
                    .field("polar", &self.polar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabCfgSel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DlabCfgSel {{ clk_src: {:?}, pwr: {=bool:?}, polar: {=bool:?} }}",
                    self.clk_src(),
                    self.pwr(),
                    self.polar()
                )
            }
        }
        #[doc = "UART FIFO Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabFifoCr(pub u8);
        impl DlabFifoCr {
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub const fn exrf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub fn set_exrf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub const fn clr_recv_fifo(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub fn set_clr_recv_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub const fn clr_xmit_fifo(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub fn set_clr_xmit_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub const fn dma_mode_sel(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub fn set_dma_mode_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub const fn recv_fifo_trig_lvl(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub fn set_recv_fifo_trig_lvl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DlabFifoCr {
            #[inline(always)]
            fn default() -> DlabFifoCr {
                DlabFifoCr(0)
            }
        }
        impl core::fmt::Debug for DlabFifoCr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabFifoCr")
                    .field("exrf", &self.exrf())
                    .field("clr_recv_fifo", &self.clr_recv_fifo())
                    .field("clr_xmit_fifo", &self.clr_xmit_fifo())
                    .field("dma_mode_sel", &self.dma_mode_sel())
                    .field("recv_fifo_trig_lvl", &self.recv_fifo_trig_lvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabFifoCr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabFifoCr {{ exrf: {=bool:?}, clr_recv_fifo: {=bool:?}, clr_xmit_fifo: {=bool:?}, dma_mode_sel: {=bool:?}, recv_fifo_trig_lvl: {=u8:?} }}" , self . exrf () , self . clr_recv_fifo () , self . clr_xmit_fifo () , self . dma_mode_sel () , self . recv_fifo_trig_lvl ())
            }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabIntId(pub u8);
        impl DlabIntId {
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub const fn ipend(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub fn set_ipend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub const fn intid(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub fn set_intid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u8) & 0x07) << 1usize);
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub const fn fifo_en(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub fn set_fifo_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DlabIntId {
            #[inline(always)]
            fn default() -> DlabIntId {
                DlabIntId(0)
            }
        }
        impl core::fmt::Debug for DlabIntId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabIntId")
                    .field("ipend", &self.ipend())
                    .field("intid", &self.intid())
                    .field("fifo_en", &self.fifo_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabIntId {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DlabIntId {{ ipend: {=bool:?}, intid: {=u8:?}, fifo_en: {=u8:?} }}",
                    self.ipend(),
                    self.intid(),
                    self.fifo_en()
                )
            }
        }
        #[doc = "UART Line Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabLcr(pub u8);
        impl DlabLcr {
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn word_len(&self) -> super::vals::DlabLcrWordLen {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::DlabLcrWordLen::from_bits(val as u8)
            }
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_word_len(&mut self, val: super::vals::DlabLcrWordLen) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn stop_bits(&self) -> super::vals::DlabLcrStopBits {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::DlabLcrStopBits::from_bits(val as u8)
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_stop_bits(&mut self, val: super::vals::DlabLcrStopBits) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub const fn en_par(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub fn set_en_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub const fn par_sel(&self) -> super::vals::DlabLcrParSel {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::DlabLcrParSel::from_bits(val as u8)
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub fn set_par_sel(&mut self, val: super::vals::DlabLcrParSel) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub const fn stick_par(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub fn set_stick_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub const fn brk_ctrl(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub fn set_brk_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub const fn dlab(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub fn set_dlab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DlabLcr {
            #[inline(always)]
            fn default() -> DlabLcr {
                DlabLcr(0)
            }
        }
        impl core::fmt::Debug for DlabLcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabLcr")
                    .field("word_len", &self.word_len())
                    .field("stop_bits", &self.stop_bits())
                    .field("en_par", &self.en_par())
                    .field("par_sel", &self.par_sel())
                    .field("stick_par", &self.stick_par())
                    .field("brk_ctrl", &self.brk_ctrl())
                    .field("dlab", &self.dlab())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabLcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabLcr {{ word_len: {:?}, stop_bits: {:?}, en_par: {=bool:?}, par_sel: {:?}, stick_par: {=bool:?}, brk_ctrl: {=bool:?}, dlab: {=bool:?} }}" , self . word_len () , self . stop_bits () , self . en_par () , self . par_sel () , self . stick_par () , self . brk_ctrl () , self . dlab ())
            }
        }
        #[doc = "UART Line Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabLsr(pub u8);
        impl DlabLsr {
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub const fn data_ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub fn set_data_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub const fn pe(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub fn set_pe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub const fn frame_err(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub fn set_frame_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub const fn brk_intr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub fn set_brk_intr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub const fn trans_empty(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub fn set_trans_empty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub const fn trans_err(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub fn set_trans_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub const fn fifo_err(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub fn set_fifo_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DlabLsr {
            #[inline(always)]
            fn default() -> DlabLsr {
                DlabLsr(0)
            }
        }
        impl core::fmt::Debug for DlabLsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabLsr")
                    .field("data_ready", &self.data_ready())
                    .field("overrun", &self.overrun())
                    .field("pe", &self.pe())
                    .field("frame_err", &self.frame_err())
                    .field("brk_intr", &self.brk_intr())
                    .field("trans_empty", &self.trans_empty())
                    .field("trans_err", &self.trans_err())
                    .field("fifo_err", &self.fifo_err())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabLsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabLsr {{ data_ready: {=bool:?}, overrun: {=bool:?}, pe: {=bool:?}, frame_err: {=bool:?}, brk_intr: {=bool:?}, trans_empty: {=bool:?}, trans_err: {=bool:?}, fifo_err: {=bool:?} }}" , self . data_ready () , self . overrun () , self . pe () , self . frame_err () , self . brk_intr () , self . trans_empty () , self . trans_err () , self . fifo_err ())
            }
        }
        #[doc = "UART Modem Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabMcr(pub u8);
        impl DlabMcr {
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub const fn dtr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub fn set_dtr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub const fn rts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub fn set_rts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub const fn out1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub fn set_out1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub const fn out2(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub fn set_out2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub const fn loopback(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub fn set_loopback(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for DlabMcr {
            #[inline(always)]
            fn default() -> DlabMcr {
                DlabMcr(0)
            }
        }
        impl core::fmt::Debug for DlabMcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabMcr")
                    .field("dtr", &self.dtr())
                    .field("rts", &self.rts())
                    .field("out1", &self.out1())
                    .field("out2", &self.out2())
                    .field("loopback", &self.loopback())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabMcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabMcr {{ dtr: {=bool:?}, rts: {=bool:?}, out1: {=bool:?}, out2: {=bool:?}, loopback: {=bool:?} }}" , self . dtr () , self . rts () , self . out1 () , self . out2 () , self . loopback ())
            }
        }
        #[doc = "UART Modem Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabMsr(pub u8);
        impl DlabMsr {
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub const fn cts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub fn set_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub const fn dsr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub fn set_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub const fn ri(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub fn set_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub const fn dcd(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub fn set_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub const fn n_cts(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub fn set_n_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub const fn n_dsr(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub fn set_n_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub const fn n_ri(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub fn set_n_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub const fn n_dcd(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub fn set_n_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DlabMsr {
            #[inline(always)]
            fn default() -> DlabMsr {
                DlabMsr(0)
            }
        }
        impl core::fmt::Debug for DlabMsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabMsr")
                    .field("cts", &self.cts())
                    .field("dsr", &self.dsr())
                    .field("ri", &self.ri())
                    .field("dcd", &self.dcd())
                    .field("n_cts", &self.n_cts())
                    .field("n_dsr", &self.n_dsr())
                    .field("n_ri", &self.n_ri())
                    .field("n_dcd", &self.n_dcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabMsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabMsr {{ cts: {=bool:?}, dsr: {=bool:?}, ri: {=bool:?}, dcd: {=bool:?}, n_cts: {=bool:?}, n_dsr: {=bool:?}, n_ri: {=bool:?}, n_dcd: {=bool:?} }}" , self . cts () , self . dsr () , self . ri () , self . dcd () , self . n_cts () , self . n_dsr () , self . n_ri () , self . n_dcd ())
            }
        }
        #[doc = "UART Interrupt Enable Register (DLAB=0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "ERDAI This bit enables the Received Data Available Interrupt (and timeout interrupts in the FIFO mode) when set to logic '1'."]
            #[inline(always)]
            pub const fn erdai(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "ERDAI This bit enables the Received Data Available Interrupt (and timeout interrupts in the FIFO mode) when set to logic '1'."]
            #[inline(always)]
            pub fn set_erdai(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "ETHREI This bit enables the Transmitter Holding Register Empty Interrupt when set to logic '1'."]
            #[inline(always)]
            pub const fn ethrei(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "ETHREI This bit enables the Transmitter Holding Register Empty Interrupt when set to logic '1'."]
            #[inline(always)]
            pub fn set_ethrei(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "ELSI This bit enables the Received Line Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub const fn elsi(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "ELSI This bit enables the Received Line Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub fn set_elsi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "EMSI This bit enables the MODEM Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub const fn emsi(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "EMSI This bit enables the MODEM Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub fn set_emsi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("erdai", &self.erdai())
                    .field("ethrei", &self.ethrei())
                    .field("elsi", &self.elsi())
                    .field("emsi", &self.emsi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ erdai: {=bool:?}, ethrei: {=bool:?}, elsi: {=bool:?}, emsi: {=bool:?} }}",
                    self.erdai(),
                    self.ethrei(),
                    self.elsi(),
                    self.emsi()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BaudClkSel {
            #[doc = "Baud clock is derived from the 1.8432MHz Clk"]
            _1843200_HZ = 0x0,
            #[doc = "baud clock is derived from the 48MHz Clk"]
            _48000000_HZ = 0x01,
        }
        impl BaudClkSel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BaudClkSel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BaudClkSel {
            #[inline(always)]
            fn from(val: u8) -> BaudClkSel {
                BaudClkSel::from_bits(val)
            }
        }
        impl From<BaudClkSel> for u8 {
            #[inline(always)]
            fn from(val: BaudClkSel) -> u8 {
                BaudClkSel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DataCfgSelClkSrc {
            #[doc = "Baud Clock is derived from one of the two internal clock sources"]
            INTERNAL = 0x0,
            #[doc = "Baud Clock is derived from an external clock source"]
            EXTERNAL = 0x01,
        }
        impl DataCfgSelClkSrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DataCfgSelClkSrc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DataCfgSelClkSrc {
            #[inline(always)]
            fn from(val: u8) -> DataCfgSelClkSrc {
                DataCfgSelClkSrc::from_bits(val)
            }
        }
        impl From<DataCfgSelClkSrc> for u8 {
            #[inline(always)]
            fn from(val: DataCfgSelClkSrc) -> u8 {
                DataCfgSelClkSrc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DataLcrParSel {
            #[doc = "Odd Parity"]
            ODD = 0x0,
            #[doc = "Even Parity"]
            EVEN = 0x01,
        }
        impl DataLcrParSel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DataLcrParSel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DataLcrParSel {
            #[inline(always)]
            fn from(val: u8) -> DataLcrParSel {
                DataLcrParSel::from_bits(val)
            }
        }
        impl From<DataLcrParSel> for u8 {
            #[inline(always)]
            fn from(val: DataLcrParSel) -> u8 {
                DataLcrParSel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DataLcrStopBits {
            #[doc = "1 Stop bit"]
            ONE_STOP_BIT = 0x0,
            #[doc = "1.5 or 2 Stop bits"]
            ONE_FIVE_TWO_STOP_BITS = 0x01,
        }
        impl DataLcrStopBits {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DataLcrStopBits {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DataLcrStopBits {
            #[inline(always)]
            fn from(val: u8) -> DataLcrStopBits {
                DataLcrStopBits::from_bits(val)
            }
        }
        impl From<DataLcrStopBits> for u8 {
            #[inline(always)]
            fn from(val: DataLcrStopBits) -> u8 {
                DataLcrStopBits::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DataLcrWordLen {
            #[doc = "5 Bits"]
            _5_BIT = 0x0,
            #[doc = "6 Bits"]
            _6_BIT = 0x01,
            #[doc = "7 Bits"]
            _7_BIT = 0x02,
            #[doc = "8 Bits"]
            _8_BIT = 0x03,
        }
        impl DataLcrWordLen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DataLcrWordLen {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DataLcrWordLen {
            #[inline(always)]
            fn from(val: u8) -> DataLcrWordLen {
                DataLcrWordLen::from_bits(val)
            }
        }
        impl From<DataLcrWordLen> for u8 {
            #[inline(always)]
            fn from(val: DataLcrWordLen) -> u8 {
                DataLcrWordLen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DlabCfgSelClkSrc {
            #[doc = "Baud Clock is derived from one of the two internal clock sources"]
            INTERNAL = 0x0,
            #[doc = "Baud Clock is derived from an external clock source"]
            EXTERNAL = 0x01,
        }
        impl DlabCfgSelClkSrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DlabCfgSelClkSrc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DlabCfgSelClkSrc {
            #[inline(always)]
            fn from(val: u8) -> DlabCfgSelClkSrc {
                DlabCfgSelClkSrc::from_bits(val)
            }
        }
        impl From<DlabCfgSelClkSrc> for u8 {
            #[inline(always)]
            fn from(val: DlabCfgSelClkSrc) -> u8 {
                DlabCfgSelClkSrc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DlabLcrParSel {
            #[doc = "Odd Parity"]
            ODD = 0x0,
            #[doc = "Even Parity"]
            EVEN = 0x01,
        }
        impl DlabLcrParSel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DlabLcrParSel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DlabLcrParSel {
            #[inline(always)]
            fn from(val: u8) -> DlabLcrParSel {
                DlabLcrParSel::from_bits(val)
            }
        }
        impl From<DlabLcrParSel> for u8 {
            #[inline(always)]
            fn from(val: DlabLcrParSel) -> u8 {
                DlabLcrParSel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DlabLcrStopBits {
            #[doc = "1 Stop bit"]
            ONE_STOP_BIT = 0x0,
            #[doc = "1.5 or 2 Stop bits"]
            ONE_FIVE_TWO_STOP_BITS = 0x01,
        }
        impl DlabLcrStopBits {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DlabLcrStopBits {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DlabLcrStopBits {
            #[inline(always)]
            fn from(val: u8) -> DlabLcrStopBits {
                DlabLcrStopBits::from_bits(val)
            }
        }
        impl From<DlabLcrStopBits> for u8 {
            #[inline(always)]
            fn from(val: DlabLcrStopBits) -> u8 {
                DlabLcrStopBits::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DlabLcrWordLen {
            #[doc = "5 Bits"]
            _5_BIT = 0x0,
            #[doc = "6 Bits"]
            _6_BIT = 0x01,
            #[doc = "7 Bits"]
            _7_BIT = 0x02,
            #[doc = "8 Bits"]
            _8_BIT = 0x03,
        }
        impl DlabLcrWordLen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DlabLcrWordLen {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DlabLcrWordLen {
            #[inline(always)]
            fn from(val: u8) -> DlabLcrWordLen {
                DlabLcrWordLen::from_bits(val)
            }
        }
        impl From<DlabLcrWordLen> for u8 {
            #[inline(always)]
            fn from(val: DlabLcrWordLen) -> u8 {
                DlabLcrWordLen::to_bits(val)
            }
        }
    }
}
pub mod vtr_reg_bank {
    #[doc = "The VBAT Register Bank block is a block implemented for miscellaneous battery-backed registers."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct VtrRegBank {
        ptr: *mut u8,
    }
    unsafe impl Send for VtrRegBank {}
    unsafe impl Sync for VtrRegBank {}
    impl VtrRegBank {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The Power-Fail and Reset Status Register collects and retains the VBAT RST and WDT event status when VCC1 is unpowered."]
        #[inline(always)]
        pub const fn pfrs(self) -> crate::common::Reg<regs::Pfrs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "The Power-Fail and Reset Status Register collects and retains the VBAT RST and WDT event status when VCC1 is unpowered."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pfrs(pub u32);
        impl Pfrs {
            #[doc = "Detect 32KHz Clock Input (R/WC)"]
            #[inline(always)]
            pub const fn det_32khz(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Detect 32KHz Clock Input (R/WC)"]
            #[inline(always)]
            pub fn set_det_32khz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to '1b' if a was triggered by an assertion of the SOFT_SYS_RESET bit in the System Reset Register. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn sft_rst(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a was triggered by an assertion of the SOFT_SYS_RESET bit in the System Reset Register. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a low signal on the RESETI# input pin. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn rsti(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a low signal on the RESETI# input pin. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_rsti(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a Watchdog Timer event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn wdt_evt(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a Watchdog Timer event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_wdt_evt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by an ARM SYSRESETREQ event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn sys_rstreq(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by an ARM SYSRESETREQ event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_sys_rstreq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Pfrs {
            #[inline(always)]
            fn default() -> Pfrs {
                Pfrs(0)
            }
        }
        impl core::fmt::Debug for Pfrs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pfrs")
                    .field("det_32khz", &self.det_32khz())
                    .field("sft_rst", &self.sft_rst())
                    .field("rsti", &self.rsti())
                    .field("wdt_evt", &self.wdt_evt())
                    .field("sys_rstreq", &self.sys_rstreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pfrs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pfrs {{ det_32khz: {=bool:?}, sft_rst: {=bool:?}, rsti: {=bool:?}, wdt_evt: {=bool:?}, sys_rstreq: {=bool:?} }}" , self . det_32khz () , self . sft_rst () , self . rsti () , self . wdt_evt () , self . sys_rstreq ())
            }
        }
    }
}
pub mod wdt {
    #[doc = "The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Wdt {}
    unsafe impl Sync for Wdt {}
    impl Wdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Writing this field reloads the Watch Dog Timer counter."]
        #[inline(always)]
        pub const fn load(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "WDT Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The WDT Kick Register is a strobe. Reads of this register return 0. Writes to this register cause the WDT to reload the WDT Load Register value and start decrementing when the WDT_ENABLE bit in the WDT Control Register is set to '1'. When the WDT_ENABLE bit in the WDT Control Register is cleared to '0', writes to the WDT Kick Register have no effect."]
        #[inline(always)]
        pub const fn kick(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This read-only register provides the current WDT count."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "This register provides the current WDT count."]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Watch Dog Interrupt Enable Register."]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "WDT Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u16);
        impl Ctrl {
            #[doc = "WDT Block enabled"]
            #[inline(always)]
            pub const fn wdt_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "WDT Block enabled"]
            #[inline(always)]
            pub fn set_wdt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "WDT_STATUS is set by hardware if the last reset of the device was caused by an underflow of the WDT. This bit must be cleared by the EC firmware writing a '1' to this bit. Writing a '0' to this bit has no effect."]
            #[inline(always)]
            pub const fn wdt_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "WDT_STATUS is set by hardware if the last reset of the device was caused by an underflow of the WDT. This bit must be cleared by the EC firmware writing a '1' to this bit. Writing a '0' to this bit has no effect."]
            #[inline(always)]
            pub fn set_wdt_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u16) & 0x01) << 1usize);
            }
            #[doc = "This bit enables the WDT Stall function if the Hibernation Timer 0 is active. 1=The WDT is stalled while the Hibernation Timer 0 is active 0=The WDT is not affected by Hibernation Timer 0."]
            #[inline(always)]
            pub const fn hib_tmr0_stl(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the WDT Stall function if the Hibernation Timer 0 is active. 1=The WDT is stalled while the Hibernation Timer 0 is active 0=The WDT is not affected by Hibernation Timer 0."]
            #[inline(always)]
            pub fn set_hib_tmr0_stl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u16) & 0x01) << 2usize);
            }
            #[doc = "This bit enables the WDT Stall function if the Week Timer is active. 1=The WDT is stalled while the Week Timer is active 0=The WDT is not affected by the Week Timer."]
            #[inline(always)]
            pub const fn wk_tmr_stl(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the WDT Stall function if the Week Timer is active. 1=The WDT is stalled while the Week Timer is active 0=The WDT is not affected by the Week Timer."]
            #[inline(always)]
            pub fn set_wk_tmr_stl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u16) & 0x01) << 3usize);
            }
            #[doc = "This bit enables the WDT Stall function if JTAG or SWD debug functions are active 1=The WDT is stalled while either JTAG or SWD is active 0=The WDT is not affected by the JTAG debug interface."]
            #[inline(always)]
            pub const fn jtag_stl(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the WDT Stall function if JTAG or SWD debug functions are active 1=The WDT is stalled while either JTAG or SWD is active 0=The WDT is not affected by the JTAG debug interface."]
            #[inline(always)]
            pub fn set_jtag_stl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u16) & 0x01) << 4usize);
            }
            #[doc = "If the WDT_RESET bit is set and the watch dog timer expires, the Watch dog module will generate interrupt and clear the WDT_RESET to 0b."]
            #[inline(always)]
            pub const fn wdt_rst(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "If the WDT_RESET bit is set and the watch dog timer expires, the Watch dog module will generate interrupt and clear the WDT_RESET to 0b."]
            #[inline(always)]
            pub fn set_wdt_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u16) & 0x01) << 9usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("wdt_en", &self.wdt_en())
                    .field("wdt_sts", &self.wdt_sts())
                    .field("hib_tmr0_stl", &self.hib_tmr0_stl())
                    .field("wk_tmr_stl", &self.wk_tmr_stl())
                    .field("jtag_stl", &self.jtag_stl())
                    .field("wdt_rst", &self.wdt_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ wdt_en: {=bool:?}, wdt_sts: {=bool:?}, hib_tmr0_stl: {=bool:?}, wk_tmr_stl: {=bool:?}, jtag_stl: {=bool:?}, wdt_rst: {=bool:?} }}" , self . wdt_en () , self . wdt_sts () , self . hib_tmr0_stl () , self . wk_tmr_stl () , self . jtag_stl () , self . wdt_rst ())
            }
        }
        #[doc = "Watch Dog Interrupt Enable Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "WDT_Int_Enable: This is the interrupt enables bit for WDT_INT interrupt. 1= WDT_INT Interrupt Enable 0= WDT_INT Interrupt Disabled"]
            #[inline(always)]
            pub const fn wdt_inten(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "WDT_Int_Enable: This is the interrupt enables bit for WDT_INT interrupt. 1= WDT_INT Interrupt Enable 0= WDT_INT Interrupt Disabled"]
            #[inline(always)]
            pub fn set_wdt_inten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien").field("wdt_inten", &self.wdt_inten()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ien {{ wdt_inten: {=bool:?} }}", self.wdt_inten())
            }
        }
        #[doc = "This register provides the current WDT count."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u8);
        impl Sts {
            #[doc = "WDT_EVENT_IRQ : This bit indicates the status of interrupt from Watch dog module."]
            #[inline(always)]
            pub const fn wdt_ev_irq(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "WDT_EVENT_IRQ : This bit indicates the status of interrupt from Watch dog module."]
            #[inline(always)]
            pub fn set_wdt_ev_irq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts").field("wdt_ev_irq", &self.wdt_ev_irq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sts {{ wdt_ev_irq: {=bool:?} }}", self.wdt_ev_irq())
            }
        }
    }
}
