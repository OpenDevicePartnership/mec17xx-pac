#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

#![doc = "Peripheral access API (generated using chiptool v0.1.0 (d771c7b 2025-03-27))"]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Interrupt {
    #[doc = "0 - GIRQ08"]
    GIRQ08 = 0,
    #[doc = "1 - GIRQ09"]
    GIRQ09 = 1,
    #[doc = "2 - GIRQ10"]
    GIRQ10 = 2,
    #[doc = "3 - GIRQ11"]
    GIRQ11 = 3,
    #[doc = "4 - GIRQ12"]
    GIRQ12 = 4,
    #[doc = "17 - GIRQ26"]
    GIRQ26 = 17,
    #[doc = "20 - SMB0"]
    SMB0 = 20,
    #[doc = "21 - SMB1"]
    SMB1 = 21,
    #[doc = "22 - SMB2"]
    SMB2 = 22,
    #[doc = "23 - SMB3"]
    SMB3 = 23,
    #[doc = "24 - DMA_CH00"]
    DMA_CH00 = 24,
    #[doc = "25 - DMA_CH01"]
    DMA_CH01 = 25,
    #[doc = "26 - DMA_CH02"]
    DMA_CH02 = 26,
    #[doc = "27 - DMA_CH03"]
    DMA_CH03 = 27,
    #[doc = "28 - DMA_CH04"]
    DMA_CH04 = 28,
    #[doc = "29 - DMA_CH05"]
    DMA_CH05 = 29,
    #[doc = "30 - DMA_CH06"]
    DMA_CH06 = 30,
    #[doc = "31 - DMA_CH07"]
    DMA_CH07 = 31,
    #[doc = "32 - DMA_CH08"]
    DMA_CH08 = 32,
    #[doc = "33 - DMA_CH09"]
    DMA_CH09 = 33,
    #[doc = "34 - DMA_CH10"]
    DMA_CH10 = 34,
    #[doc = "35 - DMA_CH11"]
    DMA_CH11 = 35,
    #[doc = "36 - DMA_CH12"]
    DMA_CH12 = 36,
    #[doc = "37 - DMA_CH13"]
    DMA_CH13 = 37,
    #[doc = "40 - UART0"]
    UART0 = 40,
    #[doc = "41 - UART1"]
    UART1 = 41,
    #[doc = "71 - TACH0"]
    TACH0 = 71,
    #[doc = "72 - TACH1"]
    TACH1 = 72,
    #[doc = "74 - RPM2PWM_0_FAIL"]
    RPM2PWM_0_FAIL = 74,
    #[doc = "75 - RPM2PWM_0_STALL"]
    RPM2PWM_0_STALL = 75,
    #[doc = "76 - RPM2PWM_1_FAIL"]
    RPM2PWM_1_FAIL = 76,
    #[doc = "77 - RPM2PWM_1_STALL"]
    RPM2PWM_1_STALL = 77,
    #[doc = "78 - SNGL"]
    SNGL = 78,
    #[doc = "79 - RPT"]
    RPT = 79,
    #[doc = "80 - RC_ID0"]
    RC_ID0 = 80,
    #[doc = "81 - RC_ID1"]
    RC_ID1 = 81,
    #[doc = "83 - LED0"]
    LED0 = 83,
    #[doc = "84 - LED1"]
    LED1 = 84,
    #[doc = "91 - QMSPI"]
    QMSPI = 91,
    #[doc = "92 - TX0"]
    TX0 = 92,
    #[doc = "93 - RX0"]
    RX0 = 93,
    #[doc = "111 - TIMER"]
    TIMER = 111,
    #[doc = "112 - HTM0"]
    HTM0 = 112,
    #[doc = "113 - HTM1"]
    HTM1 = 113,
    #[doc = "114 - ALARM_INT"]
    ALARM_INT = 114,
    #[doc = "115 - WKSUB"]
    WKSUB = 115,
    #[doc = "116 - WKSEC"]
    WKSEC = 116,
    #[doc = "117 - WKSUBSEC"]
    WKSUBSEC = 117,
    #[doc = "118 - SYSPWR"]
    SYSPWR = 118,
    #[doc = "119 - RTC"]
    RTC = 119,
    #[doc = "120 - RTC_ALARM"]
    RTC_ALARM = 120,
    #[doc = "121 - OVRD_IN"]
    OVRD_IN = 121,
    #[doc = "122 - IN0"]
    IN0 = 122,
    #[doc = "123 - IN1"]
    IN1 = 123,
    #[doc = "124 - IN2"]
    IN2 = 124,
    #[doc = "125 - IN3"]
    IN3 = 125,
    #[doc = "126 - IN4"]
    IN4 = 126,
    #[doc = "127 - IN5"]
    IN5 = 127,
    #[doc = "128 - IN6"]
    IN6 = 128,
    #[doc = "135 - KMS"]
    KMS = 135,
    #[doc = "136 - TIMER16_0"]
    TIMER16_0 = 136,
    #[doc = "137 - TIMER16_1"]
    TIMER16_1 = 137,
    #[doc = "138 - TIMER16_2"]
    TIMER16_2 = 138,
    #[doc = "139 - TIMER16_3"]
    TIMER16_3 = 139,
    #[doc = "140 - TIMER32_0"]
    TIMER32_0 = 140,
    #[doc = "141 - TIMER32_1"]
    TIMER32_1 = 141,
    #[doc = "142 - CNT_TMR0"]
    CNT_TMR0 = 142,
    #[doc = "143 - CNT_TMR1"]
    CNT_TMR1 = 143,
    #[doc = "144 - CNT_TMR2"]
    CNT_TMR2 = 144,
    #[doc = "145 - CNT_TMR3"]
    CNT_TMR3 = 145,
    #[doc = "146 - CAPTURE_TIMER"]
    CAPTURE_TIMER = 146,
    #[doc = "147 - CAPTURE_0"]
    CAPTURE_0 = 147,
    #[doc = "148 - CAPTURE_1"]
    CAPTURE_1 = 148,
    #[doc = "149 - CAPTURE_2"]
    CAPTURE_2 = 149,
    #[doc = "150 - CAPTURE_3"]
    CAPTURE_3 = 150,
    #[doc = "151 - CAPTURE_4"]
    CAPTURE_4 = 151,
    #[doc = "152 - CAPTURE_5"]
    CAPTURE_5 = 152,
    #[doc = "153 - COMPARE_0"]
    COMPARE_0 = 153,
    #[doc = "154 - COMPARE_1"]
    COMPARE_1 = 154,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[cfg(feature = "rt")]
mod _vectors {
    extern "C" {
        fn GIRQ08();
        fn GIRQ09();
        fn GIRQ10();
        fn GIRQ11();
        fn GIRQ12();
        fn GIRQ26();
        fn SMB0();
        fn SMB1();
        fn SMB2();
        fn SMB3();
        fn DMA_CH00();
        fn DMA_CH01();
        fn DMA_CH02();
        fn DMA_CH03();
        fn DMA_CH04();
        fn DMA_CH05();
        fn DMA_CH06();
        fn DMA_CH07();
        fn DMA_CH08();
        fn DMA_CH09();
        fn DMA_CH10();
        fn DMA_CH11();
        fn DMA_CH12();
        fn DMA_CH13();
        fn UART0();
        fn UART1();
        fn TACH0();
        fn TACH1();
        fn RPM2PWM_0_FAIL();
        fn RPM2PWM_0_STALL();
        fn RPM2PWM_1_FAIL();
        fn RPM2PWM_1_STALL();
        fn SNGL();
        fn RPT();
        fn RC_ID0();
        fn RC_ID1();
        fn LED0();
        fn LED1();
        fn QMSPI();
        fn TX0();
        fn RX0();
        fn TIMER();
        fn HTM0();
        fn HTM1();
        fn ALARM_INT();
        fn WKSUB();
        fn WKSEC();
        fn WKSUBSEC();
        fn SYSPWR();
        fn RTC();
        fn RTC_ALARM();
        fn OVRD_IN();
        fn IN0();
        fn IN1();
        fn IN2();
        fn IN3();
        fn IN4();
        fn IN5();
        fn IN6();
        fn KMS();
        fn TIMER16_0();
        fn TIMER16_1();
        fn TIMER16_2();
        fn TIMER16_3();
        fn TIMER32_0();
        fn TIMER32_1();
        fn CNT_TMR0();
        fn CNT_TMR1();
        fn CNT_TMR2();
        fn CNT_TMR3();
        fn CAPTURE_TIMER();
        fn CAPTURE_0();
        fn CAPTURE_1();
        fn CAPTURE_2();
        fn CAPTURE_3();
        fn CAPTURE_4();
        fn CAPTURE_5();
        fn COMPARE_0();
        fn COMPARE_1();
    }
    pub union Vector {
        _handler: unsafe extern "C" fn(),
        _reserved: u32,
    }
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    pub static __INTERRUPTS: [Vector; 155] = [
        Vector { _handler: GIRQ08 },
        Vector { _handler: GIRQ09 },
        Vector { _handler: GIRQ10 },
        Vector { _handler: GIRQ11 },
        Vector { _handler: GIRQ12 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: GIRQ26 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SMB0 },
        Vector { _handler: SMB1 },
        Vector { _handler: SMB2 },
        Vector { _handler: SMB3 },
        Vector { _handler: DMA_CH00 },
        Vector { _handler: DMA_CH01 },
        Vector { _handler: DMA_CH02 },
        Vector { _handler: DMA_CH03 },
        Vector { _handler: DMA_CH04 },
        Vector { _handler: DMA_CH05 },
        Vector { _handler: DMA_CH06 },
        Vector { _handler: DMA_CH07 },
        Vector { _handler: DMA_CH08 },
        Vector { _handler: DMA_CH09 },
        Vector { _handler: DMA_CH10 },
        Vector { _handler: DMA_CH11 },
        Vector { _handler: DMA_CH12 },
        Vector { _handler: DMA_CH13 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: UART0 },
        Vector { _handler: UART1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: TACH0 },
        Vector { _handler: TACH1 },
        Vector { _reserved: 0 },
        Vector {
            _handler: RPM2PWM_0_FAIL,
        },
        Vector {
            _handler: RPM2PWM_0_STALL,
        },
        Vector {
            _handler: RPM2PWM_1_FAIL,
        },
        Vector {
            _handler: RPM2PWM_1_STALL,
        },
        Vector { _handler: SNGL },
        Vector { _handler: RPT },
        Vector { _handler: RC_ID0 },
        Vector { _handler: RC_ID1 },
        Vector { _reserved: 0 },
        Vector { _handler: LED0 },
        Vector { _handler: LED1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: QMSPI },
        Vector { _handler: TX0 },
        Vector { _handler: RX0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: TIMER },
        Vector { _handler: HTM0 },
        Vector { _handler: HTM1 },
        Vector { _handler: ALARM_INT },
        Vector { _handler: WKSUB },
        Vector { _handler: WKSEC },
        Vector { _handler: WKSUBSEC },
        Vector { _handler: SYSPWR },
        Vector { _handler: RTC },
        Vector { _handler: RTC_ALARM },
        Vector { _handler: OVRD_IN },
        Vector { _handler: IN0 },
        Vector { _handler: IN1 },
        Vector { _handler: IN2 },
        Vector { _handler: IN3 },
        Vector { _handler: IN4 },
        Vector { _handler: IN5 },
        Vector { _handler: IN6 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: KMS },
        Vector { _handler: TIMER16_0 },
        Vector { _handler: TIMER16_1 },
        Vector { _handler: TIMER16_2 },
        Vector { _handler: TIMER16_3 },
        Vector { _handler: TIMER32_0 },
        Vector { _handler: TIMER32_1 },
        Vector { _handler: CNT_TMR0 },
        Vector { _handler: CNT_TMR1 },
        Vector { _handler: CNT_TMR2 },
        Vector { _handler: CNT_TMR3 },
        Vector {
            _handler: CAPTURE_TIMER,
        },
        Vector { _handler: CAPTURE_0 },
        Vector { _handler: CAPTURE_1 },
        Vector { _handler: CAPTURE_2 },
        Vector { _handler: CAPTURE_3 },
        Vector { _handler: CAPTURE_4 },
        Vector { _handler: CAPTURE_5 },
        Vector { _handler: COMPARE_0 },
        Vector { _handler: COMPARE_1 },
    ];
}
#[doc = "The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed. When enabled, the Watchdog Timer (WDT) circuit will generate a WDT Event if the user program fails to reload the WDT within a specified length of time known as the WDT Interval."]
pub const WDT: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x4000_0000usize as _) };
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits. The name of the timer instance indicates the size of the timer."]
pub const TIMER16_0: timer16_0::Timer160 = unsafe { timer16_0::Timer160::from_ptr(0x4000_0c00usize as _) };
pub const TIMER16_1: timer16_0::Timer160 = unsafe { timer16_0::Timer160::from_ptr(0x4000_0c20usize as _) };
pub const TIMER16_2: timer16_0::Timer160 = unsafe { timer16_0::Timer160::from_ptr(0x4000_0c40usize as _) };
pub const TIMER16_3: timer16_0::Timer160 = unsafe { timer16_0::Timer160::from_ptr(0x4000_0c80usize as _) };
#[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 32 bits. The name of the timer instance indicates the size of the timer."]
pub const TIMER32_0: timer32_0::Timer320 = unsafe { timer32_0::Timer320::from_ptr(0x4000_0c80usize as _) };
pub const TIMER32_1: timer32_0::Timer320 = unsafe { timer32_0::Timer320::from_ptr(0x4000_0ca0usize as _) };
#[doc = "This interface is a 16-bit auto-reloading timer/counter."]
pub const CNT_TMR0: cnt_tmr0::CntTmr0 = unsafe { cnt_tmr0::CntTmr0::from_ptr(0x4000_0d00usize as _) };
pub const CNT_TMR1: cnt_tmr0::CntTmr0 = unsafe { cnt_tmr0::CntTmr0::from_ptr(0x4000_0d20usize as _) };
pub const CNT_TMR2: cnt_tmr0::CntTmr0 = unsafe { cnt_tmr0::CntTmr0::from_ptr(0x4000_0d40usize as _) };
pub const CNT_TMR3: cnt_tmr0::CntTmr0 = unsafe { cnt_tmr0::CntTmr0::from_ptr(0x4000_0d60usize as _) };
#[doc = "This is a 16-bit auto-reloading timer/counter."]
pub const CCT: cct::Cct = unsafe { cct::Cct::from_ptr(0x4000_1000usize as _) };
#[doc = "This interface provides a single pin interface which can discriminate a number of quantized RC constants."]
pub const RC_ID0: rc_id0::RcId0 = unsafe { rc_id0::RcId0::from_ptr(0x4000_1400usize as _) };
pub const RC_ID1: rc_id0::RcId0 = unsafe { rc_id0::RcId0::from_ptr(0x4000_1480usize as _) };
#[doc = "DMA Main Registers"]
pub const DMA_MAIN: dma_main::DmaMain = unsafe { dma_main::DmaMain::from_ptr(0x4000_2400usize as _) };
#[doc = "DMA Channel 00 Registers"]
pub const DMA_CHAN00: dma_chan00::DmaChan00 = unsafe { dma_chan00::DmaChan00::from_ptr(0x4000_2440usize as _) };
#[doc = "DMA Channel 01 Registers"]
pub const DMA_CHAN01: dma_chan01::DmaChan01 = unsafe { dma_chan01::DmaChan01::from_ptr(0x4000_2480usize as _) };
#[doc = "DMA Channel 00 Registers"]
pub const DMA_CHAN02: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_24c0usize as _) };
pub const DMA_CHAN03: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2500usize as _) };
pub const DMA_CHAN04: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2540usize as _) };
pub const DMA_CHAN05: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2580usize as _) };
pub const DMA_CHAN06: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_25c0usize as _) };
pub const DMA_CHAN07: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2600usize as _) };
pub const DMA_CHAN08: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2640usize as _) };
pub const DMA_CHAN09: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2680usize as _) };
pub const DMA_CHAN10: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_26c0usize as _) };
pub const DMA_CHAN11: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2700usize as _) };
pub const DMA_CHAN12: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2740usize as _) };
pub const DMA_CHAN13: dma_chan02::DmaChan02 = unsafe { dma_chan02::DmaChan02::from_ptr(0x4000_2780usize as _) };
#[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
pub const SMB0: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4000usize as _) };
pub const SMB1: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4400usize as _) };
pub const SMB2: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4800usize as _) };
pub const SMB3: smb0::Smb0 = unsafe { smb0::Smb0::from_ptr(0x4000_4c00usize as _) };
#[doc = "The Quad SPI Master Controller may be used to communicate with various peripheral devices that use a Serial Peripheral Interface, such as EEPROMS, DACs and ADCs. The controller can be configured to support advanced SPI Flash devices with multi-phase access protocols."]
pub const QMSPI: qmspi::Qmspi = unsafe { qmspi::Qmspi::from_ptr(0x4000_5400usize as _) };
#[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz. The PWM controller can also used to generate the PROCHOT output and Speaker output."]
pub const PWM0: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5800usize as _) };
pub const PWM1: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5810usize as _) };
pub const PWM2: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5820usize as _) };
pub const PWM3: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5830usize as _) };
pub const PWM4: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5840usize as _) };
pub const PWM5: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_5850usize as _) };
pub const PWM10: pwm0::Pwm0 = unsafe { pwm0::Pwm0::from_ptr(0x4000_58a0usize as _) };
#[doc = "This block monitors TACH output signals (or locked rotor signals) from various types of fans, and determines their speed."]
pub const TACH0: tach0::Tach0 = unsafe { tach0::Tach0::from_ptr(0x4000_6000usize as _) };
pub const TACH1: tach0::Tach0 = unsafe { tach0::Tach0::from_ptr(0x4000_6010usize as _) };
#[doc = "The RTOS Timer is a low-power, 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states. This allows firmware the option to sleep the processor, enter heavy or deep chip sleep states, and wake after a programmed amount of time. The timer may be used as a one-shot timer or a continuous timer. When the timer transitions to 0 it is capable of generating a wake-capable interrupt to the embedded controller. This timer may be halted during debug by hardware or via a software control bit."]
pub const RTOS: rtos::Rtos = unsafe { rtos::Rtos::from_ptr(0x4000_7400usize as _) };
#[doc = "This block is designed to convert external analog voltage readings into digital values."]
pub const ADC: adc::Adc = unsafe { adc::Adc::from_ptr(0x4000_7c00usize as _) };
#[doc = "The TFDP serially transmits Embedded Controller (EC)-originated diagnostic vectors to an external debug trace system."]
pub const TFDP: tfdp::Tfdp = unsafe { tfdp::Tfdp::from_ptr(0x4000_8c00usize as _) };
#[doc = "The General Purpose Serial Peripheral Interface (GP-SPI) may be used to communicate with various peripheral devices, e.g., EEPROMS, DACs, ADCs, that use a standard Serial Peripheral Interface."]
pub const GP_SPI0: gp_spi0::GpSpi0 = unsafe { gp_spi0::GpSpi0::from_ptr(0x4000_9400usize as _) };
#[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode. This block supports wake events up to 2 hours in duration. The timer is a 16-bit binary count-down timer that can be programmed in 30.5us and 0.125 second increments for period ranges of 30.5us to 2s or 0.125s to 136.5 minutes, respectively."]
pub const HTM0: htm0::Htm0 = unsafe { htm0::Htm0::from_ptr(0x4000_9800usize as _) };
pub const HTM1: htm0::Htm0 = unsafe { htm0::Htm0::from_ptr(0x4000_9820usize as _) };
#[doc = "The Keyboard Scan Interface block provides a register interface to the EC to directly scan an external keyboard matrix of size up to 18x8."]
pub const KMS: kms::Kms = unsafe { kms::Kms::from_ptr(0x4000_9c00usize as _) };
#[doc = "The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors the fan's speed and automatically adjusts the drive to maintain the desired fan speed. This RPM based Fan Control Algorithm controls a PWM output based on a tachometer input."]
pub const FAN0: fan0::Fan0 = unsafe { fan0::Fan0::from_ptr(0x4000_a000usize as _) };
pub const FAN1: fan0::Fan0 = unsafe { fan0::Fan0::from_ptr(0x4000_a080usize as _) };
#[doc = "The VBAT Register Bank block is a block implemented for aggregating miscellaneous battery-backed registers required the host and by the Embedded Controller (EC) Subsystem that are not unique to a block implemented in the EC subsystem."]
pub const VBAT: vbat::Vbat = unsafe { vbat::Vbat::from_ptr(0x4000_a400usize as _) };
#[doc = "The VBAT Powered RAM provides a 128 Byte Random Accessed Memory that is operational while the main power rail is operational, and will retain its values powered by battery power while the main rail is unpowered."]
pub const VBAT_RAM: vbat_ram::VbatRam = unsafe { vbat_ram::VbatRam::from_ptr(0x4000_a800usize as _) };
#[doc = "The Week Alarm Interface provides two timekeeping functions: a Week Timer and a Sub-Week Timer. Both the Week Timer and the Sub-Week Timer assert the Power-Up Event Output which automatically powers-up the system from the G3 state."]
pub const WEEK: week::Week = unsafe { week::Week::from_ptr(0x4000_ac80usize as _) };
#[doc = "The VBAT-Powered Control Interface has VBAT-powered combinational logic and input and output signal pins. The block interfaces with the RTC With Date and DST Adjustment as well as the Week Alarm."]
pub const VCI: vci::Vci = unsafe { vci::Vci::from_ptr(0x4000_ae00usize as _) };
#[doc = "The blinking/breathing hardware is implemented using a PWM. The PWM can be driven either by the 48 MHz clock or by a 32.768 KHz clock input. When driven by the 48 MHz clock, the PWM can be used as a standard 8-bit PWM in order to control a fan. When used to drive blinking or breathing LEDs, the 32.768 KHz clock source is used."]
pub const LED0: led0::Led0 = unsafe { led0::Led0::from_ptr(0x4000_b800usize as _) };
pub const LED1: led0::Led0 = unsafe { led0::Led0::from_ptr(0x4000_b900usize as _) };
#[doc = "The interrupt generation logic is made of 16 groups of signals, each of which consist of a Status register, a Enable register and a Result register. The Status and Enable are latched registers. The Result register is a bit by bit AND function of the Source and Enable registers. All the bits of the Result register are OR'ed together and AND'ed with the corresponding bit in the Block Select register to form the interrupt signal that is routed to the ARM interrupt controller."]
pub const ECIA: ecia::Ecia = unsafe { ecia::Ecia::from_ptr(0x4000_e000usize as _) };
#[doc = "This block is designed to be accessed internally by the EC via the register interface."]
pub const EC_REG_BANK: ec_reg_bank::EcRegBank = unsafe { ec_reg_bank::EcRegBank::from_ptr(0x4000_fc04usize as _) };
#[doc = "The Power, Clocks, and Resets (PCR) Section identifies all the power supplies, clock sources, and reset inputs to the chip and defines all the derived power, clock, and reset signals."]
pub const PCR: pcr::Pcr = unsafe { pcr::Pcr::from_ptr(0x4008_0100usize as _) };
#[doc = "GPIO Pin Control Registers"]
pub const GPIO: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x4008_1000usize as _) };
#[doc = "The eFUSE block provides a means of programming and accessing the eFUSE bits."]
pub const EFUSE: efuse::Efuse = unsafe { efuse::Efuse::from_ptr(0x4008_2000usize as _) };
#[doc = "The 16550 UART (Universal Asynchronous Receiver/Transmitter) is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
pub const UART0: uart0::Uart0 = unsafe { uart0::Uart0::from_ptr(0x400f_2400usize as _) };
pub const UART1: uart0::Uart0 = unsafe { uart0::Uart0::from_ptr(0x400f_2800usize as _) };
#[doc = "This is the set of registers that are automatically counted by hardware every 1 second while the block is enabled to run and to update. These registers are: Seconds, Minutes, Hours, Day of Week, Day of Month, Month, and Year."]
pub const RTC: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x400f_5000usize as _) };
#[doc = "The Logical Device Configuration registers support motherboard designs in which the resources required by their components are known and assigned by the BIOS at POST."]
pub const GCR: gcr::Gcr = unsafe { gcr::Gcr::from_ptr(0x400f_ff00usize as _) };
#[doc = "Memory Protection Unit Registers"]
pub const MPU: mpu::Mpu = unsafe { mpu::Mpu::from_ptr(0xe000_ed90usize as _) };
#[doc = r" Number available in the NVIC for configuring priority"]
#[cfg(feature = "rt")]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
pub use Interrupt as interrupt;
#[doc = "Pin buffer drive type."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum BufferType {
    #[doc = "Output buffer type is Open-drain."]
    PUSH_PULL = 0x0,
    #[doc = "Output buffer type is Push-pull."]
    OPEN_DRAIN = 0x01,
}
impl BufferType {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> BufferType {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for BufferType {
    #[inline(always)]
    fn from(val: u8) -> BufferType {
        BufferType::from_bits(val)
    }
}
impl From<BufferType> for u8 {
    #[inline(always)]
    fn from(val: BufferType) -> u8 {
        BufferType::to_bits(val)
    }
}
#[doc = "Pin direction."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Dir {
    #[doc = "Input GPIO."]
    INPUT = 0x0,
    #[doc = "Output GPIO."]
    OUTPUT = 0x01,
}
impl Dir {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Dir {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Dir {
    #[inline(always)]
    fn from(val: u8) -> Dir {
        Dir::from_bits(val)
    }
}
impl From<Dir> for u8 {
    #[inline(always)]
    fn from(val: Dir) -> u8 {
        Dir::to_bits(val)
    }
}
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Function {
    #[doc = "GPIO function selected."]
    GPIO = 0x0,
    #[doc = "Function 1 selected."]
    F1 = 0x01,
    #[doc = "Function 2 selected."]
    F2 = 0x02,
    #[doc = "Function 3 selected."]
    F3 = 0x03,
    #[doc = "Function 4 selected."]
    F4 = 0x04,
    #[doc = "Function 5 selected."]
    F5 = 0x05,
    _RESERVED_6 = 0x06,
    _RESERVED_7 = 0x07,
}
impl Function {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Function {
        unsafe { core::mem::transmute(val & 0x07) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Function {
    #[inline(always)]
    fn from(val: u8) -> Function {
        Function::from_bits(val)
    }
}
impl From<Function> for u8 {
    #[inline(always)]
    fn from(val: Function) -> u8 {
        Function::to_bits(val)
    }
}
#[doc = "Power Gating Signals provide the chip Power Emulation options."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Pgs {
    #[doc = "The output buffer is tristated when VTR_PWRGD=0."]
    VTR = 0x0,
    #[doc = "The output buffer is tristated when VCC_PWRGD=0."]
    VCC = 0x01,
    #[doc = "The always unpowered setting on a GPIO will force the pin to tristate. The input and output are disabled, and the pad is in the lowest power state."]
    UNPOWERED = 0x02,
    _RESERVED_3 = 0x03,
}
impl Pgs {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Pgs {
        unsafe { core::mem::transmute(val & 0x03) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Pgs {
    #[inline(always)]
    fn from(val: u8) -> Pgs {
        Pgs::from_bits(val)
    }
}
impl From<Pgs> for u8 {
    #[inline(always)]
    fn from(val: Pgs) -> u8 {
        Pgs::to_bits(val)
    }
}
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Pol {
    #[doc = "Non-inverted polarity."]
    NON_INVERTED = 0x0,
    #[doc = "Inverted polarity."]
    INVERTED = 0x01,
}
impl Pol {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Pol {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Pol {
    #[inline(always)]
    fn from(val: u8) -> Pol {
        Pol::from_bits(val)
    }
}
impl From<Pol> for u8 {
    #[inline(always)]
    fn from(val: Pol) -> u8 {
        Pol::to_bits(val)
    }
}
#[doc = "Configure internal pull-up and pull-down resistors."]
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Pull {
    #[doc = "Pin tristates when no active driver is present on the pin."]
    NONE = 0x0,
    #[doc = "Pull up enabled."]
    UP = 0x01,
    #[doc = "Pull down enabled."]
    DOWN = 0x02,
    #[doc = "Pin is kept at previous voltage level when no active driver is present on the pin."]
    REPEATER = 0x03,
}
impl Pull {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Pull {
        unsafe { core::mem::transmute(val & 0x03) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Pull {
    #[inline(always)]
    fn from(val: u8) -> Pull {
        Pull::from_bits(val)
    }
}
impl From<Pull> for u8 {
    #[inline(always)]
    fn from(val: Pull) -> u8 {
        Pull::to_bits(val)
    }
}
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Sel {
    #[doc = "Single GPIO output data bit is enabled."]
    PIN = 0x0,
    #[doc = "Grouped Output GPIO is enabled."]
    GROUP = 0x01,
}
impl Sel {
    #[inline(always)]
    pub const fn from_bits(val: u8) -> Sel {
        unsafe { core::mem::transmute(val & 0x01) }
    }
    #[inline(always)]
    pub const fn to_bits(self) -> u8 {
        unsafe { core::mem::transmute(self) }
    }
}
impl From<u8> for Sel {
    #[inline(always)]
    fn from(val: u8) -> Sel {
        Sel::from_bits(val)
    }
}
impl From<Sel> for u8 {
    #[inline(always)]
    fn from(val: Sel) -> u8 {
        Sel::to_bits(val)
    }
}
pub mod adc {
    #[doc = "This block is designed to convert external analog voltage readings into digital values."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Adc {
        ptr: *mut u8,
    }
    unsafe impl Send for Adc {}
    unsafe impl Sync for Adc {}
    impl Adc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The ADC Control Register is used to control the behavior of the Analog to Digital Converter."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "The ADC Delay register determines the delay from setting Start_Repeat in the ADC Control Register and the start of a conversion cycle. This register also controls the interval between conversion cycles in repeat mode."]
        #[inline(always)]
        pub const fn delay(self) -> crate::common::Reg<regs::Delay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The ADC Status Register indicates whether the ADC has completed a conversion cycle. All bits are cleared by being written with a 1. 0: conversion of the corresponding ADC channel is not complete 1: conversion of the corresponding ADC channel is complete"]
        #[inline(always)]
        pub const fn chan_sts(self) -> crate::common::Reg<regs::ChanSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "The ADC Single Register is used to control which ADC channel is captured during a Single-Sample conversion cycle initiated by the Start_Single bit in the ADC Control Register. APPLICATION NOTE: Do not change the bits in this register in the middle of a conversion cycle to insure proper operation. 0: single cycle conversions for this channel are disabled 1: single cycle conversions for this channel are enabled"]
        #[inline(always)]
        pub const fn sng_en(self) -> crate::common::Reg<regs::SngEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "The ADC Repeat Register is used to control which ADC channels are captured during a repeat conversion cycle initiated by the Start_Repeat bit in the ADC Control Register."]
        #[inline(always)]
        pub const fn rept_en(self) -> crate::common::Reg<regs::ReptEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "All 16 ADC channels return their results into a 32-bit reading register. In each case the low 10 bits of the reading register return the result of the Analog to Digital conversion and the upper 22 bits return 0."]
        #[inline(always)]
        pub const fn chan_rd(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "The ADC Status Register indicates whether the ADC has completed a conversion cycle. All bits are cleared by being written with a 1. 0: conversion of the corresponding ADC channel is not complete 1: conversion of the corresponding ADC channel is complete"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ChanSts(pub u32);
        impl ChanSts {
            #[doc = "All bits are cleared by being written with a '1'. 1=conversion of the corresponding ADC channel is complete; 0=conversion of the corresponding ADC channel is not complete. For enabled single cycles, the SINGLE_DONE_STATUS bit in the ADC Control Register is also set after all enabled channel conversion are done; for enabled repeat cycles, the REPEAT_DONE_STATUS in the ADC Control Register is also set after all enabled channel conversion are done."]
            #[inline(always)]
            pub const fn sts(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "All bits are cleared by being written with a '1'. 1=conversion of the corresponding ADC channel is complete; 0=conversion of the corresponding ADC channel is not complete. For enabled single cycles, the SINGLE_DONE_STATUS bit in the ADC Control Register is also set after all enabled channel conversion are done; for enabled repeat cycles, the REPEAT_DONE_STATUS in the ADC Control Register is also set after all enabled channel conversion are done."]
            #[inline(always)]
            pub fn set_sts(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for ChanSts {
            #[inline(always)]
            fn default() -> ChanSts {
                ChanSts(0)
            }
        }
        impl core::fmt::Debug for ChanSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ChanSts").field("sts", &self.sts()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ChanSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ChanSts {{ sts: {=u16:?} }}", self.sts())
            }
        }
        #[doc = "The ADC Control Register is used to control the behavior of the Analog to Digital Converter."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "0: The ADC is disabled and placed in its lowest power state. 1: ADC block is enabled for operation."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "0: The ADC is disabled and placed in its lowest power state. 1: ADC block is enabled for operation."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "(STRT_SIN) 0: The ADC Single Mode is disabled. 1: The ADC Single Mode is enabled. Note: This bit is self-clearing"]
            #[inline(always)]
            pub const fn strt_sin(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "(STRT_SIN) 0: The ADC Single Mode is disabled. 1: The ADC Single Mode is enabled. Note: This bit is self-clearing"]
            #[inline(always)]
            pub fn set_strt_sin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "0: The ADC Repeat Mode is disabled. 1: The ADC Repeat Mode is enabled."]
            #[inline(always)]
            pub const fn strt_rpt(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "0: The ADC Repeat Mode is disabled. 1: The ADC Repeat Mode is enabled."]
            #[inline(always)]
            pub fn set_strt_rpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "0: Power saving feature is enabled. 1: Power saving feature is disabled."]
            #[inline(always)]
            pub const fn pwr_sav_dis(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "0: Power saving feature is enabled. 1: Power saving feature is disabled."]
            #[inline(always)]
            pub fn set_pwr_sav_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "(SFT_RST) 1: writing one causes a reset of the ADC block hardware (not the registers) 0: writing zero takes the ADC block out of reset"]
            #[inline(always)]
            pub const fn sft_rst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "(SFT_RST) 1: writing one causes a reset of the ADC block hardware (not the registers) 0: writing zero takes the ADC block out of reset"]
            #[inline(always)]
            pub fn set_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "0: ADC repeat-sample conversion is not complete. 1: ADC repeat-sample conversion is completed. (R/WC)"]
            #[inline(always)]
            pub const fn rpt_done_sts(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "0: ADC repeat-sample conversion is not complete. 1: ADC repeat-sample conversion is completed. (R/WC)"]
            #[inline(always)]
            pub fn set_rpt_done_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "0: ADC single-sample conversion is not complete. 1: ADC single-sample conversion is completed. (R/WC)"]
            #[inline(always)]
            pub const fn sin_done_sts(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "0: ADC single-sample conversion is not complete. 1: ADC single-sample conversion is completed. (R/WC)"]
            #[inline(always)]
            pub fn set_sin_done_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("act", &self.act())
                    .field("strt_sin", &self.strt_sin())
                    .field("strt_rpt", &self.strt_rpt())
                    .field("pwr_sav_dis", &self.pwr_sav_dis())
                    .field("sft_rst", &self.sft_rst())
                    .field("rpt_done_sts", &self.rpt_done_sts())
                    .field("sin_done_sts", &self.sin_done_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ act: {=bool:?}, strt_sin: {=bool:?}, strt_rpt: {=bool:?}, pwr_sav_dis: {=bool:?}, sft_rst: {=bool:?}, rpt_done_sts: {=bool:?}, sin_done_sts: {=bool:?} }}" , self . act () , self . strt_sin () , self . strt_rpt () , self . pwr_sav_dis () , self . sft_rst () , self . rpt_done_sts () , self . sin_done_sts ())
            }
        }
        #[doc = "The ADC Delay register determines the delay from setting Start_Repeat in the ADC Control Register and the start of a conversion cycle. This register also controls the interval between conversion cycles in repeat mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Delay(pub u32);
        impl Delay {
            #[doc = "This field determines the starting delay before a conversion cycle is begun when Start_Repeat is written with a 1."]
            #[inline(always)]
            pub const fn strt_dly(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This field determines the starting delay before a conversion cycle is begun when Start_Repeat is written with a 1."]
            #[inline(always)]
            pub fn set_strt_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "This field determines the interval between conversion cycles when Start_Repeat is 1."]
            #[inline(always)]
            pub const fn rpt_dly(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This field determines the interval between conversion cycles when Start_Repeat is 1."]
            #[inline(always)]
            pub fn set_rpt_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Delay {
            #[inline(always)]
            fn default() -> Delay {
                Delay(0)
            }
        }
        impl core::fmt::Debug for Delay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Delay")
                    .field("strt_dly", &self.strt_dly())
                    .field("rpt_dly", &self.rpt_dly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Delay {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Delay {{ strt_dly: {=u16:?}, rpt_dly: {=u16:?} }}",
                    self.strt_dly(),
                    self.rpt_dly()
                )
            }
        }
        #[doc = "The ADC Repeat Register is used to control which ADC channels are captured during a repeat conversion cycle initiated by the Start_Repeat bit in the ADC Control Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ReptEn(pub u32);
        impl ReptEn {
            #[doc = "Each bit in this field enables the corresponding ADC channel for each pass of the Repeated ADC Conversion that is controlled by bit START_REPEAT in the ADC Control Register. 1=repeat conversions for this channel are enabled; 0=repeat conversions for this channel are disabled"]
            #[inline(always)]
            pub const fn r_en(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Each bit in this field enables the corresponding ADC channel for each pass of the Repeated ADC Conversion that is controlled by bit START_REPEAT in the ADC Control Register. 1=repeat conversions for this channel are enabled; 0=repeat conversions for this channel are disabled"]
            #[inline(always)]
            pub fn set_r_en(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for ReptEn {
            #[inline(always)]
            fn default() -> ReptEn {
                ReptEn(0)
            }
        }
        impl core::fmt::Debug for ReptEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ReptEn").field("r_en", &self.r_en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ReptEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ReptEn {{ r_en: {=u16:?} }}", self.r_en())
            }
        }
        #[doc = "The ADC Single Register is used to control which ADC channel is captured during a Single-Sample conversion cycle initiated by the Start_Single bit in the ADC Control Register. APPLICATION NOTE: Do not change the bits in this register in the middle of a conversion cycle to insure proper operation. 0: single cycle conversions for this channel are disabled 1: single cycle conversions for this channel are enabled"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SngEn(pub u32);
        impl SngEn {
            #[doc = "Each bit in this field enables the corresponding ADC channel when a single cycle of conversions is started when the START_SINGLE bit in the ADC Control Register is written with a 1. 1=single cycle conversions for this channel are enabled 0=single cycle conversions for this channel are disabled. Note: If this register is changed while a conversion."]
            #[inline(always)]
            pub const fn s_en(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Each bit in this field enables the corresponding ADC channel when a single cycle of conversions is started when the START_SINGLE bit in the ADC Control Register is written with a 1. 1=single cycle conversions for this channel are enabled 0=single cycle conversions for this channel are disabled. Note: If this register is changed while a conversion."]
            #[inline(always)]
            pub fn set_s_en(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for SngEn {
            #[inline(always)]
            fn default() -> SngEn {
                SngEn(0)
            }
        }
        impl core::fmt::Debug for SngEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SngEn").field("s_en", &self.s_en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SngEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SngEn {{ s_en: {=u16:?} }}", self.s_en())
            }
        }
    }
}
pub mod cct {
    #[doc = "This is a 16-bit auto-reloading timer/counter."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cct {
        ptr: *mut u8,
    }
    unsafe impl Send for Cct {}
    unsafe impl Sync for Cct {}
    impl Cct {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This register controls the capture and compare timer."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This register is used to configure capture and compare timers 0-3."]
        #[inline(always)]
        pub const fn cap0_ctrl(self) -> crate::common::Reg<regs::Cap0ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This register is used to configure capture and compare timers 4-5."]
        #[inline(always)]
        pub const fn cap1_ctrl(self) -> crate::common::Reg<regs::Cap1ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This register contains the current value of the Free Running Timer."]
        #[inline(always)]
        pub const fn free_run(self) -> crate::common::Reg<regs::FreeRun, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[inline(always)]
        pub const fn cap0(self) -> crate::common::Reg<regs::Cap0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
        #[inline(always)]
        pub const fn cap1(self) -> crate::common::Reg<regs::Cap1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[inline(always)]
        pub const fn cap2(self) -> crate::common::Reg<regs::Cap2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[inline(always)]
        pub const fn cap3(self) -> crate::common::Reg<regs::Cap3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
        #[inline(always)]
        pub const fn cap4(self) -> crate::common::Reg<regs::Cap4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
        #[inline(always)]
        pub const fn cap5(self) -> crate::common::Reg<regs::Cap5, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[inline(always)]
        pub const fn comp0(self) -> crate::common::Reg<regs::Comp0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[inline(always)]
        pub const fn comp1(self) -> crate::common::Reg<regs::Comp1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap0(pub u32);
        impl Cap0 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
            #[inline(always)]
            pub const fn cap_0(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
            #[inline(always)]
            pub fn set_cap_0(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap0 {
            #[inline(always)]
            fn default() -> Cap0 {
                Cap0(0)
            }
        }
        impl core::fmt::Debug for Cap0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap0").field("cap_0", &self.cap_0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap0 {{ cap_0: {=u32:?} }}", self.cap_0())
            }
        }
        #[doc = "This register is used to configure capture and compare timers 0-3."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap0ctrl(pub u32);
        impl Cap0ctrl {
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 0."]
            #[inline(always)]
            pub const fn cap_edge0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 0."]
            #[inline(always)]
            pub fn set_cap_edge0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 0, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp0(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 0, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 0."]
            #[inline(always)]
            pub const fn fclk_sel0(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 0."]
            #[inline(always)]
            pub fn set_fclk_sel0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u32) & 0x07) << 5usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 1."]
            #[inline(always)]
            pub const fn cap_edge1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 1."]
            #[inline(always)]
            pub fn set_cap_edge1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 1, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp1(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 1, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 1."]
            #[inline(always)]
            pub const fn fclk_sel1(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 1."]
            #[inline(always)]
            pub fn set_fclk_sel1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val as u32) & 0x07) << 13usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 2."]
            #[inline(always)]
            pub const fn cap_edge2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 2."]
            #[inline(always)]
            pub fn set_cap_edge2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 16usize)) | (((val as u32) & 0x03) << 16usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 2, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 2, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 2."]
            #[inline(always)]
            pub const fn fclk_sel2(&self) -> u8 {
                let val = (self.0 >> 21usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 2."]
            #[inline(always)]
            pub fn set_fclk_sel2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 21usize)) | (((val as u32) & 0x07) << 21usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 3."]
            #[inline(always)]
            pub const fn cap_edge3(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 3."]
            #[inline(always)]
            pub fn set_cap_edge3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 3, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp3(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 3, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 3."]
            #[inline(always)]
            pub const fn fclk_sel3(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 3."]
            #[inline(always)]
            pub fn set_fclk_sel3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 29usize)) | (((val as u32) & 0x07) << 29usize);
            }
        }
        impl Default for Cap0ctrl {
            #[inline(always)]
            fn default() -> Cap0ctrl {
                Cap0ctrl(0)
            }
        }
        impl core::fmt::Debug for Cap0ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap0ctrl")
                    .field("cap_edge0", &self.cap_edge0())
                    .field("filter_byp0", &self.filter_byp0())
                    .field("fclk_sel0", &self.fclk_sel0())
                    .field("cap_edge1", &self.cap_edge1())
                    .field("filter_byp1", &self.filter_byp1())
                    .field("fclk_sel1", &self.fclk_sel1())
                    .field("cap_edge2", &self.cap_edge2())
                    .field("filter_byp2", &self.filter_byp2())
                    .field("fclk_sel2", &self.fclk_sel2())
                    .field("cap_edge3", &self.cap_edge3())
                    .field("filter_byp3", &self.filter_byp3())
                    .field("fclk_sel3", &self.fclk_sel3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap0ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cap0ctrl {{ cap_edge0: {=u8:?}, filter_byp0: {=bool:?}, fclk_sel0: {=u8:?}, cap_edge1: {=u8:?}, filter_byp1: {=bool:?}, fclk_sel1: {=u8:?}, cap_edge2: {=u8:?}, filter_byp2: {=bool:?}, fclk_sel2: {=u8:?}, cap_edge3: {=u8:?}, filter_byp3: {=bool:?}, fclk_sel3: {=u8:?} }}" , self . cap_edge0 () , self . filter_byp0 () , self . fclk_sel0 () , self . cap_edge1 () , self . filter_byp1 () , self . fclk_sel1 () , self . cap_edge2 () , self . filter_byp2 () , self . fclk_sel2 () , self . cap_edge3 () , self . filter_byp3 () , self . fclk_sel3 ())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap1(pub u32);
        impl Cap1 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
            #[inline(always)]
            pub const fn cap_1(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT1."]
            #[inline(always)]
            pub fn set_cap_1(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap1 {
            #[inline(always)]
            fn default() -> Cap1 {
                Cap1(0)
            }
        }
        impl core::fmt::Debug for Cap1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap1").field("cap_1", &self.cap_1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap1 {{ cap_1: {=u32:?} }}", self.cap_1())
            }
        }
        #[doc = "This register is used to configure capture and compare timers 4-5."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap1ctrl(pub u32);
        impl Cap1ctrl {
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 4."]
            #[inline(always)]
            pub const fn cap_edge4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 4."]
            #[inline(always)]
            pub fn set_cap_edge4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 4, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp4(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 4, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 4."]
            #[inline(always)]
            pub const fn fclk_sel4(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 4."]
            #[inline(always)]
            pub fn set_fclk_sel4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u32) & 0x07) << 5usize);
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 5."]
            #[inline(always)]
            pub const fn cap_edge5(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 5."]
            #[inline(always)]
            pub fn set_cap_edge5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 5, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub const fn filter_byp5(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables bypassing the input noise filter for Capture Register 5, so that the input signal goes directly into the timer."]
            #[inline(always)]
            pub fn set_filter_byp5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 5."]
            #[inline(always)]
            pub const fn fclk_sel5(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the input filter for Capture Register 5."]
            #[inline(always)]
            pub fn set_fclk_sel5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 13usize)) | (((val as u32) & 0x07) << 13usize);
            }
        }
        impl Default for Cap1ctrl {
            #[inline(always)]
            fn default() -> Cap1ctrl {
                Cap1ctrl(0)
            }
        }
        impl core::fmt::Debug for Cap1ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap1ctrl")
                    .field("cap_edge4", &self.cap_edge4())
                    .field("filter_byp4", &self.filter_byp4())
                    .field("fclk_sel4", &self.fclk_sel4())
                    .field("cap_edge5", &self.cap_edge5())
                    .field("filter_byp5", &self.filter_byp5())
                    .field("fclk_sel5", &self.fclk_sel5())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap1ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cap1ctrl {{ cap_edge4: {=u8:?}, filter_byp4: {=bool:?}, fclk_sel4: {=u8:?}, cap_edge5: {=u8:?}, filter_byp5: {=bool:?}, fclk_sel5: {=u8:?} }}" , self . cap_edge4 () , self . filter_byp4 () , self . fclk_sel4 () , self . cap_edge5 () , self . filter_byp5 () , self . fclk_sel5 ())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap2(pub u32);
        impl Cap2 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT2."]
            #[inline(always)]
            pub const fn cap_2(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT2."]
            #[inline(always)]
            pub fn set_cap_2(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap2 {
            #[inline(always)]
            fn default() -> Cap2 {
                Cap2(0)
            }
        }
        impl core::fmt::Debug for Cap2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap2").field("cap_2", &self.cap_2()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap2 {{ cap_2: {=u32:?} }}", self.cap_2())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap3(pub u32);
        impl Cap3 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT3."]
            #[inline(always)]
            pub const fn cap_3(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT3."]
            #[inline(always)]
            pub fn set_cap_3(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap3 {
            #[inline(always)]
            fn default() -> Cap3 {
                Cap3(0)
            }
        }
        impl core::fmt::Debug for Cap3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap3").field("cap_3", &self.cap_3()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap3 {{ cap_3: {=u32:?} }}", self.cap_3())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap4(pub u32);
        impl Cap4 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
            #[inline(always)]
            pub const fn cap_4(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT4."]
            #[inline(always)]
            pub fn set_cap_4(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap4 {
            #[inline(always)]
            fn default() -> Cap4 {
                Cap4(0)
            }
        }
        impl core::fmt::Debug for Cap4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap4").field("cap_4", &self.cap_4()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap4 {{ cap_4: {=u32:?} }}", self.cap_4())
            }
        }
        #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap5(pub u32);
        impl Cap5 {
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
            #[inline(always)]
            pub const fn cap_5(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register saves the value copied from the Free Running timer on a programmed edge of ICT5."]
            #[inline(always)]
            pub fn set_cap_5(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cap5 {
            #[inline(always)]
            fn default() -> Cap5 {
                Cap5(0)
            }
        }
        impl core::fmt::Debug for Cap5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap5").field("cap_5", &self.cap_5()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap5 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap5 {{ cap_5: {=u32:?} }}", self.cap_5())
            }
        }
        #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Comp0(pub u32);
        impl Comp0 {
            #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub const fn comp_0(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub fn set_comp_0(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Comp0 {
            #[inline(always)]
            fn default() -> Comp0 {
                Comp0(0)
            }
        }
        impl core::fmt::Debug for Comp0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Comp0").field("comp_0", &self.comp_0()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Comp0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Comp0 {{ comp_0: {=u32:?} }}", self.comp_0())
            }
        }
        #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Comp1(pub u32);
        impl Comp1 {
            #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub const fn comp_1(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer."]
            #[inline(always)]
            pub fn set_comp_1(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Comp1 {
            #[inline(always)]
            fn default() -> Comp1 {
                Comp1(0)
            }
        }
        impl core::fmt::Debug for Comp1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Comp1").field("comp_1", &self.comp_1()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Comp1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Comp1 {{ comp_1: {=u32:?} }}", self.comp_1())
            }
        }
        #[doc = "This register controls the capture and compare timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This bit is used to start the capture and compare timer running and power it down."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to start the capture and compare timer running and power it down."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Free-Running Timer Enable. This bit is used to start and stop the free running timer."]
            #[inline(always)]
            pub const fn free_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Free-Running Timer Enable. This bit is used to start and stop the free running timer."]
            #[inline(always)]
            pub fn set_free_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Free Running Timer Reset. This bit stops the timer and resets the internal counter to 0000_0000h."]
            #[inline(always)]
            pub const fn free_rst(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Free Running Timer Reset. This bit stops the timer and resets the internal counter to 0000_0000h."]
            #[inline(always)]
            pub fn set_free_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This 3-bit field sets the clock source for the Free-Running Counter."]
            #[inline(always)]
            pub const fn tclk(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "This 3-bit field sets the clock source for the Free-Running Counter."]
            #[inline(always)]
            pub fn set_tclk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
            }
            #[doc = "Compare Enable for Compare 0 Register."]
            #[inline(always)]
            pub const fn cmp_en0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Compare Enable for Compare 0 Register."]
            #[inline(always)]
            pub fn set_cmp_en0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Compare Enable for Compare 1 Register."]
            #[inline(always)]
            pub const fn cmp_en1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Compare Enable for Compare 1 Register."]
            #[inline(always)]
            pub fn set_cmp_en1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub const fn cmp_set1(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub fn set_cmp_set1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub const fn cmp_set0(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub fn set_cmp_set0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub const fn cmp_clr1(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 1 state."]
            #[inline(always)]
            pub fn set_cmp_clr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub const fn cmp_clr0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "When read, returns the current value off the Compare Timer Output 0 state."]
            #[inline(always)]
            pub fn set_cmp_clr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("act", &self.act())
                    .field("free_en", &self.free_en())
                    .field("free_rst", &self.free_rst())
                    .field("tclk", &self.tclk())
                    .field("cmp_en0", &self.cmp_en0())
                    .field("cmp_en1", &self.cmp_en1())
                    .field("cmp_set1", &self.cmp_set1())
                    .field("cmp_set0", &self.cmp_set0())
                    .field("cmp_clr1", &self.cmp_clr1())
                    .field("cmp_clr0", &self.cmp_clr0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ act: {=bool:?}, free_en: {=bool:?}, free_rst: {=bool:?}, tclk: {=u8:?}, cmp_en0: {=bool:?}, cmp_en1: {=bool:?}, cmp_set1: {=bool:?}, cmp_set0: {=bool:?}, cmp_clr1: {=bool:?}, cmp_clr0: {=bool:?} }}" , self . act () , self . free_en () , self . free_rst () , self . tclk () , self . cmp_en0 () , self . cmp_en1 () , self . cmp_set1 () , self . cmp_set0 () , self . cmp_clr1 () , self . cmp_clr0 ())
            }
        }
        #[doc = "This register contains the current value of the Free Running Timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FreeRun(pub u32);
        impl FreeRun {
            #[doc = "This register contains the current value of the Free Running Timer."]
            #[inline(always)]
            pub const fn tmr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register contains the current value of the Free Running Timer."]
            #[inline(always)]
            pub fn set_tmr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FreeRun {
            #[inline(always)]
            fn default() -> FreeRun {
                FreeRun(0)
            }
        }
        impl core::fmt::Debug for FreeRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FreeRun").field("tmr", &self.tmr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FreeRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FreeRun {{ tmr: {=u32:?} }}", self.tmr())
            }
        }
    }
}
pub mod cnt_tmr0 {
    #[doc = "This interface is a 16-bit auto-reloading timer/counter."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CntTmr0 {
        ptr: *mut u8,
    }
    unsafe impl Send for CntTmr0 {}
    unsafe impl Sync for CntTmr0 {}
    impl CntTmr0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This bit reflects the current state of the timer's Clock_Required output signal."]
        #[inline(always)]
        pub const fn timerx_ctrl(self) -> crate::common::Reg<regs::TimerxCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the value of the Timer pre-load for the counter. This is used by H/W when the counter is to be restarted automatically; this will become the new value of the counter upon restart."]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<regs::Prld, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This register is used in Timer and One-Shot modes to set the lower limit of the timer."]
        #[inline(always)]
        pub const fn timerx_rld(self) -> crate::common::Reg<regs::TimerxRld, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This register returns the current value of the timer in all modes."]
        #[inline(always)]
        pub const fn timerx_cnt(self) -> crate::common::Reg<regs::TimerxCnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This is the value of the Timer pre-load for the counter. This is used by H/W when the counter is to be restarted automatically; this will become the new value of the counter upon restart."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prld(pub u32);
        impl Prld {
            #[doc = "Timer Clock Select. This field determines the clock source for the 16-bit counter in the timer."]
            #[inline(always)]
            pub const fn tclk(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Timer Clock Select. This field determines the clock source for the 16-bit counter in the timer."]
            #[inline(always)]
            pub fn set_tclk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "This field selects which edge of the TINx input signal affects the timer in Event Mode, One-Shot Mode and Measurement Mode. Event Mode: 11b=No event selected; 10b=Counts rising and falling edges; 01b=Counts rising edges; 00b=Counts falling edges. One-Shot Mode: 11b=Start counting when the Enable bit is set; 10b=Starts counting on a rising or falling edge; 01b=Starts counting on a rising edge; 00b=Starts counting on a falling edge. Measurement Mode: 11b=No event selected; 10b=Measures the time between rising edges and falling edges and the time between falling edges and rising edges; 01b=Measures the time between rising edges; 00b=Measures the time between falling edges."]
            #[inline(always)]
            pub const fn edge(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects which edge of the TINx input signal affects the timer in Event Mode, One-Shot Mode and Measurement Mode. Event Mode: 11b=No event selected; 10b=Counts rising and falling edges; 01b=Counts rising edges; 00b=Counts falling edges. One-Shot Mode: 11b=Start counting when the Enable bit is set; 10b=Starts counting on a rising or falling edge; 01b=Starts counting on a rising edge; 00b=Starts counting on a falling edge. Measurement Mode: 11b=No event selected; 10b=Measures the time between rising edges and falling edges and the time between falling edges and rising edges; 01b=Measures the time between rising edges; 00b=Measures the time between falling edges."]
            #[inline(always)]
            pub fn set_edge(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize);
            }
            #[doc = "Event Select. This bit is used to select the count source when the timer is operating in Event Mode. 1=TINx is count source; 0=Timer x-1 overflow is count source."]
            #[inline(always)]
            pub const fn event(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Event Select. This bit is used to select the count source when the timer is operating in Event Mode. 1=TINx is count source; 0=Timer x-1 overflow is count source."]
            #[inline(always)]
            pub fn set_event(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Timer Clock Select. This field determines the clock source for the TINx noise filter. The available frequencies are the same as for TCLK."]
            #[inline(always)]
            pub const fn fclk(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Timer Clock Select. This field determines the clock source for the TINx noise filter. The available frequencies are the same as for TCLK."]
            #[inline(always)]
            pub fn set_fclk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Prld {
            #[inline(always)]
            fn default() -> Prld {
                Prld(0)
            }
        }
        impl core::fmt::Debug for Prld {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prld")
                    .field("tclk", &self.tclk())
                    .field("edge", &self.edge())
                    .field("event", &self.event())
                    .field("fclk", &self.fclk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prld {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Prld {{ tclk: {=u8:?}, edge: {=u8:?}, event: {=bool:?}, fclk: {=u8:?} }}",
                    self.tclk(),
                    self.edge(),
                    self.event(),
                    self.fclk()
                )
            }
        }
        #[doc = "This register returns the current value of the timer in all modes."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TimerxCnt(pub u32);
        impl TimerxCnt {
            #[doc = "This is the current value of the timer in all modes."]
            #[inline(always)]
            pub const fn tmr_cnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is the current value of the timer in all modes."]
            #[inline(always)]
            pub fn set_tmr_cnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TimerxCnt {
            #[inline(always)]
            fn default() -> TimerxCnt {
                TimerxCnt(0)
            }
        }
        impl core::fmt::Debug for TimerxCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TimerxCnt").field("tmr_cnt", &self.tmr_cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TimerxCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TimerxCnt {{ tmr_cnt: {=u16:?} }}", self.tmr_cnt())
            }
        }
        #[doc = "This bit reflects the current state of the timer's Clock_Required output signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TimerxCtrl(pub u32);
        impl TimerxCtrl {
            #[doc = "This bit is used to start and stop the timer. This bit does not reset the timer count but does reset the timer pulse output. This bit will be cleared when the timer stops counting in One-Shot mode. The ENABLE bit is cleared after a RESET cycle has completed. Firmware must poll the RESET bit in order to determine when the timer is active after reset. 1=Timer is enabled; 0=Timer is disabled."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to start and stop the timer. This bit does not reset the timer count but does reset the timer pulse output. This bit will be cleared when the timer stops counting in One-Shot mode. The ENABLE bit is cleared after a RESET cycle has completed. Firmware must poll the RESET bit in order to determine when the timer is active after reset. 1=Timer is enabled; 0=Timer is disabled."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit stops the timer and resets the internal counter to the value in the Timer Reload Register. This bit also clears the ENABLE bit if it is set. This bit is self-clearing after the timer is reset. Firmware must poll the RESET bit in order to determine when the timer is active after reset. Interrupts are blocked only when RESET takes effect and the ENABLE bit is cleared. If interrupts are not desired, firmware must mask the interrupt in the interrupt block. 1=Timer reset; 0=Normal timer operation."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit stops the timer and resets the internal counter to the value in the Timer Reload Register. This bit also clears the ENABLE bit if it is set. This bit is self-clearing after the timer is reset. Firmware must poll the RESET bit in order to determine when the timer is active after reset. Interrupts are blocked only when RESET takes effect and the ENABLE bit is cleared. If interrupts are not desired, firmware must mask the interrupt in the interrupt block. 1=Timer reset; 0=Normal timer operation."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Timer Mode. 3=Measurement Mode; 2=One Shot Mode; 1=Event Mode; 0=Timer Mode."]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Timer Mode. 3=Measurement Mode; 2=One Shot Mode; 1=Event Mode; 0=Timer Mode."]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "This bit selects the polarity of the TINx input. 1=TINx is active low; 0=TINx is active high."]
            #[inline(always)]
            pub const fn inpol(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects the polarity of the TINx input. 1=TINx is active low; 0=TINx is active high."]
            #[inline(always)]
            pub fn set_inpol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "In Event Mode, this bit selects the timer count direction. In Timer Mode enables timer control by the TINx input pin. Event Mode: 1=The timer counts up; 0=The timer counts down. Timer Mode:; 1=TINx pin pauses the timer when de-asserted; 0=TINx pin has no effect on the timer."]
            #[inline(always)]
            pub const fn updn(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "In Event Mode, this bit selects the timer count direction. In Timer Mode enables timer control by the TINx input pin. Event Mode: 1=The timer counts up; 0=The timer counts down. Timer Mode:; 1=TINx pin pauses the timer when de-asserted; 0=TINx pin has no effect on the timer."]
            #[inline(always)]
            pub fn set_updn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit enables the TOUTx pin. 1=TOUTx pin function is enabled; 0=TOUTx pin is inactive."]
            #[inline(always)]
            pub const fn tout_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the TOUTx pin. 1=TOUTx pin function is enabled; 0=TOUTx pin is inactive."]
            #[inline(always)]
            pub fn set_tout_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Reload Control. This bit controls how the timer is reloaded on overflow or underflow in Event and Timer modes. It has no effect in One shot mode. 1=Reload timer from Timer Reload Register and continue counting; 0=Roll timer over to FFFFh and continue counting when counting down and rolls over to 0000h and continues counting when counting up."]
            #[inline(always)]
            pub const fn rload(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Reload Control. This bit controls how the timer is reloaded on overflow or underflow in Event and Timer modes. It has no effect in One shot mode. 1=Reload timer from Timer Reload Register and continue counting; 0=Roll timer over to FFFFh and continue counting when counting down and rolls over to 0000h and continues counting when counting up."]
            #[inline(always)]
            pub fn set_rload(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This bit is used to enable or disable the noise filter on the TINx input signal. 1=Bypass Mode: input filter disabled. The TINx input directly affects the timer; 0=Filter Mode: input filter enabled. The TINx input is filtered by the input filter."]
            #[inline(always)]
            pub const fn fil_bypass(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to enable or disable the noise filter on the TINx input signal. 1=Bypass Mode: input filter disabled. The TINx input directly affects the timer; 0=Filter Mode: input filter enabled. The TINx input is filtered by the input filter."]
            #[inline(always)]
            pub fn set_fil_bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Power Down. 1=The timer is powered down and all clocks are gated; 0=The timer is in a running state."]
            #[inline(always)]
            pub const fn pd(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Power Down. 1=The timer is powered down and all clocks are gated; 0=The timer is in a running state."]
            #[inline(always)]
            pub fn set_pd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This bit determines the polarity of the TOUTx output signal. In timer modes that toggle the TOUTx signal, this polarity bit will not have a perceivable difference, except to determine the inactive state. In One-Shot mode this determines if the pulsed output is active high or active low. 1=Active low; 0=Active high."]
            #[inline(always)]
            pub const fn tout_pol(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit determines the polarity of the TOUTx output signal. In timer modes that toggle the TOUTx signal, this polarity bit will not have a perceivable difference, except to determine the inactive state. In One-Shot mode this determines if the pulsed output is active high or active low. 1=Active low; 0=Active high."]
            #[inline(always)]
            pub fn set_tout_pol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This bit reflects the current state of the timer's Sleep_Enable input signal. 1=Normal operation; 0=Sleep Mode is requested."]
            #[inline(always)]
            pub const fn slp_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reflects the current state of the timer's Sleep_Enable input signal. 1=Normal operation; 0=Sleep Mode is requested."]
            #[inline(always)]
            pub fn set_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "This bit reflects the current state of the timer's Clock_Required output signal. 1=The main clock is required by this block; 0=The main clock is not required by this block."]
            #[inline(always)]
            pub const fn tmrx_clk_req(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reflects the current state of the timer's Clock_Required output signal. 1=The main clock is required by this block; 0=The main clock is not required by this block."]
            #[inline(always)]
            pub fn set_tmrx_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for TimerxCtrl {
            #[inline(always)]
            fn default() -> TimerxCtrl {
                TimerxCtrl(0)
            }
        }
        impl core::fmt::Debug for TimerxCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TimerxCtrl")
                    .field("en", &self.en())
                    .field("rst", &self.rst())
                    .field("mode", &self.mode())
                    .field("inpol", &self.inpol())
                    .field("updn", &self.updn())
                    .field("tout_en", &self.tout_en())
                    .field("rload", &self.rload())
                    .field("fil_bypass", &self.fil_bypass())
                    .field("pd", &self.pd())
                    .field("tout_pol", &self.tout_pol())
                    .field("slp_en", &self.slp_en())
                    .field("tmrx_clk_req", &self.tmrx_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TimerxCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "TimerxCtrl {{ en: {=bool:?}, rst: {=bool:?}, mode: {:?}, inpol: {=bool:?}, updn: {=bool:?}, tout_en: {=bool:?}, rload: {=bool:?}, fil_bypass: {=bool:?}, pd: {=bool:?}, tout_pol: {=bool:?}, slp_en: {=bool:?}, tmrx_clk_req: {=bool:?} }}" , self . en () , self . rst () , self . mode () , self . inpol () , self . updn () , self . tout_en () , self . rload () , self . fil_bypass () , self . pd () , self . tout_pol () , self . slp_en () , self . tmrx_clk_req ())
            }
        }
        #[doc = "This register is used in Timer and One-Shot modes to set the lower limit of the timer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TimerxRld(pub u32);
        impl TimerxRld {
            #[doc = "The Timer Reload register is used in Timer and One-Shot modes to set the lower limit of the timer. In Event mode the Timer Reload register sets either the upper or lower limit of the timer depending on if the timer is counting up or down. Valid Timer Reload values are 0001h - FFFFh. If the timer is running, the reload value will not be updated until the timer overflows or underflows. Programming a 0000h as a preload value is not a valid count value. Using a value of 0000h will cause unpredictable behavior."]
            #[inline(always)]
            pub const fn tmr_rld(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "The Timer Reload register is used in Timer and One-Shot modes to set the lower limit of the timer. In Event mode the Timer Reload register sets either the upper or lower limit of the timer depending on if the timer is counting up or down. Valid Timer Reload values are 0001h - FFFFh. If the timer is running, the reload value will not be updated until the timer overflows or underflows. Programming a 0000h as a preload value is not a valid count value. Using a value of 0000h will cause unpredictable behavior."]
            #[inline(always)]
            pub fn set_tmr_rld(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TimerxRld {
            #[inline(always)]
            fn default() -> TimerxRld {
                TimerxRld(0)
            }
        }
        impl core::fmt::Debug for TimerxRld {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TimerxRld").field("tmr_rld", &self.tmr_rld()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TimerxRld {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TimerxRld {{ tmr_rld: {=u16:?} }}", self.tmr_rld())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "0=Timer Mode"]
            TIMER_MODE = 0x0,
            #[doc = "1=Event Mode"]
            EVENT_MODE = 0x01,
            #[doc = "2=One Shot Mode"]
            ONE_SHOT_MODE = 0x02,
            #[doc = "3=Measurement Mode"]
            MEASUREMENT_MODE = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
    }
}
pub mod common {
    use core::marker::PhantomData;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct RW;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct R;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct W;
    mod sealed {
        use super::*;
        pub trait Access {}
        impl Access for R {}
        impl Access for W {}
        impl Access for RW {}
    }
    pub trait Access: sealed::Access + Copy {}
    impl Access for R {}
    impl Access for W {}
    impl Access for RW {}
    pub trait Read: Access {}
    impl Read for RW {}
    impl Read for R {}
    pub trait Write: Access {}
    impl Write for RW {}
    impl Write for W {}
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct Reg<T: Copy, A: Access> {
        ptr: *mut u8,
        phantom: PhantomData<*mut (T, A)>,
    }
    unsafe impl<T: Copy, A: Access> Send for Reg<T, A> {}
    unsafe impl<T: Copy, A: Access> Sync for Reg<T, A> {}
    impl<T: Copy, A: Access> Reg<T, A> {
        #[allow(clippy::missing_safety_doc)]
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut T) -> Self {
            Self {
                ptr: ptr as _,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut T {
            self.ptr as _
        }
    }
    impl<T: Copy, A: Read> Reg<T, A> {
        #[inline(always)]
        pub fn read(&self) -> T {
            unsafe { (self.ptr as *mut T).read_volatile() }
        }
    }
    impl<T: Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write_value(&self, val: T) {
            unsafe { (self.ptr as *mut T).write_volatile(val) }
        }
    }
    impl<T: Default + Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = Default::default();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
    impl<T: Copy, A: Read + Write> Reg<T, A> {
        #[inline(always)]
        pub fn modify<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = self.read();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
}
pub mod dma_chan00 {
    #[doc = "DMA Channel 00 Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaChan00 {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaChan00 {}
    unsafe impl Sync for DmaChan00 {}
    impl DmaChan00 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<regs::Activate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the starting address for the Memory device."]
        #[inline(always)]
        pub const fn mstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the ending address for the Memory device."]
        #[inline(always)]
        pub const fn mend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the Master Device address."]
        #[inline(always)]
        pub const fn dstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DMA Channel N Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[inline(always)]
        pub const fn ists(self) -> crate::common::Reg<regs::Ists, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "DMA CHANNEL N CRC ENABLE"]
        #[inline(always)]
        pub const fn crc_en(self) -> crate::common::Reg<regs::CrcEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "DMA CHANNEL N CRC DATA"]
        #[inline(always)]
        pub const fn crc_data(self) -> crate::common::Reg<regs::CrcData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "DMA CHANNEL N CRC POST STATUS"]
        #[inline(always)]
        pub const fn crc_post_sts(self) -> crate::common::Reg<regs::CrcPostSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate(pub u8);
        impl Activate {
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate {
            #[inline(always)]
            fn default() -> Activate {
                Activate(0)
            }
        }
        impl core::fmt::Debug for Activate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate {{ chn: {=bool:?} }}", self.chn())
            }
        }
        #[doc = "DMA CHANNEL N CRC DATA"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcData(pub u32);
        impl CrcData {
            #[doc = "Writes to this register initialize the CRC generator. Reads from this register return the output of the CRC that is calculated from the data transferred by DMA Channel N. The output of the CRC generator is bit-reversed and inverted on reads, as required by the CRC-32-IEEE definition. A CRC can be accumulated across multiple DMA transactions on Channel N. If it is necessary to save the intermediate CRC value, the result of the read of this register must be bit-reversed and inverted before being written back to this register."]
            #[inline(always)]
            pub const fn crc(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Writes to this register initialize the CRC generator. Reads from this register return the output of the CRC that is calculated from the data transferred by DMA Channel N. The output of the CRC generator is bit-reversed and inverted on reads, as required by the CRC-32-IEEE definition. A CRC can be accumulated across multiple DMA transactions on Channel N. If it is necessary to save the intermediate CRC value, the result of the read of this register must be bit-reversed and inverted before being written back to this register."]
            #[inline(always)]
            pub fn set_crc(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for CrcData {
            #[inline(always)]
            fn default() -> CrcData {
                CrcData(0)
            }
        }
        impl core::fmt::Debug for CrcData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcData").field("crc", &self.crc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CrcData {{ crc: {=u32:?} }}", self.crc())
            }
        }
        #[doc = "DMA CHANNEL N CRC ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcEn(pub u32);
        impl CrcEn {
            #[doc = "1=Enable the calculation of CRC-32 for DMA Channel N 0=Disable the calculation of CRC-32 for DMA Channel N"]
            #[inline(always)]
            pub const fn mode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable the calculation of CRC-32 for DMA Channel N 0=Disable the calculation of CRC-32 for DMA Channel N"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The bit enables the transfer of the calculated CRC-32 after the completion of the DMA transaction. If the DMA transaction is aborted by either firmware or an internal bus error, the transfer will not occur. If the target of the DMA transfer is a device and the device signaled the termination of the DMA transaction, the CRC post transfer will not occur. 1=Enable the transfer of CRC-32 for DMA Channel N after the DMA transaction completes 0=Disable the automatic transfer of the CRC"]
            #[inline(always)]
            pub const fn post_trans(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The bit enables the transfer of the calculated CRC-32 after the completion of the DMA transaction. If the DMA transaction is aborted by either firmware or an internal bus error, the transfer will not occur. If the target of the DMA transfer is a device and the device signaled the termination of the DMA transaction, the CRC post transfer will not occur. 1=Enable the transfer of CRC-32 for DMA Channel N after the DMA transaction completes 0=Disable the automatic transfer of the CRC"]
            #[inline(always)]
            pub fn set_post_trans(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for CrcEn {
            #[inline(always)]
            fn default() -> CrcEn {
                CrcEn(0)
            }
        }
        impl core::fmt::Debug for CrcEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcEn")
                    .field("mode", &self.mode())
                    .field("post_trans", &self.post_trans())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "CrcEn {{ mode: {=bool:?}, post_trans: {=bool:?} }}",
                    self.mode(),
                    self.post_trans()
                )
            }
        }
        #[doc = "DMA CHANNEL N CRC POST STATUS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CrcPostSts(pub u32);
        impl CrcPostSts {
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub const fn crc_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub fn set_crc_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub const fn crc_running(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub fn set_crc_running(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller has completed the post-transfer of the CRC data. This bit is cleared to '0b' when the a new DMA transfer starts."]
            #[inline(always)]
            pub const fn crc_data_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller has completed the post-transfer of the CRC data. This bit is cleared to '0b' when the a new DMA transfer starts."]
            #[inline(always)]
            pub fn set_crc_data_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller is processing the post-transfer of the CRC data. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub const fn crc_data_ready(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller is processing the post-transfer of the CRC data. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub fn set_crc_data_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for CrcPostSts {
            #[inline(always)]
            fn default() -> CrcPostSts {
                CrcPostSts(0)
            }
        }
        impl core::fmt::Debug for CrcPostSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CrcPostSts")
                    .field("crc_done", &self.crc_done())
                    .field("crc_running", &self.crc_running())
                    .field("crc_data_done", &self.crc_data_done())
                    .field("crc_data_ready", &self.crc_data_ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CrcPostSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CrcPostSts {{ crc_done: {=bool:?}, crc_running: {=bool:?}, crc_data_done: {=bool:?}, crc_data_ready: {=bool:?} }}" , self . crc_done () , self . crc_running () , self . crc_data_done () , self . crc_data_ready ())
            }
        }
        #[doc = "DMA Channel N Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub const fn run(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub fn set_run(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub const fn req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub fn set_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Sts {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Sts::from_bits(val as u8)
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Sts) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u32) & 0x03) << 3usize);
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub const fn tx_dir(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub fn set_tx_dir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub const fn hw_flow_ctrl_dev(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub fn set_hw_flow_ctrl_dev(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u32) & 0x7f) << 9usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub const fn inc_mem_addr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub fn set_inc_mem_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub const fn inc_dev_addr(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub fn set_inc_dev_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub const fn dis_hw_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub fn set_dis_hw_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub const fn trans_size(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub fn set_trans_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub const fn trans_go(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub fn set_trans_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub const fn trans_abort(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub fn set_trans_abort(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("run", &self.run())
                    .field("req", &self.req())
                    .field("done", &self.done())
                    .field("sts", &self.sts())
                    .field("busy", &self.busy())
                    .field("tx_dir", &self.tx_dir())
                    .field("hw_flow_ctrl_dev", &self.hw_flow_ctrl_dev())
                    .field("inc_mem_addr", &self.inc_mem_addr())
                    .field("inc_dev_addr", &self.inc_dev_addr())
                    .field("lock", &self.lock())
                    .field("dis_hw_flow_ctrl", &self.dis_hw_flow_ctrl())
                    .field("trans_size", &self.trans_size())
                    .field("trans_go", &self.trans_go())
                    .field("trans_abort", &self.trans_abort())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ run: {=bool:?}, req: {=bool:?}, done: {=bool:?}, sts: {:?}, busy: {=bool:?}, tx_dir: {=bool:?}, hw_flow_ctrl_dev: {=u8:?}, inc_mem_addr: {=bool:?}, inc_dev_addr: {=bool:?}, lock: {=bool:?}, dis_hw_flow_ctrl: {=bool:?}, trans_size: {=u8:?}, trans_go: {=bool:?}, trans_abort: {=bool:?} }}" , self . run () , self . req () , self . done () , self . sts () , self . busy () , self . tx_dir () , self . hw_flow_ctrl_dev () , self . inc_mem_addr () , self . inc_dev_addr () , self . lock () , self . dis_hw_flow_ctrl () , self . trans_size () , self . trans_go () , self . trans_abort ())
            }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("sts_en_bus_err", &self.sts_en_bus_err())
                    .field("sts_en_flow_ctrl", &self.sts_en_flow_ctrl())
                    .field("sts_en_done", &self.sts_en_done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ sts_en_bus_err: {=bool:?}, sts_en_flow_ctrl: {=bool:?}, sts_en_done: {=bool:?} }}",
                    self.sts_en_bus_err(),
                    self.sts_en_flow_ctrl(),
                    self.sts_en_done()
                )
            }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ists(pub u8);
        impl Ists {
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub const fn bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub fn set_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub const fn flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub fn set_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ists {
            #[inline(always)]
            fn default() -> Ists {
                Ists(0)
            }
        }
        impl core::fmt::Debug for Ists {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ists")
                    .field("bus_err", &self.bus_err())
                    .field("flow_ctrl", &self.flow_ctrl())
                    .field("done", &self.done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ists {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ists {{ bus_err: {=bool:?}, flow_ctrl: {=bool:?}, done: {=bool:?} }}",
                    self.bus_err(),
                    self.flow_ctrl(),
                    self.done()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sts {
            #[doc = "0: DMA Channel Control:Run is Disabled (0x0)"]
            DIS = 0x0,
            #[doc = "1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address"]
            LOC_DONE = 0x01,
            #[doc = "2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term"]
            EXT_DONE = 0x02,
            #[doc = "3: Error detected by the DMA"]
            ERROR = 0x03,
        }
        impl Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sts {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sts {
            #[inline(always)]
            fn from(val: u8) -> Sts {
                Sts::from_bits(val)
            }
        }
        impl From<Sts> for u8 {
            #[inline(always)]
            fn from(val: Sts) -> u8 {
                Sts::to_bits(val)
            }
        }
    }
}
pub mod dma_chan01 {
    #[doc = "DMA Channel 01 Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaChan01 {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaChan01 {}
    unsafe impl Sync for DmaChan01 {}
    impl DmaChan01 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<regs::Activate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the starting address for the Memory device."]
        #[inline(always)]
        pub const fn mstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the ending address for the Memory device."]
        #[inline(always)]
        pub const fn mend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the Master Device address."]
        #[inline(always)]
        pub const fn dstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DMA Channel N Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[inline(always)]
        pub const fn ists(self) -> crate::common::Reg<regs::Ists, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "DMA CHANNEL N FILL ENABLE"]
        #[inline(always)]
        pub const fn fill_en(self) -> crate::common::Reg<regs::FillEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "DMA CHANNEL N FILL DATA"]
        #[inline(always)]
        pub const fn fill_data(self) -> crate::common::Reg<regs::FillData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "DMA CHANNEL N FILL STATUS"]
        #[inline(always)]
        pub const fn fill_sts(self) -> crate::common::Reg<regs::FillSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate(pub u8);
        impl Activate {
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate {
            #[inline(always)]
            fn default() -> Activate {
                Activate(0)
            }
        }
        impl core::fmt::Debug for Activate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate {{ chn: {=bool:?} }}", self.chn())
            }
        }
        #[doc = "DMA Channel N Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub const fn run(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub fn set_run(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub const fn req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub fn set_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Sts {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Sts::from_bits(val as u8)
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Sts) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u32) & 0x03) << 3usize);
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub const fn tx_dir(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub fn set_tx_dir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub const fn hw_flow_ctrl_dev(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub fn set_hw_flow_ctrl_dev(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u32) & 0x7f) << 9usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub const fn inc_mem_addr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub fn set_inc_mem_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub const fn inc_dev_addr(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub fn set_inc_dev_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub const fn dis_hw_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub fn set_dis_hw_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub const fn trans_size(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub fn set_trans_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub const fn trans_go(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub fn set_trans_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub const fn trans_abort(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub fn set_trans_abort(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("run", &self.run())
                    .field("req", &self.req())
                    .field("done", &self.done())
                    .field("sts", &self.sts())
                    .field("busy", &self.busy())
                    .field("tx_dir", &self.tx_dir())
                    .field("hw_flow_ctrl_dev", &self.hw_flow_ctrl_dev())
                    .field("inc_mem_addr", &self.inc_mem_addr())
                    .field("inc_dev_addr", &self.inc_dev_addr())
                    .field("lock", &self.lock())
                    .field("dis_hw_flow_ctrl", &self.dis_hw_flow_ctrl())
                    .field("trans_size", &self.trans_size())
                    .field("trans_go", &self.trans_go())
                    .field("trans_abort", &self.trans_abort())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ run: {=bool:?}, req: {=bool:?}, done: {=bool:?}, sts: {:?}, busy: {=bool:?}, tx_dir: {=bool:?}, hw_flow_ctrl_dev: {=u8:?}, inc_mem_addr: {=bool:?}, inc_dev_addr: {=bool:?}, lock: {=bool:?}, dis_hw_flow_ctrl: {=bool:?}, trans_size: {=u8:?}, trans_go: {=bool:?}, trans_abort: {=bool:?} }}" , self . run () , self . req () , self . done () , self . sts () , self . busy () , self . tx_dir () , self . hw_flow_ctrl_dev () , self . inc_mem_addr () , self . inc_dev_addr () , self . lock () , self . dis_hw_flow_ctrl () , self . trans_size () , self . trans_go () , self . trans_abort ())
            }
        }
        #[doc = "DMA CHANNEL N FILL DATA"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FillData(pub u32);
        impl FillData {
            #[doc = "This is the data pattern used to fill memory."]
            #[inline(always)]
            pub const fn data(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This is the data pattern used to fill memory."]
            #[inline(always)]
            pub fn set_data(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for FillData {
            #[inline(always)]
            fn default() -> FillData {
                FillData(0)
            }
        }
        impl core::fmt::Debug for FillData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FillData").field("data", &self.data()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FillData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FillData {{ data: {=u32:?} }}", self.data())
            }
        }
        #[doc = "DMA CHANNEL N FILL ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FillEn(pub u32);
        impl FillEn {
            #[doc = "1=Enable the calculation of CRC-32 for DMA Channel N 0=Disable the calculation of CRC-32 for DMA Channel N"]
            #[inline(always)]
            pub const fn mode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable the calculation of CRC-32 for DMA Channel N 0=Disable the calculation of CRC-32 for DMA Channel N"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for FillEn {
            #[inline(always)]
            fn default() -> FillEn {
                FillEn(0)
            }
        }
        impl core::fmt::Debug for FillEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FillEn").field("mode", &self.mode()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FillEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FillEn {{ mode: {=bool:?} }}", self.mode())
            }
        }
        #[doc = "DMA CHANNEL N FILL STATUS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FillSts(pub u32);
        impl FillSts {
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination. It is cleared to '0b' when the DMA controller starts a new transfer on the channel."]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub const fn running(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC. It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared to '0b' when the post-transfer completes."]
            #[inline(always)]
            pub fn set_running(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for FillSts {
            #[inline(always)]
            fn default() -> FillSts {
                FillSts(0)
            }
        }
        impl core::fmt::Debug for FillSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FillSts")
                    .field("done", &self.done())
                    .field("running", &self.running())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FillSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FillSts {{ done: {=bool:?}, running: {=bool:?} }}",
                    self.done(),
                    self.running()
                )
            }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("sts_en_bus_err", &self.sts_en_bus_err())
                    .field("sts_en_flow_ctrl", &self.sts_en_flow_ctrl())
                    .field("sts_en_done", &self.sts_en_done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ sts_en_bus_err: {=bool:?}, sts_en_flow_ctrl: {=bool:?}, sts_en_done: {=bool:?} }}",
                    self.sts_en_bus_err(),
                    self.sts_en_flow_ctrl(),
                    self.sts_en_done()
                )
            }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ists(pub u8);
        impl Ists {
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub const fn bus_error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub fn set_bus_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub const fn flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub fn set_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ists {
            #[inline(always)]
            fn default() -> Ists {
                Ists(0)
            }
        }
        impl core::fmt::Debug for Ists {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ists")
                    .field("bus_error", &self.bus_error())
                    .field("flow_ctrl", &self.flow_ctrl())
                    .field("done", &self.done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ists {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ists {{ bus_error: {=bool:?}, flow_ctrl: {=bool:?}, done: {=bool:?} }}",
                    self.bus_error(),
                    self.flow_ctrl(),
                    self.done()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sts {
            #[doc = "0: DMA Channel Control:Run is Disabled (0x0)"]
            DIS = 0x0,
            #[doc = "1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address"]
            LOC_DONE = 0x01,
            #[doc = "2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term"]
            EXT_DONE = 0x02,
            #[doc = "3: Error detected by the DMA"]
            ERROR = 0x03,
        }
        impl Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sts {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sts {
            #[inline(always)]
            fn from(val: u8) -> Sts {
                Sts::from_bits(val)
            }
        }
        impl From<Sts> for u8 {
            #[inline(always)]
            fn from(val: Sts) -> u8 {
                Sts::to_bits(val)
            }
        }
    }
}
pub mod dma_chan02 {
    #[doc = "DMA Channel 00 Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaChan02 {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaChan02 {}
    unsafe impl Sync for DmaChan02 {}
    impl DmaChan02 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<regs::Activate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the starting address for the Memory device."]
        #[inline(always)]
        pub const fn mstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the ending address for the Memory device."]
        #[inline(always)]
        pub const fn mend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the Master Device address."]
        #[inline(always)]
        pub const fn dstart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DMA Channel N Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[inline(always)]
        pub const fn ists(self) -> crate::common::Reg<regs::Ists, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Activate(pub u8);
        impl Activate {
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub const fn chn(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational. 1=Enable channel(block). Each individual channel must be enabled separately. 0=Disable channel(block)."]
            #[inline(always)]
            pub fn set_chn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Activate {
            #[inline(always)]
            fn default() -> Activate {
                Activate(0)
            }
        }
        impl core::fmt::Debug for Activate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Activate").field("chn", &self.chn()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Activate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Activate {{ chn: {=bool:?} }}", self.chn())
            }
        }
        #[doc = "DMA Channel N Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub const fn run(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is a control field. Note: This bit only applies to Hardware Flow Control mode. 1= This channel is enabled and will service transfer requests 0=This channel is disabled. All transfer requests are ignored."]
            #[inline(always)]
            pub fn set_run(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub const fn req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status field. 1= There is a transfer request from the Master Device 0= There is no transfer request from the Master Device"]
            #[inline(always)]
            pub fn set_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field. 1=Channel is done 0=Channel is not done or it is OFF"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub const fn sts(&self) -> super::vals::Sts {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Sts::from_bits(val as u8)
            }
            #[doc = "This is a status signal. The status decode is listed in priority order with the highest priority first. 3: Error detected by the DMA 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address 0: DMA Channel Control:Run is Disabled (0x0)"]
            #[inline(always)]
            pub fn set_sts(&mut self, val: super::vals::Sts) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u32) & 0x03) << 3usize);
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This is a status signal. 1=The DMA Channel is busy (FSM is not IDLE) 0=The DMA Channel is not busy (FSM is IDLE)"]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub const fn tx_dir(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This determines the direction of the DMA Transfer. 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address"]
            #[inline(always)]
            pub fn set_tx_dir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub const fn hw_flow_ctrl_dev(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "This is the device that is connected to this channel as its Hardware Flow Control master. The Flow Control Interface is a bus with each master concatenated onto it. This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel. The Flow Control Interface Port list is dma_req, dma_term, and dma_done."]
            #[inline(always)]
            pub fn set_hw_flow_ctrl_dev(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u32) & 0x7f) << 9usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub const fn inc_mem_addr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Memory Address. 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0=Do nothing"]
            #[inline(always)]
            pub fn set_inc_mem_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub const fn inc_dev_addr(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This will enable an auto-increment to the DMA Channel Device Address. 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer 0: Do nothing"]
            #[inline(always)]
            pub fn set_inc_dev_addr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions)."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub const fn dis_hw_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode."]
            #[inline(always)]
            pub fn set_dis_hw_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub const fn trans_size(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x07;
                val as u8
            }
            #[doc = "This is the transfer size in Bytes of each Data Packet transfer. Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes."]
            #[inline(always)]
            pub fn set_trans_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize);
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub const fn trans_go(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This is used for the Firmware Flow Control DMA transfer."]
            #[inline(always)]
            pub fn set_trans_go(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub const fn trans_abort(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately."]
            #[inline(always)]
            pub fn set_trans_abort(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("run", &self.run())
                    .field("req", &self.req())
                    .field("done", &self.done())
                    .field("sts", &self.sts())
                    .field("busy", &self.busy())
                    .field("tx_dir", &self.tx_dir())
                    .field("hw_flow_ctrl_dev", &self.hw_flow_ctrl_dev())
                    .field("inc_mem_addr", &self.inc_mem_addr())
                    .field("inc_dev_addr", &self.inc_dev_addr())
                    .field("lock", &self.lock())
                    .field("dis_hw_flow_ctrl", &self.dis_hw_flow_ctrl())
                    .field("trans_size", &self.trans_size())
                    .field("trans_go", &self.trans_go())
                    .field("trans_abort", &self.trans_abort())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ run: {=bool:?}, req: {=bool:?}, done: {=bool:?}, sts: {:?}, busy: {=bool:?}, tx_dir: {=bool:?}, hw_flow_ctrl_dev: {=u8:?}, inc_mem_addr: {=bool:?}, inc_dev_addr: {=bool:?}, lock: {=bool:?}, dis_hw_flow_ctrl: {=bool:?}, trans_size: {=u8:?}, trans_go: {=bool:?}, trans_abort: {=bool:?} }}" , self . run () , self . req () , self . done () , self . sts () , self . busy () , self . tx_dir () , self . hw_flow_ctrl_dev () , self . inc_mem_addr () , self . inc_dev_addr () , self . lock () , self . dis_hw_flow_ctrl () , self . trans_size () , self . trans_go () , self . trans_abort ())
            }
        }
        #[doc = "DMA CHANNEL N INTERRUPT ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Bus Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub const fn sts_en_done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt enable for DMA Channel Interrupt:Status Done. 1=Enable Interrupt 0=Disable Interrupt"]
            #[inline(always)]
            pub fn set_sts_en_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("sts_en_bus_err", &self.sts_en_bus_err())
                    .field("sts_en_flow_ctrl", &self.sts_en_flow_ctrl())
                    .field("sts_en_done", &self.sts_en_done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ sts_en_bus_err: {=bool:?}, sts_en_flow_ctrl: {=bool:?}, sts_en_done: {=bool:?} }}",
                    self.sts_en_bus_err(),
                    self.sts_en_flow_ctrl(),
                    self.sts_en_done()
                )
            }
        }
        #[doc = "DMA Channel N Interrupt Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ists(pub u8);
        impl Ists {
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub const fn bus_err(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus. 1: Error detected. (R/WC)"]
            #[inline(always)]
            pub fn set_bus_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub const fn flow_ctrl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA. 1=Hardware Flow Control is requesting after the transfer has completed 0=No Hardware Flow Control event"]
            #[inline(always)]
            pub fn set_flow_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt. 1=Memory Start Address equals Memory End Address 0=Memory Start Address does not equal Memory End Address"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Ists {
            #[inline(always)]
            fn default() -> Ists {
                Ists(0)
            }
        }
        impl core::fmt::Debug for Ists {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ists")
                    .field("bus_err", &self.bus_err())
                    .field("flow_ctrl", &self.flow_ctrl())
                    .field("done", &self.done())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ists {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ists {{ bus_err: {=bool:?}, flow_ctrl: {=bool:?}, done: {=bool:?} }}",
                    self.bus_err(),
                    self.flow_ctrl(),
                    self.done()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sts {
            #[doc = "0: DMA Channel Control:Run is Disabled (0x0)"]
            DIS = 0x0,
            #[doc = "1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address"]
            LOC_DONE = 0x01,
            #[doc = "2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term"]
            EXT_DONE = 0x02,
            #[doc = "3: Error detected by the DMA"]
            ERROR = 0x03,
        }
        impl Sts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sts {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sts {
            #[inline(always)]
            fn from(val: u8) -> Sts {
                Sts::from_bits(val)
            }
        }
        impl From<Sts> for u8 {
            #[inline(always)]
            fn from(val: Sts) -> u8 {
                Sts::to_bits(val)
            }
        }
    }
}
pub mod dma_main {
    #[doc = "DMA Main Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaMain {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaMain {}
    unsafe impl Sync for DmaMain {}
    impl DmaMain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Soft reset the entire module. Enable the blocks operation."]
        #[inline(always)]
        pub const fn actrst(self) -> crate::common::Reg<regs::Actrst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Debug register that has the data that is stored in the Data Packet. This data is read data from the currently active transfer source."]
        #[inline(always)]
        pub const fn data_pkt(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Soft reset the entire module. Enable the blocks operation."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Actrst(pub u8);
        impl Actrst {
            #[doc = "Enable the blocks operation. (R/WS) 1=Enable block. Each individual channel must be enabled separately. 0=Disable all channels."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the blocks operation. (R/WS) 1=Enable block. Each individual channel must be enabled separately. 0=Disable all channels."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Soft reset the entire module. This bit is self-clearing."]
            #[inline(always)]
            pub const fn soft_rst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Soft reset the entire module. This bit is self-clearing."]
            #[inline(always)]
            pub fn set_soft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Actrst {
            #[inline(always)]
            fn default() -> Actrst {
                Actrst(0)
            }
        }
        impl core::fmt::Debug for Actrst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Actrst")
                    .field("act", &self.act())
                    .field("soft_rst", &self.soft_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Actrst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Actrst {{ act: {=bool:?}, soft_rst: {=bool:?} }}",
                    self.act(),
                    self.soft_rst()
                )
            }
        }
    }
}
pub mod ec_reg_bank {
    #[doc = "This block is designed to be accessed internally by the EC via the register interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EcRegBank {
        ptr: *mut u8,
    }
    unsafe impl Send for EcRegBank {}
    unsafe impl Sync for EcRegBank {}
    impl EcRegBank {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "AHB Error Address \\[0:0\\] AHB_ERR_ADDR, In priority order: 1. AHB address is registered when an AHB error occurs on the processor's AHB master port and the register value was already 0. This way only the first address to generate an exception is captured. 2. The processor can clear this register by writing any 32-bit value to this register."]
        #[inline(always)]
        pub const fn ahb_err_addr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "AHB Error Control \\[0:0\\] AHB_ERROR_DISABLE, 0: EC memory exceptions are enabled. 1: EC memory exceptions are disabled."]
        #[inline(always)]
        pub const fn ahb_err_ctrl(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Interrupt Control \\[0:0\\] NVIC_EN (NVIC_EN) This bit enables Alternate NVIC IRQ's Vectors. The Alternate NVIC Vectors provides each interrupt event with a dedicated (direct) NVIC vector. 0 = Alternate NVIC vectors disabled, 1= Alternate NVIC vectors enabled"]
        #[inline(always)]
        pub const fn intr_ctrl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "ETM TRACE Enable \\[0:0\\] TRACE_EN (TRACE_EN) This bit enables the ARM TRACE debug port (ETM/ITM). The Trace Debug Interface pins are forced to the TRACE functions. 0 = ARM TRACE port disabled, 1= ARM TRACE port enabled"]
        #[inline(always)]
        pub const fn etm_ctrl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Debug Enable Register"]
        #[inline(always)]
        pub const fn debug_ctrl(self) -> crate::common::Reg<regs::DebugCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "OTP Lock"]
        #[inline(always)]
        pub const fn otp_lock(self) -> crate::common::Reg<regs::OtpLock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "WDT Event Count \\[3:0\\] WDT_COUNT (WDT_COUNT) These EC R/W bits are cleared to 0 on VCC1 POR, but not on a WDT Note: This field is written by Boot ROM firmware to indicate the number of times a WDT fired before loading a good EC code image."]
        #[inline(always)]
        pub const fn wdt_cnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "AES HASH Byte Swap Control Register."]
        #[inline(always)]
        pub const fn aesh_bswap_ctrl(self) -> crate::common::Reg<regs::AeshBswapCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "AES HASH Byte Swap Control Register."]
        #[inline(always)]
        pub const fn sys_shutdwn_rst(self) -> crate::common::Reg<regs::SysShutdwnRst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "PECI Disable"]
        #[inline(always)]
        pub const fn peci_dis(self) -> crate::common::Reg<regs::PeciDis, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "System Shutdown Reset"]
        #[inline(always)]
        pub const fn crypto_srst(self) -> crate::common::Reg<regs::CryptoSrst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "GPIO Bank Power Register"]
        #[inline(always)]
        pub const fn gpio_bank_pwr(self) -> crate::common::Reg<regs::GpioBankPwr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "JTAG Master Configuration Register"]
        #[inline(always)]
        pub const fn jtag_mcfg(self) -> crate::common::Reg<regs::JtagMcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "JTAG Master Status Register"]
        #[inline(always)]
        pub const fn jtag_msts(self) -> crate::common::Reg<regs::JtagMsts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "JTAG Master TDO Register"]
        #[inline(always)]
        pub const fn jtag_mtdo(self) -> crate::common::Reg<regs::JtagMtdo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "JTAG Master TDI Register"]
        #[inline(always)]
        pub const fn jtag_mtdi(self) -> crate::common::Reg<regs::JtagMtdi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "JTAG Master TMS Register"]
        #[inline(always)]
        pub const fn jtag_mtms(self) -> crate::common::Reg<regs::JtagMtms, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "JTAG Master Command Register"]
        #[inline(always)]
        pub const fn jtag_mcmd(self) -> crate::common::Reg<regs::JtagMcmd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "AES HASH Byte Swap Control Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AeshBswapCtrl(pub u32);
        impl AeshBswapCtrl {
            #[doc = "Used to enable byte swap on a DWORD during AHB read from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub const fn ip_byte_swap_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Used to enable byte swap on a DWORD during AHB read from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub fn set_ip_byte_swap_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Used to enable byte swap on a DWORD during AHB write from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub const fn op_byte_swap_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Used to enable byte swap on a DWORD during AHB write from AES / HASH block: 1=Enable; 0=Disable."]
            #[inline(always)]
            pub fn set_op_byte_swap_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Used to enable word swap on a DWORD during AHB read from AES / HASH block 4=Swap 32-bit doublewords in 128-byte blocks 3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C, 0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,... 2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,... 1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4, 0x0, 0xC, 0x8, ... 0=Disable."]
            #[inline(always)]
            pub const fn ip_blk_swap_en(&self) -> super::vals::IpBlkSwapEn {
                let val = (self.0 >> 2usize) & 0x07;
                super::vals::IpBlkSwapEn::from_bits(val as u8)
            }
            #[doc = "Used to enable word swap on a DWORD during AHB read from AES / HASH block 4=Swap 32-bit doublewords in 128-byte blocks 3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C, 0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,... 2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,... 1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4, 0x0, 0xC, 0x8, ... 0=Disable."]
            #[inline(always)]
            pub fn set_ip_blk_swap_en(&mut self, val: super::vals::IpBlkSwapEn) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val.to_bits() as u32) & 0x07) << 2usize);
            }
            #[doc = "Used to enable word swap on a DWORD during AHB write from AES / HASH block 4=Swap 32-bit doublewords in 128-byte blocks 3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C, 0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,... 2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,... 1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4, 0x0, 0xC, 0x8, ... 0=Disable."]
            #[inline(always)]
            pub const fn op_blk_swap_en(&self) -> super::vals::OpBlkSwapEn {
                let val = (self.0 >> 5usize) & 0x07;
                super::vals::OpBlkSwapEn::from_bits(val as u8)
            }
            #[doc = "Used to enable word swap on a DWORD during AHB write from AES / HASH block 4=Swap 32-bit doublewords in 128-byte blocks 3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C, 0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,... 2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,... 1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4, 0x0, 0xC, 0x8, ... 0=Disable."]
            #[inline(always)]
            pub fn set_op_blk_swap_en(&mut self, val: super::vals::OpBlkSwapEn) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val.to_bits() as u32) & 0x07) << 5usize);
            }
        }
        impl Default for AeshBswapCtrl {
            #[inline(always)]
            fn default() -> AeshBswapCtrl {
                AeshBswapCtrl(0)
            }
        }
        impl core::fmt::Debug for AeshBswapCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AeshBswapCtrl")
                    .field("ip_byte_swap_en", &self.ip_byte_swap_en())
                    .field("op_byte_swap_en", &self.op_byte_swap_en())
                    .field("ip_blk_swap_en", &self.ip_blk_swap_en())
                    .field("op_blk_swap_en", &self.op_blk_swap_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AeshBswapCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "AeshBswapCtrl {{ ip_byte_swap_en: {=bool:?}, op_byte_swap_en: {=bool:?}, ip_blk_swap_en: {:?}, op_blk_swap_en: {:?} }}" , self . ip_byte_swap_en () , self . op_byte_swap_en () , self . ip_blk_swap_en () , self . op_blk_swap_en ())
            }
        }
        #[doc = "System Shutdown Reset"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CryptoSrst(pub u32);
        impl CryptoSrst {
            #[doc = "When this bit is asserted 1, the Random Number Generator block is reset."]
            #[inline(always)]
            pub const fn rng_sft_rst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is asserted 1, the Random Number Generator block is reset."]
            #[inline(always)]
            pub fn set_rng_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When this bit is asserted 1, the Public Key block is reset."]
            #[inline(always)]
            pub const fn pub_key_sft_rst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is asserted 1, the Public Key block is reset."]
            #[inline(always)]
            pub fn set_pub_key_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "When this bit is asserted 1, the AES and Hash blocks are reset."]
            #[inline(always)]
            pub const fn aes_hash_sft_rst(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is asserted 1, the AES and Hash blocks are reset."]
            #[inline(always)]
            pub fn set_aes_hash_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for CryptoSrst {
            #[inline(always)]
            fn default() -> CryptoSrst {
                CryptoSrst(0)
            }
        }
        impl core::fmt::Debug for CryptoSrst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CryptoSrst")
                    .field("rng_sft_rst", &self.rng_sft_rst())
                    .field("pub_key_sft_rst", &self.pub_key_sft_rst())
                    .field("aes_hash_sft_rst", &self.aes_hash_sft_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CryptoSrst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "CryptoSrst {{ rng_sft_rst: {=bool:?}, pub_key_sft_rst: {=bool:?}, aes_hash_sft_rst: {=bool:?} }}",
                    self.rng_sft_rst(),
                    self.pub_key_sft_rst(),
                    self.aes_hash_sft_rst()
                )
            }
        }
        #[doc = "Debug Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DebugCtrl(pub u32);
        impl DebugCtrl {
            #[doc = "EN (JTAG_EN) This bit enables the JTAG/SWD debug port. 0= JTAG/SWD port disabled. JTAG/SWD cannot be enabled (i.e., the TRST# pin is ignored and the JTAG signals remain in their non-JTAG state) 1= JTAG/SWD port enabled. A high on TRST# enables JTAG or SWD, as determined by SWD_EN."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "EN (JTAG_EN) This bit enables the JTAG/SWD debug port. 0= JTAG/SWD port disabled. JTAG/SWD cannot be enabled (i.e., the TRST# pin is ignored and the JTAG signals remain in their non-JTAG state) 1= JTAG/SWD port enabled. A high on TRST# enables JTAG or SWD, as determined by SWD_EN."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This field determines which pins are affected by the TRST# debug enable pin.3=Reserved 2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required 1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) and Serial Wire Viewer (SWV) are both required for debugging 0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high. This setting should be used when the JTAG TAP controller is required for debugging."]
            #[inline(always)]
            pub const fn pin_cfg(&self) -> super::vals::PinCfg {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::PinCfg::from_bits(val as u8)
            }
            #[doc = "This field determines which pins are affected by the TRST# debug enable pin.3=Reserved 2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required 1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) and Serial Wire Viewer (SWV) are both required for debugging 0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high. This setting should be used when the JTAG TAP controller is required for debugging."]
            #[inline(always)]
            pub fn set_pin_cfg(&mut self, val: super::vals::PinCfg) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u32) & 0x03) << 1usize);
            }
            #[doc = "If this bit is set to '1b' internal pull-up resistors are automatically enabled on the appropriate debugging port wires whenever the debug port is enabled (the DEBUG_EN bit in this register is '1b' and the JTAG_RST# pin is high). The setting of DEBUG_PIN_CFG determines which pins have pull-ups enabled when the debug port is enabled."]
            #[inline(always)]
            pub const fn pu_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is set to '1b' internal pull-up resistors are automatically enabled on the appropriate debugging port wires whenever the debug port is enabled (the DEBUG_EN bit in this register is '1b' and the JTAG_RST# pin is high). The setting of DEBUG_PIN_CFG determines which pins have pull-ups enabled when the debug port is enabled."]
            #[inline(always)]
            pub fn set_pu_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for DebugCtrl {
            #[inline(always)]
            fn default() -> DebugCtrl {
                DebugCtrl(0)
            }
        }
        impl core::fmt::Debug for DebugCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DebugCtrl")
                    .field("en", &self.en())
                    .field("pin_cfg", &self.pin_cfg())
                    .field("pu_en", &self.pu_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DebugCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DebugCtrl {{ en: {=bool:?}, pin_cfg: {:?}, pu_en: {=bool:?} }}",
                    self.en(),
                    self.pin_cfg(),
                    self.pu_en()
                )
            }
        }
        #[doc = "GPIO Bank Power Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GpioBankPwr(pub u32);
        impl GpioBankPwr {
            #[doc = "Voltage value on VTR1. This bit is set by hardware after a VTR Power On Reset, but may be overridden by software. It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7. 1=VTR1 is powered by 3.3V 0=VTR1 is powered by 1.8V."]
            #[inline(always)]
            pub const fn vtr_lvl1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Voltage value on VTR1. This bit is set by hardware after a VTR Power On Reset, but may be overridden by software. It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7. 1=VTR1 is powered by 3.3V 0=VTR1 is powered by 1.8V."]
            #[inline(always)]
            pub fn set_vtr_lvl1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Voltage value on VTR2. This bit is set by hardware after a VTR Power On Reset, but may be overridden by software. It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7. 1=VTR2 is powered by 3.3V 0=VTR2 is powered by 1.8V."]
            #[inline(always)]
            pub const fn vtr_lvl2(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Voltage value on VTR2. This bit is set by hardware after a VTR Power On Reset, but may be overridden by software. It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7. 1=VTR2 is powered by 3.3V 0=VTR2 is powered by 1.8V."]
            #[inline(always)]
            pub fn set_vtr_lvl2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Voltage value on VTR3. This bit is set by hardware after a VTR Power On Reset, but may be overridden by software. It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7. 1=VTR3 is powered by 3.3V 0=VTR3 is powered by 1.8V."]
            #[inline(always)]
            pub const fn vtr_lvl3(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Voltage value on VTR3. This bit is set by hardware after a VTR Power On Reset, but may be overridden by software. It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7. 1=VTR3 is powered by 3.3V 0=VTR3 is powered by 1.8V."]
            #[inline(always)]
            pub fn set_vtr_lvl3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GPIO Bank Power Lock. 0: VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are R/W 1 = VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are Read Only."]
            #[inline(always)]
            pub const fn gpio_bank_pwr_lock(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "GPIO Bank Power Lock. 0: VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are R/W 1 = VTR_LEVEL bits\\[2:0\\] and GPIO Bank Power Lock bit are Read Only."]
            #[inline(always)]
            pub fn set_gpio_bank_pwr_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for GpioBankPwr {
            #[inline(always)]
            fn default() -> GpioBankPwr {
                GpioBankPwr(0)
            }
        }
        impl core::fmt::Debug for GpioBankPwr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GpioBankPwr")
                    .field("vtr_lvl1", &self.vtr_lvl1())
                    .field("vtr_lvl2", &self.vtr_lvl2())
                    .field("vtr_lvl3", &self.vtr_lvl3())
                    .field("gpio_bank_pwr_lock", &self.gpio_bank_pwr_lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GpioBankPwr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "GpioBankPwr {{ vtr_lvl1: {=bool:?}, vtr_lvl2: {=bool:?}, vtr_lvl3: {=bool:?}, gpio_bank_pwr_lock: {=bool:?} }}" , self . vtr_lvl1 () , self . vtr_lvl2 () , self . vtr_lvl3 () , self . gpio_bank_pwr_lock ())
            }
        }
        #[doc = "JTAG Master Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMcfg(pub u32);
        impl JtagMcfg {
            #[doc = "This field determines the JTAG Master clock rate, derived from the 48MHz master clock. 7=375KHz; 6=750KHz; 5=1.5Mhz; 4=3Mhz; 3=6Mhz; 2=12Mhz; 1=24MHz; 0=Reserved."]
            #[inline(always)]
            pub const fn jtm_clk(&self) -> super::vals::JtmClk {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::JtmClk::from_bits(val as u8)
            }
            #[doc = "This field determines the JTAG Master clock rate, derived from the 48MHz master clock. 7=375KHz; 6=750KHz; 5=1.5Mhz; 4=3Mhz; 3=6Mhz; 2=12Mhz; 1=24MHz; 0=Reserved."]
            #[inline(always)]
            pub fn set_jtm_clk(&mut self, val: super::vals::JtmClk) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "This bit controls the direction of the JTAG port. 1=The JTAG Port is configured as a Master 0=The JTAG Port is configures as a Slave."]
            #[inline(always)]
            pub const fn mas_slv(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls the direction of the JTAG port. 1=The JTAG Port is configured as a Master 0=The JTAG Port is configures as a Slave."]
            #[inline(always)]
            pub fn set_mas_slv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for JtagMcfg {
            #[inline(always)]
            fn default() -> JtagMcfg {
                JtagMcfg(0)
            }
        }
        impl core::fmt::Debug for JtagMcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMcfg")
                    .field("jtm_clk", &self.jtm_clk())
                    .field("mas_slv", &self.mas_slv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "JtagMcfg {{ jtm_clk: {:?}, mas_slv: {=bool:?} }}",
                    self.jtm_clk(),
                    self.mas_slv()
                )
            }
        }
        #[doc = "JTAG Master Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMcmd(pub u32);
        impl JtagMcmd {
            #[doc = "If the JTAG Port is configured as a Master, writing this register starts clocking and shifting on the JTAG port. The JTAG Master port will shift JTM_COUNT+1 times, so writing a '0h' will shift 1 bit, and writing '31h' will shift 32 bits. The signal JTAG_CLK will cycle JTM_COUNT+1 times. The contents of the JTAG Master TMS Register and the JTAG Master TDI Register will be shifted out on the falling edge of JTAG_CLK and the.JTAG Master TDO Register will get shifted in on the rising edge of JTAG_CLK. If the JTAG Port is configured as a Slave, writing this register has no effect."]
            #[inline(always)]
            pub const fn jtm_count(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "If the JTAG Port is configured as a Master, writing this register starts clocking and shifting on the JTAG port. The JTAG Master port will shift JTM_COUNT+1 times, so writing a '0h' will shift 1 bit, and writing '31h' will shift 32 bits. The signal JTAG_CLK will cycle JTM_COUNT+1 times. The contents of the JTAG Master TMS Register and the JTAG Master TDI Register will be shifted out on the falling edge of JTAG_CLK and the.JTAG Master TDO Register will get shifted in on the rising edge of JTAG_CLK. If the JTAG Port is configured as a Slave, writing this register has no effect."]
            #[inline(always)]
            pub fn set_jtm_count(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for JtagMcmd {
            #[inline(always)]
            fn default() -> JtagMcmd {
                JtagMcmd(0)
            }
        }
        impl core::fmt::Debug for JtagMcmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMcmd")
                    .field("jtm_count", &self.jtm_count())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMcmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "JtagMcmd {{ jtm_count: {=u8:?} }}", self.jtm_count())
            }
        }
        #[doc = "JTAG Master Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMsts(pub u32);
        impl JtagMsts {
            #[doc = "This bit is set to '1b' when the JTAG Master Command Register is written. It becomes '0b' when shifting has completed. Software can poll this bit to determine when a command has completed and it is therefore safe to remove the data in the JTAG Master TDO Register and load new data into the JTAG Master TMS Register and the JTAG Master TDI Register."]
            #[inline(always)]
            pub const fn jtm_done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' when the JTAG Master Command Register is written. It becomes '0b' when shifting has completed. Software can poll this bit to determine when a command has completed and it is therefore safe to remove the data in the JTAG Master TDO Register and load new data into the JTAG Master TMS Register and the JTAG Master TDI Register."]
            #[inline(always)]
            pub fn set_jtm_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for JtagMsts {
            #[inline(always)]
            fn default() -> JtagMsts {
                JtagMsts(0)
            }
        }
        impl core::fmt::Debug for JtagMsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMsts").field("jtm_done", &self.jtm_done()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "JtagMsts {{ jtm_done: {=bool:?} }}", self.jtm_done())
            }
        }
        #[doc = "JTAG Master TDI Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMtdi(pub u32);
        impl JtagMtdi {
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0, onto the JTAG_TDI pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub const fn jtm_tdi(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0, onto the JTAG_TDI pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub fn set_jtm_tdi(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for JtagMtdi {
            #[inline(always)]
            fn default() -> JtagMtdi {
                JtagMtdi(0)
            }
        }
        impl core::fmt::Debug for JtagMtdi {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMtdi").field("jtm_tdi", &self.jtm_tdi()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMtdi {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "JtagMtdi {{ jtm_tdi: {=u32:?} }}", self.jtm_tdi())
            }
        }
        #[doc = "JTAG Master TDO Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMtdo(pub u32);
        impl JtagMtdo {
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted into this register, starting with bit 0, from the JTAG_TDO pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub const fn jtm_tdo(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted into this register, starting with bit 0, from the JTAG_TDO pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub fn set_jtm_tdo(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for JtagMtdo {
            #[inline(always)]
            fn default() -> JtagMtdo {
                JtagMtdo(0)
            }
        }
        impl core::fmt::Debug for JtagMtdo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMtdo").field("jtm_tdo", &self.jtm_tdo()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMtdo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "JtagMtdo {{ jtm_tdo: {=u32:?} }}", self.jtm_tdo())
            }
        }
        #[doc = "JTAG Master TMS Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct JtagMtms(pub u32);
        impl JtagMtms {
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0, onto the JTAG_TMS pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub const fn jtm_tms(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0, onto the JTAG_TMS pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register."]
            #[inline(always)]
            pub fn set_jtm_tms(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for JtagMtms {
            #[inline(always)]
            fn default() -> JtagMtms {
                JtagMtms(0)
            }
        }
        impl core::fmt::Debug for JtagMtms {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("JtagMtms").field("jtm_tms", &self.jtm_tms()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for JtagMtms {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "JtagMtms {{ jtm_tms: {=u32:?} }}", self.jtm_tms())
            }
        }
        #[doc = "OTP Lock"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OtpLock(pub u32);
        impl OtpLock {
            #[doc = "Test"]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Test"]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit controls access to Microchip region of the eFuse memory, bytes 32 to 127. Once written, this bit becomes Read Only. If the JTAG_EN bit is 1 (enabled), the Private Key is inaccessible, independent of the state of this bit. 1=The Microchip region is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The Microchip region is accessible."]
            #[inline(always)]
            pub const fn mchip_lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls access to Microchip region of the eFuse memory, bytes 32 to 127. Once written, this bit becomes Read Only. If the JTAG_EN bit is 1 (enabled), the Private Key is inaccessible, independent of the state of this bit. 1=The Microchip region is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The Microchip region is accessible."]
            #[inline(always)]
            pub fn set_mchip_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit controls access to Private Key region of the eFuse memory, bytes 0 to 31. Once written, this bit becomes Read Only. If the JTAG_EN bit is 1 (enabled), the Private Key is inaccessible, independent of the state of this bit. 1=The Private Key is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The Private Key is accessible."]
            #[inline(always)]
            pub const fn priv_key_lock(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls access to Private Key region of the eFuse memory, bytes 0 to 31. Once written, this bit becomes Read Only. If the JTAG_EN bit is 1 (enabled), the Private Key is inaccessible, independent of the state of this bit. 1=The Private Key is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The Private Key is accessible."]
            #[inline(always)]
            pub fn set_priv_key_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit controls access to the User region of the eFuse memory, bytes 192 to 511. Once written, this bit becomes Read Only. If the JTAG_EN bit is 1 (enabled), the User region is inaccessible, independent of the state of this bit. 1=The User region is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The User region is accessible"]
            #[inline(always)]
            pub const fn user_otp_lock(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls access to the User region of the eFuse memory, bytes 192 to 511. Once written, this bit becomes Read Only. If the JTAG_EN bit is 1 (enabled), the User region is inaccessible, independent of the state of this bit. 1=The User region is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The User region is accessible"]
            #[inline(always)]
            pub fn set_user_otp_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit controls access to the Public Key region of the eFuse memory, bytes 128 to 191. Once written, this bit becomes Read Only. If the JTAG_EN bit is 1 (enabled), the Public Key is inaccessible, independent of the state of this bit. 1=The Public Key is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The Public Key is accessible"]
            #[inline(always)]
            pub const fn pub_key_lock(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls access to the Public Key region of the eFuse memory, bytes 128 to 191. Once written, this bit becomes Read Only. If the JTAG_EN bit is 1 (enabled), the Public Key is inaccessible, independent of the state of this bit. 1=The Public Key is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The Public Key is accessible"]
            #[inline(always)]
            pub fn set_pub_key_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for OtpLock {
            #[inline(always)]
            fn default() -> OtpLock {
                OtpLock(0)
            }
        }
        impl core::fmt::Debug for OtpLock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OtpLock")
                    .field("test", &self.test())
                    .field("mchip_lock", &self.mchip_lock())
                    .field("priv_key_lock", &self.priv_key_lock())
                    .field("user_otp_lock", &self.user_otp_lock())
                    .field("pub_key_lock", &self.pub_key_lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OtpLock {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "OtpLock {{ test: {=bool:?}, mchip_lock: {=bool:?}, priv_key_lock: {=bool:?}, user_otp_lock: {=bool:?}, pub_key_lock: {=bool:?} }}" , self . test () , self . mchip_lock () , self . priv_key_lock () , self . user_otp_lock () , self . pub_key_lock ())
            }
        }
        #[doc = "PECI Disable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PeciDis(pub u32);
        impl PeciDis {
            #[doc = "When this bit is asserted 1, it disables the PECI pads to reduce leakage."]
            #[inline(always)]
            pub const fn peci_disable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is asserted 1, it disables the PECI pads to reduce leakage."]
            #[inline(always)]
            pub fn set_peci_disable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for PeciDis {
            #[inline(always)]
            fn default() -> PeciDis {
                PeciDis(0)
            }
        }
        impl core::fmt::Debug for PeciDis {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PeciDis")
                    .field("peci_disable", &self.peci_disable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PeciDis {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PeciDis {{ peci_disable: {=bool:?} }}", self.peci_disable())
            }
        }
        #[doc = "AES HASH Byte Swap Control Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SysShutdwnRst(pub u32);
        impl SysShutdwnRst {
            #[doc = "When this bit is asserted 1, the SYS_SHDN# output is deasserted"]
            #[inline(always)]
            pub const fn sys_shdn_rst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is asserted 1, the SYS_SHDN# output is deasserted"]
            #[inline(always)]
            pub fn set_sys_shdn_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SysShutdwnRst {
            #[inline(always)]
            fn default() -> SysShutdwnRst {
                SysShutdwnRst(0)
            }
        }
        impl core::fmt::Debug for SysShutdwnRst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SysShutdwnRst")
                    .field("sys_shdn_rst", &self.sys_shdn_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SysShutdwnRst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SysShutdwnRst {{ sys_shdn_rst: {=bool:?} }}", self.sys_shdn_rst())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IpBlkSwapEn {
            #[doc = "0=Disable."]
            DIS = 0x0,
            #[doc = "1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4, 0x0, 0xC, 0x8, ..."]
            SWAP_8_BYTE_BLOCK = 0x01,
            #[doc = "2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,..."]
            SWAP_16_BYTE_BLOCK = 0x02,
            #[doc = "3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C, 0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,..."]
            SWAP_64_BYTE_BLOCK = 0x03,
            #[doc = "4=Swap 32-bit doublewords in 128-byte blocks"]
            SWAP_128_BYTE_BLOCK = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl IpBlkSwapEn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IpBlkSwapEn {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IpBlkSwapEn {
            #[inline(always)]
            fn from(val: u8) -> IpBlkSwapEn {
                IpBlkSwapEn::from_bits(val)
            }
        }
        impl From<IpBlkSwapEn> for u8 {
            #[inline(always)]
            fn from(val: IpBlkSwapEn) -> u8 {
                IpBlkSwapEn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum JtmClk {
            _RESERVED_0 = 0x0,
            #[doc = "1=24MHz"]
            JTM_CLK_24MHZ = 0x01,
            #[doc = "2=12Mhz"]
            JTM_CLK_12MHZ = 0x02,
            #[doc = "3=6Mhz"]
            JTM_CLK_6MHZ = 0x03,
            #[doc = "4=3Mhz"]
            JTM_CLK_3MHZ = 0x04,
            #[doc = "5=1.5Mhz"]
            JTM_CLK_1MHZ = 0x05,
            #[doc = "6=750KHz"]
            JTM_CLK_750KHZ = 0x06,
            #[doc = "7=375KHz"]
            JTM_CLK_375KHZ = 0x07,
        }
        impl JtmClk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> JtmClk {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for JtmClk {
            #[inline(always)]
            fn from(val: u8) -> JtmClk {
                JtmClk::from_bits(val)
            }
        }
        impl From<JtmClk> for u8 {
            #[inline(always)]
            fn from(val: JtmClk) -> u8 {
                JtmClk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum OpBlkSwapEn {
            #[doc = "0=Disable."]
            DIS = 0x0,
            #[doc = "1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4, 0x0, 0xC, 0x8, ..."]
            SWAP_8_BYTE_BLOCK = 0x01,
            #[doc = "2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,..."]
            SWAP_16_BYTE_BLOCK = 0x02,
            #[doc = "3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C, 0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,..."]
            SWAP_64_BYTE_BLOCK = 0x03,
            #[doc = "4=Swap 32-bit doublewords in 128-byte blocks"]
            SWAP_128_BYTE_BLOCK = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl OpBlkSwapEn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> OpBlkSwapEn {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for OpBlkSwapEn {
            #[inline(always)]
            fn from(val: u8) -> OpBlkSwapEn {
                OpBlkSwapEn::from_bits(val)
            }
        }
        impl From<OpBlkSwapEn> for u8 {
            #[inline(always)]
            fn from(val: OpBlkSwapEn) -> u8 {
                OpBlkSwapEn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PinCfg {
            #[doc = "0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high. This setting should be used when the JTAG TAP controller is required for debugging."]
            JTAG_TCK_TMS_TDO_TDI = 0x0,
            #[doc = "1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) and Serial Wire Viewer (SWV) are both required for debugging"]
            JTAG_TCK_TMS_TDO = 0x01,
            #[doc = "2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required"]
            JTAG_TCK_TMS = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PinCfg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PinCfg {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PinCfg {
            #[inline(always)]
            fn from(val: u8) -> PinCfg {
                PinCfg::from_bits(val)
            }
        }
        impl From<PinCfg> for u8 {
            #[inline(always)]
            fn from(val: PinCfg) -> u8 {
                PinCfg::to_bits(val)
            }
        }
    }
}
pub mod ecia {
    #[doc = "The interrupt generation logic is made of 16 groups of signals, each of which consist of a Status register, a Enable register and a Result register. The Status and Enable are latched registers. The Result register is a bit by bit AND function of the Source and Enable registers. All the bits of the Result register are OR'ed together and AND'ed with the corresponding bit in the Block Select register to form the interrupt signal that is routed to the ARM interrupt controller."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ecia {
        ptr: *mut u8,
    }
    unsafe impl Send for Ecia {}
    unsafe impl Sync for Ecia {}
    impl Ecia {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[inline(always)]
        pub const fn girq(self, n: usize) -> Girq {
            assert!(n < 19usize);
            unsafe { Girq::from_ptr(self.ptr.add(0x0usize + n * 20usize) as _) }
        }
        #[doc = "Block Enable Set Register"]
        #[inline(always)]
        pub const fn blk_en_set(self) -> crate::common::Reg<regs::BlkEnSet, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Block Enable Clear Register."]
        #[inline(always)]
        pub const fn blk_en_clr(self) -> crate::common::Reg<regs::BlkEnClr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize) as _) }
        }
        #[doc = "Block IRQ Vector Register"]
        #[inline(always)]
        pub const fn blk_irq_vtor(self) -> crate::common::Reg<regs::BlkIrqVtor, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Girq {
        ptr: *mut u8,
    }
    unsafe impl Send for Girq {}
    unsafe impl Sync for Girq {}
    impl Girq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Status R/W1C"]
        #[inline(always)]
        pub const fn src(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Write to set source enables"]
        #[inline(always)]
        pub const fn en_set(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Read-only bitwise OR of Source and Enable"]
        #[inline(always)]
        pub const fn result(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Write to clear source enables"]
        #[inline(always)]
        pub const fn en_clr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Block Enable Clear Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BlkEnClr(pub u32);
        impl BlkEnClr {
            #[doc = "Each GIRQx bit can be individually disabled to inhibit an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_ CLEAR bit. (0=disabled, 1=enabled) (R/WC) 1=All interrupts in the GIRQx Source Register are disabled 0=No effect."]
            #[inline(always)]
            pub const fn vtor_en_clr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "Each GIRQx bit can be individually disabled to inhibit an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_ CLEAR bit. (0=disabled, 1=enabled) (R/WC) 1=All interrupts in the GIRQx Source Register are disabled 0=No effect."]
            #[inline(always)]
            pub fn set_vtor_en_clr(&mut self, val: u32) {
                self.0 = (self.0 & !(0x7fff_ffff << 0usize)) | (((val as u32) & 0x7fff_ffff) << 0usize);
            }
        }
        impl Default for BlkEnClr {
            #[inline(always)]
            fn default() -> BlkEnClr {
                BlkEnClr(0)
            }
        }
        impl core::fmt::Debug for BlkEnClr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BlkEnClr")
                    .field("vtor_en_clr", &self.vtor_en_clr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BlkEnClr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BlkEnClr {{ vtor_en_clr: {=u32:?} }}", self.vtor_en_clr())
            }
        }
        #[doc = "Block Enable Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BlkEnSet(pub u32);
        impl BlkEnSet {
            #[doc = "Each GIRQx bit can be individually enabled to assert an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_ CLEAR bit. (0=disabled, 1=enabled) (R/WS) 1=Interrupts in the GIRQx Source Register may be enabled 0=No effect."]
            #[inline(always)]
            pub const fn vtor_en_set(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "Each GIRQx bit can be individually enabled to assert an interrupt event. Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_ CLEAR bit. (0=disabled, 1=enabled) (R/WS) 1=Interrupts in the GIRQx Source Register may be enabled 0=No effect."]
            #[inline(always)]
            pub fn set_vtor_en_set(&mut self, val: u32) {
                self.0 = (self.0 & !(0x7fff_ffff << 0usize)) | (((val as u32) & 0x7fff_ffff) << 0usize);
            }
        }
        impl Default for BlkEnSet {
            #[inline(always)]
            fn default() -> BlkEnSet {
                BlkEnSet(0)
            }
        }
        impl core::fmt::Debug for BlkEnSet {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BlkEnSet")
                    .field("vtor_en_set", &self.vtor_en_set())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BlkEnSet {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BlkEnSet {{ vtor_en_set: {=u32:?} }}", self.vtor_en_set())
            }
        }
        #[doc = "Block IRQ Vector Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BlkIrqVtor(pub u32);
        impl BlkIrqVtor {
            #[doc = "Each bit in this field reports the status of the group GIRQ interrupt assertion to the NVIC. If the GIRQx interrupt is disabled as a group, by the Block Enable Clear Register, then the corresponding bit will be '0'b and no interrupt will be asserted."]
            #[inline(always)]
            pub const fn vtor(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x01ff_ffff;
                val as u32
            }
            #[doc = "Each bit in this field reports the status of the group GIRQ interrupt assertion to the NVIC. If the GIRQx interrupt is disabled as a group, by the Block Enable Clear Register, then the corresponding bit will be '0'b and no interrupt will be asserted."]
            #[inline(always)]
            pub fn set_vtor(&mut self, val: u32) {
                self.0 = (self.0 & !(0x01ff_ffff << 0usize)) | (((val as u32) & 0x01ff_ffff) << 0usize);
            }
        }
        impl Default for BlkIrqVtor {
            #[inline(always)]
            fn default() -> BlkIrqVtor {
                BlkIrqVtor(0)
            }
        }
        impl core::fmt::Debug for BlkIrqVtor {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BlkIrqVtor").field("vtor", &self.vtor()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BlkIrqVtor {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BlkIrqVtor {{ vtor: {=u32:?} }}", self.vtor())
            }
        }
    }
}
pub mod efuse {
    #[doc = "The eFUSE block provides a means of programming and accessing the eFUSE bits."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Efuse {
        ptr: *mut u8,
    }
    unsafe impl Send for Efuse {}
    unsafe impl Sync for Efuse {}
    impl Efuse {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "eFUSE CTRL Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Manual Control Register"]
        #[inline(always)]
        pub const fn man_ctrl(self) -> crate::common::Reg<regs::ManCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "MANUAL MODE ADDRESS REGISTER"]
        #[inline(always)]
        pub const fn man_mod_addr(self) -> crate::common::Reg<regs::ManModAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "MANUAL MODE DATA REGISTER"]
        #[inline(always)]
        pub const fn man_mod_data(self) -> crate::common::Reg<regs::ManModData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "512 Bytes of EFUSE Memory (IP_MEM) Represented in 128 DW chunks: eFUSE memory read-back data. Access to this region depends on the operating mode: NORMAL MODE: Reading any of the bytes starting at this base will automatically start the controller to sequence all eFUSE signals to generate read data. Wait cycles added to the read cycle as appropriate. MANUAL MODE: Refer to the manual mode section for the proper procedure for accessing data in this mode. See REG_MAN_CTRL.MAN_EN and REG_CTRL.EXT_PRGM bits for controlling the operating mode of the block."]
        #[inline(always)]
        pub const fn mem_dw(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 128usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "eFUSE CTRL Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u16);
        impl Ctrl {
            #[doc = "Block enable: 1=block is enabled for operation; 0=block is disabled and in lowest power state."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Block enable: 1=block is enabled for operation; 0=block is disabled and in lowest power state."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "Block reset: 1=Block is reset; 0=Normal operation. This bit self-clears and always reads back 0."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Block reset: 1=Block is reset; 0=Normal operation. This bit self-clears and always reads back 0."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u16) & 0x01) << 1usize);
            }
            #[doc = "External programming enable: 1=eFUSE programming is done via external pin interface 0=Manual/Normal mode. eFUSE programming is done via this block's register set."]
            #[inline(always)]
            pub const fn ext_pgm(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "External programming enable: 1=eFUSE programming is done via external pin interface 0=Manual/Normal mode. eFUSE programming is done via this block's register set."]
            #[inline(always)]
            pub fn set_ext_pgm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u16) & 0x01) << 2usize);
            }
            #[doc = "FSOURCE pin enable for programming: 1=FSOURCE switch logic connects eFUSE FSOURCE pin to a power pad for PROGRAM mode. Only set this bit when FSOURCE_EN_READ bit is already 0 to avoid shorting the power pad to ground; 0=FSOURCE switch logic isolates eFUSE FSOURCE pin from power pad."]
            #[inline(always)]
            pub const fn fsource_en_prgm(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "FSOURCE pin enable for programming: 1=FSOURCE switch logic connects eFUSE FSOURCE pin to a power pad for PROGRAM mode. Only set this bit when FSOURCE_EN_READ bit is already 0 to avoid shorting the power pad to ground; 0=FSOURCE switch logic isolates eFUSE FSOURCE pin from power pad."]
            #[inline(always)]
            pub fn set_fsource_en_prgm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u16) & 0x01) << 3usize);
            }
            #[doc = "FSOURCE pin enable for reading: 1=FSOURCE switch logic connects eFUSE FSOURCE pin to a power pad for read mode. Only set this bit when FSOURCE_EN_PRGM bit is already 0 to avoid shorting the power pad to ground; 0=FSOURCE switch logic isolates eFUSE FSOURCE pin from ground."]
            #[inline(always)]
            pub const fn fsource_en_read(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "FSOURCE pin enable for reading: 1=FSOURCE switch logic connects eFUSE FSOURCE pin to a power pad for read mode. Only set this bit when FSOURCE_EN_PRGM bit is already 0 to avoid shorting the power pad to ground; 0=FSOURCE switch logic isolates eFUSE FSOURCE pin from ground."]
            #[inline(always)]
            pub fn set_fsource_en_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u16) & 0x01) << 4usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("en", &self.en())
                    .field("rst", &self.rst())
                    .field("ext_pgm", &self.ext_pgm())
                    .field("fsource_en_prgm", &self.fsource_en_prgm())
                    .field("fsource_en_read", &self.fsource_en_read())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ en: {=bool:?}, rst: {=bool:?}, ext_pgm: {=bool:?}, fsource_en_prgm: {=bool:?}, fsource_en_read: {=bool:?} }}" , self . en () , self . rst () , self . ext_pgm () , self . fsource_en_prgm () , self . fsource_en_read ())
            }
        }
        #[doc = "Manual Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ManCtrl(pub u16);
        impl ManCtrl {
            #[doc = "Manual mode enable bit: 1=Manual mode is enabled and this register interfaces to the eFUSE; 0=Normal mode, internal controller interfaces to eFUSE IP. This bit only takes affect when REG_CTRL.EXT_PRGM bit is 0."]
            #[inline(always)]
            pub const fn man_enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Manual mode enable bit: 1=Manual mode is enabled and this register interfaces to the eFUSE; 0=Normal mode, internal controller interfaces to eFUSE IP. This bit only takes affect when REG_CTRL.EXT_PRGM bit is 0."]
            #[inline(always)]
            pub fn set_man_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "eFUSE chip select (CS) pin: 1=eFUSE is enabled for PROGRAM/READ modes; 0=eFUSE is disabled and in low power state."]
            #[inline(always)]
            pub const fn ip_cs(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "eFUSE chip select (CS) pin: 1=eFUSE is enabled for PROGRAM/READ modes; 0=eFUSE is disabled and in low power state."]
            #[inline(always)]
            pub fn set_ip_cs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u16) & 0x01) << 1usize);
            }
            #[doc = "eFUSE program enable. Can also be considered the write signal: 1=eFUSE is programming; 0=eFUSE is in read mode."]
            #[inline(always)]
            pub const fn ip_prgm_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "eFUSE program enable. Can also be considered the write signal: 1=eFUSE is programming; 0=eFUSE is in read mode."]
            #[inline(always)]
            pub fn set_ip_prgm_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u16) & 0x01) << 2usize);
            }
            #[doc = "eFUSE precharge: 1=outputs are being precharged; 0=outputs are not precharged."]
            #[inline(always)]
            pub const fn ip_prchg(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "eFUSE precharge: 1=outputs are being precharged; 0=outputs are not precharged."]
            #[inline(always)]
            pub fn set_ip_prchg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u16) & 0x01) << 3usize);
            }
            #[doc = "eFUSE sense, outputs are valid on falling edge of this bit."]
            #[inline(always)]
            pub const fn ip_sense_pulse(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "eFUSE sense, outputs are valid on falling edge of this bit."]
            #[inline(always)]
            pub fn set_ip_sense_pulse(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u16) & 0x01) << 4usize);
            }
            #[doc = "eFUSE output enable. The IP might tri-state at various times, so this bit isolates the outputs to avoid potential crowbar. 1=eFUSE outputs enabled for read; 0=eFUSE outputs isolated"]
            #[inline(always)]
            pub const fn ip_oe(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "eFUSE output enable. The IP might tri-state at various times, so this bit isolates the outputs to avoid potential crowbar. 1=eFUSE outputs enabled for read; 0=eFUSE outputs isolated"]
            #[inline(always)]
            pub fn set_ip_oe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u16) & 0x01) << 5usize);
            }
        }
        impl Default for ManCtrl {
            #[inline(always)]
            fn default() -> ManCtrl {
                ManCtrl(0)
            }
        }
        impl core::fmt::Debug for ManCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ManCtrl")
                    .field("man_enable", &self.man_enable())
                    .field("ip_cs", &self.ip_cs())
                    .field("ip_prgm_en", &self.ip_prgm_en())
                    .field("ip_prchg", &self.ip_prchg())
                    .field("ip_sense_pulse", &self.ip_sense_pulse())
                    .field("ip_oe", &self.ip_oe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ManCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ManCtrl {{ man_enable: {=bool:?}, ip_cs: {=bool:?}, ip_prgm_en: {=bool:?}, ip_prchg: {=bool:?}, ip_sense_pulse: {=bool:?}, ip_oe: {=bool:?} }}" , self . man_enable () , self . ip_cs () , self . ip_prgm_en () , self . ip_prchg () , self . ip_sense_pulse () , self . ip_oe ())
            }
        }
        #[doc = "MANUAL MODE ADDRESS REGISTER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ManModAddr(pub u32);
        impl ManModAddr {
            #[doc = "Manual mode address, selecting the bit address within a 1K bit block."]
            #[inline(always)]
            pub const fn ip_addr_lo(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Manual mode address, selecting the bit address within a 1K bit block."]
            #[inline(always)]
            pub fn set_ip_addr_lo(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
            #[doc = "Manual mode address, selecting a 1K bit block of eFuse data"]
            #[inline(always)]
            pub const fn ip_addr_hi(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x03;
                val as u8
            }
            #[doc = "Manual mode address, selecting a 1K bit block of eFuse data"]
            #[inline(always)]
            pub fn set_ip_addr_hi(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize);
            }
        }
        impl Default for ManModAddr {
            #[inline(always)]
            fn default() -> ManModAddr {
                ManModAddr(0)
            }
        }
        impl core::fmt::Debug for ManModAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ManModAddr")
                    .field("ip_addr_lo", &self.ip_addr_lo())
                    .field("ip_addr_hi", &self.ip_addr_hi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ManModAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "ManModAddr {{ ip_addr_lo: {=u16:?}, ip_addr_hi: {=u8:?} }}",
                    self.ip_addr_lo(),
                    self.ip_addr_hi()
                )
            }
        }
        #[doc = "MANUAL MODE DATA REGISTER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ManModData(pub u32);
        impl ManModData {
            #[doc = "Manual mode data: This field connects to the eFUSE data output pins."]
            #[inline(always)]
            pub const fn ip_data(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Manual mode data: This field connects to the eFUSE data output pins."]
            #[inline(always)]
            pub fn set_ip_data(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for ManModData {
            #[inline(always)]
            fn default() -> ManModData {
                ManModData(0)
            }
        }
        impl core::fmt::Debug for ManModData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ManModData").field("ip_data", &self.ip_data()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ManModData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ManModData {{ ip_data: {=u16:?} }}", self.ip_data())
            }
        }
    }
}
pub mod fan0 {
    #[doc = "The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors the fan's speed and automatically adjusts the drive to maintain the desired fan speed. This RPM based Fan Control Algorithm controls a PWM output based on a tachometer input."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fan0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Fan0 {}
    unsafe impl Sync for Fan0 {}
    impl Fan0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The Fan Driver Setting used to control the output of the Fan Driver."]
        #[inline(always)]
        pub const fn set(self) -> crate::common::Reg<regs::Set, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "The Fan Configuration Register controls the general operation of the RPM based Fan Control Algorithm used by the fan driver."]
        #[inline(always)]
        pub const fn cfg(self) -> crate::common::Reg<regs::Cfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "PWM Divide"]
        #[inline(always)]
        pub const fn pwm_div(self) -> crate::common::Reg<regs::PwmDiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Gain Register stores the gain terms used by the proportional and integral portions of the RPM based Fan Control Algorithm."]
        #[inline(always)]
        pub const fn gain(self) -> crate::common::Reg<regs::Gain, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "The Fan Spin Up Configuration Register controls the settings of Spin Up Routine."]
        #[inline(always)]
        pub const fn spin_up_cfg(self) -> crate::common::Reg<regs::SpinUpCfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "FAN_STEP The Fan Step value represents the maximum step size the fan driver will take between update times"]
        #[inline(always)]
        pub const fn step(self) -> crate::common::Reg<regs::Step, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "the minimum drive setting for the RPM based Fan Control Algorithm."]
        #[inline(always)]
        pub const fn min_drive(self) -> crate::common::Reg<regs::MinDrive, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "The maximum TACH Reading Register value to indicate that the fan is spinning properly."]
        #[inline(always)]
        pub const fn val_tach_cnt(self) -> crate::common::Reg<regs::ValTachCnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "The number of Tach counts used by the Fan Drive Fail detection circuitry"]
        #[inline(always)]
        pub const fn drive_fail_band(self) -> crate::common::Reg<regs::DriveFailBand, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "The target tachometer value."]
        #[inline(always)]
        pub const fn tach_tgt(self) -> crate::common::Reg<regs::TachTgt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "15:3\\] The current tachometer reading value."]
        #[inline(always)]
        pub const fn tach_rd(self) -> crate::common::Reg<regs::TachRd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "1:0\\] Determines the frequency range of the PWM fan driver"]
        #[inline(always)]
        pub const fn driv_base_freq(self) -> crate::common::Reg<regs::DrivBaseFreq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "The bits in this register are routed to interrupts."]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x11usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "The Fan Configuration Register controls the general operation of the RPM based Fan Control Algorithm used by the fan driver."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfg(pub u16);
        impl Cfg {
            #[doc = "Determines the base time between fan driver updates. The Update Time, along with the Fan Step Register, is used to control the ramp rate of the drive response to provide a cleaner transition of the actual fan operation as the desired fan speed changes. 7=1600ms 6=1200ms 5=800ms 4=500ms 3=400ms 2=300ms 1=200ms 0=100ms Note: This ramp rate control applies for all changes to the active PWM output including when the RPM based Fan Speed Control Algorithm is disabled."]
            #[inline(always)]
            pub const fn update(&self) -> super::vals::Update {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Update::from_bits(val as u8)
            }
            #[doc = "Determines the base time between fan driver updates. The Update Time, along with the Fan Step Register, is used to control the ramp rate of the drive response to provide a cleaner transition of the actual fan operation as the desired fan speed changes. 7=1600ms 6=1200ms 5=800ms 4=500ms 3=400ms 2=300ms 1=200ms 0=100ms Note: This ramp rate control applies for all changes to the active PWM output including when the RPM based Fan Speed Control Algorithm is disabled."]
            #[inline(always)]
            pub fn set_update(&mut self, val: super::vals::Update) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u16) & 0x07) << 0usize);
            }
            #[doc = "Determines the minimum number of edges that must be detected on the TACH signal to determine a single rotation. A typical fan measured 5 edges (for a 2-pole fan). Increasing the number of edges measured with respect to the number of poles of the fan will cause the TACH Reading registers to indicate a fan speed that is higher or lower than the actual speed. In order for the FSC Algorithm to operate correctly, the TACH Target must be updated by the user to accommodate this shift. The Effective Tach Multiplier is used as a direct multiplier term that is applied to the Actual RPM to achieve the Reported RPM. It should only be applied if the number of edges measured does not match the number of edges expected based on the number of poles of the fan (which is fixed for any given fan)."]
            #[inline(always)]
            pub const fn edges(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x03;
                val as u8
            }
            #[doc = "Determines the minimum number of edges that must be detected on the TACH signal to determine a single rotation. A typical fan measured 5 edges (for a 2-pole fan). Increasing the number of edges measured with respect to the number of poles of the fan will cause the TACH Reading registers to indicate a fan speed that is higher or lower than the actual speed. In order for the FSC Algorithm to operate correctly, the TACH Target must be updated by the user to accommodate this shift. The Effective Tach Multiplier is used as a direct multiplier term that is applied to the Actual RPM to achieve the Reported RPM. It should only be applied if the number of edges measured does not match the number of edges expected based on the number of poles of the fan (which is fixed for any given fan)."]
            #[inline(always)]
            pub fn set_edges(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val as u16) & 0x03) << 3usize);
            }
            #[doc = "Adjusts the range of reported and programmed tachometer reading values. The RANGE bits determine the weighting of all TACH values (including the Valid TACH Count, TACH Target, and TACH reading). 3=Reported Minimum RPM: 4000. Tach Count Multiplier: 1 2=Reported Minimum RPM: 2000. Tach Count Multiplier: 2 1=Reported Minimum RPM: 1000. Tach Count Multiplier: 4 0=Reported Minimum RPM: 500. Tach Count Multiplier: 8"]
            #[inline(always)]
            pub const fn range(&self) -> super::vals::Range {
                let val = (self.0 >> 5usize) & 0x03;
                super::vals::Range::from_bits(val as u8)
            }
            #[doc = "Adjusts the range of reported and programmed tachometer reading values. The RANGE bits determine the weighting of all TACH values (including the Valid TACH Count, TACH Target, and TACH reading). 3=Reported Minimum RPM: 4000. Tach Count Multiplier: 1 2=Reported Minimum RPM: 2000. Tach Count Multiplier: 2 1=Reported Minimum RPM: 1000. Tach Count Multiplier: 4 0=Reported Minimum RPM: 500. Tach Count Multiplier: 8"]
            #[inline(always)]
            pub fn set_range(&mut self, val: super::vals::Range) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val.to_bits() as u16) & 0x03) << 5usize);
            }
            #[doc = "Enables the RPM based Fan Control Algorithm. 1=The control circuitry is enabled and the Fan Driver output will be automatically updated to maintain the programmed fan speed as indicated by the TACH Target Register. 0=The control circuitry is disabled and the fan driver output is determined by the Fan Driver Setting Register."]
            #[inline(always)]
            pub const fn en_algo(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the RPM based Fan Control Algorithm. 1=The control circuitry is enabled and the Fan Driver output will be automatically updated to maintain the programmed fan speed as indicated by the TACH Target Register. 0=The control circuitry is disabled and the fan driver output is determined by the Fan Driver Setting Register."]
            #[inline(always)]
            pub fn set_en_algo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u16) & 0x01) << 7usize);
            }
            #[doc = "Determines the polarity of the PWM driver. This does NOT affect the drive setting registers. A setting of 0% drive will still correspond to 0% drive independent of the polarity. 1 - The Polarity of the PWM driver is inverted. A drive setting of 00h will cause the output to be set at 100% duty cycle and a drive setting of FFh will cause the output to be set at 0% duty cycle. 0 - the Polarity of the PWM driver is normal. A drive setting of 00h will cause the output to be set at 0% duty cycle and a drive setting of FFh will cause the output to be set at 100% duty cycle."]
            #[inline(always)]
            pub const fn polarity(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Determines the polarity of the PWM driver. This does NOT affect the drive setting registers. A setting of 0% drive will still correspond to 0% drive independent of the polarity. 1 - The Polarity of the PWM driver is inverted. A drive setting of 00h will cause the output to be set at 100% duty cycle and a drive setting of FFh will cause the output to be set at 0% duty cycle. 0 - the Polarity of the PWM driver is normal. A drive setting of 00h will cause the output to be set at 0% duty cycle and a drive setting of FFh will cause the output to be set at 100% duty cycle."]
            #[inline(always)]
            pub fn set_polarity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u16) & 0x01) << 9usize);
            }
            #[doc = "Control some of the advanced options that affect the error window. When the measured fan speed is within the programmed error window around the target speed, the fan drive setting is not updated. These bits only apply if the Fan Speed Control Algorithm is used. 3=200 RPM 2=100 RPM 1=50 RPM 0=0 RPM"]
            #[inline(always)]
            pub const fn err_rng(&self) -> super::vals::ErrRng {
                let val = (self.0 >> 10usize) & 0x03;
                super::vals::ErrRng::from_bits(val as u8)
            }
            #[doc = "Control some of the advanced options that affect the error window. When the measured fan speed is within the programmed error window around the target speed, the fan drive setting is not updated. These bits only apply if the Fan Speed Control Algorithm is used. 3=200 RPM 2=100 RPM 1=50 RPM 0=0 RPM"]
            #[inline(always)]
            pub fn set_err_rng(&mut self, val: super::vals::ErrRng) {
                self.0 = (self.0 & !(0x03 << 10usize)) | (((val.to_bits() as u16) & 0x03) << 10usize);
            }
            #[doc = "Control some of the advanced options that affect the derivative portion of the RPM based fan control algorithm. These bits only apply if the Fan Speed Control Algorithm is used."]
            #[inline(always)]
            pub const fn der_opt(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x03;
                val as u8
            }
            #[doc = "Control some of the advanced options that affect the derivative portion of the RPM based fan control algorithm. These bits only apply if the Fan Speed Control Algorithm is used."]
            #[inline(always)]
            pub fn set_der_opt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 12usize)) | (((val as u16) & 0x03) << 12usize);
            }
            #[doc = "Disables the low pass glitch filter that removes high frequency noise injected on the TACH pin. 1 - The glitch filter is disabled. 0 - The glitch filter is enabled."]
            #[inline(always)]
            pub const fn dis_glitch(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Disables the low pass glitch filter that removes high frequency noise injected on the TACH pin. 1 - The glitch filter is disabled. 0 - The glitch filter is enabled."]
            #[inline(always)]
            pub fn set_dis_glitch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u16) & 0x01) << 14usize);
            }
            #[doc = "Enables the ramp rate control circuitry during the Manual Mode of operation. 1=The ramp rate control circuitry for the Manual Mode of operation is enabled. The PWM setting will follow the ramp rate controls as determined by the Fan Step and Update Time settings. The maximum PWM step is capped at the Fan Step setting and is updated based on the Update Time as given by the field UPDATE. 0=The ramp rate control circuitry for the Manual Mode of operation is disabled. When the Fan Drive Setting values are changed and the RPM based Fan Control Algorithm is disabled, the fan driver will be set to the new setting immediately."]
            #[inline(always)]
            pub const fn en_rrc(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the ramp rate control circuitry during the Manual Mode of operation. 1=The ramp rate control circuitry for the Manual Mode of operation is enabled. The PWM setting will follow the ramp rate controls as determined by the Fan Step and Update Time settings. The maximum PWM step is capped at the Fan Step setting and is updated based on the Update Time as given by the field UPDATE. 0=The ramp rate control circuitry for the Manual Mode of operation is disabled. When the Fan Drive Setting values are changed and the RPM based Fan Control Algorithm is disabled, the fan driver will be set to the new setting immediately."]
            #[inline(always)]
            pub fn set_en_rrc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Cfg {
            #[inline(always)]
            fn default() -> Cfg {
                Cfg(0)
            }
        }
        impl core::fmt::Debug for Cfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfg")
                    .field("update", &self.update())
                    .field("edges", &self.edges())
                    .field("range", &self.range())
                    .field("en_algo", &self.en_algo())
                    .field("polarity", &self.polarity())
                    .field("err_rng", &self.err_rng())
                    .field("der_opt", &self.der_opt())
                    .field("dis_glitch", &self.dis_glitch())
                    .field("en_rrc", &self.en_rrc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cfg {{ update: {:?}, edges: {=u8:?}, range: {:?}, en_algo: {=bool:?}, polarity: {=bool:?}, err_rng: {:?}, der_opt: {=u8:?}, dis_glitch: {=bool:?}, en_rrc: {=bool:?} }}" , self . update () , self . edges () , self . range () , self . en_algo () , self . polarity () , self . err_rng () , self . der_opt () , self . dis_glitch () , self . en_rrc ())
            }
        }
        #[doc = "1:0\\] Determines the frequency range of the PWM fan driver"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DrivBaseFreq(pub u8);
        impl DrivBaseFreq {
            #[doc = "Determines the frequency range of the PWM fan driver (when enabled). PWM resolution is 10-bit, except when this field is set to '0b', when it is 8-bit. 3=2.34KHz 2=4.67KHz 1=23.4KHz 0=26.8KHz"]
            #[inline(always)]
            pub const fn pwm_base(&self) -> super::vals::PwmBase {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::PwmBase::from_bits(val as u8)
            }
            #[doc = "Determines the frequency range of the PWM fan driver (when enabled). PWM resolution is 10-bit, except when this field is set to '0b', when it is 8-bit. 3=2.34KHz 2=4.67KHz 1=23.4KHz 0=26.8KHz"]
            #[inline(always)]
            pub fn set_pwm_base(&mut self, val: super::vals::PwmBase) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for DrivBaseFreq {
            #[inline(always)]
            fn default() -> DrivBaseFreq {
                DrivBaseFreq(0)
            }
        }
        impl core::fmt::Debug for DrivBaseFreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DrivBaseFreq")
                    .field("pwm_base", &self.pwm_base())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DrivBaseFreq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DrivBaseFreq {{ pwm_base: {:?} }}", self.pwm_base())
            }
        }
        #[doc = "The number of Tach counts used by the Fan Drive Fail detection circuitry"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DriveFailBand(pub u16);
        impl DriveFailBand {
            #[doc = "The number of Tach counts used by the Fan Drive Fail detection circuitry."]
            #[inline(always)]
            pub const fn fan_drive_fail_band(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x1fff;
                val as u16
            }
            #[doc = "The number of Tach counts used by the Fan Drive Fail detection circuitry."]
            #[inline(always)]
            pub fn set_fan_drive_fail_band(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 3usize)) | (((val as u16) & 0x1fff) << 3usize);
            }
        }
        impl Default for DriveFailBand {
            #[inline(always)]
            fn default() -> DriveFailBand {
                DriveFailBand(0)
            }
        }
        impl core::fmt::Debug for DriveFailBand {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DriveFailBand")
                    .field("fan_drive_fail_band", &self.fan_drive_fail_band())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DriveFailBand {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DriveFailBand {{ fan_drive_fail_band: {=u16:?} }}",
                    self.fan_drive_fail_band()
                )
            }
        }
        #[doc = "Gain Register stores the gain terms used by the proportional and integral portions of the RPM based Fan Control Algorithm."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gain(pub u8);
        impl Gain {
            #[doc = "The proportional gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub const fn gainp(&self) -> super::vals::Gainp {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Gainp::from_bits(val as u8)
            }
            #[doc = "The proportional gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub fn set_gainp(&mut self, val: super::vals::Gainp) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "The integral gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub const fn gaini(&self) -> super::vals::Gaini {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Gaini::from_bits(val as u8)
            }
            #[doc = "The integral gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub fn set_gaini(&mut self, val: super::vals::Gaini) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u8) & 0x03) << 2usize);
            }
            #[doc = "The derivative gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub const fn gaind(&self) -> super::vals::Gaind {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Gaind::from_bits(val as u8)
            }
            #[doc = "The derivative gain term. Gain Factor: 3=8x 2=4x 1=2x 0=1x"]
            #[inline(always)]
            pub fn set_gaind(&mut self, val: super::vals::Gaind) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
        }
        impl Default for Gain {
            #[inline(always)]
            fn default() -> Gain {
                Gain(0)
            }
        }
        impl core::fmt::Debug for Gain {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gain")
                    .field("gainp", &self.gainp())
                    .field("gaini", &self.gaini())
                    .field("gaind", &self.gaind())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gain {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gain {{ gainp: {:?}, gaini: {:?}, gaind: {:?} }}",
                    self.gainp(),
                    self.gaini(),
                    self.gaind()
                )
            }
        }
        #[doc = "the minimum drive setting for the RPM based Fan Control Algorithm."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MinDrive(pub u8);
        impl MinDrive {
            #[doc = "The minimum drive setting."]
            #[inline(always)]
            pub const fn min_drive(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The minimum drive setting."]
            #[inline(always)]
            pub fn set_min_drive(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for MinDrive {
            #[inline(always)]
            fn default() -> MinDrive {
                MinDrive(0)
            }
        }
        impl core::fmt::Debug for MinDrive {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MinDrive")
                    .field("min_drive", &self.min_drive())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MinDrive {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MinDrive {{ min_drive: {=u8:?} }}", self.min_drive())
            }
        }
        #[doc = "PWM Divide"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PwmDiv(pub u8);
        impl PwmDiv {
            #[doc = "The PWM Divide value determines the final frequency of the PWM driver. The driver base frequency is divided by the PWM Divide value to determine the final frequency."]
            #[inline(always)]
            pub const fn pwm_div(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The PWM Divide value determines the final frequency of the PWM driver. The driver base frequency is divided by the PWM Divide value to determine the final frequency."]
            #[inline(always)]
            pub fn set_pwm_div(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for PwmDiv {
            #[inline(always)]
            fn default() -> PwmDiv {
                PwmDiv(0)
            }
        }
        impl core::fmt::Debug for PwmDiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PwmDiv").field("pwm_div", &self.pwm_div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PwmDiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PwmDiv {{ pwm_div: {=u8:?} }}", self.pwm_div())
            }
        }
        #[doc = "The Fan Driver Setting used to control the output of the Fan Driver."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Set(pub u16);
        impl Set {
            #[doc = "The Fan Driver Setting used to control the output of the Fan Driver."]
            #[inline(always)]
            pub const fn fan_setting(&self) -> u16 {
                let val = (self.0 >> 6usize) & 0x03ff;
                val as u16
            }
            #[doc = "The Fan Driver Setting used to control the output of the Fan Driver."]
            #[inline(always)]
            pub fn set_fan_setting(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 6usize)) | (((val as u16) & 0x03ff) << 6usize);
            }
        }
        impl Default for Set {
            #[inline(always)]
            fn default() -> Set {
                Set(0)
            }
        }
        impl core::fmt::Debug for Set {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Set").field("fan_setting", &self.fan_setting()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Set {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Set {{ fan_setting: {=u16:?} }}", self.fan_setting())
            }
        }
        #[doc = "The Fan Spin Up Configuration Register controls the settings of Spin Up Routine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpinUpCfg(pub u8);
        impl SpinUpCfg {
            #[doc = "Determines the maximum Spin Time that the Spin Up Routine will run for. If a valid tachometer measurement is not detected before the Spin Time has elapsed, an interrupt will be generated. When the RPM based Fan Control Algorithm is active, the fan driver will attempt to re-start the fan immediately after the end of the last spin up attempt. 3=2 seconds 2=1 second 1=500 ms 0=250 ms"]
            #[inline(always)]
            pub const fn spinup_time(&self) -> super::vals::SpinupTime {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SpinupTime::from_bits(val as u8)
            }
            #[doc = "Determines the maximum Spin Time that the Spin Up Routine will run for. If a valid tachometer measurement is not detected before the Spin Time has elapsed, an interrupt will be generated. When the RPM based Fan Control Algorithm is active, the fan driver will attempt to re-start the fan immediately after the end of the last spin up attempt. 3=2 seconds 2=1 second 1=500 ms 0=250 ms"]
            #[inline(always)]
            pub fn set_spinup_time(&mut self, val: super::vals::SpinupTime) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Determines the final drive level that is used by the Spin Up Routine. 7=65% 6=60% 5=55% 4=50% 3=45% 2=40% 1=35% 0=30%"]
            #[inline(always)]
            pub const fn spin_lvl(&self) -> super::vals::SpinLvl {
                let val = (self.0 >> 2usize) & 0x07;
                super::vals::SpinLvl::from_bits(val as u8)
            }
            #[doc = "Determines the final drive level that is used by the Spin Up Routine. 7=65% 6=60% 5=55% 4=50% 3=45% 2=40% 1=35% 0=30%"]
            #[inline(always)]
            pub fn set_spin_lvl(&mut self, val: super::vals::SpinLvl) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val.to_bits() as u8) & 0x07) << 2usize);
            }
            #[doc = "Determines if the Spin Up Routine will drive the fan to 100% duty cycle for 1/4 of the programmed spin up time before driving it at the programmed level. 1=The Spin Up Routine will not drive the PWM to 100%. It will set the drive at the programmed spin level for the entire duration of the programmed spin up time 0=The Spin Up Routine will drive the PWM to 100% for 1/4 of the programmed spin up time before reverting to the programmed spin level."]
            #[inline(always)]
            pub const fn nokick(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Determines if the Spin Up Routine will drive the fan to 100% duty cycle for 1/4 of the programmed spin up time before driving it at the programmed level. 1=The Spin Up Routine will not drive the PWM to 100%. It will set the drive at the programmed spin level for the entire duration of the programmed spin up time 0=The Spin Up Routine will drive the PWM to 100% for 1/4 of the programmed spin up time before reverting to the programmed spin level."]
            #[inline(always)]
            pub fn set_nokick(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Determines how many update cycles are used for the Drive Fail detection function. This circuitry determines whether the fan can be driven to the desired Tach target. These settings only apply if the Fan Speed Control Algorithm is enabled. 3=Drive Fail detection circuitry will count for 64 update periods 2=Drive Fail detection circuitry will count for 32 update periods 1=Drive Fail detection circuitry will count for 16 update periods 0=Drive Fail detection circuitry is disabled."]
            #[inline(always)]
            pub const fn drive_fail_cnt(&self) -> super::vals::DriveFailCnt {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::DriveFailCnt::from_bits(val as u8)
            }
            #[doc = "Determines how many update cycles are used for the Drive Fail detection function. This circuitry determines whether the fan can be driven to the desired Tach target. These settings only apply if the Fan Speed Control Algorithm is enabled. 3=Drive Fail detection circuitry will count for 64 update periods 2=Drive Fail detection circuitry will count for 32 update periods 1=Drive Fail detection circuitry will count for 16 update periods 0=Drive Fail detection circuitry is disabled."]
            #[inline(always)]
            pub fn set_drive_fail_cnt(&mut self, val: super::vals::DriveFailCnt) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for SpinUpCfg {
            #[inline(always)]
            fn default() -> SpinUpCfg {
                SpinUpCfg(0)
            }
        }
        impl core::fmt::Debug for SpinUpCfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpinUpCfg")
                    .field("spinup_time", &self.spinup_time())
                    .field("spin_lvl", &self.spin_lvl())
                    .field("nokick", &self.nokick())
                    .field("drive_fail_cnt", &self.drive_fail_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpinUpCfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SpinUpCfg {{ spinup_time: {:?}, spin_lvl: {:?}, nokick: {=bool:?}, drive_fail_cnt: {:?} }}",
                    self.spinup_time(),
                    self.spin_lvl(),
                    self.nokick(),
                    self.drive_fail_cnt()
                )
            }
        }
        #[doc = "FAN_STEP The Fan Step value represents the maximum step size the fan driver will take between update times"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Step(pub u8);
        impl Step {
            #[doc = "The Fan Step value represents the maximum step size the fan driver will take between update times. When the PWM_BASE frequency range field in the PWM Driver Base Frequency Register is set to the value 1, 2 or 3, this 8-bit field is added to the 10-bit PWM duty cycle, for a maximum step size of 25%. When the PWM_BASE field is set to 0, the PWM operates in an 8-bit mode. In 8-bit mode, this 8-bit field is added to the 8-bit duty cycle, for a maximum step size of 100%."]
            #[inline(always)]
            pub const fn fan_step(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Fan Step value represents the maximum step size the fan driver will take between update times. When the PWM_BASE frequency range field in the PWM Driver Base Frequency Register is set to the value 1, 2 or 3, this 8-bit field is added to the 10-bit PWM duty cycle, for a maximum step size of 25%. When the PWM_BASE field is set to 0, the PWM operates in an 8-bit mode. In 8-bit mode, this 8-bit field is added to the 8-bit duty cycle, for a maximum step size of 100%."]
            #[inline(always)]
            pub fn set_fan_step(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Step {
            #[inline(always)]
            fn default() -> Step {
                Step(0)
            }
        }
        impl core::fmt::Debug for Step {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Step").field("fan_step", &self.fan_step()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Step {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Step {{ fan_step: {=u8:?} }}", self.fan_step())
            }
        }
        #[doc = "The bits in this register are routed to interrupts."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u8);
        impl Sts {
            #[doc = "The bit Indicates that the tachometer measurement on the Fan detects a stalled fan. (R/WC) 0 - Stalled fan not detected. 1 - Stalled fan detected."]
            #[inline(always)]
            pub const fn fan_stall(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The bit Indicates that the tachometer measurement on the Fan detects a stalled fan. (R/WC) 0 - Stalled fan not detected. 1 - Stalled fan detected."]
            #[inline(always)]
            pub fn set_fan_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "The bit Indicates that the Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum time window. (R/WC) 1 - The Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum time window. 0 - The Spin up Routine for the Fan detected a valid tachometer reading within its maximum time window."]
            #[inline(always)]
            pub const fn fan_spin(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The bit Indicates that the Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum time window. (R/WC) 1 - The Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum time window. 0 - The Spin up Routine for the Fan detected a valid tachometer reading within its maximum time window."]
            #[inline(always)]
            pub fn set_fan_spin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "The bit Indicates that the RPM-based Fan Speed Control Algorithm cannot drive the Fan to the desired target setting at maximum drive. (R/WC) 1- The RPM-based Fan Speed Control Algorithm cannot drive Fan to the desired target setting at maximum drive. 0- The RPM-based Fan Speed Control Algorithm can drive Fan to the desired target setting."]
            #[inline(always)]
            pub const fn drive_fail(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "The bit Indicates that the RPM-based Fan Speed Control Algorithm cannot drive the Fan to the desired target setting at maximum drive. (R/WC) 1- The RPM-based Fan Speed Control Algorithm cannot drive Fan to the desired target setting at maximum drive. 0- The RPM-based Fan Speed Control Algorithm can drive Fan to the desired target setting."]
            #[inline(always)]
            pub fn set_drive_fail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("fan_stall", &self.fan_stall())
                    .field("fan_spin", &self.fan_spin())
                    .field("drive_fail", &self.drive_fail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sts {{ fan_stall: {=bool:?}, fan_spin: {=bool:?}, drive_fail: {=bool:?} }}",
                    self.fan_stall(),
                    self.fan_spin(),
                    self.drive_fail()
                )
            }
        }
        #[doc = "15:3\\] The current tachometer reading value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TachRd(pub u16);
        impl TachRd {
            #[doc = "The current tachometer reading value."]
            #[inline(always)]
            pub const fn tach_rd(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x1fff;
                val as u16
            }
            #[doc = "The current tachometer reading value."]
            #[inline(always)]
            pub fn set_tach_rd(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 3usize)) | (((val as u16) & 0x1fff) << 3usize);
            }
        }
        impl Default for TachRd {
            #[inline(always)]
            fn default() -> TachRd {
                TachRd(0)
            }
        }
        impl core::fmt::Debug for TachRd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TachRd").field("tach_rd", &self.tach_rd()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TachRd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TachRd {{ tach_rd: {=u16:?} }}", self.tach_rd())
            }
        }
        #[doc = "The target tachometer value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TachTgt(pub u16);
        impl TachTgt {
            #[doc = "The target tachometer value."]
            #[inline(always)]
            pub const fn tach_tgt(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x1fff;
                val as u16
            }
            #[doc = "The target tachometer value."]
            #[inline(always)]
            pub fn set_tach_tgt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 3usize)) | (((val as u16) & 0x1fff) << 3usize);
            }
        }
        impl Default for TachTgt {
            #[inline(always)]
            fn default() -> TachTgt {
                TachTgt(0)
            }
        }
        impl core::fmt::Debug for TachTgt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TachTgt").field("tach_tgt", &self.tach_tgt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TachTgt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TachTgt {{ tach_tgt: {=u16:?} }}", self.tach_tgt())
            }
        }
        #[doc = "The maximum TACH Reading Register value to indicate that the fan is spinning properly."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ValTachCnt(pub u8);
        impl ValTachCnt {
            #[doc = "The maximum TACH Reading Register value to indicate that the fan is spinning properly."]
            #[inline(always)]
            pub const fn valid_tach_cnt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The maximum TACH Reading Register value to indicate that the fan is spinning properly."]
            #[inline(always)]
            pub fn set_valid_tach_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for ValTachCnt {
            #[inline(always)]
            fn default() -> ValTachCnt {
                ValTachCnt(0)
            }
        }
        impl core::fmt::Debug for ValTachCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ValTachCnt")
                    .field("valid_tach_cnt", &self.valid_tach_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ValTachCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ValTachCnt {{ valid_tach_cnt: {=u8:?} }}", self.valid_tach_cnt())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DriveFailCnt {
            #[doc = "0=Drive Fail detection circuitry is disabled."]
            DRIVE_FAIL_CNT_DIS = 0x0,
            #[doc = "1=Drive Fail detection circuitry will count for 16 update periods"]
            DRIVE_FAIL_CNT_16_PERIOD = 0x01,
            #[doc = "2=Drive Fail detection circuitry will count for 32 update periods"]
            DRIVE_FAIL_CNT_32_PERIOD = 0x02,
            #[doc = "3=Drive Fail detection circuitry will count for 64 update periods"]
            DRIVE_FAIL_CNT_64_PERIOD = 0x03,
        }
        impl DriveFailCnt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DriveFailCnt {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DriveFailCnt {
            #[inline(always)]
            fn from(val: u8) -> DriveFailCnt {
                DriveFailCnt::from_bits(val)
            }
        }
        impl From<DriveFailCnt> for u8 {
            #[inline(always)]
            fn from(val: DriveFailCnt) -> u8 {
                DriveFailCnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ErrRng {
            #[doc = "0=0 RPM"]
            RPM_0 = 0x0,
            #[doc = "1=50 RPM"]
            RPM_50 = 0x01,
            #[doc = "2=100 RPM"]
            RPM_100 = 0x02,
            #[doc = "3=200 RPM"]
            RPM_200 = 0x03,
        }
        impl ErrRng {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ErrRng {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ErrRng {
            #[inline(always)]
            fn from(val: u8) -> ErrRng {
                ErrRng::from_bits(val)
            }
        }
        impl From<ErrRng> for u8 {
            #[inline(always)]
            fn from(val: ErrRng) -> u8 {
                ErrRng::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gaind {
            #[doc = "Gain Factor: 0=1x"]
            GAIND_1X = 0x0,
            #[doc = "Gain Factor: 1=2x"]
            GAIND_2X = 0x01,
            #[doc = "Gain Factor: 2=4x"]
            GAIND_4X = 0x02,
            #[doc = "Gain Factor: 3=8x"]
            GAIND_8X = 0x03,
        }
        impl Gaind {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gaind {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gaind {
            #[inline(always)]
            fn from(val: u8) -> Gaind {
                Gaind::from_bits(val)
            }
        }
        impl From<Gaind> for u8 {
            #[inline(always)]
            fn from(val: Gaind) -> u8 {
                Gaind::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gaini {
            #[doc = "Gain Factor: 0=1x"]
            GAINI_1X = 0x0,
            #[doc = "Gain Factor: 1=2x"]
            GAINI_2X = 0x01,
            #[doc = "Gain Factor: 2=4x"]
            GAINI_4X = 0x02,
            #[doc = "Gain Factor: 3=8x"]
            GAINI_8X = 0x03,
        }
        impl Gaini {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gaini {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gaini {
            #[inline(always)]
            fn from(val: u8) -> Gaini {
                Gaini::from_bits(val)
            }
        }
        impl From<Gaini> for u8 {
            #[inline(always)]
            fn from(val: Gaini) -> u8 {
                Gaini::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gainp {
            #[doc = "Gain Factor: 0=1x"]
            GAINP_1X = 0x0,
            #[doc = "Gain Factor: 1=2x"]
            GAINP_2X = 0x01,
            #[doc = "Gain Factor: 2=4x"]
            GAINP_4X = 0x02,
            #[doc = "Gain Factor: 3=8x"]
            GAINP_8X = 0x03,
        }
        impl Gainp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gainp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gainp {
            #[inline(always)]
            fn from(val: u8) -> Gainp {
                Gainp::from_bits(val)
            }
        }
        impl From<Gainp> for u8 {
            #[inline(always)]
            fn from(val: Gainp) -> u8 {
                Gainp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PwmBase {
            #[doc = "0=26.8KHz"]
            PWM_FAN_FREQ_26KHZ = 0x0,
            #[doc = "1=23.4KHz"]
            PWM_FAN_FREQ_23KHZ = 0x01,
            #[doc = "2=4.67KHz"]
            PWM_FAN_FREQ_4KHZ = 0x02,
            #[doc = "3=2.34KHz"]
            PWM_FAN_FREQ_2KHZ = 0x03,
        }
        impl PwmBase {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PwmBase {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PwmBase {
            #[inline(always)]
            fn from(val: u8) -> PwmBase {
                PwmBase::from_bits(val)
            }
        }
        impl From<PwmBase> for u8 {
            #[inline(always)]
            fn from(val: PwmBase) -> u8 {
                PwmBase::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Range {
            #[doc = "0=Reported Minimum RPM: 500. Tach Count Multiplier: 1"]
            TACH_COUNT_MULTIPLIER_1 = 0x0,
            #[doc = "1=Reported Minimum RPM: 1000. Tach Count Multiplier: 2"]
            TACH_COUNT_MULTIPLIER_2 = 0x01,
            #[doc = "2=Reported Minimum RPM: 2000. Tach Count Multiplier: 4"]
            TACH_COUNT_MULTIPLIER_4 = 0x02,
            #[doc = "3=Reported Minimum RPM: 4000. Tach Count Multiplier: 8"]
            TACH_COUNT_MULTIPLIER_8 = 0x03,
        }
        impl Range {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Range {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Range {
            #[inline(always)]
            fn from(val: u8) -> Range {
                Range::from_bits(val)
            }
        }
        impl From<Range> for u8 {
            #[inline(always)]
            fn from(val: Range) -> u8 {
                Range::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpinLvl {
            #[doc = "0=30%"]
            SPIN_LVL_30 = 0x0,
            #[doc = "1=35%"]
            SPIN_LVL_35 = 0x01,
            #[doc = "2=40%"]
            SPIN_LVL_40 = 0x02,
            #[doc = "3=45%"]
            SPIN_LVL_45 = 0x03,
            #[doc = "4=50%"]
            SPIN_LVL_50 = 0x04,
            #[doc = "5=55%"]
            SPIN_LVL_55 = 0x05,
            #[doc = "6=60%"]
            SPIN_LVL_60 = 0x06,
            #[doc = "7=65%"]
            SPIN_LVL_65 = 0x07,
        }
        impl SpinLvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpinLvl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpinLvl {
            #[inline(always)]
            fn from(val: u8) -> SpinLvl {
                SpinLvl::from_bits(val)
            }
        }
        impl From<SpinLvl> for u8 {
            #[inline(always)]
            fn from(val: SpinLvl) -> u8 {
                SpinLvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpinupTime {
            #[doc = "0=250 ms"]
            SPINUP_250_MSEC = 0x0,
            #[doc = "1=500 ms"]
            SPINUP_500_MSEC = 0x01,
            #[doc = "2=1 second"]
            SPINUP_1_SEC = 0x02,
            #[doc = "3=2 seconds"]
            SPINUP_2_SEC = 0x03,
        }
        impl SpinupTime {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpinupTime {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpinupTime {
            #[inline(always)]
            fn from(val: u8) -> SpinupTime {
                SpinupTime::from_bits(val)
            }
        }
        impl From<SpinupTime> for u8 {
            #[inline(always)]
            fn from(val: SpinupTime) -> u8 {
                SpinupTime::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Update {
            _RESERVED_0 = 0x0,
            #[doc = "0=100ms"]
            BASE_TIME_100MS = 0x01,
            #[doc = "1=200ms"]
            BASE_TIME_200MS = 0x02,
            #[doc = "2=300ms"]
            BASE_TIME_300MS = 0x03,
            #[doc = "3=400ms"]
            BASE_TIME_400MS = 0x04,
            #[doc = "4=500ms"]
            BASE_TIME_500MS = 0x05,
            #[doc = "5=800ms"]
            BASE_TIME_800MS = 0x06,
            #[doc = "7=1600ms"]
            BASE_TIME_1600MS = 0x07,
        }
        impl Update {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Update {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Update {
            #[inline(always)]
            fn from(val: u8) -> Update {
                Update::from_bits(val)
            }
        }
        impl From<Update> for u8 {
            #[inline(always)]
            fn from(val: Update) -> u8 {
                Update::to_bits(val)
            }
        }
    }
}
pub mod gcr {
    #[doc = "The Logical Device Configuration registers support motherboard designs in which the resources required by their components are known and assigned by the BIOS at POST."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gcr {
        ptr: *mut u8,
    }
    unsafe impl Send for Gcr {}
    unsafe impl Sync for Gcr {}
    impl Gcr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "A write to this register selects the current logical device. This allows access to the control and configuration registers for each logical device. Note: The Activate command operates only on the selected logical device."]
        #[inline(always)]
        pub const fn ldn(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "A read-only register which provides device identification."]
        #[inline(always)]
        pub const fn dev_id(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "A read-only register which provides device revision information."]
        #[inline(always)]
        pub const fn dev_rev(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x21usize) as _) }
        }
    }
}
pub mod gp_spi0 {
    #[doc = "The General Purpose Serial Peripheral Interface (GP-SPI) may be used to communicate with various peripheral devices, e.g., EEPROMS, DACs, ADCs, that use a standard Serial Peripheral Interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct GpSpi0 {
        ptr: *mut u8,
    }
    unsafe impl Send for GpSpi0 {}
    unsafe impl Sync for GpSpi0 {}
    impl GpSpi0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "0:0\\] 1=Enabled. The device is fully operational 0=Disabled. Clocks are gated to conserve power and the SPDOUT and SPI_CLK signals are set to their inactive state"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SPI Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Status"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "7:0\\] A write to this register when the Tx_Data buffer is empty (TXBE in the SPI Status Register is '1') initiates a SPI transaction."]
        #[inline(always)]
        pub const fn tx_dat(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "7:0\\] This register is used to read the value returned by the external SPI device."]
        #[inline(always)]
        pub const fn rx_dat(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "SPI Clock Control. This register should not be changed during an active SPI transaction."]
        #[inline(always)]
        pub const fn clk_ctrl(self) -> crate::common::Reg<regs::ClkCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "5:0\\] PRELOAD SPI Clock Generator Preload value."]
        #[inline(always)]
        pub const fn clk_gen(self) -> crate::common::Reg<regs::ClkGen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "SPI Clock Control. This register should not be changed during an active SPI transaction."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkCtrl(pub u32);
        impl ClkCtrl {
            #[doc = "1=Valid data is clocked out on the first SPI_CLK edge on SPDOUT signal. The slave device should sample this data on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is clocked out on the SPDOUT signal prior to the first SPI_CLK edge. The slave device should sample this data on the first and following odd SPI_CLK edges (i.e., sample data on rising edge)"]
            #[inline(always)]
            pub const fn tclkph(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Valid data is clocked out on the first SPI_CLK edge on SPDOUT signal. The slave device should sample this data on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is clocked out on the SPDOUT signal prior to the first SPI_CLK edge. The slave device should sample this data on the first and following odd SPI_CLK edges (i.e., sample data on rising edge)"]
            #[inline(always)]
            pub fn set_tclkph(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=Valid data on SPDIN signal is expected after the first SPI_CLK edge. This data is sampled on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is expected on the SPDIN signal on the first SPI_CLK edge. This data is sampled on the first and following odd SPI_-CLK edges (i.e., sample data on rising edge)"]
            #[inline(always)]
            pub const fn rclkph(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=Valid data on SPDIN signal is expected after the first SPI_CLK edge. This data is sampled on the second and following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is expected on the SPDIN signal on the first SPI_CLK edge. This data is sampled on the first and following odd SPI_-CLK edges (i.e., sample data on rising edge)"]
            #[inline(always)]
            pub fn set_rclkph(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1=The SPI_CLK signal is high when the interface is idle and the first clock edge is a falling edge 0=The SPI_CLK is low when the interface is idle and the first clock edge is a rising edge"]
            #[inline(always)]
            pub const fn clkpol(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=The SPI_CLK signal is high when the interface is idle and the first clock edge is a falling edge 0=The SPI_CLK is low when the interface is idle and the first clock edge is a rising edge"]
            #[inline(always)]
            pub fn set_clkpol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=2MHz, 0=48 MHz Ring Oscillator"]
            #[inline(always)]
            pub const fn clksrc(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "1=2MHz, 0=48 MHz Ring Oscillator"]
            #[inline(always)]
            pub fn set_clksrc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for ClkCtrl {
            #[inline(always)]
            fn default() -> ClkCtrl {
                ClkCtrl(0)
            }
        }
        impl core::fmt::Debug for ClkCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkCtrl")
                    .field("tclkph", &self.tclkph())
                    .field("rclkph", &self.rclkph())
                    .field("clkpol", &self.clkpol())
                    .field("clksrc", &self.clksrc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "ClkCtrl {{ tclkph: {=bool:?}, rclkph: {=bool:?}, clkpol: {=bool:?}, clksrc: {=bool:?} }}",
                    self.tclkph(),
                    self.rclkph(),
                    self.clkpol(),
                    self.clksrc()
                )
            }
        }
        #[doc = "5:0\\] PRELOAD SPI Clock Generator Preload value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkGen(pub u32);
        impl ClkGen {
            #[doc = "SPI Clock Generator Preload Value"]
            #[inline(always)]
            pub const fn prld(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "SPI Clock Generator Preload Value"]
            #[inline(always)]
            pub fn set_prld(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for ClkGen {
            #[inline(always)]
            fn default() -> ClkGen {
                ClkGen(0)
            }
        }
        impl core::fmt::Debug for ClkGen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkGen").field("prld", &self.prld()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkGen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ClkGen {{ prld: {=u8:?} }}", self.prld())
            }
        }
        #[doc = "SPI Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "Least Significant Bit First 1= The data is transferred in LSB-first order. 0= The data is transferred in MSB-first order. (default)"]
            #[inline(always)]
            pub const fn lsbf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Least Significant Bit First 1= The data is transferred in LSB-first order. 0= The data is transferred in MSB-first order. (default)"]
            #[inline(always)]
            pub fn set_lsbf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Bidirectional Output Enable control. 1=The SPDOUT_Direction signal configures the SPDOUT signal as an output. 0=The SPDOUT_Direction signal configures the SPDOUT signal as an input."]
            #[inline(always)]
            pub const fn bioen(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Bidirectional Output Enable control. 1=The SPDOUT_Direction signal configures the SPDOUT signal as an output. 0=The SPDOUT_Direction signal configures the SPDOUT signal as an input."]
            #[inline(always)]
            pub fn set_bioen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "3:2\\] 1xb=SPDIN1 and SPDIN2. Select this option for Dual Mode \\[3:2\\] 01b=SPDIN2 only. Select this option for Half Duplex \\[3:2\\] 00b=SPDIN1 only. Select this option for Full Duplex"]
            #[inline(always)]
            pub const fn spdin_sel(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "3:2\\] 1xb=SPDIN1 and SPDIN2. Select this option for Dual Mode \\[3:2\\] 01b=SPDIN2 only. Select this option for Half Duplex \\[3:2\\] 00b=SPDIN1 only. Select this option for Full Duplex"]
            #[inline(always)]
            pub fn set_spdin_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "Soft Reset is a self-clearing bit. Writing zero to this bit has no effect. Writing a one to this bit resets the entire SPI Interface, including all counters and registers back to their initial state."]
            #[inline(always)]
            pub const fn soft_rst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Soft Reset is a self-clearing bit. Writing zero to this bit has no effect. Writing a one to this bit resets the entire SPI Interface, including all counters and registers back to their initial state."]
            #[inline(always)]
            pub fn set_soft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Auto Read Enable. 1=A read of the SPI RX_DATA Register will clear both the RXBF status bit and the TXBE status bit 0=A read of the SPI RX_DATA Register will clear the RXBF status bit. The TXBE status bit will not be modified"]
            #[inline(always)]
            pub const fn auto_rd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Auto Read Enable. 1=A read of the SPI RX_DATA Register will clear both the RXBF status bit and the TXBE status bit 0=A read of the SPI RX_DATA Register will clear the RXBF status bit. The TXBE status bit will not be modified"]
            #[inline(always)]
            pub fn set_auto_rd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "SPI Chip Select Enable. 1= SPI_CS# output signal is asserted, i.e., driven to logic '0' 0= SPI_CS# output signal is deasserted, i.e., driven to logic '1'"]
            #[inline(always)]
            pub const fn ce(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "SPI Chip Select Enable. 1= SPI_CS# output signal is asserted, i.e., driven to logic '0' 0= SPI_CS# output signal is deasserted, i.e., driven to logic '1'"]
            #[inline(always)]
            pub fn set_ce(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("lsbf", &self.lsbf())
                    .field("bioen", &self.bioen())
                    .field("spdin_sel", &self.spdin_sel())
                    .field("soft_rst", &self.soft_rst())
                    .field("auto_rd", &self.auto_rd())
                    .field("ce", &self.ce())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ lsbf: {=bool:?}, bioen: {=bool:?}, spdin_sel: {=u8:?}, soft_rst: {=bool:?}, auto_rd: {=bool:?}, ce: {=bool:?} }}" , self . lsbf () , self . bioen () , self . spdin_sel () , self . soft_rst () , self . auto_rd () , self . ce ())
            }
        }
        #[doc = "SPI Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "1=TX_Data buffer is empty, 0=TX_Data buffer is not empty"]
            #[inline(always)]
            pub const fn txbe(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=TX_Data buffer is empty, 0=TX_Data buffer is not empty"]
            #[inline(always)]
            pub fn set_txbe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=RX_Data buffer is full, 0=RX_Data buffer is not full"]
            #[inline(always)]
            pub const fn rxbf(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=RX_Data buffer is full, 0=RX_Data buffer is not full"]
            #[inline(always)]
            pub fn set_rxbf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "ACTIVE status"]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "ACTIVE status"]
            #[inline(always)]
            pub fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("txbe", &self.txbe())
                    .field("rxbf", &self.rxbf())
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sts {{ txbe: {=bool:?}, rxbf: {=bool:?}, active: {=bool:?} }}",
                    self.txbe(),
                    self.rxbf(),
                    self.active()
                )
            }
        }
    }
}
pub mod gpio {
    #[doc = "GPIO Pin Control Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpio {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpio {}
    unsafe impl Sync for Gpio {}
    impl Gpio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "GPIO Pin Control Register"]
        #[inline(always)]
        pub const fn ctrl(self, n: usize) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            assert!(n < 172usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "The GPIO Input Registers."]
        #[inline(always)]
        pub const fn parin(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize + n * 4usize) as _) }
        }
        #[doc = "The GPIO Output Registers."]
        #[inline(always)]
        pub const fn parout(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0380usize + n * 4usize) as _) }
        }
        #[doc = "The GPIO PIN_CTRL2 Registers"]
        #[inline(always)]
        pub const fn ctrl2p(self, n: usize) -> crate::common::Reg<regs::Ctrl2, crate::common::RW> {
            assert!(n < 172usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "GPIO Pin Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "These bits are used to enable an internal pull-up or pull-down resistor. 00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11 = None"]
            #[inline(always)]
            pub const fn pu_pd(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are used to enable an internal pull-up or pull-down resistor. 00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11 = None"]
            #[inline(always)]
            pub fn set_pu_pd(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "The GPIO pin will be tristated when the selected power well is off. 00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined by the VCC_PWRGD input), 1x = Reserved"]
            #[inline(always)]
            pub const fn pwr_gating(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "The GPIO pin will be tristated when the selected power well is off. 00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined by the VCC_PWRGD input), 1x = Reserved"]
            #[inline(always)]
            pub fn set_pwr_gating(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "When combined with the field INTERRUPT_DETECTION in this register, determines the interrupt capability of the GPIO input. 0 000 = Low Level Sensitive 0 001 = High Level Sensitive 0 100 = Interrupt events are disabled 1 101 = Rising Edge Triggered 1 110 = Falling Edge Triggered 1 111 = Either edge triggered"]
            #[inline(always)]
            pub const fn intr_det(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "When combined with the field INTERRUPT_DETECTION in this register, determines the interrupt capability of the GPIO input. 0 000 = Low Level Sensitive 0 001 = High Level Sensitive 0 100 = Interrupt events are disabled 1 101 = Rising Edge Triggered 1 110 = Falling Edge Triggered 1 111 = Either edge triggered"]
            #[inline(always)]
            pub fn set_intr_det(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
            }
            #[doc = "When combined with the field INTERRUPT_DETECTION in this register, determines the interrupt capability of the GPIO input. 0 = Edge detection disabled, 1 = Edge detection enabled"]
            #[inline(always)]
            pub const fn edge_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "When combined with the field INTERRUPT_DETECTION in this register, determines the interrupt capability of the GPIO input. 0 = Edge detection disabled, 1 = Edge detection enabled"]
            #[inline(always)]
            pub fn set_edge_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Unless explicitly stated otherwise, pins with (I/O/OD) or (O/OD) in their buffer type column in the tables are compliant with the following Programmable OD/PP Multiplexing Design Rule: Each compliant pin has a programmable open drain/push-pull buffer controlled by the Output Buffer Type bit in the associated Pin Control Register. The state of this bit controls the mode of the interface buffer for all selected functions, including the GPIO function. 0 = Push-Pull, 1 = Open Drain"]
            #[inline(always)]
            pub const fn out_buff_type(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Unless explicitly stated otherwise, pins with (I/O/OD) or (O/OD) in their buffer type column in the tables are compliant with the following Programmable OD/PP Multiplexing Design Rule: Each compliant pin has a programmable open drain/push-pull buffer controlled by the Output Buffer Type bit in the associated Pin Control Register. The state of this bit controls the mode of the interface buffer for all selected functions, including the GPIO function. 0 = Push-Pull, 1 = Open Drain"]
            #[inline(always)]
            pub fn set_out_buff_type(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This bit controls the buffer direction only when the MUX_CONTROL field is '00' selecting the pin signal function to be GPIO. When the MUX_CONTROL field is greater than '00' (i.e., a non-GPIO signal function is selected) this bit has no affect and the selected signal function logic directly controls the pin direction. 0 = Input, 1 = Output"]
            #[inline(always)]
            pub const fn gpio_dir(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls the buffer direction only when the MUX_CONTROL field is '00' selecting the pin signal function to be GPIO. When the MUX_CONTROL field is greater than '00' (i.e., a non-GPIO signal function is selected) this bit has no affect and the selected signal function logic directly controls the pin direction. 0 = Input, 1 = Output"]
            #[inline(always)]
            pub fn set_gpio_dir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This control bit determines which register is used to update the data register for GPIO outputs. 0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA field of this register; writes to the bit representing this GPIO in the GPIO Output Register do not affect the GPIO; 1=GPIO output data for this GPIO come from the bit representing this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA field of this register do not affect the GPIO."]
            #[inline(always)]
            pub const fn gpio_out_sel(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This control bit determines which register is used to update the data register for GPIO outputs. 0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA field of this register; writes to the bit representing this GPIO in the GPIO Output Register do not affect the GPIO; 1=GPIO output data for this GPIO come from the bit representing this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA field of this register do not affect the GPIO."]
            #[inline(always)]
            pub fn set_gpio_out_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "When the Polarity bit is set to '1' and the MUX_CONTROL bits are greater than '00', the selected signal function outputs are inverted and Interrupt Detection sense is inverted. When the MUX_CONTROL field selects the GPIO signal function (Mux='00'), the Polarity bit does not effect the output. Regardless of the state of the MUX_CONTROL field and the Polarity bit, the state of the pin is always reported without inversion in the GPIO input register. 1=Inverted; 0=Non-inverted"]
            #[inline(always)]
            pub const fn pol(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "When the Polarity bit is set to '1' and the MUX_CONTROL bits are greater than '00', the selected signal function outputs are inverted and Interrupt Detection sense is inverted. When the MUX_CONTROL field selects the GPIO signal function (Mux='00'), the Polarity bit does not effect the output. Regardless of the state of the MUX_CONTROL field and the Polarity bit, the state of the pin is always reported without inversion in the GPIO input register. 1=Inverted; 0=Non-inverted"]
            #[inline(always)]
            pub fn set_pol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "This field determines the active signal function for a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected, 10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected."]
            #[inline(always)]
            pub const fn mux_ctrl(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x03;
                val as u8
            }
            #[doc = "This field determines the active signal function for a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected, 10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected."]
            #[inline(always)]
            pub fn set_mux_ctrl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize);
            }
            #[doc = "Reads of this bit always return the last data written to the GPIO output data register bit; reads do not return the current output value of the GPIO pin if it is configured as an output. If the GPIO_OUTPUT_SEL T bit in this register is '1', then this bit is Read Only and the GPIO output data register bit is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT bit in this register is '0', then this bit is R/W, and the bit corresponding to this GPIO in the GPIO Output Register is Read Only."]
            #[inline(always)]
            pub const fn alt_gpio_data(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Reads of this bit always return the last data written to the GPIO output data register bit; reads do not return the current output value of the GPIO pin if it is configured as an output. If the GPIO_OUTPUT_SEL T bit in this register is '1', then this bit is Read Only and the GPIO output data register bit is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT bit in this register is '0', then this bit is R/W, and the bit corresponding to this GPIO in the GPIO Output Register is Read Only."]
            #[inline(always)]
            pub fn set_alt_gpio_data(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Reads of this bit always return the state of GPIO input from the pad, independent of the Mux selection for the pin or the Direction. This bit is forced high when the selected power well is off as selected by the POWER_GATING field in this register."]
            #[inline(always)]
            pub const fn gpio_inp(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Reads of this bit always return the state of GPIO input from the pad, independent of the Mux selection for the pin or the Direction. This bit is forced high when the selected power well is off as selected by the POWER_GATING field in this register."]
            #[inline(always)]
            pub fn set_gpio_inp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("pu_pd", &self.pu_pd())
                    .field("pwr_gating", &self.pwr_gating())
                    .field("intr_det", &self.intr_det())
                    .field("edge_en", &self.edge_en())
                    .field("out_buff_type", &self.out_buff_type())
                    .field("gpio_dir", &self.gpio_dir())
                    .field("gpio_out_sel", &self.gpio_out_sel())
                    .field("pol", &self.pol())
                    .field("mux_ctrl", &self.mux_ctrl())
                    .field("alt_gpio_data", &self.alt_gpio_data())
                    .field("gpio_inp", &self.gpio_inp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ pu_pd: {=u8:?}, pwr_gating: {=u8:?}, intr_det: {=u8:?}, edge_en: {=bool:?}, out_buff_type: {=bool:?}, gpio_dir: {=bool:?}, gpio_out_sel: {=bool:?}, pol: {=bool:?}, mux_ctrl: {=u8:?}, alt_gpio_data: {=bool:?}, gpio_inp: {=bool:?} }}" , self . pu_pd () , self . pwr_gating () , self . intr_det () , self . edge_en () , self . out_buff_type () , self . gpio_dir () , self . gpio_out_sel () , self . pol () , self . mux_ctrl () , self . alt_gpio_data () , self . gpio_inp ())
            }
        }
        #[doc = "The GPIO PIN_CTRL2 Registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl2(pub u32);
        impl Ctrl2 {
            #[doc = "This bit is used to select the slew rate on the pin. 0 = slow (half frequency), 1 = fast"]
            #[inline(always)]
            pub const fn slew_rate(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to select the slew rate on the pin. 0 = slow (half frequency), 1 = fast"]
            #[inline(always)]
            pub fn set_slew_rate(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "These bits are used to select the drive strength on the pin. The drive strength is the same whether the pin is powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA"]
            #[inline(always)]
            pub const fn driv_stren(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "These bits are used to select the drive strength on the pin. The drive strength is the same whether the pin is powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA"]
            #[inline(always)]
            pub fn set_driv_stren(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
        }
        impl Default for Ctrl2 {
            #[inline(always)]
            fn default() -> Ctrl2 {
                Ctrl2(0)
            }
        }
        impl core::fmt::Debug for Ctrl2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl2")
                    .field("slew_rate", &self.slew_rate())
                    .field("driv_stren", &self.driv_stren())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl2 {{ slew_rate: {=bool:?}, driv_stren: {=u8:?} }}",
                    self.slew_rate(),
                    self.driv_stren()
                )
            }
        }
    }
}
pub mod htm0 {
    #[doc = "The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode. This block supports wake events up to 2 hours in duration. The timer is a 16-bit binary count-down timer that can be programmed in 30.5us and 0.125 second increments for period ranges of 30.5us to 2s or 0.125s to 136.5 minutes, respectively."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Htm0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Htm0 {}
    unsafe impl Sync for Htm0 {}
    impl Htm0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "15:0\\] This register is used to set the Hibernation Timer Preload value."]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "HTimer Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The current state of the Hibernation Timer."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "HTimer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u16);
        impl Ctrl {
            #[doc = "1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours. 0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds."]
            #[inline(always)]
            pub const fn ctrl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours. 0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds."]
            #[inline(always)]
            pub fn set_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl").field("ctrl", &self.ctrl()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctrl {{ ctrl: {=bool:?} }}", self.ctrl())
            }
        }
    }
}
pub mod kms {
    #[doc = "The Keyboard Scan Interface block provides a register interface to the EC to directly scan an external keyboard matrix of size up to 18x8."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Kms {
        ptr: *mut u8,
    }
    unsafe impl Send for Kms {}
    unsafe impl Sync for Kms {}
    impl Kms {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "KSO Select and control"]
        #[inline(always)]
        pub const fn kso_sel(self) -> crate::common::Reg<regs::KsoSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "7:0\\] This field returns the current state of the KSI pins."]
        #[inline(always)]
        pub const fn ksi(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "7:0\\] Each bit in this field is set on the falling edge of the corresponding KSI input pin. A KSI interrupt is generated when its corresponding status bit and interrupt enable bit are both set. KSI interrupts are logically ORed together to produce KSC_INT and KSC_INT_WAKE. Writing a '1' to a bit will clear it. Writing a '0' to a bit has no effect."]
        #[inline(always)]
        pub const fn ksi_sts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "7:0\\] Each bit in KSI_IEN enables interrupt generation due to highto-low transition on a KSI input. An interrupt is generated when the corresponding bits in KSI_STATUS and KSI_INT_EN are both set."]
        #[inline(always)]
        pub const fn ksi_ien(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "0:0\\] PREDRIVE_ENABLE enables the PREDRIVE mode to actively drive the KSO pins high for approximately 100ns before switching to open-drain operation. 0=Disable predrive on KSO pins 1=Enable predrive on KSO pins."]
        #[inline(always)]
        pub const fn ext_ctrl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "KSO Select and control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct KsoSel(pub u32);
        impl KsoSel {
            #[doc = "This field selects a KSO line (00000b = KSO\\[0\\] etc.) for output according to the value off KSO_INVERT in this register."]
            #[inline(always)]
            pub const fn sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "This field selects a KSO line (00000b = KSO\\[0\\] etc.) for output according to the value off KSO_INVERT in this register."]
            #[inline(always)]
            pub fn set_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "0=When key scan is enabled, KSO output controlled by the KSO_SELECT field. 1=KSO\\[x\\] driven high when selected."]
            #[inline(always)]
            pub const fn all(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "0=When key scan is enabled, KSO output controlled by the KSO_SELECT field. 1=KSO\\[x\\] driven high when selected."]
            #[inline(always)]
            pub fn set_all(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "0= Keyboard scan enabled, 1= Keyboard scan disabled. All KSO output buffers disabled."]
            #[inline(always)]
            pub const fn ksen(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "0= Keyboard scan enabled, 1= Keyboard scan disabled. All KSO output buffers disabled."]
            #[inline(always)]
            pub fn set_ksen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "0= KSO\\[x\\] driven low when selected, 1= KSO\\[x\\] driven high when selected."]
            #[inline(always)]
            pub const fn inv(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "0= KSO\\[x\\] driven low when selected, 1= KSO\\[x\\] driven high when selected."]
            #[inline(always)]
            pub fn set_inv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for KsoSel {
            #[inline(always)]
            fn default() -> KsoSel {
                KsoSel(0)
            }
        }
        impl core::fmt::Debug for KsoSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("KsoSel")
                    .field("sel", &self.sel())
                    .field("all", &self.all())
                    .field("ksen", &self.ksen())
                    .field("inv", &self.inv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for KsoSel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "KsoSel {{ sel: {=u8:?}, all: {=bool:?}, ksen: {=bool:?}, inv: {=bool:?} }}",
                    self.sel(),
                    self.all(),
                    self.ksen(),
                    self.inv()
                )
            }
        }
    }
}
pub mod led0 {
    #[doc = "The blinking/breathing hardware is implemented using a PWM. The PWM can be driven either by the 48 MHz clock or by a 32.768 KHz clock input. When driven by the 48 MHz clock, the PWM can be used as a standard 8-bit PWM in order to control a fan. When used to drive blinking or breathing LEDs, the 32.768 KHz clock source is used."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Led0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Led0 {}
    unsafe impl Sync for Led0 {}
    impl Led0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "LED Configuration"]
        #[inline(always)]
        pub const fn cfg(self) -> crate::common::Reg<regs::Cfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "LED Limits This register may be written at any time. Values written into the register are held in an holding register, which is transferred into the actual register at the end of a PWM period. The two byte fields may be written independently. Reads of this register return the current contents and not the value of the holding register."]
        #[inline(always)]
        pub const fn limit(self) -> crate::common::Reg<regs::Limit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "LED Delay"]
        #[inline(always)]
        pub const fn dly(self) -> crate::common::Reg<regs::Dly, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This register has eight segment fields which provide the amount the current duty cycle is adjusted at the end of every PWM period. Segment field selection is decoded based on the segment index. The segment index equation utilized depends on the SYMMETRY bit in the LED Configuration Register Register) . In Symmetric Mode the Segment_Index\\[2:0\\] = Duty Cycle Bits\\[7:5\\] . In Asymmetric Mode the Segment_Index\\[2:0\\] is the bit concatenation of following: Segment_Index\\[2\\] = (FALLING RAMP TIME in Figure 30-3, Clipping Example) and Segment_Index\\[1:0\\] = Duty Cycle Bits\\[7:6\\]."]
        #[inline(always)]
        pub const fn step(self) -> crate::common::Reg<regs::Step, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "LED Update Interval"]
        #[inline(always)]
        pub const fn intrvl(self) -> crate::common::Reg<regs::Intrvl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "LED Output Delay"]
        #[inline(always)]
        pub const fn outdly(self) -> crate::common::Reg<regs::Outdly, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "LED Configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfg(pub u32);
        impl Cfg {
            #[doc = "CTRL 3=PWM is always on 2=LED blinking (standard PWM) 1=LED breathing configuration 0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated"]
            #[inline(always)]
            pub const fn ctrl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "CTRL 3=PWM is always on 2=LED blinking (standard PWM) 1=LED breathing configuration 0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated"]
            #[inline(always)]
            pub fn set_ctrl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock"]
            #[inline(always)]
            pub const fn clk_src(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock"]
            #[inline(always)]
            pub fn set_clk_src(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SYNCH When this bit is '1', all counters for all LEDs are reset to their initial values. When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required."]
            #[inline(always)]
            pub const fn synch(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SYNCH When this bit is '1', all counters for all LEDs are reset to their initial values. When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required."]
            #[inline(always)]
            pub fn set_synch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "PWM_SIZE This bit controls the behavior of PWM: 3=Reserved 2=PWM is configured as a 6-bit PWM 1=PWM is configured as a 7-bit PWM 0=PWM is configured as an 8-bit PWM"]
            #[inline(always)]
            pub const fn pwm_size(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "PWM_SIZE This bit controls the behavior of PWM: 3=Reserved 2=PWM is configured as a 6-bit PWM 1=PWM is configured as a 7-bit PWM 0=PWM is configured as an 8-bit PWM"]
            #[inline(always)]
            pub fn set_pwm_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "EN_UPDATE This bit is set to 1 when written with a '1'. Writes of '0' have no effect. Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time."]
            #[inline(always)]
            pub const fn en_update(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "EN_UPDATE This bit is set to 1 when written with a '1'. Writes of '0' have no effect. Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time."]
            #[inline(always)]
            pub fn set_en_update(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "RST Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing. Writes of '0' to this bit have no effect."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "RST Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing. Writes of '0' to this bit have no effect."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "WDT_RELOAD The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value."]
            #[inline(always)]
            pub const fn wdt_reload(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "WDT_RELOAD The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value."]
            #[inline(always)]
            pub fn set_wdt_reload(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "SYMMETRY 1=The rising and falling ramp times are in Asymmetric mode. 0=The rising and falling ramp times are in Symmetric mode."]
            #[inline(always)]
            pub const fn symmetry(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "SYMMETRY 1=The rising and falling ramp times are in Asymmetric mode. 0=The rising and falling ramp times are in Symmetric mode."]
            #[inline(always)]
            pub fn set_symmetry(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Cfg {
            #[inline(always)]
            fn default() -> Cfg {
                Cfg(0)
            }
        }
        impl core::fmt::Debug for Cfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfg")
                    .field("ctrl", &self.ctrl())
                    .field("clk_src", &self.clk_src())
                    .field("synch", &self.synch())
                    .field("pwm_size", &self.pwm_size())
                    .field("en_update", &self.en_update())
                    .field("rst", &self.rst())
                    .field("wdt_reload", &self.wdt_reload())
                    .field("symmetry", &self.symmetry())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cfg {{ ctrl: {=u8:?}, clk_src: {=bool:?}, synch: {=bool:?}, pwm_size: {=u8:?}, en_update: {=bool:?}, rst: {=bool:?}, wdt_reload: {=u8:?}, symmetry: {=bool:?} }}" , self . ctrl () , self . clk_src () , self . synch () , self . pwm_size () , self . en_update () , self . rst () , self . wdt_reload () , self . symmetry ())
            }
        }
        #[doc = "LED Delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dly(pub u32);
        impl Dly {
            #[doc = "The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MIN in register LED_LIMIT."]
            #[inline(always)]
            pub const fn low_pulse(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MIN in register LED_LIMIT."]
            #[inline(always)]
            pub fn set_low_pulse(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MAX in register LED_LIMIT."]
            #[inline(always)]
            pub const fn high_pulse(&self) -> u16 {
                let val = (self.0 >> 12usize) & 0x0fff;
                val as u16
            }
            #[doc = "In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MAX in register LED_LIMIT."]
            #[inline(always)]
            pub fn set_high_pulse(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 12usize)) | (((val as u32) & 0x0fff) << 12usize);
            }
        }
        impl Default for Dly {
            #[inline(always)]
            fn default() -> Dly {
                Dly(0)
            }
        }
        impl core::fmt::Debug for Dly {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dly")
                    .field("low_pulse", &self.low_pulse())
                    .field("high_pulse", &self.high_pulse())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dly {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dly {{ low_pulse: {=u16:?}, high_pulse: {=u16:?} }}",
                    self.low_pulse(),
                    self.high_pulse()
                )
            }
        }
        #[doc = "LED Update Interval"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Intrvl(pub u32);
        impl Intrvl {
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b."]
            #[inline(always)]
            pub const fn i0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b."]
            #[inline(always)]
            pub fn set_i0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b."]
            #[inline(always)]
            pub const fn i1(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b."]
            #[inline(always)]
            pub fn set_i1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b."]
            #[inline(always)]
            pub const fn i2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b."]
            #[inline(always)]
            pub fn set_i2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b."]
            #[inline(always)]
            pub const fn i3(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b."]
            #[inline(always)]
            pub fn set_i3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b."]
            #[inline(always)]
            pub const fn i4(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b."]
            #[inline(always)]
            pub fn set_i4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b."]
            #[inline(always)]
            pub const fn i5(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b."]
            #[inline(always)]
            pub fn set_i5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b."]
            #[inline(always)]
            pub const fn i6(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b."]
            #[inline(always)]
            pub fn set_i6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b."]
            #[inline(always)]
            pub const fn i7(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[doc = "The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b."]
            #[inline(always)]
            pub fn set_i7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Intrvl {
            #[inline(always)]
            fn default() -> Intrvl {
                Intrvl(0)
            }
        }
        impl core::fmt::Debug for Intrvl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Intrvl")
                    .field("i0", &self.i0())
                    .field("i1", &self.i1())
                    .field("i2", &self.i2())
                    .field("i3", &self.i3())
                    .field("i4", &self.i4())
                    .field("i5", &self.i5())
                    .field("i6", &self.i6())
                    .field("i7", &self.i7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Intrvl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Intrvl {{ i0: {=u8:?}, i1: {=u8:?}, i2: {=u8:?}, i3: {=u8:?}, i4: {=u8:?}, i5: {=u8:?}, i6: {=u8:?}, i7: {=u8:?} }}" , self . i0 () , self . i1 () , self . i2 () , self . i3 () , self . i4 () , self . i5 () , self . i6 () , self . i7 ())
            }
        }
        #[doc = "LED Limits This register may be written at any time. Values written into the register are held in an holding register, which is transferred into the actual register at the end of a PWM period. The two byte fields may be written independently. Reads of this register return the current contents and not the value of the holding register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Limit(pub u32);
        impl Limit {
            #[doc = "In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode, this field defines the duty cycle of the blink function."]
            #[inline(always)]
            pub const fn min(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode, this field defines the duty cycle of the blink function."]
            #[inline(always)]
            pub fn set_min(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle"]
            #[inline(always)]
            pub const fn max(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle"]
            #[inline(always)]
            pub fn set_max(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Limit {
            #[inline(always)]
            fn default() -> Limit {
                Limit(0)
            }
        }
        impl core::fmt::Debug for Limit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Limit")
                    .field("min", &self.min())
                    .field("max", &self.max())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Limit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Limit {{ min: {=u8:?}, max: {=u8:?} }}", self.min(), self.max())
            }
        }
        #[doc = "LED Output Delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outdly(pub u32);
        impl Outdly {
            #[doc = "The delay, in counts of the clock defined in Clock Source (CLKSRC), in which output transitions are delayed. When this field is 0, there is no added transition delay. When the LED is programmed to be Always On or Always Off, the Output Delay field has no effect."]
            #[inline(always)]
            pub const fn delay(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The delay, in counts of the clock defined in Clock Source (CLKSRC), in which output transitions are delayed. When this field is 0, there is no added transition delay. When the LED is programmed to be Always On or Always Off, the Output Delay field has no effect."]
            #[inline(always)]
            pub fn set_delay(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Outdly {
            #[inline(always)]
            fn default() -> Outdly {
                Outdly(0)
            }
        }
        impl core::fmt::Debug for Outdly {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outdly").field("delay", &self.delay()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outdly {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Outdly {{ delay: {=u8:?} }}", self.delay())
            }
        }
        #[doc = "This register has eight segment fields which provide the amount the current duty cycle is adjusted at the end of every PWM period. Segment field selection is decoded based on the segment index. The segment index equation utilized depends on the SYMMETRY bit in the LED Configuration Register Register) . In Symmetric Mode the Segment_Index\\[2:0\\] = Duty Cycle Bits\\[7:5\\] . In Asymmetric Mode the Segment_Index\\[2:0\\] is the bit concatenation of following: Segment_Index\\[2\\] = (FALLING RAMP TIME in Figure 30-3, Clipping Example) and Segment_Index\\[1:0\\] = Duty Cycle Bits\\[7:6\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Step(pub u32);
        impl Step {
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000."]
            #[inline(always)]
            pub const fn s0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000."]
            #[inline(always)]
            pub fn set_s0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001."]
            #[inline(always)]
            pub const fn s1(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001."]
            #[inline(always)]
            pub fn set_s1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010."]
            #[inline(always)]
            pub const fn s2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010."]
            #[inline(always)]
            pub fn set_s2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011."]
            #[inline(always)]
            pub const fn s3(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011."]
            #[inline(always)]
            pub fn set_s3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100."]
            #[inline(always)]
            pub const fn s4(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100."]
            #[inline(always)]
            pub fn set_s4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101"]
            #[inline(always)]
            pub const fn s5(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101"]
            #[inline(always)]
            pub fn set_s5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110."]
            #[inline(always)]
            pub const fn s6(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110."]
            #[inline(always)]
            pub fn set_s6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111."]
            #[inline(always)]
            pub const fn s7(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[doc = "Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111."]
            #[inline(always)]
            pub fn set_s7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for Step {
            #[inline(always)]
            fn default() -> Step {
                Step(0)
            }
        }
        impl core::fmt::Debug for Step {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Step")
                    .field("s0", &self.s0())
                    .field("s1", &self.s1())
                    .field("s2", &self.s2())
                    .field("s3", &self.s3())
                    .field("s4", &self.s4())
                    .field("s5", &self.s5())
                    .field("s6", &self.s6())
                    .field("s7", &self.s7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Step {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Step {{ s0: {=u8:?}, s1: {=u8:?}, s2: {=u8:?}, s3: {=u8:?}, s4: {=u8:?}, s5: {=u8:?}, s6: {=u8:?}, s7: {=u8:?} }}" , self . s0 () , self . s1 () , self . s2 () , self . s3 () , self . s4 () , self . s5 () , self . s6 () , self . s7 ())
            }
        }
    }
}
pub mod mpu {
    #[doc = "Memory Protection Unit Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mpu {
        ptr: *mut u8,
    }
    unsafe impl Send for Mpu {}
    unsafe impl Sync for Mpu {}
    impl Mpu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "MPU Type Register"]
        #[inline(always)]
        pub const fn type_(self) -> crate::common::Reg<regs::Type, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "MPU Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "MPU Region Number Register"]
        #[inline(always)]
        pub const fn rnr(self) -> crate::common::Reg<regs::Rnr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "MPU Region Base Address Register"]
        #[inline(always)]
        pub const fn rbar(self) -> crate::common::Reg<regs::Rbar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "MPU Region Attribute and Size Register"]
        #[inline(always)]
        pub const fn rasr(self) -> crate::common::Reg<regs::Rasr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "MPU Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "Enables the MPU"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the MPU"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enables the operation of MPU during hard fault, NMI, and FAULTMASK handlers."]
            #[inline(always)]
            pub const fn hfnmiena(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the operation of MPU during hard fault, NMI, and FAULTMASK handlers."]
            #[inline(always)]
            pub fn set_hfnmiena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enables privileged software access to the default memory map."]
            #[inline(always)]
            pub const fn privdefena(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enables privileged software access to the default memory map."]
            #[inline(always)]
            pub fn set_privdefena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("enable", &self.enable())
                    .field("hfnmiena", &self.hfnmiena())
                    .field("privdefena", &self.privdefena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl {{ enable: {=bool:?}, hfnmiena: {=bool:?}, privdefena: {=bool:?} }}",
                    self.enable(),
                    self.hfnmiena(),
                    self.privdefena()
                )
            }
        }
        #[doc = "MPU Region Attribute and Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rasr(pub u32);
        impl Rasr {
            #[doc = "Region enable bit."]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Region enable bit."]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Specifies the size of the MPU protection region."]
            #[inline(always)]
            pub const fn size(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x1f;
                val as u8
            }
            #[doc = "Specifies the size of the MPU protection region."]
            #[inline(always)]
            pub fn set_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 1usize)) | (((val as u32) & 0x1f) << 1usize);
            }
            #[doc = "Subregion disable bits."]
            #[inline(always)]
            pub const fn srd(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Subregion disable bits."]
            #[inline(always)]
            pub fn set_srd(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "MPU access permission attributes."]
            #[inline(always)]
            pub const fn b(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "MPU access permission attributes."]
            #[inline(always)]
            pub fn set_b(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "MPU access permission attributes."]
            #[inline(always)]
            pub const fn c(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "MPU access permission attributes."]
            #[inline(always)]
            pub fn set_c(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Shareable bit."]
            #[inline(always)]
            pub const fn s(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Shareable bit."]
            #[inline(always)]
            pub fn set_s(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "MPU access permission attributes."]
            #[inline(always)]
            pub const fn tex(&self) -> u8 {
                let val = (self.0 >> 19usize) & 0x07;
                val as u8
            }
            #[doc = "MPU access permission attributes."]
            #[inline(always)]
            pub fn set_tex(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 19usize)) | (((val as u32) & 0x07) << 19usize);
            }
            #[doc = "Access permission field."]
            #[inline(always)]
            pub const fn ap(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x07;
                val as u8
            }
            #[doc = "Access permission field."]
            #[inline(always)]
            pub fn set_ap(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 24usize)) | (((val as u32) & 0x07) << 24usize);
            }
            #[doc = "Instruction access disable bit."]
            #[inline(always)]
            pub const fn xn(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction access disable bit."]
            #[inline(always)]
            pub fn set_xn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Rasr {
            #[inline(always)]
            fn default() -> Rasr {
                Rasr(0)
            }
        }
        impl core::fmt::Debug for Rasr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rasr")
                    .field("enable", &self.enable())
                    .field("size", &self.size())
                    .field("srd", &self.srd())
                    .field("b", &self.b())
                    .field("c", &self.c())
                    .field("s", &self.s())
                    .field("tex", &self.tex())
                    .field("ap", &self.ap())
                    .field("xn", &self.xn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rasr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rasr {{ enable: {=bool:?}, size: {=u8:?}, srd: {=u8:?}, b: {=bool:?}, c: {=bool:?}, s: {=bool:?}, tex: {=u8:?}, ap: {=u8:?}, xn: {=bool:?} }}" , self . enable () , self . size () , self . srd () , self . b () , self . c () , self . s () , self . tex () , self . ap () , self . xn ())
            }
        }
        #[doc = "MPU Region Base Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rbar(pub u32);
        impl Rbar {
            #[doc = "MPU region field."]
            #[inline(always)]
            pub const fn region(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "MPU region field."]
            #[inline(always)]
            pub fn set_region(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "MPU Region Number valid bit."]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "MPU Region Number valid bit."]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Region base address field."]
            #[inline(always)]
            pub const fn addr(&self) -> u32 {
                let val = (self.0 >> 5usize) & 0x07ff_ffff;
                val as u32
            }
            #[doc = "Region base address field."]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u32) {
                self.0 = (self.0 & !(0x07ff_ffff << 5usize)) | (((val as u32) & 0x07ff_ffff) << 5usize);
            }
        }
        impl Default for Rbar {
            #[inline(always)]
            fn default() -> Rbar {
                Rbar(0)
            }
        }
        impl core::fmt::Debug for Rbar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rbar")
                    .field("region", &self.region())
                    .field("valid", &self.valid())
                    .field("addr", &self.addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rbar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rbar {{ region: {=u8:?}, valid: {=bool:?}, addr: {=u32:?} }}",
                    self.region(),
                    self.valid(),
                    self.addr()
                )
            }
        }
        #[doc = "MPU Region Number Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rnr(pub u32);
        impl Rnr {
            #[doc = "Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR registers."]
            #[inline(always)]
            pub const fn region(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR registers."]
            #[inline(always)]
            pub fn set_region(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Rnr {
            #[inline(always)]
            fn default() -> Rnr {
                Rnr(0)
            }
        }
        impl core::fmt::Debug for Rnr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rnr").field("region", &self.region()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rnr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rnr {{ region: {=u8:?} }}", self.region())
            }
        }
        #[doc = "MPU Type Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Type(pub u32);
        impl Type {
            #[doc = "Indicates support for unified or separate instruction and date memory maps."]
            #[inline(always)]
            pub const fn separate(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates support for unified or separate instruction and date memory maps."]
            #[inline(always)]
            pub fn set_separate(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates the number of supported MPU instruction regions."]
            #[inline(always)]
            pub const fn dregion(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Indicates the number of supported MPU instruction regions."]
            #[inline(always)]
            pub fn set_dregion(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Indicates the number of supported MPU data regions."]
            #[inline(always)]
            pub const fn iregion(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Indicates the number of supported MPU data regions."]
            #[inline(always)]
            pub fn set_iregion(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for Type {
            #[inline(always)]
            fn default() -> Type {
                Type(0)
            }
        }
        impl core::fmt::Debug for Type {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Type")
                    .field("separate", &self.separate())
                    .field("dregion", &self.dregion())
                    .field("iregion", &self.iregion())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Type {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Type {{ separate: {=bool:?}, dregion: {=u8:?}, iregion: {=u8:?} }}",
                    self.separate(),
                    self.dregion(),
                    self.iregion()
                )
            }
        }
    }
}
pub mod pcr {
    #[doc = "The Power, Clocks, and Resets (PCR) Section identifies all the power supplies, clock sources, and reset inputs to the chip and defines all the derived power, clock, and reset signals."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pcr {
        ptr: *mut u8,
    }
    unsafe impl Send for Pcr {}
    unsafe impl Sync for Pcr {}
    impl Pcr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "System Sleep Control"]
        #[inline(always)]
        pub const fn sys_slp_ctrl(self) -> crate::common::Reg<regs::SysSlpCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Processor Clock Control Register \\[7:0\\] Processor Clock Divide Value (PROC_DIV) 1: divide 48 MHz Ring Oscillator by 1. 3: divide 48 MHz Ring Oscillator by 3. 4: divide 48 MHz Ring Oscillator by 4. 16: divide 48 MHz Ring Oscillator by 16. 48: divide 48 MHz Ring Oscillator by 48. No other values are supported."]
        #[inline(always)]
        pub const fn proc_clk_ctrl(self) -> crate::common::Reg<regs::ProcClkCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Configures the EC_CLK clock domain"]
        #[inline(always)]
        pub const fn slow_clk_ctrl(self) -> crate::common::Reg<regs::SlowClkCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Oscillator ID Register"]
        #[inline(always)]
        pub const fn osc_id(self) -> crate::common::Reg<regs::OscId, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "PCR Power Reset Status Register"]
        #[inline(always)]
        pub const fn pwr_rst_sts(self) -> crate::common::Reg<regs::PwrRstSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Power Reset Control Register"]
        #[inline(always)]
        pub const fn pwr_rst_ctrl(self) -> crate::common::Reg<regs::PwrRstCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "System Reset Register"]
        #[inline(always)]
        pub const fn sys_rst(self) -> crate::common::Reg<regs::SysRst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Sleep Enable 0 Register"]
        #[inline(always)]
        pub const fn slp_en_0(self) -> crate::common::Reg<regs::SlpEn0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Sleep Enable 1 Register"]
        #[inline(always)]
        pub const fn slp_en_1(self) -> crate::common::Reg<regs::SlpEn1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Sleep Enable 2 Register"]
        #[inline(always)]
        pub const fn slp_en_2(self) -> crate::common::Reg<regs::SlpEn2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Sleep Enable 3 Register"]
        #[inline(always)]
        pub const fn slp_en_3(self) -> crate::common::Reg<regs::SlpEn3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Sleep Enable 4 Register"]
        #[inline(always)]
        pub const fn slp_en_4(self) -> crate::common::Reg<regs::SlpEn4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Clock Required 0 Register"]
        #[inline(always)]
        pub const fn clk_req_0(self) -> crate::common::Reg<regs::ClkReq0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "Clock Required 1 Register"]
        #[inline(always)]
        pub const fn clk_req_1(self) -> crate::common::Reg<regs::ClkReq1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "Clock Required 2 Register"]
        #[inline(always)]
        pub const fn clk_req_2(self) -> crate::common::Reg<regs::ClkReq2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "Clock Required 3 Register"]
        #[inline(always)]
        pub const fn clk_req_3(self) -> crate::common::Reg<regs::ClkReq3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "Clock Required 4 Register"]
        #[inline(always)]
        pub const fn clk_req_4(self) -> crate::common::Reg<regs::ClkReq4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Reset Enable 0 Register"]
        #[inline(always)]
        pub const fn rst_en_0(self) -> crate::common::Reg<regs::RstEn0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "Reset Enable 1 Register"]
        #[inline(always)]
        pub const fn rst_en_1(self) -> crate::common::Reg<regs::RstEn1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "Reset Enable 2 Register"]
        #[inline(always)]
        pub const fn rst_en_2(self) -> crate::common::Reg<regs::RstEn2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "Reset Enable 3 Register"]
        #[inline(always)]
        pub const fn rst_en_3(self) -> crate::common::Reg<regs::RstEn3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "Reset Enable 4 Register"]
        #[inline(always)]
        pub const fn rst_en_4(self) -> crate::common::Reg<regs::RstEn4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Clock Required 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkReq0(pub u32);
        impl ClkReq0 {
            #[doc = "JTAG Clock Reuqired"]
            #[inline(always)]
            pub const fn jtag_stap_clk_req(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "JTAG Clock Reuqired"]
            #[inline(always)]
            pub fn set_jtag_stap_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "eFuse Clock Reuqired"]
            #[inline(always)]
            pub const fn efuse_clk_req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "eFuse Clock Reuqired"]
            #[inline(always)]
            pub fn set_efuse_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for ClkReq0 {
            #[inline(always)]
            fn default() -> ClkReq0 {
                ClkReq0(0)
            }
        }
        impl core::fmt::Debug for ClkReq0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkReq0")
                    .field("jtag_stap_clk_req", &self.jtag_stap_clk_req())
                    .field("efuse_clk_req", &self.efuse_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkReq0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "ClkReq0 {{ jtag_stap_clk_req: {=bool:?}, efuse_clk_req: {=bool:?} }}",
                    self.jtag_stap_clk_req(),
                    self.efuse_clk_req()
                )
            }
        }
        #[doc = "Clock Required 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkReq1(pub u32);
        impl ClkReq1 {
            #[doc = "Interrupt Clock Reuqired"]
            #[inline(always)]
            pub const fn int_clk_req(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt Clock Reuqired"]
            #[inline(always)]
            pub fn set_int_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "TACH0 Clock Reuqired"]
            #[inline(always)]
            pub const fn tach0_clk_req(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "TACH0 Clock Reuqired"]
            #[inline(always)]
            pub fn set_tach0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "PWM0 Clock Reuqired"]
            #[inline(always)]
            pub const fn pwm0_clk_req(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PWM0 Clock Reuqired"]
            #[inline(always)]
            pub fn set_pwm0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "PMC Clock Reuqired"]
            #[inline(always)]
            pub const fn pmc_clk_req(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "PMC Clock Reuqired"]
            #[inline(always)]
            pub fn set_pmc_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "DMA Clock Reuqired"]
            #[inline(always)]
            pub const fn dma_clk_req(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA Clock Reuqired"]
            #[inline(always)]
            pub fn set_dma_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "TFDP Clock Reuqired"]
            #[inline(always)]
            pub const fn tfdp_clk_req(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "TFDP Clock Reuqired"]
            #[inline(always)]
            pub fn set_tfdp_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "PROCESSOR Clock Reuqired"]
            #[inline(always)]
            pub const fn processor_clk_req(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "PROCESSOR Clock Reuqired"]
            #[inline(always)]
            pub fn set_processor_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "WDT Clock Reuqired"]
            #[inline(always)]
            pub const fn wdt_clk_req(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "WDT Clock Reuqired"]
            #[inline(always)]
            pub fn set_wdt_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SMB0 Clock Reuqired"]
            #[inline(always)]
            pub const fn smb0_clk_req(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SMB0 Clock Reuqired"]
            #[inline(always)]
            pub fn set_smb0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "TACH1 Clock Reuqired"]
            #[inline(always)]
            pub const fn tach1_clk_req(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "TACH1 Clock Reuqired"]
            #[inline(always)]
            pub fn set_tach1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "PWM1 Clock Reuqired"]
            #[inline(always)]
            pub const fn pwm1_clk_req(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "PWM1 Clock Reuqired"]
            #[inline(always)]
            pub fn set_pwm1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "PWM2 Clock Reuqired"]
            #[inline(always)]
            pub const fn pwm2_clk_req(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "PWM2 Clock Reuqired"]
            #[inline(always)]
            pub fn set_pwm2_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "PWM3 Clock Reuqired"]
            #[inline(always)]
            pub const fn pwm3_clk_req(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "PWM3 Clock Reuqired"]
            #[inline(always)]
            pub fn set_pwm3_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "PWM4 Clock Reuqired"]
            #[inline(always)]
            pub const fn pwm4_clk_req(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "PWM4 Clock Reuqired"]
            #[inline(always)]
            pub fn set_pwm4_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "PWM5 Clock Reuqired"]
            #[inline(always)]
            pub const fn pwm5_clk_req(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "PWM5 Clock Reuqired"]
            #[inline(always)]
            pub fn set_pwm5_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "EC_REG_BANK Clock Reuqired"]
            #[inline(always)]
            pub const fn ec_reg_bank_clk_req(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "EC_REG_BANK Clock Reuqired"]
            #[inline(always)]
            pub fn set_ec_reg_bank_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "TIMER16_0 Clock Reuqired"]
            #[inline(always)]
            pub const fn tmr16_0_clk_req(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_0 Clock Reuqired"]
            #[inline(always)]
            pub fn set_tmr16_0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "TIMER16_1 Clock Reuqired"]
            #[inline(always)]
            pub const fn tmr16_1_clk_req(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_1 Clock Reuqired"]
            #[inline(always)]
            pub fn set_tmr16_1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for ClkReq1 {
            #[inline(always)]
            fn default() -> ClkReq1 {
                ClkReq1(0)
            }
        }
        impl core::fmt::Debug for ClkReq1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkReq1")
                    .field("int_clk_req", &self.int_clk_req())
                    .field("tach0_clk_req", &self.tach0_clk_req())
                    .field("pwm0_clk_req", &self.pwm0_clk_req())
                    .field("pmc_clk_req", &self.pmc_clk_req())
                    .field("dma_clk_req", &self.dma_clk_req())
                    .field("tfdp_clk_req", &self.tfdp_clk_req())
                    .field("processor_clk_req", &self.processor_clk_req())
                    .field("wdt_clk_req", &self.wdt_clk_req())
                    .field("smb0_clk_req", &self.smb0_clk_req())
                    .field("tach1_clk_req", &self.tach1_clk_req())
                    .field("pwm1_clk_req", &self.pwm1_clk_req())
                    .field("pwm2_clk_req", &self.pwm2_clk_req())
                    .field("pwm3_clk_req", &self.pwm3_clk_req())
                    .field("pwm4_clk_req", &self.pwm4_clk_req())
                    .field("pwm5_clk_req", &self.pwm5_clk_req())
                    .field("ec_reg_bank_clk_req", &self.ec_reg_bank_clk_req())
                    .field("tmr16_0_clk_req", &self.tmr16_0_clk_req())
                    .field("tmr16_1_clk_req", &self.tmr16_1_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkReq1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkReq1 {{ int_clk_req: {=bool:?}, tach0_clk_req: {=bool:?}, pwm0_clk_req: {=bool:?}, pmc_clk_req: {=bool:?}, dma_clk_req: {=bool:?}, tfdp_clk_req: {=bool:?}, processor_clk_req: {=bool:?}, wdt_clk_req: {=bool:?}, smb0_clk_req: {=bool:?}, tach1_clk_req: {=bool:?}, pwm1_clk_req: {=bool:?}, pwm2_clk_req: {=bool:?}, pwm3_clk_req: {=bool:?}, pwm4_clk_req: {=bool:?}, pwm5_clk_req: {=bool:?}, ec_reg_bank_clk_req: {=bool:?}, tmr16_0_clk_req: {=bool:?}, tmr16_1_clk_req: {=bool:?} }}" , self . int_clk_req () , self . tach0_clk_req () , self . pwm0_clk_req () , self . pmc_clk_req () , self . dma_clk_req () , self . tfdp_clk_req () , self . processor_clk_req () , self . wdt_clk_req () , self . smb0_clk_req () , self . tach1_clk_req () , self . pwm1_clk_req () , self . pwm2_clk_req () , self . pwm3_clk_req () , self . pwm4_clk_req () , self . pwm5_clk_req () , self . ec_reg_bank_clk_req () , self . tmr16_0_clk_req () , self . tmr16_1_clk_req ())
            }
        }
        #[doc = "Clock Required 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkReq2(pub u32);
        impl ClkReq2 {
            #[doc = "UART 0 Clock Reuqired"]
            #[inline(always)]
            pub const fn uart_0_clk_req(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "UART 0 Clock Reuqired"]
            #[inline(always)]
            pub fn set_uart_0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "UART 1 Clock Reuqired"]
            #[inline(always)]
            pub const fn uart_1_clk_req(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "UART 1 Clock Reuqired"]
            #[inline(always)]
            pub fn set_uart_1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GLBL_CFG Clock Reuqired"]
            #[inline(always)]
            pub const fn glbl_cfg_clk_req(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "GLBL_CFG Clock Reuqired"]
            #[inline(always)]
            pub fn set_glbl_cfg_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "RTC Clock Reuqired"]
            #[inline(always)]
            pub const fn rtc_clk_req(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "RTC Clock Reuqired"]
            #[inline(always)]
            pub fn set_rtc_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for ClkReq2 {
            #[inline(always)]
            fn default() -> ClkReq2 {
                ClkReq2(0)
            }
        }
        impl core::fmt::Debug for ClkReq2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkReq2")
                    .field("uart_0_clk_req", &self.uart_0_clk_req())
                    .field("uart_1_clk_req", &self.uart_1_clk_req())
                    .field("glbl_cfg_clk_req", &self.glbl_cfg_clk_req())
                    .field("rtc_clk_req", &self.rtc_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkReq2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkReq2 {{ uart_0_clk_req: {=bool:?}, uart_1_clk_req: {=bool:?}, glbl_cfg_clk_req: {=bool:?}, rtc_clk_req: {=bool:?} }}" , self . uart_0_clk_req () , self . uart_1_clk_req () , self . glbl_cfg_clk_req () , self . rtc_clk_req ())
            }
        }
        #[doc = "Clock Required 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkReq3(pub u32);
        impl ClkReq3 {
            #[doc = "ADC Clock Reuqired"]
            #[inline(always)]
            pub const fn adc_clk_req(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ADC Clock Reuqired"]
            #[inline(always)]
            pub fn set_adc_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GP SPI0 Clock Reuqired"]
            #[inline(always)]
            pub const fn gp_spi0_clk_req(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "GP SPI0 Clock Reuqired"]
            #[inline(always)]
            pub fn set_gp_spi0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "HTIMER 0 Clock Reuqired"]
            #[inline(always)]
            pub const fn htmr_0_clk_req(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "HTIMER 0 Clock Reuqired"]
            #[inline(always)]
            pub fn set_htmr_0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "KEYSCAN Clock Reuqired"]
            #[inline(always)]
            pub const fn keyscan_clk_req(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "KEYSCAN Clock Reuqired"]
            #[inline(always)]
            pub fn set_keyscan_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "RPM-PWM Clock Reuqired"]
            #[inline(always)]
            pub const fn rpmpwm_clk_req(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "RPM-PWM Clock Reuqired"]
            #[inline(always)]
            pub fn set_rpmpwm_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "SMB1 Clock Reuqired"]
            #[inline(always)]
            pub const fn smb1_clk_req(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SMB1 Clock Reuqired"]
            #[inline(always)]
            pub fn set_smb1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SMB2 Clock Reuqired"]
            #[inline(always)]
            pub const fn smb2_clk_req(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SMB2 Clock Reuqired"]
            #[inline(always)]
            pub fn set_smb2_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "SMB3 Clock Reuqired"]
            #[inline(always)]
            pub const fn smb3_clk_req(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "SMB3 Clock Reuqired"]
            #[inline(always)]
            pub fn set_smb3_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "LED0 Clock Reuqired"]
            #[inline(always)]
            pub const fn led0_clk_req(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LED0 Clock Reuqired"]
            #[inline(always)]
            pub fn set_led0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "LED1 Clock Reuqired"]
            #[inline(always)]
            pub const fn led1_clk_req(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "LED1 Clock Reuqired"]
            #[inline(always)]
            pub fn set_led1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "TIMER16_2 Clock Reuqired"]
            #[inline(always)]
            pub const fn tmr16_2_clk_req(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_2 Clock Reuqired"]
            #[inline(always)]
            pub fn set_tmr16_2_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TIMER16_3 Clock Reuqired"]
            #[inline(always)]
            pub const fn tmr16_3_clk_req(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_3 Clock Reuqired"]
            #[inline(always)]
            pub fn set_tmr16_3_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "TIMER32_0 Clock Reuqired"]
            #[inline(always)]
            pub const fn tmr32_0_clk_req(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0 Clock Reuqired"]
            #[inline(always)]
            pub fn set_tmr32_0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "TIMER32_1 Clock Reuqired"]
            #[inline(always)]
            pub const fn tmr32_1_clk_req(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1 Clock Reuqired"]
            #[inline(always)]
            pub fn set_tmr32_1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "HTIMER 1 Clock Reuqired"]
            #[inline(always)]
            pub const fn htmr_1_clk_req(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "HTIMER 1 Clock Reuqired"]
            #[inline(always)]
            pub fn set_htmr_1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Capture Compare Timer Clock Reuqired"]
            #[inline(always)]
            pub const fn cctmr_clk_req(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Capture Compare Timer Clock Reuqired"]
            #[inline(always)]
            pub fn set_cctmr_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for ClkReq3 {
            #[inline(always)]
            fn default() -> ClkReq3 {
                ClkReq3(0)
            }
        }
        impl core::fmt::Debug for ClkReq3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkReq3")
                    .field("adc_clk_req", &self.adc_clk_req())
                    .field("gp_spi0_clk_req", &self.gp_spi0_clk_req())
                    .field("htmr_0_clk_req", &self.htmr_0_clk_req())
                    .field("keyscan_clk_req", &self.keyscan_clk_req())
                    .field("rpmpwm_clk_req", &self.rpmpwm_clk_req())
                    .field("smb1_clk_req", &self.smb1_clk_req())
                    .field("smb2_clk_req", &self.smb2_clk_req())
                    .field("smb3_clk_req", &self.smb3_clk_req())
                    .field("led0_clk_req", &self.led0_clk_req())
                    .field("led1_clk_req", &self.led1_clk_req())
                    .field("tmr16_2_clk_req", &self.tmr16_2_clk_req())
                    .field("tmr16_3_clk_req", &self.tmr16_3_clk_req())
                    .field("tmr32_0_clk_req", &self.tmr32_0_clk_req())
                    .field("tmr32_1_clk_req", &self.tmr32_1_clk_req())
                    .field("htmr_1_clk_req", &self.htmr_1_clk_req())
                    .field("cctmr_clk_req", &self.cctmr_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkReq3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkReq3 {{ adc_clk_req: {=bool:?}, gp_spi0_clk_req: {=bool:?}, htmr_0_clk_req: {=bool:?}, keyscan_clk_req: {=bool:?}, rpmpwm_clk_req: {=bool:?}, smb1_clk_req: {=bool:?}, smb2_clk_req: {=bool:?}, smb3_clk_req: {=bool:?}, led0_clk_req: {=bool:?}, led1_clk_req: {=bool:?}, tmr16_2_clk_req: {=bool:?}, tmr16_3_clk_req: {=bool:?}, tmr32_0_clk_req: {=bool:?}, tmr32_1_clk_req: {=bool:?}, htmr_1_clk_req: {=bool:?}, cctmr_clk_req: {=bool:?} }}" , self . adc_clk_req () , self . gp_spi0_clk_req () , self . htmr_0_clk_req () , self . keyscan_clk_req () , self . rpmpwm_clk_req () , self . smb1_clk_req () , self . smb2_clk_req () , self . smb3_clk_req () , self . led0_clk_req () , self . led1_clk_req () , self . tmr16_2_clk_req () , self . tmr16_3_clk_req () , self . tmr32_0_clk_req () , self . tmr32_1_clk_req () , self . htmr_1_clk_req () , self . cctmr_clk_req ())
            }
        }
        #[doc = "Clock Required 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkReq4(pub u32);
        impl ClkReq4 {
            #[doc = "PWM10 Clock Reuqired"]
            #[inline(always)]
            pub const fn pwm10_clk_req(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PWM10 Clock Reuqired"]
            #[inline(always)]
            pub fn set_pwm10_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "CNT_TMER0 Clock Reuqired"]
            #[inline(always)]
            pub const fn cnt_tmer0_clk_req(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER0 Clock Reuqired"]
            #[inline(always)]
            pub fn set_cnt_tmer0_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CNT_TMER1 Clock Reuqired"]
            #[inline(always)]
            pub const fn cnt_tmer1_clk_req(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER1 Clock Reuqired"]
            #[inline(always)]
            pub fn set_cnt_tmer1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "CNT_TMER2 Clock Reuqired"]
            #[inline(always)]
            pub const fn cnt_tmer2_clk_req(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER2 Clock Reuqired"]
            #[inline(always)]
            pub fn set_cnt_tmer2_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "CNT_TMER3 Clock Reuqired"]
            #[inline(always)]
            pub const fn cnt_tmer3_clk_req(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER3 Clock Reuqired"]
            #[inline(always)]
            pub fn set_cnt_tmer3_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "PWM6 Clock Reuqired"]
            #[inline(always)]
            pub const fn rtos_clk_req(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "PWM6 Clock Reuqired"]
            #[inline(always)]
            pub fn set_rtos_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "RPMPWM 1 Clock Reuqired"]
            #[inline(always)]
            pub const fn rpmpwm1_clk_req(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "RPMPWM 1 Clock Reuqired"]
            #[inline(always)]
            pub fn set_rpmpwm1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Quad SPI Clock Reuqired"]
            #[inline(always)]
            pub const fn qspi_clk_req(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Quad SPI Clock Reuqired"]
            #[inline(always)]
            pub fn set_qspi_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "RC_ID1 Clock Reuqired"]
            #[inline(always)]
            pub const fn rc_id1_clk_req(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID1 Clock Reuqired"]
            #[inline(always)]
            pub fn set_rc_id1_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "RC_ID2 Clock Reuqired"]
            #[inline(always)]
            pub const fn rc_id2_clk_req(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID2 Clock Reuqired"]
            #[inline(always)]
            pub fn set_rc_id2_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "PROCHOT Clock Reuqired"]
            #[inline(always)]
            pub const fn prochot_clk_req(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "PROCHOT Clock Reuqired"]
            #[inline(always)]
            pub fn set_prochot_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Fujitsu Custom Logic Clock Reuqired"]
            #[inline(always)]
            pub const fn fujicl_clk_req(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Fujitsu Custom Logic Clock Reuqired"]
            #[inline(always)]
            pub fn set_fujicl_clk_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for ClkReq4 {
            #[inline(always)]
            fn default() -> ClkReq4 {
                ClkReq4(0)
            }
        }
        impl core::fmt::Debug for ClkReq4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkReq4")
                    .field("pwm10_clk_req", &self.pwm10_clk_req())
                    .field("cnt_tmer0_clk_req", &self.cnt_tmer0_clk_req())
                    .field("cnt_tmer1_clk_req", &self.cnt_tmer1_clk_req())
                    .field("cnt_tmer2_clk_req", &self.cnt_tmer2_clk_req())
                    .field("cnt_tmer3_clk_req", &self.cnt_tmer3_clk_req())
                    .field("rtos_clk_req", &self.rtos_clk_req())
                    .field("rpmpwm1_clk_req", &self.rpmpwm1_clk_req())
                    .field("qspi_clk_req", &self.qspi_clk_req())
                    .field("rc_id1_clk_req", &self.rc_id1_clk_req())
                    .field("rc_id2_clk_req", &self.rc_id2_clk_req())
                    .field("prochot_clk_req", &self.prochot_clk_req())
                    .field("fujicl_clk_req", &self.fujicl_clk_req())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkReq4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkReq4 {{ pwm10_clk_req: {=bool:?}, cnt_tmer0_clk_req: {=bool:?}, cnt_tmer1_clk_req: {=bool:?}, cnt_tmer2_clk_req: {=bool:?}, cnt_tmer3_clk_req: {=bool:?}, rtos_clk_req: {=bool:?}, rpmpwm1_clk_req: {=bool:?}, qspi_clk_req: {=bool:?}, rc_id1_clk_req: {=bool:?}, rc_id2_clk_req: {=bool:?}, prochot_clk_req: {=bool:?}, fujicl_clk_req: {=bool:?} }}" , self . pwm10_clk_req () , self . cnt_tmer0_clk_req () , self . cnt_tmer1_clk_req () , self . cnt_tmer2_clk_req () , self . cnt_tmer3_clk_req () , self . rtos_clk_req () , self . rpmpwm1_clk_req () , self . qspi_clk_req () , self . rc_id1_clk_req () , self . rc_id2_clk_req () , self . prochot_clk_req () , self . fujicl_clk_req ())
            }
        }
        #[doc = "Oscillator ID Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OscId(pub u32);
        impl OscId {
            #[doc = "Test bits"]
            #[inline(always)]
            pub const fn test(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Test bits"]
            #[inline(always)]
            pub fn set_test(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "PLL Lock Status"]
            #[inline(always)]
            pub const fn pll_lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "PLL Lock Status"]
            #[inline(always)]
            pub fn set_pll_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for OscId {
            #[inline(always)]
            fn default() -> OscId {
                OscId(0)
            }
        }
        impl core::fmt::Debug for OscId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OscId")
                    .field("test", &self.test())
                    .field("pll_lock", &self.pll_lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OscId {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "OscId {{ test: {=u8:?}, pll_lock: {=bool:?} }}",
                    self.test(),
                    self.pll_lock()
                )
            }
        }
        #[doc = "Processor Clock Control Register \\[7:0\\] Processor Clock Divide Value (PROC_DIV) 1: divide 48 MHz Ring Oscillator by 1. 3: divide 48 MHz Ring Oscillator by 3. 4: divide 48 MHz Ring Oscillator by 4. 16: divide 48 MHz Ring Oscillator by 16. 48: divide 48 MHz Ring Oscillator by 48. No other values are supported."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ProcClkCtrl(pub u32);
        impl ProcClkCtrl {
            #[doc = "Selects the EC clock rate"]
            #[inline(always)]
            pub const fn div(&self) -> super::vals::Div {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Div::from_bits(val as u8)
            }
            #[doc = "Selects the EC clock rate"]
            #[inline(always)]
            pub fn set_div(&mut self, val: super::vals::Div) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
            }
        }
        impl Default for ProcClkCtrl {
            #[inline(always)]
            fn default() -> ProcClkCtrl {
                ProcClkCtrl(0)
            }
        }
        impl core::fmt::Debug for ProcClkCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ProcClkCtrl").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ProcClkCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ProcClkCtrl {{ div: {:?} }}", self.div())
            }
        }
        #[doc = "Power Reset Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PwrRstCtrl(pub u32);
        impl PwrRstCtrl {
            #[doc = "Used by FW to control internal RESET_VCC signal function and external PWROK pin. This bit is read-only when VCC_PWRGD is de-asserted low."]
            #[inline(always)]
            pub const fn pwr_inv(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Used by FW to control internal RESET_VCC signal function and external PWROK pin. This bit is read-only when VCC_PWRGD is de-asserted low."]
            #[inline(always)]
            pub fn set_pwr_inv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Determines what generates the internal platform reset signal. 1=LRESET# pin; 0=eSPI PLTRST# VWire"]
            #[inline(always)]
            pub const fn h_rst_sel(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Determines what generates the internal platform reset signal. 1=LRESET# pin; 0=eSPI PLTRST# VWire"]
            #[inline(always)]
            pub fn set_h_rst_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for PwrRstCtrl {
            #[inline(always)]
            fn default() -> PwrRstCtrl {
                PwrRstCtrl(0)
            }
        }
        impl core::fmt::Debug for PwrRstCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PwrRstCtrl")
                    .field("pwr_inv", &self.pwr_inv())
                    .field("h_rst_sel", &self.h_rst_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PwrRstCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "PwrRstCtrl {{ pwr_inv: {=bool:?}, h_rst_sel: {=bool:?} }}",
                    self.pwr_inv(),
                    self.h_rst_sel()
                )
            }
        }
        #[doc = "PCR Power Reset Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PwrRstSts(pub u32);
        impl PwrRstSts {
            #[doc = "Indicates the status of VCC_PWRGD. 0 = PWRGD not asserted. 1 = PWRGD asserte."]
            #[inline(always)]
            pub const fn vcc_pwrgd_sts(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the status of VCC_PWRGD. 0 = PWRGD not asserted. 1 = PWRGD asserte."]
            #[inline(always)]
            pub fn set_vcc_pwrgd_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates the status of RESET_VCC. 0 = reset active. 1 = reset not active."]
            #[inline(always)]
            pub const fn rst_h_sts(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the status of RESET_VCC. 0 = reset active. 1 = reset not active."]
            #[inline(always)]
            pub fn set_rst_h_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "VBAT reset status 0 = No reset occurred while VTR was off or since the last time this bit was cleared. 1 = A reset occurred.(R/WC)"]
            #[inline(always)]
            pub const fn vbat_rst_sts(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "VBAT reset status 0 = No reset occurred while VTR was off or since the last time this bit was cleared. 1 = A reset occurred.(R/WC)"]
            #[inline(always)]
            pub fn set_vbat_rst_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Indicates the status of VTR_RESET.(R/WC) 0 = No reset occurred since the last time this bit was cleared. 1 = A reset occurred."]
            #[inline(always)]
            pub const fn rst_vtr_sts(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the status of VTR_RESET.(R/WC) 0 = No reset occurred since the last time this bit was cleared. 1 = A reset occurred."]
            #[inline(always)]
            pub fn set_rst_vtr_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Indicates s RESET_SYS was triggered by a JTAG action.(R/WC) 0 = No JTAG reset occurred since the last time this bit was cleared. 1 = A reset occurred because of a JATAG command."]
            #[inline(always)]
            pub const fn jtag_rst_sts(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates s RESET_SYS was triggered by a JTAG action.(R/WC) 0 = No JTAG reset occurred since the last time this bit was cleared. 1 = A reset occurred because of a JATAG command."]
            #[inline(always)]
            pub fn set_jtag_rst_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "32K_ACTIVE"]
            #[inline(always)]
            pub const fn _32k_active(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "32K_ACTIVE"]
            #[inline(always)]
            pub fn set__32k_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "PCICLK_ACTIVE"]
            #[inline(always)]
            pub const fn pciclk_active(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "PCICLK_ACTIVE"]
            #[inline(always)]
            pub fn set_pciclk_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "ESPI_CLK_ACTIVE"]
            #[inline(always)]
            pub const fn espi_clk_active(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "ESPI_CLK_ACTIVE"]
            #[inline(always)]
            pub fn set_espi_clk_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for PwrRstSts {
            #[inline(always)]
            fn default() -> PwrRstSts {
                PwrRstSts(0)
            }
        }
        impl core::fmt::Debug for PwrRstSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PwrRstSts")
                    .field("vcc_pwrgd_sts", &self.vcc_pwrgd_sts())
                    .field("rst_h_sts", &self.rst_h_sts())
                    .field("vbat_rst_sts", &self.vbat_rst_sts())
                    .field("rst_vtr_sts", &self.rst_vtr_sts())
                    .field("jtag_rst_sts", &self.jtag_rst_sts())
                    .field("_32k_active", &self._32k_active())
                    .field("pciclk_active", &self.pciclk_active())
                    .field("espi_clk_active", &self.espi_clk_active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PwrRstSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PwrRstSts {{ vcc_pwrgd_sts: {=bool:?}, rst_h_sts: {=bool:?}, vbat_rst_sts: {=bool:?}, rst_vtr_sts: {=bool:?}, jtag_rst_sts: {=bool:?}, _32k_active: {=bool:?}, pciclk_active: {=bool:?}, espi_clk_active: {=bool:?} }}" , self . vcc_pwrgd_sts () , self . rst_h_sts () , self . vbat_rst_sts () , self . rst_vtr_sts () , self . jtag_rst_sts () , self . _32k_active () , self . pciclk_active () , self . espi_clk_active ())
            }
        }
        #[doc = "Reset Enable 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn0(pub u32);
        impl RstEn0 {
            #[doc = "JTAG STAP Reset Enable"]
            #[inline(always)]
            pub const fn jtag_stap_rst_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "JTAG STAP Reset Enable"]
            #[inline(always)]
            pub fn set_jtag_stap_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "eFuse Reset Enable"]
            #[inline(always)]
            pub const fn efuse_rst_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "eFuse Reset Enable"]
            #[inline(always)]
            pub fn set_efuse_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for RstEn0 {
            #[inline(always)]
            fn default() -> RstEn0 {
                RstEn0(0)
            }
        }
        impl core::fmt::Debug for RstEn0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn0")
                    .field("jtag_stap_rst_en", &self.jtag_stap_rst_en())
                    .field("efuse_rst_en", &self.efuse_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RstEn0 {{ jtag_stap_rst_en: {=bool:?}, efuse_rst_en: {=bool:?} }}",
                    self.jtag_stap_rst_en(),
                    self.efuse_rst_en()
                )
            }
        }
        #[doc = "Reset Enable 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn1(pub u32);
        impl RstEn1 {
            #[doc = "Interrupt Reset Enable"]
            #[inline(always)]
            pub const fn int_rst_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt Reset Enable"]
            #[inline(always)]
            pub fn set_int_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "TACH0 Reset Enable"]
            #[inline(always)]
            pub const fn tach0_rst_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "TACH0 Reset Enable"]
            #[inline(always)]
            pub fn set_tach0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "PWM0 Reset Enable"]
            #[inline(always)]
            pub const fn pwm0_rst_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PWM0 Reset Enable"]
            #[inline(always)]
            pub fn set_pwm0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "PMC Reset Enable"]
            #[inline(always)]
            pub const fn pmc_rst_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "PMC Reset Enable"]
            #[inline(always)]
            pub fn set_pmc_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "DMA Reset Enable"]
            #[inline(always)]
            pub const fn dma_rst_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA Reset Enable"]
            #[inline(always)]
            pub fn set_dma_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "TFDP Reset Enable"]
            #[inline(always)]
            pub const fn tfdp_rst_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "TFDP Reset Enable"]
            #[inline(always)]
            pub fn set_tfdp_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "PROCESSOR Reset Enable"]
            #[inline(always)]
            pub const fn processor_rst_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "PROCESSOR Reset Enable"]
            #[inline(always)]
            pub fn set_processor_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "WDT Reset Enable"]
            #[inline(always)]
            pub const fn wdt_rst_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "WDT Reset Enable"]
            #[inline(always)]
            pub fn set_wdt_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SMB0 Reset Enable"]
            #[inline(always)]
            pub const fn smb0_rst_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SMB0 Reset Enable"]
            #[inline(always)]
            pub fn set_smb0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "TACH1 Reset Enable"]
            #[inline(always)]
            pub const fn tach1_rst_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "TACH1 Reset Enable"]
            #[inline(always)]
            pub fn set_tach1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "PWM1 Reset Enable"]
            #[inline(always)]
            pub const fn pwm1_rst_en(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "PWM1 Reset Enable"]
            #[inline(always)]
            pub fn set_pwm1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "PWM2 Reset Enable"]
            #[inline(always)]
            pub const fn pwm2_rst_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "PWM2 Reset Enable"]
            #[inline(always)]
            pub fn set_pwm2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "PWM3 Reset Enable"]
            #[inline(always)]
            pub const fn pwm3_rst_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "PWM3 Reset Enable"]
            #[inline(always)]
            pub fn set_pwm3_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "PWM4 Reset Enable"]
            #[inline(always)]
            pub const fn pwm4_rst_en(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "PWM4 Reset Enable"]
            #[inline(always)]
            pub fn set_pwm4_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "PWM5 Reset Enable"]
            #[inline(always)]
            pub const fn pwm5_rst_en(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "PWM5 Reset Enable"]
            #[inline(always)]
            pub fn set_pwm5_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "EC_REG_BANK Reset Enable"]
            #[inline(always)]
            pub const fn ec_reg_bank_rst_en(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "EC_REG_BANK Reset Enable"]
            #[inline(always)]
            pub fn set_ec_reg_bank_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "TIMER16_0 Reset Enable"]
            #[inline(always)]
            pub const fn tmr16_0_rst_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_0 Reset Enable"]
            #[inline(always)]
            pub fn set_tmr16_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "TIMER16_1 Reset Enable"]
            #[inline(always)]
            pub const fn tmr16_1_rst_en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_1 Reset Enable"]
            #[inline(always)]
            pub fn set_tmr16_1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for RstEn1 {
            #[inline(always)]
            fn default() -> RstEn1 {
                RstEn1(0)
            }
        }
        impl core::fmt::Debug for RstEn1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn1")
                    .field("int_rst_en", &self.int_rst_en())
                    .field("tach0_rst_en", &self.tach0_rst_en())
                    .field("pwm0_rst_en", &self.pwm0_rst_en())
                    .field("pmc_rst_en", &self.pmc_rst_en())
                    .field("dma_rst_en", &self.dma_rst_en())
                    .field("tfdp_rst_en", &self.tfdp_rst_en())
                    .field("processor_rst_en", &self.processor_rst_en())
                    .field("wdt_rst_en", &self.wdt_rst_en())
                    .field("smb0_rst_en", &self.smb0_rst_en())
                    .field("tach1_rst_en", &self.tach1_rst_en())
                    .field("pwm1_rst_en", &self.pwm1_rst_en())
                    .field("pwm2_rst_en", &self.pwm2_rst_en())
                    .field("pwm3_rst_en", &self.pwm3_rst_en())
                    .field("pwm4_rst_en", &self.pwm4_rst_en())
                    .field("pwm5_rst_en", &self.pwm5_rst_en())
                    .field("ec_reg_bank_rst_en", &self.ec_reg_bank_rst_en())
                    .field("tmr16_0_rst_en", &self.tmr16_0_rst_en())
                    .field("tmr16_1_rst_en", &self.tmr16_1_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn1 {{ int_rst_en: {=bool:?}, tach0_rst_en: {=bool:?}, pwm0_rst_en: {=bool:?}, pmc_rst_en: {=bool:?}, dma_rst_en: {=bool:?}, tfdp_rst_en: {=bool:?}, processor_rst_en: {=bool:?}, wdt_rst_en: {=bool:?}, smb0_rst_en: {=bool:?}, tach1_rst_en: {=bool:?}, pwm1_rst_en: {=bool:?}, pwm2_rst_en: {=bool:?}, pwm3_rst_en: {=bool:?}, pwm4_rst_en: {=bool:?}, pwm5_rst_en: {=bool:?}, ec_reg_bank_rst_en: {=bool:?}, tmr16_0_rst_en: {=bool:?}, tmr16_1_rst_en: {=bool:?} }}" , self . int_rst_en () , self . tach0_rst_en () , self . pwm0_rst_en () , self . pmc_rst_en () , self . dma_rst_en () , self . tfdp_rst_en () , self . processor_rst_en () , self . wdt_rst_en () , self . smb0_rst_en () , self . tach1_rst_en () , self . pwm1_rst_en () , self . pwm2_rst_en () , self . pwm3_rst_en () , self . pwm4_rst_en () , self . pwm5_rst_en () , self . ec_reg_bank_rst_en () , self . tmr16_0_rst_en () , self . tmr16_1_rst_en ())
            }
        }
        #[doc = "Reset Enable 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn2(pub u32);
        impl RstEn2 {
            #[doc = "UART 0 Reset Enable"]
            #[inline(always)]
            pub const fn uart_0_rst_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "UART 0 Reset Enable"]
            #[inline(always)]
            pub fn set_uart_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "UART 1 Reset Enable"]
            #[inline(always)]
            pub const fn uart_1_rst_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "UART 1 Reset Enable"]
            #[inline(always)]
            pub fn set_uart_1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GLBL_CFG Reset Enable"]
            #[inline(always)]
            pub const fn glbl_cfg_rst_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "GLBL_CFG Reset Enable"]
            #[inline(always)]
            pub fn set_glbl_cfg_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "RTC Reset Enable"]
            #[inline(always)]
            pub const fn rtc_rst_en(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "RTC Reset Enable"]
            #[inline(always)]
            pub fn set_rtc_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for RstEn2 {
            #[inline(always)]
            fn default() -> RstEn2 {
                RstEn2(0)
            }
        }
        impl core::fmt::Debug for RstEn2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn2")
                    .field("uart_0_rst_en", &self.uart_0_rst_en())
                    .field("uart_1_rst_en", &self.uart_1_rst_en())
                    .field("glbl_cfg_rst_en", &self.glbl_cfg_rst_en())
                    .field("rtc_rst_en", &self.rtc_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn2 {{ uart_0_rst_en: {=bool:?}, uart_1_rst_en: {=bool:?}, glbl_cfg_rst_en: {=bool:?}, rtc_rst_en: {=bool:?} }}" , self . uart_0_rst_en () , self . uart_1_rst_en () , self . glbl_cfg_rst_en () , self . rtc_rst_en ())
            }
        }
        #[doc = "Reset Enable 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn3(pub u32);
        impl RstEn3 {
            #[doc = "ADC Reset Enable"]
            #[inline(always)]
            pub const fn adc_rst_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ADC Reset Enable"]
            #[inline(always)]
            pub fn set_adc_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GP SPI0 Reset Enable"]
            #[inline(always)]
            pub const fn gp_spi0_rst_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "GP SPI0 Reset Enable"]
            #[inline(always)]
            pub fn set_gp_spi0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "HTIMER 0 Reset Enable"]
            #[inline(always)]
            pub const fn htmr_0_rst_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "HTIMER 0 Reset Enable"]
            #[inline(always)]
            pub fn set_htmr_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "KEYSCAN Reset Enable"]
            #[inline(always)]
            pub const fn keyscan_rst_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "KEYSCAN Reset Enable"]
            #[inline(always)]
            pub fn set_keyscan_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "RPM-PWM Reset Enable"]
            #[inline(always)]
            pub const fn rpmpwm_rst_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "RPM-PWM Reset Enable"]
            #[inline(always)]
            pub fn set_rpmpwm_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "SMB1 Reset Enable"]
            #[inline(always)]
            pub const fn smb1_rst_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SMB1 Reset Enable"]
            #[inline(always)]
            pub fn set_smb1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SMB2 Reset Enable"]
            #[inline(always)]
            pub const fn smb2_rst_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SMB2 Reset Enable"]
            #[inline(always)]
            pub fn set_smb2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "SMB3 Reset Enable"]
            #[inline(always)]
            pub const fn smb3_rst_en(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "SMB3 Reset Enable"]
            #[inline(always)]
            pub fn set_smb3_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "LED0 Reset Enable"]
            #[inline(always)]
            pub const fn led0_rst_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LED0 Reset Enable"]
            #[inline(always)]
            pub fn set_led0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "LED1 Reset Enable"]
            #[inline(always)]
            pub const fn led1_rst_en(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "LED1 Reset Enable"]
            #[inline(always)]
            pub fn set_led1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "TIMER16_2 Reset Enable"]
            #[inline(always)]
            pub const fn tmr16_2_rst_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_2 Reset Enable"]
            #[inline(always)]
            pub fn set_tmr16_2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TIMER16_3 Reset Enable"]
            #[inline(always)]
            pub const fn tmr16_3_rst_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_3 Reset Enable"]
            #[inline(always)]
            pub fn set_tmr16_3_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "TIMER32_0 Reset Enable"]
            #[inline(always)]
            pub const fn tmr32_0_rst_en(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0 Reset Enable"]
            #[inline(always)]
            pub fn set_tmr32_0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "TIMER32_1 Reset Enable"]
            #[inline(always)]
            pub const fn tmr32_1_rst_en(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1 Reset Enable"]
            #[inline(always)]
            pub fn set_tmr32_1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "HTIMER 1 Reset Enable"]
            #[inline(always)]
            pub const fn htmr_1_rst_en(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "HTIMER 1 Reset Enable"]
            #[inline(always)]
            pub fn set_htmr_1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Capture Compare Timer Reset Enable"]
            #[inline(always)]
            pub const fn cctmr_rst_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Capture Compare Timer Reset Enable"]
            #[inline(always)]
            pub fn set_cctmr_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for RstEn3 {
            #[inline(always)]
            fn default() -> RstEn3 {
                RstEn3(0)
            }
        }
        impl core::fmt::Debug for RstEn3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn3")
                    .field("adc_rst_en", &self.adc_rst_en())
                    .field("gp_spi0_rst_en", &self.gp_spi0_rst_en())
                    .field("htmr_0_rst_en", &self.htmr_0_rst_en())
                    .field("keyscan_rst_en", &self.keyscan_rst_en())
                    .field("rpmpwm_rst_en", &self.rpmpwm_rst_en())
                    .field("smb1_rst_en", &self.smb1_rst_en())
                    .field("smb2_rst_en", &self.smb2_rst_en())
                    .field("smb3_rst_en", &self.smb3_rst_en())
                    .field("led0_rst_en", &self.led0_rst_en())
                    .field("led1_rst_en", &self.led1_rst_en())
                    .field("tmr16_2_rst_en", &self.tmr16_2_rst_en())
                    .field("tmr16_3_rst_en", &self.tmr16_3_rst_en())
                    .field("tmr32_0_rst_en", &self.tmr32_0_rst_en())
                    .field("tmr32_1_rst_en", &self.tmr32_1_rst_en())
                    .field("htmr_1_rst_en", &self.htmr_1_rst_en())
                    .field("cctmr_rst_en", &self.cctmr_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn3 {{ adc_rst_en: {=bool:?}, gp_spi0_rst_en: {=bool:?}, htmr_0_rst_en: {=bool:?}, keyscan_rst_en: {=bool:?}, rpmpwm_rst_en: {=bool:?}, smb1_rst_en: {=bool:?}, smb2_rst_en: {=bool:?}, smb3_rst_en: {=bool:?}, led0_rst_en: {=bool:?}, led1_rst_en: {=bool:?}, tmr16_2_rst_en: {=bool:?}, tmr16_3_rst_en: {=bool:?}, tmr32_0_rst_en: {=bool:?}, tmr32_1_rst_en: {=bool:?}, htmr_1_rst_en: {=bool:?}, cctmr_rst_en: {=bool:?} }}" , self . adc_rst_en () , self . gp_spi0_rst_en () , self . htmr_0_rst_en () , self . keyscan_rst_en () , self . rpmpwm_rst_en () , self . smb1_rst_en () , self . smb2_rst_en () , self . smb3_rst_en () , self . led0_rst_en () , self . led1_rst_en () , self . tmr16_2_rst_en () , self . tmr16_3_rst_en () , self . tmr32_0_rst_en () , self . tmr32_1_rst_en () , self . htmr_1_rst_en () , self . cctmr_rst_en ())
            }
        }
        #[doc = "Reset Enable 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RstEn4(pub u32);
        impl RstEn4 {
            #[doc = "PWM10 Reset Enable"]
            #[inline(always)]
            pub const fn pwm10_rst_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PWM10 Reset Enable"]
            #[inline(always)]
            pub fn set_pwm10_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "CNT_TMER0 Reset Enable"]
            #[inline(always)]
            pub const fn cnt_tmer0_rst_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER0 Reset Enable"]
            #[inline(always)]
            pub fn set_cnt_tmer0_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CNT_TMER1 Reset Enable"]
            #[inline(always)]
            pub const fn cnt_tmer1_rst_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER1 Reset Enable"]
            #[inline(always)]
            pub fn set_cnt_tmer1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "CNT_TMER2 Reset Enable"]
            #[inline(always)]
            pub const fn cnt_tmer2_rst_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER2 Reset Enable"]
            #[inline(always)]
            pub fn set_cnt_tmer2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "CNT_TMER3 Reset Enable"]
            #[inline(always)]
            pub const fn cnt_tmer3_rst_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER3 Reset Enable"]
            #[inline(always)]
            pub fn set_cnt_tmer3_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "PWM6 Reset Enable"]
            #[inline(always)]
            pub const fn rtos_rst_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "PWM6 Reset Enable"]
            #[inline(always)]
            pub fn set_rtos_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "RPMPWM 1 Reset Enable"]
            #[inline(always)]
            pub const fn rpmpwm1_rst_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "RPMPWM 1 Reset Enable"]
            #[inline(always)]
            pub fn set_rpmpwm1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Quad SPI Reset Enable"]
            #[inline(always)]
            pub const fn qspi_rst_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Quad SPI Reset Enable"]
            #[inline(always)]
            pub fn set_qspi_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "RC_ID1 Reset Enable"]
            #[inline(always)]
            pub const fn rc_id1_rst_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID1 Reset Enable"]
            #[inline(always)]
            pub fn set_rc_id1_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "RC_ID2 Reset Enable"]
            #[inline(always)]
            pub const fn rc_id2_rst_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID2 Reset Enable"]
            #[inline(always)]
            pub fn set_rc_id2_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "PROCHOT Reset Enable"]
            #[inline(always)]
            pub const fn prochot_rst_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "PROCHOT Reset Enable"]
            #[inline(always)]
            pub fn set_prochot_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Fujitsu Custom Logic Reset Enable"]
            #[inline(always)]
            pub const fn fujicl_rst_en(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Fujitsu Custom Logic Reset Enable"]
            #[inline(always)]
            pub fn set_fujicl_rst_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for RstEn4 {
            #[inline(always)]
            fn default() -> RstEn4 {
                RstEn4(0)
            }
        }
        impl core::fmt::Debug for RstEn4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RstEn4")
                    .field("pwm10_rst_en", &self.pwm10_rst_en())
                    .field("cnt_tmer0_rst_en", &self.cnt_tmer0_rst_en())
                    .field("cnt_tmer1_rst_en", &self.cnt_tmer1_rst_en())
                    .field("cnt_tmer2_rst_en", &self.cnt_tmer2_rst_en())
                    .field("cnt_tmer3_rst_en", &self.cnt_tmer3_rst_en())
                    .field("rtos_rst_en", &self.rtos_rst_en())
                    .field("rpmpwm1_rst_en", &self.rpmpwm1_rst_en())
                    .field("qspi_rst_en", &self.qspi_rst_en())
                    .field("rc_id1_rst_en", &self.rc_id1_rst_en())
                    .field("rc_id2_rst_en", &self.rc_id2_rst_en())
                    .field("prochot_rst_en", &self.prochot_rst_en())
                    .field("fujicl_rst_en", &self.fujicl_rst_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RstEn4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RstEn4 {{ pwm10_rst_en: {=bool:?}, cnt_tmer0_rst_en: {=bool:?}, cnt_tmer1_rst_en: {=bool:?}, cnt_tmer2_rst_en: {=bool:?}, cnt_tmer3_rst_en: {=bool:?}, rtos_rst_en: {=bool:?}, rpmpwm1_rst_en: {=bool:?}, qspi_rst_en: {=bool:?}, rc_id1_rst_en: {=bool:?}, rc_id2_rst_en: {=bool:?}, prochot_rst_en: {=bool:?}, fujicl_rst_en: {=bool:?} }}" , self . pwm10_rst_en () , self . cnt_tmer0_rst_en () , self . cnt_tmer1_rst_en () , self . cnt_tmer2_rst_en () , self . cnt_tmer3_rst_en () , self . rtos_rst_en () , self . rpmpwm1_rst_en () , self . qspi_rst_en () , self . rc_id1_rst_en () , self . rc_id2_rst_en () , self . prochot_rst_en () , self . fujicl_rst_en ())
            }
        }
        #[doc = "Configures the EC_CLK clock domain"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlowClkCtrl(pub u32);
        impl SlowClkCtrl {
            #[doc = "DIV. n=Divide by n; 0=Clock off"]
            #[inline(always)]
            pub const fn div(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "DIV. n=Divide by n; 0=Clock off"]
            #[inline(always)]
            pub fn set_div(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for SlowClkCtrl {
            #[inline(always)]
            fn default() -> SlowClkCtrl {
                SlowClkCtrl(0)
            }
        }
        impl core::fmt::Debug for SlowClkCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlowClkCtrl").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlowClkCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SlowClkCtrl {{ div: {=u16:?} }}", self.div())
            }
        }
        #[doc = "Sleep Enable 0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn0(pub u32);
        impl SlpEn0 {
            #[doc = "JTAG STAP Enable"]
            #[inline(always)]
            pub const fn jtag_stap_slp_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "JTAG STAP Enable"]
            #[inline(always)]
            pub fn set_jtag_stap_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "eFuse Enable"]
            #[inline(always)]
            pub const fn otp_slp_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "eFuse Enable"]
            #[inline(always)]
            pub fn set_otp_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for SlpEn0 {
            #[inline(always)]
            fn default() -> SlpEn0 {
                SlpEn0(0)
            }
        }
        impl core::fmt::Debug for SlpEn0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn0")
                    .field("jtag_stap_slp_en", &self.jtag_stap_slp_en())
                    .field("otp_slp_en", &self.otp_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SlpEn0 {{ jtag_stap_slp_en: {=bool:?}, otp_slp_en: {=bool:?} }}",
                    self.jtag_stap_slp_en(),
                    self.otp_slp_en()
                )
            }
        }
        #[doc = "Sleep Enable 1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn1(pub u32);
        impl SlpEn1 {
            #[doc = "Interrupt Sleep Enable"]
            #[inline(always)]
            pub const fn int_slp_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt Sleep Enable"]
            #[inline(always)]
            pub fn set_int_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "TACH0 Sleep Enable"]
            #[inline(always)]
            pub const fn tach0_slp_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "TACH0 Sleep Enable"]
            #[inline(always)]
            pub fn set_tach0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "PWM0 Sleep Enable"]
            #[inline(always)]
            pub const fn pwm0_slp_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PWM0 Sleep Enable"]
            #[inline(always)]
            pub fn set_pwm0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "PMC Sleep Enable"]
            #[inline(always)]
            pub const fn pmc_slp_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "PMC Sleep Enable"]
            #[inline(always)]
            pub fn set_pmc_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "DMA Sleep Enable"]
            #[inline(always)]
            pub const fn dma_slp_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DMA Sleep Enable"]
            #[inline(always)]
            pub fn set_dma_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "TFDP Sleep Enable"]
            #[inline(always)]
            pub const fn tfdp_slp_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "TFDP Sleep Enable"]
            #[inline(always)]
            pub fn set_tfdp_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "PROCESSOR Sleep Enable"]
            #[inline(always)]
            pub const fn proc_slp_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "PROCESSOR Sleep Enable"]
            #[inline(always)]
            pub fn set_proc_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "WDT Sleep Enable"]
            #[inline(always)]
            pub const fn wdt_slp_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "WDT Sleep Enable"]
            #[inline(always)]
            pub fn set_wdt_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SMB0 Sleep Enable"]
            #[inline(always)]
            pub const fn smb0_slp_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SMB0 Sleep Enable"]
            #[inline(always)]
            pub fn set_smb0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "TACH1 Sleep Enable"]
            #[inline(always)]
            pub const fn tach1_slp_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "TACH1 Sleep Enable"]
            #[inline(always)]
            pub fn set_tach1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "PWM1 Sleep Enable"]
            #[inline(always)]
            pub const fn pwm1_slp_en(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "PWM1 Sleep Enable"]
            #[inline(always)]
            pub fn set_pwm1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "PWM2 Sleep Enable"]
            #[inline(always)]
            pub const fn pwm2_slp_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "PWM2 Sleep Enable"]
            #[inline(always)]
            pub fn set_pwm2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "PWM3 Sleep Enable"]
            #[inline(always)]
            pub const fn pwm3_slp_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "PWM3 Sleep Enable"]
            #[inline(always)]
            pub fn set_pwm3_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "PWM4 Sleep Enable"]
            #[inline(always)]
            pub const fn pwm4_slp_en(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "PWM4 Sleep Enable"]
            #[inline(always)]
            pub fn set_pwm4_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "PWM5 Sleep Enable"]
            #[inline(always)]
            pub const fn pwm5_slp_en(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "PWM5 Sleep Enable"]
            #[inline(always)]
            pub fn set_pwm5_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "EC_REG_BANK Sleep Enable"]
            #[inline(always)]
            pub const fn ec_reg_bank_slp_en(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "EC_REG_BANK Sleep Enable"]
            #[inline(always)]
            pub fn set_ec_reg_bank_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "TIMER16_0 Sleep Enable"]
            #[inline(always)]
            pub const fn tmr16_0_slp_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_0 Sleep Enable"]
            #[inline(always)]
            pub fn set_tmr16_0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "TIMER16_1 Sleep Enable"]
            #[inline(always)]
            pub const fn tmr16_1_slp_en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_1 Sleep Enable"]
            #[inline(always)]
            pub fn set_tmr16_1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for SlpEn1 {
            #[inline(always)]
            fn default() -> SlpEn1 {
                SlpEn1(0)
            }
        }
        impl core::fmt::Debug for SlpEn1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn1")
                    .field("int_slp_en", &self.int_slp_en())
                    .field("tach0_slp_en", &self.tach0_slp_en())
                    .field("pwm0_slp_en", &self.pwm0_slp_en())
                    .field("pmc_slp_en", &self.pmc_slp_en())
                    .field("dma_slp_en", &self.dma_slp_en())
                    .field("tfdp_slp_en", &self.tfdp_slp_en())
                    .field("proc_slp_en", &self.proc_slp_en())
                    .field("wdt_slp_en", &self.wdt_slp_en())
                    .field("smb0_slp_en", &self.smb0_slp_en())
                    .field("tach1_slp_en", &self.tach1_slp_en())
                    .field("pwm1_slp_en", &self.pwm1_slp_en())
                    .field("pwm2_slp_en", &self.pwm2_slp_en())
                    .field("pwm3_slp_en", &self.pwm3_slp_en())
                    .field("pwm4_slp_en", &self.pwm4_slp_en())
                    .field("pwm5_slp_en", &self.pwm5_slp_en())
                    .field("ec_reg_bank_slp_en", &self.ec_reg_bank_slp_en())
                    .field("tmr16_0_slp_en", &self.tmr16_0_slp_en())
                    .field("tmr16_1_slp_en", &self.tmr16_1_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn1 {{ int_slp_en: {=bool:?}, tach0_slp_en: {=bool:?}, pwm0_slp_en: {=bool:?}, pmc_slp_en: {=bool:?}, dma_slp_en: {=bool:?}, tfdp_slp_en: {=bool:?}, proc_slp_en: {=bool:?}, wdt_slp_en: {=bool:?}, smb0_slp_en: {=bool:?}, tach1_slp_en: {=bool:?}, pwm1_slp_en: {=bool:?}, pwm2_slp_en: {=bool:?}, pwm3_slp_en: {=bool:?}, pwm4_slp_en: {=bool:?}, pwm5_slp_en: {=bool:?}, ec_reg_bank_slp_en: {=bool:?}, tmr16_0_slp_en: {=bool:?}, tmr16_1_slp_en: {=bool:?} }}" , self . int_slp_en () , self . tach0_slp_en () , self . pwm0_slp_en () , self . pmc_slp_en () , self . dma_slp_en () , self . tfdp_slp_en () , self . proc_slp_en () , self . wdt_slp_en () , self . smb0_slp_en () , self . tach1_slp_en () , self . pwm1_slp_en () , self . pwm2_slp_en () , self . pwm3_slp_en () , self . pwm4_slp_en () , self . pwm5_slp_en () , self . ec_reg_bank_slp_en () , self . tmr16_0_slp_en () , self . tmr16_1_slp_en ())
            }
        }
        #[doc = "Sleep Enable 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn2(pub u32);
        impl SlpEn2 {
            #[doc = "UART 0 Sleep Enable"]
            #[inline(always)]
            pub const fn uart0_slp_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "UART 0 Sleep Enable"]
            #[inline(always)]
            pub fn set_uart0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "UART 1 Sleep Enable"]
            #[inline(always)]
            pub const fn uart1_slp_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "UART 1 Sleep Enable"]
            #[inline(always)]
            pub fn set_uart1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "GLBL_CFG"]
            #[inline(always)]
            pub const fn glbl_cfg_slp_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "GLBL_CFG"]
            #[inline(always)]
            pub fn set_glbl_cfg_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "RTC Sleep Enable"]
            #[inline(always)]
            pub const fn rtc_slp_en(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "RTC Sleep Enable"]
            #[inline(always)]
            pub fn set_rtc_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for SlpEn2 {
            #[inline(always)]
            fn default() -> SlpEn2 {
                SlpEn2(0)
            }
        }
        impl core::fmt::Debug for SlpEn2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn2")
                    .field("uart0_slp_en", &self.uart0_slp_en())
                    .field("uart1_slp_en", &self.uart1_slp_en())
                    .field("glbl_cfg_slp_en", &self.glbl_cfg_slp_en())
                    .field("rtc_slp_en", &self.rtc_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn2 {{ uart0_slp_en: {=bool:?}, uart1_slp_en: {=bool:?}, glbl_cfg_slp_en: {=bool:?}, rtc_slp_en: {=bool:?} }}" , self . uart0_slp_en () , self . uart1_slp_en () , self . glbl_cfg_slp_en () , self . rtc_slp_en ())
            }
        }
        #[doc = "Sleep Enable 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn3(pub u32);
        impl SlpEn3 {
            #[doc = "ADC Sleep Enable"]
            #[inline(always)]
            pub const fn adc_slp_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ADC Sleep Enable"]
            #[inline(always)]
            pub fn set_adc_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "GP SPI0 Sleep Enable"]
            #[inline(always)]
            pub const fn gp_spi0_slp_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "GP SPI0 Sleep Enable"]
            #[inline(always)]
            pub fn set_gp_spi0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "HTIMER 0 Sleep Enable"]
            #[inline(always)]
            pub const fn htmr_0_slp_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "HTIMER 0 Sleep Enable"]
            #[inline(always)]
            pub fn set_htmr_0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "KEYSCAN Sleep Enable"]
            #[inline(always)]
            pub const fn keyscan_slp_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "KEYSCAN Sleep Enable"]
            #[inline(always)]
            pub fn set_keyscan_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "RPM-PWM Sleep Enable"]
            #[inline(always)]
            pub const fn rpmpwm_slp_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "RPM-PWM Sleep Enable"]
            #[inline(always)]
            pub fn set_rpmpwm_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "SMB1 Sleep Enable"]
            #[inline(always)]
            pub const fn smb1_slp_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "SMB1 Sleep Enable"]
            #[inline(always)]
            pub fn set_smb1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "SMB2 Sleep Enable"]
            #[inline(always)]
            pub const fn smb2_slp_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "SMB2 Sleep Enable"]
            #[inline(always)]
            pub fn set_smb2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "SMB3 Sleep Enable"]
            #[inline(always)]
            pub const fn smb3_slp_en(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "SMB3 Sleep Enable"]
            #[inline(always)]
            pub fn set_smb3_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "LED0 Sleep Enable"]
            #[inline(always)]
            pub const fn led0_slp_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LED0 Sleep Enable"]
            #[inline(always)]
            pub fn set_led0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "LED1 Sleep Enable"]
            #[inline(always)]
            pub const fn led1_slp_en(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "LED1 Sleep Enable"]
            #[inline(always)]
            pub fn set_led1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "TIMER16_2_Sleep Enable"]
            #[inline(always)]
            pub const fn tmr16_2_slp_en(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_2_Sleep Enable"]
            #[inline(always)]
            pub fn set_tmr16_2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TIMER16_3 Sleep Enable"]
            #[inline(always)]
            pub const fn tmr16_3_slp_en(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER16_3 Sleep Enable"]
            #[inline(always)]
            pub fn set_tmr16_3_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "TIMER32_0 Sleep Enable"]
            #[inline(always)]
            pub const fn tmr32_0_slp_en(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_0 Sleep Enable"]
            #[inline(always)]
            pub fn set_tmr32_0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "TIMER32_1 Sleep Enable"]
            #[inline(always)]
            pub const fn tmr32_1_slp_en(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "TIMER32_1 Sleep Enable"]
            #[inline(always)]
            pub fn set_tmr32_1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "HTIMER 1 Sleep Enable"]
            #[inline(always)]
            pub const fn htmr_1_slp_en(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "HTIMER 1 Sleep Enable"]
            #[inline(always)]
            pub fn set_htmr_1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Capture Compare Timer Sleep Enable"]
            #[inline(always)]
            pub const fn cctmr_slp_en(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Capture Compare Timer Sleep Enable"]
            #[inline(always)]
            pub fn set_cctmr_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for SlpEn3 {
            #[inline(always)]
            fn default() -> SlpEn3 {
                SlpEn3(0)
            }
        }
        impl core::fmt::Debug for SlpEn3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn3")
                    .field("adc_slp_en", &self.adc_slp_en())
                    .field("gp_spi0_slp_en", &self.gp_spi0_slp_en())
                    .field("htmr_0_slp_en", &self.htmr_0_slp_en())
                    .field("keyscan_slp_en", &self.keyscan_slp_en())
                    .field("rpmpwm_slp_en", &self.rpmpwm_slp_en())
                    .field("smb1_slp_en", &self.smb1_slp_en())
                    .field("smb2_slp_en", &self.smb2_slp_en())
                    .field("smb3_slp_en", &self.smb3_slp_en())
                    .field("led0_slp_en", &self.led0_slp_en())
                    .field("led1_slp_en", &self.led1_slp_en())
                    .field("tmr16_2_slp_en", &self.tmr16_2_slp_en())
                    .field("tmr16_3_slp_en", &self.tmr16_3_slp_en())
                    .field("tmr32_0_slp_en", &self.tmr32_0_slp_en())
                    .field("tmr32_1_slp_en", &self.tmr32_1_slp_en())
                    .field("htmr_1_slp_en", &self.htmr_1_slp_en())
                    .field("cctmr_slp_en", &self.cctmr_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn3 {{ adc_slp_en: {=bool:?}, gp_spi0_slp_en: {=bool:?}, htmr_0_slp_en: {=bool:?}, keyscan_slp_en: {=bool:?}, rpmpwm_slp_en: {=bool:?}, smb1_slp_en: {=bool:?}, smb2_slp_en: {=bool:?}, smb3_slp_en: {=bool:?}, led0_slp_en: {=bool:?}, led1_slp_en: {=bool:?}, tmr16_2_slp_en: {=bool:?}, tmr16_3_slp_en: {=bool:?}, tmr32_0_slp_en: {=bool:?}, tmr32_1_slp_en: {=bool:?}, htmr_1_slp_en: {=bool:?}, cctmr_slp_en: {=bool:?} }}" , self . adc_slp_en () , self . gp_spi0_slp_en () , self . htmr_0_slp_en () , self . keyscan_slp_en () , self . rpmpwm_slp_en () , self . smb1_slp_en () , self . smb2_slp_en () , self . smb3_slp_en () , self . led0_slp_en () , self . led1_slp_en () , self . tmr16_2_slp_en () , self . tmr16_3_slp_en () , self . tmr32_0_slp_en () , self . tmr32_1_slp_en () , self . htmr_1_slp_en () , self . cctmr_slp_en ())
            }
        }
        #[doc = "Sleep Enable 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlpEn4(pub u32);
        impl SlpEn4 {
            #[doc = "PWM10 Sleep Enable"]
            #[inline(always)]
            pub const fn pwm10_slp_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PWM10 Sleep Enable"]
            #[inline(always)]
            pub fn set_pwm10_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "CNT_TMER0 Sleep Enable"]
            #[inline(always)]
            pub const fn cnt_tmer0_slp_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER0 Sleep Enable"]
            #[inline(always)]
            pub fn set_cnt_tmer0_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CNT_TMER1 Sleep Enable"]
            #[inline(always)]
            pub const fn cnt_tmer1_slp_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER1 Sleep Enable"]
            #[inline(always)]
            pub fn set_cnt_tmer1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "CNT_TMER2 Sleep Enable"]
            #[inline(always)]
            pub const fn cnt_tmer2_slp_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER2 Sleep Enable"]
            #[inline(always)]
            pub fn set_cnt_tmer2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "CNT_TMER3 Sleep Enable"]
            #[inline(always)]
            pub const fn cnt_tmer3_slp_en(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_TMER3 Sleep Enable"]
            #[inline(always)]
            pub fn set_cnt_tmer3_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "PWM6 Sleep Enable"]
            #[inline(always)]
            pub const fn rtos_slp_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "PWM6 Sleep Enable"]
            #[inline(always)]
            pub fn set_rtos_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "RPMPWM 1 Sleep Enable"]
            #[inline(always)]
            pub const fn rpmpwm1_slp_en(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "RPMPWM 1 Sleep Enable"]
            #[inline(always)]
            pub fn set_rpmpwm1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Quad SPI Sleep Enable"]
            #[inline(always)]
            pub const fn qmspi_slp_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Quad SPI Sleep Enable"]
            #[inline(always)]
            pub fn set_qmspi_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "RC_ID1 Sleep Enable"]
            #[inline(always)]
            pub const fn rc_id1_slp_en(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID1 Sleep Enable"]
            #[inline(always)]
            pub fn set_rc_id1_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "RC_ID2 Sleep Enable"]
            #[inline(always)]
            pub const fn rc_id2_slp_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "RC_ID2 Sleep Enable"]
            #[inline(always)]
            pub fn set_rc_id2_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "PROCHOT Sleep Enable"]
            #[inline(always)]
            pub const fn prochot_slp_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "PROCHOT Sleep Enable"]
            #[inline(always)]
            pub fn set_prochot_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Fujitsu Custom Logic Sleep Enable"]
            #[inline(always)]
            pub const fn fujicl_slp_en(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Fujitsu Custom Logic Sleep Enable"]
            #[inline(always)]
            pub fn set_fujicl_slp_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for SlpEn4 {
            #[inline(always)]
            fn default() -> SlpEn4 {
                SlpEn4(0)
            }
        }
        impl core::fmt::Debug for SlpEn4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlpEn4")
                    .field("pwm10_slp_en", &self.pwm10_slp_en())
                    .field("cnt_tmer0_slp_en", &self.cnt_tmer0_slp_en())
                    .field("cnt_tmer1_slp_en", &self.cnt_tmer1_slp_en())
                    .field("cnt_tmer2_slp_en", &self.cnt_tmer2_slp_en())
                    .field("cnt_tmer3_slp_en", &self.cnt_tmer3_slp_en())
                    .field("rtos_slp_en", &self.rtos_slp_en())
                    .field("rpmpwm1_slp_en", &self.rpmpwm1_slp_en())
                    .field("qmspi_slp_en", &self.qmspi_slp_en())
                    .field("rc_id1_slp_en", &self.rc_id1_slp_en())
                    .field("rc_id2_slp_en", &self.rc_id2_slp_en())
                    .field("prochot_slp_en", &self.prochot_slp_en())
                    .field("fujicl_slp_en", &self.fujicl_slp_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlpEn4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SlpEn4 {{ pwm10_slp_en: {=bool:?}, cnt_tmer0_slp_en: {=bool:?}, cnt_tmer1_slp_en: {=bool:?}, cnt_tmer2_slp_en: {=bool:?}, cnt_tmer3_slp_en: {=bool:?}, rtos_slp_en: {=bool:?}, rpmpwm1_slp_en: {=bool:?}, qmspi_slp_en: {=bool:?}, rc_id1_slp_en: {=bool:?}, rc_id2_slp_en: {=bool:?}, prochot_slp_en: {=bool:?}, fujicl_slp_en: {=bool:?} }}" , self . pwm10_slp_en () , self . cnt_tmer0_slp_en () , self . cnt_tmer1_slp_en () , self . cnt_tmer2_slp_en () , self . cnt_tmer3_slp_en () , self . rtos_slp_en () , self . rpmpwm1_slp_en () , self . qmspi_slp_en () , self . rc_id1_slp_en () , self . rc_id2_slp_en () , self . prochot_slp_en () , self . fujicl_slp_en ())
            }
        }
        #[doc = "System Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SysRst(pub u32);
        impl SysRst {
            #[doc = "A write of a 1 forces an assertion of the RESET_SYS reset signal, resetting the device. A write of 0 has no effect."]
            #[inline(always)]
            pub const fn soft_sys_rst(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 forces an assertion of the RESET_SYS reset signal, resetting the device. A write of 0 has no effect."]
            #[inline(always)]
            pub fn set_soft_sys_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for SysRst {
            #[inline(always)]
            fn default() -> SysRst {
                SysRst(0)
            }
        }
        impl core::fmt::Debug for SysRst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SysRst")
                    .field("soft_sys_rst", &self.soft_sys_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SysRst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SysRst {{ soft_sys_rst: {=bool:?} }}", self.soft_sys_rst())
            }
        }
        #[doc = "System Sleep Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SysSlpCtrl(pub u32);
        impl SysSlpCtrl {
            #[doc = "Selects the System Sleep mode"]
            #[inline(always)]
            pub const fn slp_mod(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects the System Sleep mode"]
            #[inline(always)]
            pub fn set_slp_mod(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Test bit"]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Test bit"]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Initiates the System Sleep mode"]
            #[inline(always)]
            pub const fn slp_all(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Initiates the System Sleep mode"]
            #[inline(always)]
            pub fn set_slp_all(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for SysSlpCtrl {
            #[inline(always)]
            fn default() -> SysSlpCtrl {
                SysSlpCtrl(0)
            }
        }
        impl core::fmt::Debug for SysSlpCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SysSlpCtrl")
                    .field("slp_mod", &self.slp_mod())
                    .field("test", &self.test())
                    .field("slp_all", &self.slp_all())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SysSlpCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SysSlpCtrl {{ slp_mod: {=bool:?}, test: {=bool:?}, slp_all: {=bool:?} }}",
                    self.slp_mod(),
                    self.test(),
                    self.slp_all()
                )
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Div(u8);
        impl Div {
            #[doc = "1: divide 48 MHz Ring Oscillator by 1"]
            pub const DIV_BY_1: Self = Self(0x01);
            #[doc = "3: divide 48 MHz Ring Oscillator by 3"]
            pub const DIV_BY_3: Self = Self(0x03);
            #[doc = "4: divide 48 MHz Ring Oscillator by 4"]
            pub const DIV_BY_4: Self = Self(0x04);
            #[doc = "16: divide 48 MHz Ring Oscillator by 16"]
            pub const DIV_BY_16: Self = Self(0x10);
            #[doc = "48: divide 48 MHz Ring Oscillator by 48"]
            pub const DIV_BY_48: Self = Self(0x30);
        }
        impl Div {
            pub const fn from_bits(val: u8) -> Div {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Div {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x01 => f.write_str("DIV_BY_1"),
                    0x03 => f.write_str("DIV_BY_3"),
                    0x04 => f.write_str("DIV_BY_4"),
                    0x10 => f.write_str("DIV_BY_16"),
                    0x30 => f.write_str("DIV_BY_48"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Div {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x01 => defmt::write!(f, "DIV_BY_1"),
                    0x03 => defmt::write!(f, "DIV_BY_3"),
                    0x04 => defmt::write!(f, "DIV_BY_4"),
                    0x10 => defmt::write!(f, "DIV_BY_16"),
                    0x30 => defmt::write!(f, "DIV_BY_48"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Div {
            #[inline(always)]
            fn from(val: u8) -> Div {
                Div::from_bits(val)
            }
        }
        impl From<Div> for u8 {
            #[inline(always)]
            fn from(val: Div) -> u8 {
                Div::to_bits(val)
            }
        }
    }
}
pub mod pwm0 {
    #[doc = "This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz. The PWM controller can also used to generate the PROCHOT output and Speaker output."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwm0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Pwm0 {}
    unsafe impl Sync for Pwm0 {}
    impl Pwm0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This field determines both the frequency and duty cycle of the PWM signal. Setting this field to a value of n will cause the On time of the PWM to be n+1 cycles of the PWM Clock Source. When this field is set to zero and the PWMX_COUNTER_OFF_TIME is not set to zero, the PWM_OUTPUT is held low (Full Off)."]
        #[inline(always)]
        pub const fn cnt_on(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This field determine both the frequency and duty cycle of the PWM signal. Setting this field to a value of n will cause the Off time of the PWM to be n+1 cycles of the PWM Clock Source. When this field is set to zero, the PWM_OUTPUT is held high (Full On)."]
        #[inline(always)]
        pub const fn cnt_off(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "PWMx CFGURATION REGISTER"]
        #[inline(always)]
        pub const fn cfg(self) -> crate::common::Reg<regs::Cfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "PWMx CFGURATION REGISTER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfg(pub u32);
        impl Cfg {
            #[doc = "When the PWM_EN is set to 0 the internal counters are reset and the internal state machine is set to the OFF state. In addition, the PWM_OUTPUT signal is set to the inactive state as determined by the Invert bit. The PWMx Counter ON Time Register and PWMx Counter OFF Time Register are not affected by the PWM_ENABLE bit and may be read and written while the PWM enable bit is 0. 1=Enabled (default); 0=Disabled (gates clocks to save power)."]
            #[inline(always)]
            pub const fn pwm_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "When the PWM_EN is set to 0 the internal counters are reset and the internal state machine is set to the OFF state. In addition, the PWM_OUTPUT signal is set to the inactive state as determined by the Invert bit. The PWMx Counter ON Time Register and PWMx Counter OFF Time Register are not affected by the PWM_ENABLE bit and may be read and written while the PWM enable bit is 0. 1=Enabled (default); 0=Disabled (gates clocks to save power)."]
            #[inline(always)]
            pub fn set_pwm_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit determines the clock source used by the PWM duty cycle and frequency control logic. 1=CLOCK_LOW 0=CLOCK_HIGH"]
            #[inline(always)]
            pub const fn clk_sel(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit determines the clock source used by the PWM duty cycle and frequency control logic. 1=CLOCK_LOW 0=CLOCK_HIGH"]
            #[inline(always)]
            pub fn set_clk_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1= PWM_OUTPUT ON State is active low; 0=PWM_OUTPUT ON State is active high."]
            #[inline(always)]
            pub const fn inv(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1= PWM_OUTPUT ON State is active low; 0=PWM_OUTPUT ON State is active high."]
            #[inline(always)]
            pub fn set_inv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "The Clock source for the 16-bit down counter (see PWMx Counter ON Time Register and PWMx Counter OFF Time Register) is determined by bit D1 of this register. The Clock source is then divided by the value of Pre-Divider+1 and the resulting signal determines the rate at which the down counter will be decremented. For example, a Pre-Divider value of 1 divides the input clock by 2 and a value of 2 divides the input clock by 3. A Pre-Divider of 0 will disable the Pre-Divider option."]
            #[inline(always)]
            pub const fn clk_pre_div(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x0f;
                val as u8
            }
            #[doc = "The Clock source for the 16-bit down counter (see PWMx Counter ON Time Register and PWMx Counter OFF Time Register) is determined by bit D1 of this register. The Clock source is then divided by the value of Pre-Divider+1 and the resulting signal determines the rate at which the down counter will be decremented. For example, a Pre-Divider value of 1 divides the input clock by 2 and a value of 2 divides the input clock by 3. A Pre-Divider of 0 will disable the Pre-Divider option."]
            #[inline(always)]
            pub fn set_clk_pre_div(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 3usize)) | (((val as u32) & 0x0f) << 3usize);
            }
        }
        impl Default for Cfg {
            #[inline(always)]
            fn default() -> Cfg {
                Cfg(0)
            }
        }
        impl core::fmt::Debug for Cfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfg")
                    .field("pwm_en", &self.pwm_en())
                    .field("clk_sel", &self.clk_sel())
                    .field("inv", &self.inv())
                    .field("clk_pre_div", &self.clk_pre_div())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cfg {{ pwm_en: {=bool:?}, clk_sel: {=bool:?}, inv: {=bool:?}, clk_pre_div: {=u8:?} }}",
                    self.pwm_en(),
                    self.clk_sel(),
                    self.inv(),
                    self.clk_pre_div()
                )
            }
        }
    }
}
pub mod qmspi {
    #[doc = "The Quad SPI Master Controller may be used to communicate with various peripheral devices that use a Serial Peripheral Interface, such as EEPROMS, DACs and ADCs. The controller can be configured to support advanced SPI Flash devices with multi-phase access protocols."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Qmspi {
        ptr: *mut u8,
    }
    unsafe impl Send for Qmspi {}
    unsafe impl Sync for Qmspi {}
    impl Qmspi {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "QMSPI Mode Register"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "QMSPI SPI Control"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "QMSPI Execute Register"]
        #[inline(always)]
        pub const fn exe(self) -> crate::common::Reg<regs::Exe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "QMSPI Interface Control Register"]
        #[inline(always)]
        pub const fn ifctrl(self) -> crate::common::Reg<regs::Ifctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "QMSPI Status Register"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "QMSPI Buffer Count Status Register"]
        #[inline(always)]
        pub const fn buf_cnt_sts(self) -> crate::common::Reg<regs::BufCntSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "QMSPI Interrupt Enable Register"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "QMSPI Buffer Count Trigger Register"]
        #[inline(always)]
        pub const fn buf_cnt_trig(self) -> crate::common::Reg<regs::BufCntTrig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "QMSPI Transmit Buffer Register"]
        #[inline(always)]
        pub const fn tx_fifo_u08(self, n: usize) -> crate::common::Reg<regs::TxFifoU08, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 1usize) as _) }
        }
        #[doc = "QMSPI Transmit Buffer Register"]
        #[inline(always)]
        pub const fn tx_fifo_u16(self, n: usize) -> crate::common::Reg<regs::TxFifoU16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 2usize) as _) }
        }
        #[doc = "QMSPI Transmit Buffer Register"]
        #[inline(always)]
        pub const fn tx_fifo_u32(self) -> crate::common::Reg<regs::TxFifoU32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "QMSPI Receive Buffer Register"]
        #[inline(always)]
        pub const fn rx_fifo_u08(self, n: usize) -> crate::common::Reg<regs::RxFifoU08, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize + n * 1usize) as _) }
        }
        #[doc = "QMSPI Receive Buffer Register"]
        #[inline(always)]
        pub const fn rx_fifo_u16(self, n: usize) -> crate::common::Reg<regs::RxFifoU16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize + n * 2usize) as _) }
        }
        #[doc = "QMSPI Receive Buffer Register"]
        #[inline(always)]
        pub const fn rx_fifo_u32(self) -> crate::common::Reg<regs::RxFifoU32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "QMSPI Description Buffer Register"]
        #[inline(always)]
        pub const fn descr(self, n: usize) -> crate::common::Reg<regs::Descr, crate::common::RW> {
            assert!(n < 5usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "QMSPI Buffer Count Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BufCntSts(pub u32);
        impl BufCntSts {
            #[doc = "This is a count of the number of bytes currently valid in the Transmit Buffer."]
            #[inline(always)]
            pub const fn tx_buff_cnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This is a count of the number of bytes currently valid in the Transmit Buffer."]
            #[inline(always)]
            pub fn set_tx_buff_cnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "This is a count of the number of bytes currently valid in the Receive Buffer."]
            #[inline(always)]
            pub const fn rx_buff_cnt(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This is a count of the number of bytes currently valid in the Receive Buffer."]
            #[inline(always)]
            pub fn set_rx_buff_cnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for BufCntSts {
            #[inline(always)]
            fn default() -> BufCntSts {
                BufCntSts(0)
            }
        }
        impl core::fmt::Debug for BufCntSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BufCntSts")
                    .field("tx_buff_cnt", &self.tx_buff_cnt())
                    .field("rx_buff_cnt", &self.rx_buff_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BufCntSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BufCntSts {{ tx_buff_cnt: {=u16:?}, rx_buff_cnt: {=u16:?} }}",
                    self.tx_buff_cnt(),
                    self.rx_buff_cnt()
                )
            }
        }
        #[doc = "QMSPI Buffer Count Trigger Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BufCntTrig(pub u32);
        impl BufCntTrig {
            #[doc = "An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_trig(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_trig(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_trig(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_trig(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for BufCntTrig {
            #[inline(always)]
            fn default() -> BufCntTrig {
                BufCntTrig(0)
            }
        }
        impl core::fmt::Debug for BufCntTrig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BufCntTrig")
                    .field("tx_buf_trig", &self.tx_buf_trig())
                    .field("rx_buf_trig", &self.rx_buf_trig())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BufCntTrig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "BufCntTrig {{ tx_buf_trig: {=u16:?}, rx_buf_trig: {=u16:?} }}",
                    self.tx_buf_trig(),
                    self.rx_buf_trig()
                )
            }
        }
        #[doc = "QMSPI SPI Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub const fn tx_mode(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub fn set_tx_mode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used. 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub const fn tx_trans_en(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used. 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub fn set_tx_trans_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes. 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware"]
            #[inline(always)]
            pub const fn tx_dma_en(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes. 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware"]
            #[inline(always)]
            pub fn set_tx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer 0=Receive is disabled"]
            #[inline(always)]
            pub const fn rx_trans_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer 0=Receive is disabled"]
            #[inline(always)]
            pub fn set_rx_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware"]
            #[inline(always)]
            pub const fn rx_dma_en(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware"]
            #[inline(always)]
            pub fn set_rx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 7usize)) | (((val as u32) & 0x03) << 7usize);
            }
            #[doc = "This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer. 1=The transaction is terminated 0=The transaction is not terminated"]
            #[inline(always)]
            pub const fn close_trans_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer. 1=The transaction is terminated 0=The transaction is not terminated"]
            #[inline(always)]
            pub fn set_close_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "3=TRANSFER_LENGTH defined in units of 16-byte segments 2=TRANSFER_LENGTH defined in units of 4-byte segments 1=TRANSFER_LENGTH defined in units of bytes 0=TRANSFER_LENGTH defined in units of bits."]
            #[inline(always)]
            pub const fn trans_units(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x03;
                val as u8
            }
            #[doc = "3=TRANSFER_LENGTH defined in units of 16-byte segments 2=TRANSFER_LENGTH defined in units of 4-byte segments 1=TRANSFER_LENGTH defined in units of bytes 0=TRANSFER_LENGTH defined in units of bits."]
            #[inline(always)]
            pub fn set_trans_units(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize);
            }
            #[doc = "This field selects the first buffer used if Description Buffers are enabled."]
            #[inline(always)]
            pub const fn descr_buff_ptr(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "This field selects the first buffer used if Description Buffers are enabled."]
            #[inline(always)]
            pub fn set_descr_buff_ptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "This enables the Description Buffers to be used. 1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER 0=Description Buffers disabled."]
            #[inline(always)]
            pub const fn descr_buff_en(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the Description Buffers to be used. 1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER 0=Description Buffers disabled."]
            #[inline(always)]
            pub fn set_descr_buff_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANS_LEN_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub const fn trans_len(&self) -> u16 {
                let val = (self.0 >> 17usize) & 0x7fff;
                val as u16
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANS_LEN_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub fn set_trans_len(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 17usize)) | (((val as u32) & 0x7fff) << 17usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("tx_mode", &self.tx_mode())
                    .field("tx_trans_en", &self.tx_trans_en())
                    .field("tx_dma_en", &self.tx_dma_en())
                    .field("rx_trans_en", &self.rx_trans_en())
                    .field("rx_dma_en", &self.rx_dma_en())
                    .field("close_trans_en", &self.close_trans_en())
                    .field("trans_units", &self.trans_units())
                    .field("descr_buff_ptr", &self.descr_buff_ptr())
                    .field("descr_buff_en", &self.descr_buff_en())
                    .field("trans_len", &self.trans_len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ tx_mode: {=u8:?}, tx_trans_en: {=u8:?}, tx_dma_en: {=u8:?}, rx_trans_en: {=bool:?}, rx_dma_en: {=u8:?}, close_trans_en: {=bool:?}, trans_units: {=u8:?}, descr_buff_ptr: {=u8:?}, descr_buff_en: {=bool:?}, trans_len: {=u16:?} }}" , self . tx_mode () , self . tx_trans_en () , self . tx_dma_en () , self . rx_trans_en () , self . rx_dma_en () , self . close_trans_en () , self . trans_units () , self . descr_buff_ptr () , self . descr_buff_en () , self . trans_len ())
            }
        }
        #[doc = "QMSPI Description Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Descr(pub u32);
        impl Descr {
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub const fn inface_mod(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode."]
            #[inline(always)]
            pub fn set_inface_mod(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub const fn tx_trans_en(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "This field bit selects the transmit function of the SPI interface. 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used. 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus. 0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled."]
            #[inline(always)]
            pub fn set_tx_trans_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."]
            #[inline(always)]
            pub const fn tx_dma_en(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware."]
            #[inline(always)]
            pub fn set_tx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."]
            #[inline(always)]
            pub const fn rx_trans_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the receive function of the SPI interface. 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled."]
            #[inline(always)]
            pub fn set_rx_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."]
            #[inline(always)]
            pub const fn rx_dma_en(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x03;
                val as u8
            }
            #[doc = "This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size. 1=DMA is enabled.and set to 1 Byte 2=DMA is enabled and set to 2 Bytes 3=DMA is enabled and set to 4 Bytes 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware."]
            #[inline(always)]
            pub fn set_rx_dma_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 7usize)) | (((val as u32) & 0x03) << 7usize);
            }
            #[doc = "This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer. 1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer. 0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"]
            #[inline(always)]
            pub const fn close_trans_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer. 1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer. 0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active"]
            #[inline(always)]
            pub fn set_close_trans_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "1=TRANSFER_LENGTH defined in bits 0=TRANSFER_LENGTH defined in bytes"]
            #[inline(always)]
            pub const fn trans_len_bits(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "1=TRANSFER_LENGTH defined in bits 0=TRANSFER_LENGTH defined in bytes"]
            #[inline(always)]
            pub fn set_trans_len_bits(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_ COMPLETE status will be set to 1. If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted."]
            #[inline(always)]
            pub const fn descr_buf_last(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer completes the TRANSFER_ COMPLETE status will be set to 1. If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer will be activated, and no additional status will be asserted."]
            #[inline(always)]
            pub fn set_descr_buf_last(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."]
            #[inline(always)]
            pub const fn descr_buf_nxt_ptr(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop."]
            #[inline(always)]
            pub fn set_descr_buf_nxt_ptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TX_LEN_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub const fn tx_len(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "The length of the SPI transfer. The count is in bytes or bits, depending on the value of TX_LEN_BITS. A value of 0 means an infinite length transfer."]
            #[inline(always)]
            pub fn set_tx_len(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Descr {
            #[inline(always)]
            fn default() -> Descr {
                Descr(0)
            }
        }
        impl core::fmt::Debug for Descr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Descr")
                    .field("inface_mod", &self.inface_mod())
                    .field("tx_trans_en", &self.tx_trans_en())
                    .field("tx_dma_en", &self.tx_dma_en())
                    .field("rx_trans_en", &self.rx_trans_en())
                    .field("rx_dma_en", &self.rx_dma_en())
                    .field("close_trans_en", &self.close_trans_en())
                    .field("trans_len_bits", &self.trans_len_bits())
                    .field("descr_buf_last", &self.descr_buf_last())
                    .field("descr_buf_nxt_ptr", &self.descr_buf_nxt_ptr())
                    .field("tx_len", &self.tx_len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Descr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Descr {{ inface_mod: {=u8:?}, tx_trans_en: {=u8:?}, tx_dma_en: {=u8:?}, rx_trans_en: {=bool:?}, rx_dma_en: {=u8:?}, close_trans_en: {=bool:?}, trans_len_bits: {=bool:?}, descr_buf_last: {=bool:?}, descr_buf_nxt_ptr: {=u8:?}, tx_len: {=u16:?} }}" , self . inface_mod () , self . tx_trans_en () , self . tx_dma_en () , self . rx_trans_en () , self . rx_dma_en () , self . close_trans_en () , self . trans_len_bits () , self . descr_buf_last () , self . descr_buf_nxt_ptr () , self . tx_len ())
            }
        }
        #[doc = "QMSPI Execute Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Exe(pub u32);
        impl Exe {
            #[doc = "Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing. This bit must not be set to 1 if the field STOP in this register is set to 1."]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing. This bit must not be set to 1 if the field STOP in this register is set to 1."]
            #[inline(always)]
            pub fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect. This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1."]
            #[inline(always)]
            pub const fn stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect. This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1."]
            #[inline(always)]
            pub fn set_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset. Writing a 0 to this bit has no effect. This bit is self clearing."]
            #[inline(always)]
            pub const fn clr_dat_buff(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset. Writing a 0 to this bit has no effect. This bit is self clearing."]
            #[inline(always)]
            pub fn set_clr_dat_buff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Exe {
            #[inline(always)]
            fn default() -> Exe {
                Exe(0)
            }
        }
        impl core::fmt::Debug for Exe {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Exe")
                    .field("start", &self.start())
                    .field("stop", &self.stop())
                    .field("clr_dat_buff", &self.clr_dat_buff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Exe {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Exe {{ start: {=bool:?}, stop: {=bool:?}, clr_dat_buff: {=bool:?} }}",
                    self.start(),
                    self.stop(),
                    self.clr_dat_buff()
                )
            }
        }
        #[doc = "QMSPI Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u32);
        impl Ien {
            #[doc = "1=Enable an interrupt if TRANSFER_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn trans_compl_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSFER_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_trans_compl_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=Enable an interrupt if DMA_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn dma_compl_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if DMA_COMPLETE is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_dma_compl_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_err_en(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_err_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_err_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_err_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "1=Enable an interrupt if PROGRAMMING_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn prgm_err_en(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if PROGRAMMING_ERROR is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_prgm_err_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_full_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_full_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_empty_en(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_empty_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn tx_buf_req_en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_tx_buf_req_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_ful_en(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_ful_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_empty_en(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_empty_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub const fn rx_buf_req_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted 0=Disable the interrupt."]
            #[inline(always)]
            pub fn set_rx_buf_req_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("trans_compl_en", &self.trans_compl_en())
                    .field("dma_compl_en", &self.dma_compl_en())
                    .field("tx_buf_err_en", &self.tx_buf_err_en())
                    .field("rx_buf_err_en", &self.rx_buf_err_en())
                    .field("prgm_err_en", &self.prgm_err_en())
                    .field("tx_buf_full_en", &self.tx_buf_full_en())
                    .field("tx_buf_empty_en", &self.tx_buf_empty_en())
                    .field("tx_buf_req_en", &self.tx_buf_req_en())
                    .field("rx_buf_ful_en", &self.rx_buf_ful_en())
                    .field("rx_buf_empty_en", &self.rx_buf_empty_en())
                    .field("rx_buf_req_en", &self.rx_buf_req_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ien {{ trans_compl_en: {=bool:?}, dma_compl_en: {=bool:?}, tx_buf_err_en: {=bool:?}, rx_buf_err_en: {=bool:?}, prgm_err_en: {=bool:?}, tx_buf_full_en: {=bool:?}, tx_buf_empty_en: {=bool:?}, tx_buf_req_en: {=bool:?}, rx_buf_ful_en: {=bool:?}, rx_buf_empty_en: {=bool:?}, rx_buf_req_en: {=bool:?} }}" , self . trans_compl_en () , self . dma_compl_en () , self . tx_buf_err_en () , self . rx_buf_err_en () , self . prgm_err_en () , self . tx_buf_full_en () , self . tx_buf_empty_en () , self . tx_buf_req_en () , self . rx_buf_ful_en () , self . rx_buf_empty_en () , self . rx_buf_req_en ())
            }
        }
        #[doc = "QMSPI Interface Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ifctrl(pub u32);
        impl Ifctrl {
            #[doc = "This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven. 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0"]
            #[inline(always)]
            pub const fn wr_prct_out_val(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven. 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0"]
            #[inline(always)]
            pub fn set_wr_prct_out_val(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=WRITE PROTECT SPI Output Port is driven 0=WRITE PROTECT SPI Output Port is not driven"]
            #[inline(always)]
            pub const fn wr_prct_out_en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=WRITE PROTECT SPI Output Port is driven 0=WRITE PROTECT SPI Output Port is not driven"]
            #[inline(always)]
            pub fn set_wr_prct_out_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit sets the value on the HOLD SPI Output Port if it is driven. 1=HOLD is driven to 1; 0=HOLD is driven to 0."]
            #[inline(always)]
            pub const fn hld_out_val(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit sets the value on the HOLD SPI Output Port if it is driven. 1=HOLD is driven to 1; 0=HOLD is driven to 0."]
            #[inline(always)]
            pub fn set_hld_out_val(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=HOLD SPI Output Port is driven 0=HOLD SPI Output Port is not driven."]
            #[inline(always)]
            pub const fn hld_out_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=HOLD SPI Output Port is driven 0=HOLD SPI Output Port is not driven."]
            #[inline(always)]
            pub fn set_hld_out_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-down resistors enabled on Receive pins"]
            #[inline(always)]
            pub const fn pd_on_not_sel(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-down resistors enabled on Receive pins"]
            #[inline(always)]
            pub fn set_pd_on_not_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-up resistors enabled on Receive pins."]
            #[inline(always)]
            pub const fn pu_on_notsel(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted 0=No pull-up resistors enabled on Receive pins."]
            #[inline(always)]
            pub fn set_pu_on_notsel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "1=Enable pull-down resistors on Transmit pins while the pins are not driven 0=No pull-down resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub const fn pd_on_notdriven(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-down resistors on Transmit pins while the pins are not driven 0=No pull-down resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub fn set_pd_on_notdriven(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "1=Enable pull-up resistors on Transmit pins while the pins are not driven 0=No pull-up resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub const fn pu_on_notdriven(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "1=Enable pull-up resistors on Transmit pins while the pins are not driven 0=No pull-up resistors enabled ion Transmit pins."]
            #[inline(always)]
            pub fn set_pu_on_notdriven(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Ifctrl {
            #[inline(always)]
            fn default() -> Ifctrl {
                Ifctrl(0)
            }
        }
        impl core::fmt::Debug for Ifctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ifctrl")
                    .field("wr_prct_out_val", &self.wr_prct_out_val())
                    .field("wr_prct_out_en", &self.wr_prct_out_en())
                    .field("hld_out_val", &self.hld_out_val())
                    .field("hld_out_en", &self.hld_out_en())
                    .field("pd_on_not_sel", &self.pd_on_not_sel())
                    .field("pu_on_notsel", &self.pu_on_notsel())
                    .field("pd_on_notdriven", &self.pd_on_notdriven())
                    .field("pu_on_notdriven", &self.pu_on_notdriven())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ifctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ifctrl {{ wr_prct_out_val: {=bool:?}, wr_prct_out_en: {=bool:?}, hld_out_val: {=bool:?}, hld_out_en: {=bool:?}, pd_on_not_sel: {=bool:?}, pu_on_notsel: {=bool:?}, pd_on_notdriven: {=bool:?}, pu_on_notdriven: {=bool:?} }}" , self . wr_prct_out_val () , self . wr_prct_out_en () , self . hld_out_val () , self . hld_out_en () , self . pd_on_not_sel () , self . pu_on_notsel () , self . pd_on_notdriven () , self . pu_on_notdriven ())
            }
        }
        #[doc = "QMSPI Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "This bit is used to activate the QMSPI block. 1=Enabled. The block is fully operational 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state."]
            #[inline(always)]
            pub const fn act(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is used to activate the QMSPI block. 1=Enabled. The block is fully operational 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state."]
            #[inline(always)]
            pub fn set_act(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing."]
            #[inline(always)]
            pub const fn soft_rst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing."]
            #[inline(always)]
            pub fn set_soft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low."]
            #[inline(always)]
            pub const fn cpol(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low."]
            #[inline(always)]
            pub fn set_cpol(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock"]
            #[inline(always)]
            pub const fn chpa_mosi(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock"]
            #[inline(always)]
            pub fn set_chpa_mosi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock"]
            #[inline(always)]
            pub const fn chpa_miso(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register. e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings. If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock"]
            #[inline(always)]
            pub fn set_chpa_miso(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256."]
            #[inline(always)]
            pub const fn clk_div(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x01ff;
                val as u16
            }
            #[doc = "The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256."]
            #[inline(always)]
            pub fn set_clk_div(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 16usize)) | (((val as u32) & 0x01ff) << 16usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("act", &self.act())
                    .field("soft_rst", &self.soft_rst())
                    .field("cpol", &self.cpol())
                    .field("chpa_mosi", &self.chpa_mosi())
                    .field("chpa_miso", &self.chpa_miso())
                    .field("clk_div", &self.clk_div())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mode {{ act: {=bool:?}, soft_rst: {=bool:?}, cpol: {=bool:?}, chpa_mosi: {=bool:?}, chpa_miso: {=bool:?}, clk_div: {=u16:?} }}" , self . act () , self . soft_rst () , self . cpol () , self . chpa_mosi () , self . chpa_miso () , self . clk_div ())
            }
        }
        #[doc = "QMSPI Receive Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxFifoU08(pub u8);
        impl RxFifoU08 {
            #[doc = "Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO. Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits \\[7:0\\] and a Word read will have data on bits \\[15:0\\]. It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error). Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."]
            #[inline(always)]
            pub const fn rx_buf(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO. Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits \\[7:0\\] and a Word read will have data on bits \\[15:0\\]. It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error). Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."]
            #[inline(always)]
            pub fn set_rx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u8) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for RxFifoU08 {
            #[inline(always)]
            fn default() -> RxFifoU08 {
                RxFifoU08(0)
            }
        }
        impl core::fmt::Debug for RxFifoU08 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxFifoU08").field("rx_buf", &self.rx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxFifoU08 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxFifoU08 {{ rx_buf: {=u32:?} }}", self.rx_buf())
            }
        }
        #[doc = "QMSPI Receive Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxFifoU16(pub u16);
        impl RxFifoU16 {
            #[doc = "Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO. Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits \\[7:0\\] and a Word read will have data on bits \\[15:0\\]. It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error). Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."]
            #[inline(always)]
            pub const fn rx_buf(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO. Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits \\[7:0\\] and a Word read will have data on bits \\[15:0\\]. It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error). Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."]
            #[inline(always)]
            pub fn set_rx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u16) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for RxFifoU16 {
            #[inline(always)]
            fn default() -> RxFifoU16 {
                RxFifoU16(0)
            }
        }
        impl core::fmt::Debug for RxFifoU16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxFifoU16").field("rx_buf", &self.rx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxFifoU16 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxFifoU16 {{ rx_buf: {=u32:?} }}", self.rx_buf())
            }
        }
        #[doc = "QMSPI Receive Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxFifoU32(pub u32);
        impl RxFifoU32 {
            #[doc = "Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO. Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits \\[7:0\\] and a Word read will have data on bits \\[15:0\\]. It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error). Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."]
            #[inline(always)]
            pub const fn rx_buf(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO. Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits \\[7:0\\] and a Word read will have data on bits \\[15:0\\]. It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error). Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field."]
            #[inline(always)]
            pub fn set_rx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for RxFifoU32 {
            #[inline(always)]
            fn default() -> RxFifoU32 {
                RxFifoU32(0)
            }
        }
        impl core::fmt::Debug for RxFifoU32 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxFifoU32").field("rx_buf", &self.rx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxFifoU32 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxFifoU32 {{ rx_buf: {=u32:?} }}", self.rx_buf())
            }
        }
        #[doc = "QMSPI Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH. If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer. In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied. 1=Transfer completed; 0=Transfer not complete."]
            #[inline(always)]
            pub const fn trans_compl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH. If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer. In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied. 1=Transfer completed; 0=Transfer not complete."]
            #[inline(always)]
            pub fn set_trans_compl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller. This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously. This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode. 1=DMA completed; 0=DMA not completed."]
            #[inline(always)]
            pub const fn dma_compl(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller. This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously. This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode. 1=DMA completed; 0=DMA not completed."]
            #[inline(always)]
            pub fn set_dma_compl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "1=Overflow error occurred (attempt to write to a full Transmit Buffer) 0=No overflow occurred."]
            #[inline(always)]
            pub const fn tx_buff_err(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "1=Overflow error occurred (attempt to write to a full Transmit Buffer) 0=No overflow occurred."]
            #[inline(always)]
            pub fn set_tx_buff_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=Underflow error occurred (attempt to read from an empty Receive Buffer) 0=No underflow occurred."]
            #[inline(always)]
            pub const fn rx_buff_err(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=Underflow error occurred (attempt to read from an empty Receive Buffer) 0=No underflow occurred."]
            #[inline(always)]
            pub fn set_rx_buff_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This bit if a programming error is detected. 1=Programming Error detected; 0=No programming error detected."]
            #[inline(always)]
            pub const fn prgm_err(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit if a programming error is detected. 1=Programming Error detected; 0=No programming error detected."]
            #[inline(always)]
            pub fn set_prgm_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "1=The Transmit Buffer is full 0=The Transmit Buffer is not full."]
            #[inline(always)]
            pub const fn tx_buff_full(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Transmit Buffer is full 0=The Transmit Buffer is not full."]
            #[inline(always)]
            pub fn set_tx_buff_full(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "1=The Transmit Buffer is empty 0=The Transmit Buffer is not empty."]
            #[inline(always)]
            pub const fn tx_buff_emp(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Transmit Buffer is empty 0=The Transmit Buffer is not empty."]
            #[inline(always)]
            pub fn set_tx_buff_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field. 1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER."]
            #[inline(always)]
            pub const fn tx_buff_req(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field. 1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER."]
            #[inline(always)]
            pub fn set_tx_buff_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub const fn tx_buff_stall(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub fn set_tx_buff_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "1=The Receive Buffer is full 0=The Receive Buffer is not full."]
            #[inline(always)]
            pub const fn rx_buff_full(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Receive Buffer is full 0=The Receive Buffer is not full."]
            #[inline(always)]
            pub fn set_rx_buff_full(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "1=The Receive Buffer is empty 0=The Receive Buffer is not empty."]
            #[inline(always)]
            pub const fn rx_buff_emp(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "1=The Receive Buffer is empty 0=The Receive Buffer is not empty."]
            #[inline(always)]
            pub fn set_rx_buff_emp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field. 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER."]
            #[inline(always)]
            pub const fn rx_buff_req(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field. 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER."]
            #[inline(always)]
            pub fn set_rx_buff_req(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub const fn rx_buff_stall(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer) 0=No stalls occurred."]
            #[inline(always)]
            pub fn set_rx_buff_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "1=A transfer is currently executing 0=No transfer currently in progress."]
            #[inline(always)]
            pub const fn trans_activ(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "1=A transfer is currently executing 0=No transfer currently in progress."]
            #[inline(always)]
            pub fn set_trans_activ(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled."]
            #[inline(always)]
            pub const fn cur_descr_buf(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled."]
            #[inline(always)]
            pub fn set_cur_descr_buf(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("trans_compl", &self.trans_compl())
                    .field("dma_compl", &self.dma_compl())
                    .field("tx_buff_err", &self.tx_buff_err())
                    .field("rx_buff_err", &self.rx_buff_err())
                    .field("prgm_err", &self.prgm_err())
                    .field("tx_buff_full", &self.tx_buff_full())
                    .field("tx_buff_emp", &self.tx_buff_emp())
                    .field("tx_buff_req", &self.tx_buff_req())
                    .field("tx_buff_stall", &self.tx_buff_stall())
                    .field("rx_buff_full", &self.rx_buff_full())
                    .field("rx_buff_emp", &self.rx_buff_emp())
                    .field("rx_buff_req", &self.rx_buff_req())
                    .field("rx_buff_stall", &self.rx_buff_stall())
                    .field("trans_activ", &self.trans_activ())
                    .field("cur_descr_buf", &self.cur_descr_buf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sts {{ trans_compl: {=bool:?}, dma_compl: {=bool:?}, tx_buff_err: {=bool:?}, rx_buff_err: {=bool:?}, prgm_err: {=bool:?}, tx_buff_full: {=bool:?}, tx_buff_emp: {=bool:?}, tx_buff_req: {=bool:?}, tx_buff_stall: {=bool:?}, rx_buff_full: {=bool:?}, rx_buff_emp: {=bool:?}, rx_buff_req: {=bool:?}, rx_buff_stall: {=bool:?}, trans_activ: {=bool:?}, cur_descr_buf: {=u8:?} }}" , self . trans_compl () , self . dma_compl () , self . tx_buff_err () , self . rx_buff_err () , self . prgm_err () , self . tx_buff_full () , self . tx_buff_emp () , self . tx_buff_req () , self . tx_buff_stall () , self . rx_buff_full () , self . rx_buff_emp () , self . rx_buff_req () , self . rx_buff_stall () , self . trans_activ () , self . cur_descr_buf ())
            }
        }
        #[doc = "QMSPI Transmit Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxFifoU08(pub u8);
        impl TxFifoU08 {
            #[doc = "Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave. Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes. The data must always be aligned to the bottom most byte (so 1 byte write is on bits \\[7:0\\] and Word write is on \\[15:0\\]). An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."]
            #[inline(always)]
            pub const fn tx_buf(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave. Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes. The data must always be aligned to the bottom most byte (so 1 byte write is on bits \\[7:0\\] and Word write is on \\[15:0\\]). An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."]
            #[inline(always)]
            pub fn set_tx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u8) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for TxFifoU08 {
            #[inline(always)]
            fn default() -> TxFifoU08 {
                TxFifoU08(0)
            }
        }
        impl core::fmt::Debug for TxFifoU08 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxFifoU08").field("tx_buf", &self.tx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxFifoU08 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxFifoU08 {{ tx_buf: {=u32:?} }}", self.tx_buf())
            }
        }
        #[doc = "QMSPI Transmit Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxFifoU16(pub u16);
        impl TxFifoU16 {
            #[doc = "Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave. Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes. The data must always be aligned to the bottom most byte (so 1 byte write is on bits \\[7:0\\] and Word write is on \\[15:0\\]). An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."]
            #[inline(always)]
            pub const fn tx_buf(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave. Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes. The data must always be aligned to the bottom most byte (so 1 byte write is on bits \\[7:0\\] and Word write is on \\[15:0\\]). An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."]
            #[inline(always)]
            pub fn set_tx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u16) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for TxFifoU16 {
            #[inline(always)]
            fn default() -> TxFifoU16 {
                TxFifoU16(0)
            }
        }
        impl core::fmt::Debug for TxFifoU16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxFifoU16").field("tx_buf", &self.tx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxFifoU16 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxFifoU16 {{ tx_buf: {=u32:?} }}", self.tx_buf())
            }
        }
        #[doc = "QMSPI Transmit Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxFifoU32(pub u32);
        impl TxFifoU32 {
            #[doc = "Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave. Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes. The data must always be aligned to the bottom most byte (so 1 byte write is on bits \\[7:0\\] and Word write is on \\[15:0\\]). An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."]
            #[inline(always)]
            pub const fn tx_buf(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave. Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes. The data must always be aligned to the bottom most byte (so 1 byte write is on bits \\[7:0\\] and Word write is on \\[15:0\\]). An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field."]
            #[inline(always)]
            pub fn set_tx_buf(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for TxFifoU32 {
            #[inline(always)]
            fn default() -> TxFifoU32 {
                TxFifoU32(0)
            }
        }
        impl core::fmt::Debug for TxFifoU32 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxFifoU32").field("tx_buf", &self.tx_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxFifoU32 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxFifoU32 {{ tx_buf: {=u32:?} }}", self.tx_buf())
            }
        }
    }
}
pub mod rc_id0 {
    #[doc = "This interface provides a single pin interface which can discriminate a number of quantized RC constants."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct RcId0 {
        ptr: *mut u8,
    }
    unsafe impl Send for RcId0 {}
    unsafe impl Sync for RcId0 {}
    impl RcId0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RC_ID Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Reads of this register provide the result of an RC_ID measurement."]
        #[inline(always)]
        pub const fn dat(self) -> crate::common::Reg<regs::Dat, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "RC_ID Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes an RC_ID measurement."]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes an RC_ID measurement."]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes the Discharged phase of an RC_ID measurement."]
            #[inline(always)]
            pub const fn tc(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes the Discharged phase of an RC_ID measurement."]
            #[inline(always)]
            pub fn set_tc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This bit is 1 if an RC_ID measurement encountered an error and the reading in the RC_ID Data Register is invalid. This bit is cleared to 0 when the RC_ID interface is in the Reset phase."]
            #[inline(always)]
            pub const fn cy_er(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is 1 if an RC_ID measurement encountered an error and the reading in the RC_ID Data Register is invalid. This bit is cleared to 0 when the RC_ID interface is in the Reset phase."]
            #[inline(always)]
            pub fn set_cy_er(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Setting this bit to 1 initiates the Discharged phase of an RC_ID measurement."]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Setting this bit to 1 initiates the Discharged phase of an RC_ID measurement."]
            #[inline(always)]
            pub fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Clearing the bit to 0 causes the RC_ID interface to enter the Reset state, gating its clocks, clearing the status bits in this register and entering into its lowest power state. Setting this bit to 1 causes the RC_ID interface to enter the Armed phase of an RC_ID measurement."]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Clearing the bit to 0 causes the RC_ID interface to enter the Reset state, gating its clocks, clearing the status bits in this register and entering into its lowest power state. Setting this bit to 1 causes the RC_ID interface to enter the Armed phase of an RC_ID measurement."]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This field selects the frequency of the Counter circuit clock. This field must retain the same value as long as the ENABLE bit in this register is 1."]
            #[inline(always)]
            pub const fn clock_set(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "This field selects the frequency of the Counter circuit clock. This field must retain the same value as long as the ENABLE bit in this register is 1."]
            #[inline(always)]
            pub fn set_clock_set(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("done", &self.done())
                    .field("tc", &self.tc())
                    .field("cy_er", &self.cy_er())
                    .field("start", &self.start())
                    .field("enable", &self.enable())
                    .field("clock_set", &self.clock_set())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ done: {=bool:?}, tc: {=bool:?}, cy_er: {=bool:?}, start: {=bool:?}, enable: {=bool:?}, clock_set: {=u8:?} }}" , self . done () , self . tc () , self . cy_er () , self . start () , self . enable () , self . clock_set ())
            }
        }
        #[doc = "Reads of this register provide the result of an RC_ID measurement."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dat(pub u32);
        impl Dat {
            #[doc = "Reads of this register provide the result of an RC_ID measurement."]
            #[inline(always)]
            pub const fn rcid_data(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Reads of this register provide the result of an RC_ID measurement."]
            #[inline(always)]
            pub fn set_rcid_data(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dat {
            #[inline(always)]
            fn default() -> Dat {
                Dat(0)
            }
        }
        impl core::fmt::Debug for Dat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dat").field("rcid_data", &self.rcid_data()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dat {{ rcid_data: {=u16:?} }}", self.rcid_data())
            }
        }
    }
}
pub mod rtc {
    #[doc = "This is the set of registers that are automatically counted by hardware every 1 second while the block is enabled to run and to update. These registers are: Seconds, Minutes, Hours, Day of Week, Day of Month, Month, and Year."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtc {}
    unsafe impl Sync for Rtc {}
    impl Rtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Seconds Register"]
        #[inline(always)]
        pub const fn sec(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Seconds Alarm Register"]
        #[inline(always)]
        pub const fn sec_alarm(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Minutes Register"]
        #[inline(always)]
        pub const fn min(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Minutes Alarm Register"]
        #[inline(always)]
        pub const fn min_alarm(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Hours Register"]
        #[inline(always)]
        pub const fn hr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Hours Alarm Register"]
        #[inline(always)]
        pub const fn hr_alarm(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "Day of Week Register"]
        #[inline(always)]
        pub const fn day_of_wk(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Day of Month Register"]
        #[inline(always)]
        pub const fn day_of_mon(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "Month Register"]
        #[inline(always)]
        pub const fn month(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Year Register"]
        #[inline(always)]
        pub const fn year(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "Register A"]
        #[inline(always)]
        pub const fn rega(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Register B"]
        #[inline(always)]
        pub const fn regb(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "Register C"]
        #[inline(always)]
        pub const fn regc(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Register D"]
        #[inline(always)]
        pub const fn regd(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "RTC Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Week Alarm Register\\[7:0\\] - ALARM_DAY_OF_WEEK This register, if written to a value in the range 1- -7, will inhibit the Alarm interrupt unless this field matches the contents of the Day of Week Register also."]
        #[inline(always)]
        pub const fn wk_alarm(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Daylight Savings Forward Register"]
        #[inline(always)]
        pub const fn daylt_savf(self) -> crate::common::Reg<regs::DayltSavf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Daylight Savings Backward Register"]
        #[inline(always)]
        pub const fn daylt_savb(self) -> crate::common::Reg<regs::DayltSavb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "RTC Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "BLK_EN This bit must be '1' in order for the block to function internally. Registers may be initialized first, before setting this bit to '1' to start operation."]
            #[inline(always)]
            pub const fn blk_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "BLK_EN This bit must be '1' in order for the block to function internally. Registers may be initialized first, before setting this bit to '1' to start operation."]
            #[inline(always)]
            pub fn set_blk_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SOFT_RST A '1' written to this bit position will trigger the RTC_RST reset, resetting the block and all registers except this one and the Test Register. This bit is self-clearing at the end of the reset, one cycle of Host Bus Clock later, and so requires no waiting."]
            #[inline(always)]
            pub const fn soft_rst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "SOFT_RST A '1' written to this bit position will trigger the RTC_RST reset, resetting the block and all registers except this one and the Test Register. This bit is self-clearing at the end of the reset, one cycle of Host Bus Clock later, and so requires no waiting."]
            #[inline(always)]
            pub fn set_soft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "TEST"]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "TEST"]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "ALM_EN 1=Enables the Alarm features, 0=Disables the Alarm features"]
            #[inline(always)]
            pub const fn alm_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ALM_EN 1=Enables the Alarm features, 0=Disables the Alarm features"]
            #[inline(always)]
            pub fn set_alm_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("blk_en", &self.blk_en())
                    .field("soft_rst", &self.soft_rst())
                    .field("test", &self.test())
                    .field("alm_en", &self.alm_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl {{ blk_en: {=bool:?}, soft_rst: {=bool:?}, test: {=bool:?}, alm_en: {=bool:?} }}",
                    self.blk_en(),
                    self.soft_rst(),
                    self.test(),
                    self.alm_en()
                )
            }
        }
        #[doc = "Daylight Savings Backward Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DayltSavb(pub u32);
        impl DayltSavb {
            #[doc = "This field matches the Month Register."]
            #[inline(always)]
            pub const fn dst_mon(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field matches the Month Register."]
            #[inline(always)]
            pub fn set_dst_mon(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field matches the Day of Week Register bits\\[2:0\\]."]
            #[inline(always)]
            pub const fn dst_day_of_wk(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "This field matches the Day of Week Register bits\\[2:0\\]."]
            #[inline(always)]
            pub fn set_dst_day_of_wk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize);
            }
            #[doc = "5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month"]
            #[inline(always)]
            pub const fn dst_wk(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month"]
            #[inline(always)]
            pub fn set_dst_wk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
            #[doc = "This field holds the matching value for bits\\[6:0\\] of the Hours register. The written value will be interpreted according to the 24/12 Hour mode and DM mode settings at the time of writing."]
            #[inline(always)]
            pub const fn dst_hr(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x7f;
                val as u8
            }
            #[doc = "This field holds the matching value for bits\\[6:0\\] of the Hours register. The written value will be interpreted according to the 24/12 Hour mode and DM mode settings at the time of writing."]
            #[inline(always)]
            pub fn set_dst_hr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 24usize)) | (((val as u32) & 0x7f) << 24usize);
            }
            #[doc = "This bit selects AM vs. PM, to match bit\\[7\\] of the Hours Register if 12-Hour mode is selected in Register B at the time of writing."]
            #[inline(always)]
            pub const fn dst_am_pm(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects AM vs. PM, to match bit\\[7\\] of the Hours Register if 12-Hour mode is selected in Register B at the time of writing."]
            #[inline(always)]
            pub fn set_dst_am_pm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for DayltSavb {
            #[inline(always)]
            fn default() -> DayltSavb {
                DayltSavb(0)
            }
        }
        impl core::fmt::Debug for DayltSavb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DayltSavb")
                    .field("dst_mon", &self.dst_mon())
                    .field("dst_day_of_wk", &self.dst_day_of_wk())
                    .field("dst_wk", &self.dst_wk())
                    .field("dst_hr", &self.dst_hr())
                    .field("dst_am_pm", &self.dst_am_pm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DayltSavb {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DayltSavb {{ dst_mon: {=u8:?}, dst_day_of_wk: {=u8:?}, dst_wk: {=u8:?}, dst_hr: {=u8:?}, dst_am_pm: {=bool:?} }}" , self . dst_mon () , self . dst_day_of_wk () , self . dst_wk () , self . dst_hr () , self . dst_am_pm ())
            }
        }
        #[doc = "Daylight Savings Forward Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DayltSavf(pub u32);
        impl DayltSavf {
            #[doc = "This field matches the Month Register."]
            #[inline(always)]
            pub const fn dst_mon(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field matches the Month Register."]
            #[inline(always)]
            pub fn set_dst_mon(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field matches the Day of Week Register bits\\[2:0\\]."]
            #[inline(always)]
            pub const fn dst_day_of_wk(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "This field matches the Day of Week Register bits\\[2:0\\]."]
            #[inline(always)]
            pub fn set_dst_day_of_wk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize);
            }
            #[doc = "5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month"]
            #[inline(always)]
            pub const fn dst_wk(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month"]
            #[inline(always)]
            pub fn set_dst_wk(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
            #[doc = "This field holds the matching value for bits\\[6:0\\] of the Hours register. The written value will be interpreted according to the 24/12 Hour mode and DM mode settings at the time of writing."]
            #[inline(always)]
            pub const fn dst_hr(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x7f;
                val as u8
            }
            #[doc = "This field holds the matching value for bits\\[6:0\\] of the Hours register. The written value will be interpreted according to the 24/12 Hour mode and DM mode settings at the time of writing."]
            #[inline(always)]
            pub fn set_dst_hr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 24usize)) | (((val as u32) & 0x7f) << 24usize);
            }
            #[doc = "This bit selects AM vs. PM, to match bit\\[7\\] of the Hours Register if 12-Hour mode is selected in Register B at the time of writing."]
            #[inline(always)]
            pub const fn dst_am_pm(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects AM vs. PM, to match bit\\[7\\] of the Hours Register if 12-Hour mode is selected in Register B at the time of writing."]
            #[inline(always)]
            pub fn set_dst_am_pm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for DayltSavf {
            #[inline(always)]
            fn default() -> DayltSavf {
                DayltSavf(0)
            }
        }
        impl core::fmt::Debug for DayltSavf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DayltSavf")
                    .field("dst_mon", &self.dst_mon())
                    .field("dst_day_of_wk", &self.dst_day_of_wk())
                    .field("dst_wk", &self.dst_wk())
                    .field("dst_hr", &self.dst_hr())
                    .field("dst_am_pm", &self.dst_am_pm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DayltSavf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DayltSavf {{ dst_mon: {=u8:?}, dst_day_of_wk: {=u8:?}, dst_wk: {=u8:?}, dst_hr: {=u8:?}, dst_am_pm: {=bool:?} }}" , self . dst_mon () , self . dst_day_of_wk () , self . dst_wk () , self . dst_hr () , self . dst_am_pm ())
            }
        }
    }
}
pub mod rtos {
    #[doc = "The RTOS Timer is a low-power, 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states. This allows firmware the option to sleep the processor, enter heavy or deep chip sleep states, and wake after a programmed amount of time. The timer may be used as a one-shot timer or a continuous timer. When the timer transitions to 0 it is capable of generating a wake-capable interrupt to the embedded controller. This timer may be halted during debug by hardware or via a software control bit."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtos {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtos {}
    unsafe impl Sync for Rtos {}
    impl Rtos {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RTOS Timer Count Register."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<regs::Cnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "RTOS Timer Preload Register"]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<regs::Prld, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "RTOS Timer Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Soft Interrupt Register"]
        #[inline(always)]
        pub const fn softirq(self) -> crate::common::Reg<regs::Softirq, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "RTOS Timer Count Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cnt(pub u32);
        impl Cnt {
            #[doc = "This register contains the current value of the RTOS Timer counter. This register should be read as a DWORD. There is no latching mechanism of the upper bytes implemented if the register is accessed as a byte or word. Reading the register with byte or word operations may give incorrect results."]
            #[inline(always)]
            pub const fn cntr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "This register contains the current value of the RTOS Timer counter. This register should be read as a DWORD. There is no latching mechanism of the upper bytes implemented if the register is accessed as a byte or word. Reading the register with byte or word operations may give incorrect results."]
            #[inline(always)]
            pub fn set_cntr(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Cnt {
            #[inline(always)]
            fn default() -> Cnt {
                Cnt(0)
            }
        }
        impl core::fmt::Debug for Cnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cnt").field("cntr", &self.cntr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cnt {{ cntr: {=u32:?} }}", self.cntr())
            }
        }
        #[doc = "RTOS Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "1=RTOS timer counter is enabled 0=RTOS timer disabled. All register bits are reset to their default state"]
            #[inline(always)]
            pub const fn blk_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=RTOS timer counter is enabled 0=RTOS timer disabled. All register bits are reset to their default state"]
            #[inline(always)]
            pub fn set_blk_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "1=The the RTOS Timer Preload Register is loaded into the timer counter and the counter is restarted when the counter transitions from 1 to 0 0=The timer counter halts when it transitions from 1 to 0 and will not restart."]
            #[inline(always)]
            pub const fn au_reload(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1=The the RTOS Timer Preload Register is loaded into the timer counter and the counter is restarted when the counter transitions from 1 to 0 0=The timer counter halts when it transitions from 1 to 0 and will not restart."]
            #[inline(always)]
            pub fn set_au_reload(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Writing a 1 to this bit will load the timer counter with the RTOS Timer Preload Register and start counting. If the Preload Register is 0, counting will not start and this bit will be cleared to 0. Writing a 0 to this bit will halt the counter and clear its contents to 0. The RTOS timer interrupt will not be generated. This bit is automatically cleared if the AUTO_RELOAD bit is 0 and the timer counter transitions from 1 to 0."]
            #[inline(always)]
            pub const fn tmr_strt(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 to this bit will load the timer counter with the RTOS Timer Preload Register and start counting. If the Preload Register is 0, counting will not start and this bit will be cleared to 0. Writing a 0 to this bit will halt the counter and clear its contents to 0. The RTOS timer interrupt will not be generated. This bit is automatically cleared if the AUTO_RELOAD bit is 0 and the timer counter transitions from 1 to 0."]
            #[inline(always)]
            pub fn set_tmr_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "1=The timer counter is halted when the external HALT signal is asserted. Counting is always enabled if HALT is de-asserted. 0=The HALT signal does not affect the RTOS Timer"]
            #[inline(always)]
            pub const fn ext_hw_halt_en(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "1=The timer counter is halted when the external HALT signal is asserted. Counting is always enabled if HALT is de-asserted. 0=The HALT signal does not affect the RTOS Timer"]
            #[inline(always)]
            pub fn set_ext_hw_halt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "1=The timer counter is halted. If the counter was running, clearing this bit will restart the counter from the value at which it halted 0=The timer counter, if enabled, will continue to run"]
            #[inline(always)]
            pub const fn fw_tmr_halt(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "1=The timer counter is halted. If the counter was running, clearing this bit will restart the counter from the value at which it halted 0=The timer counter, if enabled, will continue to run"]
            #[inline(always)]
            pub fn set_fw_tmr_halt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("blk_en", &self.blk_en())
                    .field("au_reload", &self.au_reload())
                    .field("tmr_strt", &self.tmr_strt())
                    .field("ext_hw_halt_en", &self.ext_hw_halt_en())
                    .field("fw_tmr_halt", &self.fw_tmr_halt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ blk_en: {=bool:?}, au_reload: {=bool:?}, tmr_strt: {=bool:?}, ext_hw_halt_en: {=bool:?}, fw_tmr_halt: {=bool:?} }}" , self . blk_en () , self . au_reload () , self . tmr_strt () , self . ext_hw_halt_en () , self . fw_tmr_halt ())
            }
        }
        #[doc = "RTOS Timer Preload Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prld(pub u32);
        impl Prld {
            #[doc = "The this register is loaded into the RTOS Timer counter either when the TIMER_START bit is written with a 1, or when the timer counter counts down to 0 and the AUTO_RELOAD bit is 1. This register must be programmed with a new count value before the TIMER_START bit is set to 1. If this register is updated while the counter is operating, the new count value will only take effect if the counter transitions form 1 to 0 while the AUTO_RELOAD bit is set."]
            #[inline(always)]
            pub const fn preload(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "The this register is loaded into the RTOS Timer counter either when the TIMER_START bit is written with a 1, or when the timer counter counts down to 0 and the AUTO_RELOAD bit is 1. This register must be programmed with a new count value before the TIMER_START bit is set to 1. If this register is updated while the counter is operating, the new count value will only take effect if the counter transitions form 1 to 0 while the AUTO_RELOAD bit is set."]
            #[inline(always)]
            pub fn set_preload(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Prld {
            #[inline(always)]
            fn default() -> Prld {
                Prld(0)
            }
        }
        impl core::fmt::Debug for Prld {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prld").field("preload", &self.preload()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prld {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prld {{ preload: {=u32:?} }}", self.preload())
            }
        }
        #[doc = "Soft Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Softirq(pub u32);
        impl Softirq {
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub const fn swi3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC. Writes of a '0' have no effect. Reads return '0'."]
            #[inline(always)]
            pub fn set_swi3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Softirq {
            #[inline(always)]
            fn default() -> Softirq {
                Softirq(0)
            }
        }
        impl core::fmt::Debug for Softirq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Softirq")
                    .field("swi0", &self.swi0())
                    .field("swi1", &self.swi1())
                    .field("swi2", &self.swi2())
                    .field("swi3", &self.swi3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Softirq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Softirq {{ swi0: {=bool:?}, swi1: {=bool:?}, swi2: {=bool:?}, swi3: {=bool:?} }}",
                    self.swi0(),
                    self.swi1(),
                    self.swi2(),
                    self.swi3()
                )
            }
        }
    }
}
pub mod smb0 {
    #[doc = "The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Smb0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Smb0 {}
    unsafe impl Sync for Smb0 {}
    impl Smb0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Status Register"]
        #[inline(always)]
        pub const fn rsts(self) -> crate::common::Reg<regs::Rsts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Control Register"]
        #[inline(always)]
        pub const fn wctrl(self) -> crate::common::Reg<regs::Wctrl, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Own Address Register Note that the Data Register and Own Address fields are offset by one bit, so that programming Own Address 1 with a value of 55h will result in the value AAh being recognized as the SMB Controller Core slave address."]
        #[inline(always)]
        pub const fn own_addr(self) -> crate::common::Reg<regs::OwnAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This register holds the data that are either shifted out to or shifted in from the I2C port."]
        #[inline(always)]
        pub const fn i2cdata(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Reserved"]
        #[inline(always)]
        pub const fn rsvd1(self, n: usize) -> crate::common::Reg<u8, crate::common::R> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize + n * 1usize) as _) }
        }
        #[doc = "SMBus Master Command Register"]
        #[inline(always)]
        pub const fn mcmd_u08(self, n: usize) -> crate::common::Reg<regs::McmdU08, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 1usize) as _) }
        }
        #[doc = "SMBus Master Command Register"]
        #[inline(always)]
        pub const fn mcmd_u16(self, n: usize) -> crate::common::Reg<regs::McmdU16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 2usize) as _) }
        }
        #[doc = "SMBus Master Command Register"]
        #[inline(always)]
        pub const fn mcmd_u32(self) -> crate::common::Reg<regs::McmdU32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SMBus Slave Command Register"]
        #[inline(always)]
        pub const fn scmd_u08(self, n: usize) -> crate::common::Reg<regs::ScmdU08, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 1usize) as _) }
        }
        #[doc = "SMBus Slave Command Register"]
        #[inline(always)]
        pub const fn scmd_u16(self, n: usize) -> crate::common::Reg<regs::ScmdU16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 2usize) as _) }
        }
        #[doc = "SMBus Slave Command Register"]
        #[inline(always)]
        pub const fn scmd_u32(self) -> crate::common::Reg<regs::ScmdU32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Packet Error Check (PEC) Register"]
        #[inline(always)]
        pub const fn pec(self) -> crate::common::Reg<regs::Pec, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Repeated Start Hold Time Register"]
        #[inline(always)]
        pub const fn rshtm(self) -> crate::common::Reg<regs::Rshtm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Reserved"]
        #[inline(always)]
        pub const fn rsvd2(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Completion Register"]
        #[inline(always)]
        pub const fn compl_u08(self, n: usize) -> crate::common::Reg<regs::ComplU08, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 1usize) as _) }
        }
        #[doc = "Completion Register"]
        #[inline(always)]
        pub const fn compl_u16(self, n: usize) -> crate::common::Reg<regs::ComplU16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 2usize) as _) }
        }
        #[doc = "Completion Register"]
        #[inline(always)]
        pub const fn compl_u32(self) -> crate::common::Reg<regs::ComplU32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Idle Scaling Register"]
        #[inline(always)]
        pub const fn idlsc(self) -> crate::common::Reg<regs::Idlsc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Configuration Register"]
        #[inline(always)]
        pub const fn cfg_u08(self, n: usize) -> crate::common::Reg<regs::CfgU08, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize + n * 1usize) as _) }
        }
        #[doc = "Configuration Register"]
        #[inline(always)]
        pub const fn cfg_u16(self, n: usize) -> crate::common::Reg<regs::CfgU16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize + n * 2usize) as _) }
        }
        #[doc = "Configuration Register"]
        #[inline(always)]
        pub const fn cfg_u32(self) -> crate::common::Reg<regs::CfgU32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Bus Clock Register"]
        #[inline(always)]
        pub const fn busclk(self) -> crate::common::Reg<regs::Busclk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Block ID Register"]
        #[inline(always)]
        pub const fn blkid(self) -> crate::common::Reg<regs::Blkid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Revision Register"]
        #[inline(always)]
        pub const fn blkrev(self) -> crate::common::Reg<regs::Blkrev, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Bit-Bang Control Register"]
        #[inline(always)]
        pub const fn bbctrl(self) -> crate::common::Reg<regs::Bbctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Test"]
        #[inline(always)]
        pub const fn test(self) -> crate::common::Reg<regs::Test, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Data Timing Register"]
        #[inline(always)]
        pub const fn datatm(self) -> crate::common::Reg<regs::Datatm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Time-Out Scaling Register"]
        #[inline(always)]
        pub const fn tmoutsc(self) -> crate::common::Reg<regs::Tmoutsc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "SMBus Slave Transmit Buffer Register"]
        #[inline(always)]
        pub const fn slv_txb(self) -> crate::common::Reg<regs::SlvTxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "SMBus Slave Receive Buffer Register"]
        #[inline(always)]
        pub const fn slv_rxb(self) -> crate::common::Reg<regs::SlvRxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "SMBus Master Transmit Buffer Register"]
        #[inline(always)]
        pub const fn mtr_txb(self) -> crate::common::Reg<regs::MtrTxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "SMBus Master Receive Buffer Register"]
        #[inline(always)]
        pub const fn mtr_rxb(self) -> crate::common::Reg<regs::MtrRxb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "WAKE STATUS Register"]
        #[inline(always)]
        pub const fn wake_sts(self) -> crate::common::Reg<regs::WakeSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "WAKE ENABLE Register"]
        #[inline(always)]
        pub const fn wake_en(self) -> crate::common::Reg<regs::WakeEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Bit-Bang Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bbctrl(pub u32);
        impl Bbctrl {
            #[doc = "Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled"]
            #[inline(always)]
            pub const fn bben(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled"]
            #[inline(always)]
            pub fn set_bben(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output"]
            #[inline(always)]
            pub const fn cldir(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output"]
            #[inline(always)]
            pub fn set_cldir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output"]
            #[inline(always)]
            pub const fn dadir(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output"]
            #[inline(always)]
            pub fn set_dadir(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'"]
            #[inline(always)]
            pub const fn bbclk(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'"]
            #[inline(always)]
            pub fn set_bbclk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'"]
            #[inline(always)]
            pub const fn bbdat(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'"]
            #[inline(always)]
            pub fn set_bbdat(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK."]
            #[inline(always)]
            pub const fn bbclki(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK."]
            #[inline(always)]
            pub fn set_bbclki(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Bit-Bang Data In. The BBDATI bit always returns the state of SDAT"]
            #[inline(always)]
            pub const fn bbdati(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Bit-Bang Data In. The BBDATI bit always returns the state of SDAT"]
            #[inline(always)]
            pub fn set_bbdati(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Bbctrl {
            #[inline(always)]
            fn default() -> Bbctrl {
                Bbctrl(0)
            }
        }
        impl core::fmt::Debug for Bbctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bbctrl")
                    .field("bben", &self.bben())
                    .field("cldir", &self.cldir())
                    .field("dadir", &self.dadir())
                    .field("bbclk", &self.bbclk())
                    .field("bbdat", &self.bbdat())
                    .field("bbclki", &self.bbclki())
                    .field("bbdati", &self.bbdati())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bbctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bbctrl {{ bben: {=bool:?}, cldir: {=bool:?}, dadir: {=bool:?}, bbclk: {=bool:?}, bbdat: {=bool:?}, bbclki: {=bool:?}, bbdati: {=bool:?} }}" , self . bben () , self . cldir () , self . dadir () , self . bbclk () , self . bbdat () , self . bbclki () , self . bbdati ())
            }
        }
        #[doc = "Block ID Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Blkid(pub u8);
        impl Blkid {
            #[doc = "Block ID."]
            #[inline(always)]
            pub const fn id(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Block ID."]
            #[inline(always)]
            pub fn set_id(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Blkid {
            #[inline(always)]
            fn default() -> Blkid {
                Blkid(0)
            }
        }
        impl core::fmt::Debug for Blkid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Blkid").field("id", &self.id()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Blkid {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Blkid {{ id: {=u8:?} }}", self.id())
            }
        }
        #[doc = "Revision Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Blkrev(pub u8);
        impl Blkrev {
            #[doc = "Block Revision Number"]
            #[inline(always)]
            pub const fn rev(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Block Revision Number"]
            #[inline(always)]
            pub fn set_rev(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Blkrev {
            #[inline(always)]
            fn default() -> Blkrev {
                Blkrev(0)
            }
        }
        impl core::fmt::Debug for Blkrev {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Blkrev").field("rev", &self.rev()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Blkrev {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Blkrev {{ rev: {=u8:?} }}", self.rev())
            }
        }
        #[doc = "Bus Clock Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busclk(pub u32);
        impl Busclk {
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub const fn low_per(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub fn set_low_per(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub const fn high_per(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock."]
            #[inline(always)]
            pub fn set_high_per(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Busclk {
            #[inline(always)]
            fn default() -> Busclk {
                Busclk(0)
            }
        }
        impl core::fmt::Debug for Busclk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busclk")
                    .field("low_per", &self.low_per())
                    .field("high_per", &self.high_per())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busclk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Busclk {{ low_per: {=u8:?}, high_per: {=u8:?} }}",
                    self.low_per(),
                    self.high_per()
                )
            }
        }
        #[doc = "Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CfgU08(pub u8);
        impl CfgU08 {
            #[doc = "The PORT SEL \\[3:0\\] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."]
            #[inline(always)]
            pub const fn port_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The PORT SEL \\[3:0\\] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."]
            #[inline(always)]
            pub fn set_port_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize);
            }
            #[doc = "When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"]
            #[inline(always)]
            pub const fn tcen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"]
            #[inline(always)]
            pub fn set_tcen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."]
            #[inline(always)]
            pub const fn slow_clk(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."]
            #[inline(always)]
            pub fn set_slow_clk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"]
            #[inline(always)]
            pub const fn pecen(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"]
            #[inline(always)]
            pub fn set_pecen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
            #[doc = "Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available. 1=Input filtering is enabled; 0=Input filtering is disabled."]
            #[inline(always)]
            pub const fn fen(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available. 1=Input filtering is enabled; 0=Input filtering is disabled."]
            #[inline(always)]
            pub fn set_fen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u8) & 0x01) << 8usize);
            }
            #[doc = "When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u8) & 0x01) << 9usize);
            }
            #[doc = "When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State). The ENAB bit must be asserted ('1') for normal operation."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State). The ENAB bit must be asserted ('1') for normal operation."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u8) & 0x01) << 10usize);
            }
            #[doc = "0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"]
            #[inline(always)]
            pub const fn dsa(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"]
            #[inline(always)]
            pub fn set_dsa(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u8) & 0x01) << 11usize);
            }
            #[doc = "If this bit is 1, the MCTP Fairness protocol is in effect."]
            #[inline(always)]
            pub const fn fair(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the MCTP Fairness protocol is in effect."]
            #[inline(always)]
            pub fn set_fair(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u8) & 0x01) << 12usize);
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub const fn test0(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub fn set_test0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u8) & 0x01) << 13usize);
            }
            #[doc = "This is the General Call Disable bit. 0: the response to the General Call address as a slave is enabled 1: the response to the General Call address as a slave is disabled."]
            #[inline(always)]
            pub const fn gc_dis(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "This is the General Call Disable bit. 0: the response to the General Call address as a slave is enabled 1: the response to the General Call address as a slave is disabled."]
            #[inline(always)]
            pub fn set_gc_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u8) & 0x01) << 14usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_sxbuf(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_sxbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u8) & 0x01) << 16usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_srbuf(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_srbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u8) & 0x01) << 17usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_mxbuf(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_mxbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u8) & 0x01) << 18usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_mrbuf(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_mrbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u8) & 0x01) << 19usize);
            }
            #[doc = "0: Disable the AAS, 1: Enable the AAS Interrupt"]
            #[inline(always)]
            pub const fn en_aas(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "0: Disable the AAS, 1: Enable the AAS Interrupt"]
            #[inline(always)]
            pub fn set_en_aas(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u8) & 0x01) << 28usize);
            }
            #[doc = "If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."]
            #[inline(always)]
            pub const fn enidi(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."]
            #[inline(always)]
            pub fn set_enidi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u8) & 0x01) << 29usize);
            }
            #[doc = "If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."]
            #[inline(always)]
            pub const fn enmi(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."]
            #[inline(always)]
            pub fn set_enmi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u8) & 0x01) << 30usize);
            }
            #[doc = "If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"]
            #[inline(always)]
            pub const fn ensi(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"]
            #[inline(always)]
            pub fn set_ensi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u8) & 0x01) << 31usize);
            }
        }
        impl Default for CfgU08 {
            #[inline(always)]
            fn default() -> CfgU08 {
                CfgU08(0)
            }
        }
        impl core::fmt::Debug for CfgU08 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CfgU08")
                    .field("port_sel", &self.port_sel())
                    .field("tcen", &self.tcen())
                    .field("slow_clk", &self.slow_clk())
                    .field("test", &self.test())
                    .field("pecen", &self.pecen())
                    .field("fen", &self.fen())
                    .field("rst", &self.rst())
                    .field("en", &self.en())
                    .field("dsa", &self.dsa())
                    .field("fair", &self.fair())
                    .field("test0", &self.test0())
                    .field("gc_dis", &self.gc_dis())
                    .field("flush_sxbuf", &self.flush_sxbuf())
                    .field("flush_srbuf", &self.flush_srbuf())
                    .field("flush_mxbuf", &self.flush_mxbuf())
                    .field("flush_mrbuf", &self.flush_mrbuf())
                    .field("en_aas", &self.en_aas())
                    .field("enidi", &self.enidi())
                    .field("enmi", &self.enmi())
                    .field("ensi", &self.ensi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CfgU08 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CfgU08 {{ port_sel: {=u8:?}, tcen: {=bool:?}, slow_clk: {=bool:?}, test: {=bool:?}, pecen: {=bool:?}, fen: {=bool:?}, rst: {=bool:?}, en: {=bool:?}, dsa: {=bool:?}, fair: {=bool:?}, test0: {=bool:?}, gc_dis: {=bool:?}, flush_sxbuf: {=bool:?}, flush_srbuf: {=bool:?}, flush_mxbuf: {=bool:?}, flush_mrbuf: {=bool:?}, en_aas: {=bool:?}, enidi: {=bool:?}, enmi: {=bool:?}, ensi: {=bool:?} }}" , self . port_sel () , self . tcen () , self . slow_clk () , self . test () , self . pecen () , self . fen () , self . rst () , self . en () , self . dsa () , self . fair () , self . test0 () , self . gc_dis () , self . flush_sxbuf () , self . flush_srbuf () , self . flush_mxbuf () , self . flush_mrbuf () , self . en_aas () , self . enidi () , self . enmi () , self . ensi ())
            }
        }
        #[doc = "Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CfgU16(pub u16);
        impl CfgU16 {
            #[doc = "The PORT SEL \\[3:0\\] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."]
            #[inline(always)]
            pub const fn port_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The PORT SEL \\[3:0\\] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."]
            #[inline(always)]
            pub fn set_port_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u16) & 0x0f) << 0usize);
            }
            #[doc = "When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"]
            #[inline(always)]
            pub const fn tcen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"]
            #[inline(always)]
            pub fn set_tcen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u16) & 0x01) << 4usize);
            }
            #[doc = "When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."]
            #[inline(always)]
            pub const fn slow_clk(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."]
            #[inline(always)]
            pub fn set_slow_clk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u16) & 0x01) << 5usize);
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u16) & 0x01) << 6usize);
            }
            #[doc = "When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"]
            #[inline(always)]
            pub const fn pecen(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"]
            #[inline(always)]
            pub fn set_pecen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u16) & 0x01) << 7usize);
            }
            #[doc = "Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available. 1=Input filtering is enabled; 0=Input filtering is disabled."]
            #[inline(always)]
            pub const fn fen(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available. 1=Input filtering is enabled; 0=Input filtering is disabled."]
            #[inline(always)]
            pub fn set_fen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u16) & 0x01) << 8usize);
            }
            #[doc = "When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u16) & 0x01) << 9usize);
            }
            #[doc = "When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State). The ENAB bit must be asserted ('1') for normal operation."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State). The ENAB bit must be asserted ('1') for normal operation."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u16) & 0x01) << 10usize);
            }
            #[doc = "0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"]
            #[inline(always)]
            pub const fn dsa(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"]
            #[inline(always)]
            pub fn set_dsa(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u16) & 0x01) << 11usize);
            }
            #[doc = "If this bit is 1, the MCTP Fairness protocol is in effect."]
            #[inline(always)]
            pub const fn fair(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the MCTP Fairness protocol is in effect."]
            #[inline(always)]
            pub fn set_fair(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u16) & 0x01) << 12usize);
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub const fn test0(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub fn set_test0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u16) & 0x01) << 13usize);
            }
            #[doc = "This is the General Call Disable bit. 0: the response to the General Call address as a slave is enabled 1: the response to the General Call address as a slave is disabled."]
            #[inline(always)]
            pub const fn gc_dis(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "This is the General Call Disable bit. 0: the response to the General Call address as a slave is enabled 1: the response to the General Call address as a slave is disabled."]
            #[inline(always)]
            pub fn set_gc_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u16) & 0x01) << 14usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_sxbuf(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_sxbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u16) & 0x01) << 16usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_srbuf(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_srbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u16) & 0x01) << 17usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_mxbuf(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_mxbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u16) & 0x01) << 18usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_mrbuf(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_mrbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u16) & 0x01) << 19usize);
            }
            #[doc = "0: Disable the AAS, 1: Enable the AAS Interrupt"]
            #[inline(always)]
            pub const fn en_aas(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "0: Disable the AAS, 1: Enable the AAS Interrupt"]
            #[inline(always)]
            pub fn set_en_aas(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u16) & 0x01) << 28usize);
            }
            #[doc = "If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."]
            #[inline(always)]
            pub const fn enidi(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."]
            #[inline(always)]
            pub fn set_enidi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u16) & 0x01) << 29usize);
            }
            #[doc = "If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."]
            #[inline(always)]
            pub const fn enmi(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."]
            #[inline(always)]
            pub fn set_enmi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u16) & 0x01) << 30usize);
            }
            #[doc = "If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"]
            #[inline(always)]
            pub const fn ensi(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"]
            #[inline(always)]
            pub fn set_ensi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u16) & 0x01) << 31usize);
            }
        }
        impl Default for CfgU16 {
            #[inline(always)]
            fn default() -> CfgU16 {
                CfgU16(0)
            }
        }
        impl core::fmt::Debug for CfgU16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CfgU16")
                    .field("port_sel", &self.port_sel())
                    .field("tcen", &self.tcen())
                    .field("slow_clk", &self.slow_clk())
                    .field("test", &self.test())
                    .field("pecen", &self.pecen())
                    .field("fen", &self.fen())
                    .field("rst", &self.rst())
                    .field("en", &self.en())
                    .field("dsa", &self.dsa())
                    .field("fair", &self.fair())
                    .field("test0", &self.test0())
                    .field("gc_dis", &self.gc_dis())
                    .field("flush_sxbuf", &self.flush_sxbuf())
                    .field("flush_srbuf", &self.flush_srbuf())
                    .field("flush_mxbuf", &self.flush_mxbuf())
                    .field("flush_mrbuf", &self.flush_mrbuf())
                    .field("en_aas", &self.en_aas())
                    .field("enidi", &self.enidi())
                    .field("enmi", &self.enmi())
                    .field("ensi", &self.ensi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CfgU16 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CfgU16 {{ port_sel: {=u8:?}, tcen: {=bool:?}, slow_clk: {=bool:?}, test: {=bool:?}, pecen: {=bool:?}, fen: {=bool:?}, rst: {=bool:?}, en: {=bool:?}, dsa: {=bool:?}, fair: {=bool:?}, test0: {=bool:?}, gc_dis: {=bool:?}, flush_sxbuf: {=bool:?}, flush_srbuf: {=bool:?}, flush_mxbuf: {=bool:?}, flush_mrbuf: {=bool:?}, en_aas: {=bool:?}, enidi: {=bool:?}, enmi: {=bool:?}, ensi: {=bool:?} }}" , self . port_sel () , self . tcen () , self . slow_clk () , self . test () , self . pecen () , self . fen () , self . rst () , self . en () , self . dsa () , self . fair () , self . test0 () , self . gc_dis () , self . flush_sxbuf () , self . flush_srbuf () , self . flush_mxbuf () , self . flush_mrbuf () , self . en_aas () , self . enidi () , self . enmi () , self . ensi ())
            }
        }
        #[doc = "Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CfgU32(pub u32);
        impl CfgU32 {
            #[doc = "The PORT SEL \\[3:0\\] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."]
            #[inline(always)]
            pub const fn port_sel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The PORT SEL \\[3:0\\] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair."]
            #[inline(always)]
            pub fn set_port_sel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"]
            #[inline(always)]
            pub const fn tcen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled"]
            #[inline(always)]
            pub fn set_tcen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."]
            #[inline(always)]
            pub const fn slow_clk(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4."]
            #[inline(always)]
            pub fn set_slow_clk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"]
            #[inline(always)]
            pub const fn pecen(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled"]
            #[inline(always)]
            pub fn set_pecen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available. 1=Input filtering is enabled; 0=Input filtering is disabled."]
            #[inline(always)]
            pub const fn fen(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available. 1=Input filtering is enabled; 0=Input filtering is disabled."]
            #[inline(always)]
            pub fn set_fen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state."]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State). The ENAB bit must be asserted ('1') for normal operation."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State). The ENAB bit must be asserted ('1') for normal operation."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"]
            #[inline(always)]
            pub const fn dsa(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode"]
            #[inline(always)]
            pub fn set_dsa(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "If this bit is 1, the MCTP Fairness protocol is in effect."]
            #[inline(always)]
            pub const fn fair(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the MCTP Fairness protocol is in effect."]
            #[inline(always)]
            pub fn set_fair(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub const fn test0(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Must be always written with 0."]
            #[inline(always)]
            pub fn set_test0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "This is the General Call Disable bit. 0: the response to the General Call address as a slave is enabled 1: the response to the General Call address as a slave is disabled."]
            #[inline(always)]
            pub const fn gc_dis(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "This is the General Call Disable bit. 0: the response to the General Call address as a slave is enabled 1: the response to the General Call address as a slave is disabled."]
            #[inline(always)]
            pub fn set_gc_dis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_sxbuf(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_sxbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_srbuf(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_srbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_mxbuf(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_mxbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub const fn flush_mrbuf(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit."]
            #[inline(always)]
            pub fn set_flush_mrbuf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "0: Disable the AAS, 1: Enable the AAS Interrupt"]
            #[inline(always)]
            pub const fn en_aas(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "0: Disable the AAS, 1: Enable the AAS Interrupt"]
            #[inline(always)]
            pub fn set_en_aas(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."]
            #[inline(always)]
            pub const fn enidi(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled."]
            #[inline(always)]
            pub fn set_enidi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."]
            #[inline(always)]
            pub const fn enmi(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled."]
            #[inline(always)]
            pub fn set_enmi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"]
            #[inline(always)]
            pub const fn ensi(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled"]
            #[inline(always)]
            pub fn set_ensi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for CfgU32 {
            #[inline(always)]
            fn default() -> CfgU32 {
                CfgU32(0)
            }
        }
        impl core::fmt::Debug for CfgU32 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CfgU32")
                    .field("port_sel", &self.port_sel())
                    .field("tcen", &self.tcen())
                    .field("slow_clk", &self.slow_clk())
                    .field("test", &self.test())
                    .field("pecen", &self.pecen())
                    .field("fen", &self.fen())
                    .field("rst", &self.rst())
                    .field("en", &self.en())
                    .field("dsa", &self.dsa())
                    .field("fair", &self.fair())
                    .field("test0", &self.test0())
                    .field("gc_dis", &self.gc_dis())
                    .field("flush_sxbuf", &self.flush_sxbuf())
                    .field("flush_srbuf", &self.flush_srbuf())
                    .field("flush_mxbuf", &self.flush_mxbuf())
                    .field("flush_mrbuf", &self.flush_mrbuf())
                    .field("en_aas", &self.en_aas())
                    .field("enidi", &self.enidi())
                    .field("enmi", &self.enmi())
                    .field("ensi", &self.ensi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CfgU32 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CfgU32 {{ port_sel: {=u8:?}, tcen: {=bool:?}, slow_clk: {=bool:?}, test: {=bool:?}, pecen: {=bool:?}, fen: {=bool:?}, rst: {=bool:?}, en: {=bool:?}, dsa: {=bool:?}, fair: {=bool:?}, test0: {=bool:?}, gc_dis: {=bool:?}, flush_sxbuf: {=bool:?}, flush_srbuf: {=bool:?}, flush_mxbuf: {=bool:?}, flush_mrbuf: {=bool:?}, en_aas: {=bool:?}, enidi: {=bool:?}, enmi: {=bool:?}, ensi: {=bool:?} }}" , self . port_sel () , self . tcen () , self . slow_clk () , self . test () , self . pecen () , self . fen () , self . rst () , self . en () , self . dsa () , self . fair () , self . test0 () , self . gc_dis () , self . flush_sxbuf () , self . flush_srbuf () , self . flush_mxbuf () , self . flush_mrbuf () , self . en_aas () , self . enidi () , self . enmi () , self . ensi ())
            }
        }
        #[doc = "Completion Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ComplU08(pub u8);
        impl ComplU08 {
            #[doc = "When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."]
            #[inline(always)]
            pub const fn dten(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."]
            #[inline(always)]
            pub fn set_dten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn mcen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_mcen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn scen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_scen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn biden(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_biden(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."]
            #[inline(always)]
            pub const fn timerr(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."]
            #[inline(always)]
            pub fn set_timerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "DTO is the Device Time-out bit. (R/WC)"]
            #[inline(always)]
            pub const fn dto(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "DTO is the Device Time-out bit. (R/WC)"]
            #[inline(always)]
            pub fn set_dto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u8) & 0x01) << 8usize);
            }
            #[doc = "MCTO is the Master Cumulative Time-out bit. (R/WC)"]
            #[inline(always)]
            pub const fn mcto(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "MCTO is the Master Cumulative Time-out bit. (R/WC)"]
            #[inline(always)]
            pub fn set_mcto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u8) & 0x01) << 9usize);
            }
            #[doc = "SCTO is the Slave Cumulative Time-out bit(R/WC)"]
            #[inline(always)]
            pub const fn scto(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SCTO is the Slave Cumulative Time-out bit(R/WC)"]
            #[inline(always)]
            pub fn set_scto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u8) & 0x01) << 10usize);
            }
            #[doc = "CHDL is the clock high time-out detect bit(R/WC)"]
            #[inline(always)]
            pub const fn chdl(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "CHDL is the clock high time-out detect bit(R/WC)"]
            #[inline(always)]
            pub fn set_chdl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u8) & 0x01) << 11usize);
            }
            #[doc = "CHDH is the bus idle time-out detect bit(R/WC)"]
            #[inline(always)]
            pub const fn chdh(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "CHDH is the bus idle time-out detect bit(R/WC)"]
            #[inline(always)]
            pub fn set_chdh(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u8) & 0x01) << 12usize);
            }
            #[doc = "If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub const fn ber(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub fn set_ber(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u8) & 0x01) << 13usize);
            }
            #[doc = "If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub const fn lab(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub fn set_lab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u8) & 0x01) << 14usize);
            }
            #[doc = "If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."]
            #[inline(always)]
            pub const fn snakr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."]
            #[inline(always)]
            pub fn set_snakr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u8) & 0x01) << 16usize);
            }
            #[doc = "0: Slave has just finished the receive phase of a transaction. 1: Slave has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub const fn str(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "0: Slave has just finished the receive phase of a transaction. 1: Slave has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub fn set_str(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u8) & 0x01) << 17usize);
            }
            #[doc = "If this bit is 1, the WriteCount\\[7:0\\] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."]
            #[inline(always)]
            pub const fn sprot(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the WriteCount\\[7:0\\] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."]
            #[inline(always)]
            pub fn set_sprot(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u8) & 0x01) << 19usize);
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."]
            #[inline(always)]
            pub const fn rep_rd(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."]
            #[inline(always)]
            pub fn set_rep_rd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u8) & 0x01) << 20usize);
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."]
            #[inline(always)]
            pub const fn rep_wr(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."]
            #[inline(always)]
            pub fn set_rep_wr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u8) & 0x01) << 21usize);
            }
            #[doc = "If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"]
            #[inline(always)]
            pub const fn mnakx(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"]
            #[inline(always)]
            pub fn set_mnakx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u8) & 0x01) << 24usize);
            }
            #[doc = "0: Master has just finished the receive phase of a transaction. 1: Master has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub const fn mtr(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "0: Master has just finished the receive phase of a transaction. 1: Master has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub fn set_mtr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u8) & 0x01) << 25usize);
            }
            #[doc = "This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"]
            #[inline(always)]
            pub const fn idle(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"]
            #[inline(always)]
            pub fn set_idle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u8) & 0x01) << 29usize);
            }
            #[doc = "If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn mdone(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_mdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u8) & 0x01) << 30usize);
            }
            #[doc = "If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"]
            #[inline(always)]
            pub const fn sdone(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"]
            #[inline(always)]
            pub fn set_sdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u8) & 0x01) << 31usize);
            }
        }
        impl Default for ComplU08 {
            #[inline(always)]
            fn default() -> ComplU08 {
                ComplU08(0)
            }
        }
        impl core::fmt::Debug for ComplU08 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ComplU08")
                    .field("dten", &self.dten())
                    .field("mcen", &self.mcen())
                    .field("scen", &self.scen())
                    .field("biden", &self.biden())
                    .field("timerr", &self.timerr())
                    .field("dto", &self.dto())
                    .field("mcto", &self.mcto())
                    .field("scto", &self.scto())
                    .field("chdl", &self.chdl())
                    .field("chdh", &self.chdh())
                    .field("ber", &self.ber())
                    .field("lab", &self.lab())
                    .field("snakr", &self.snakr())
                    .field("str", &self.str())
                    .field("sprot", &self.sprot())
                    .field("rep_rd", &self.rep_rd())
                    .field("rep_wr", &self.rep_wr())
                    .field("mnakx", &self.mnakx())
                    .field("mtr", &self.mtr())
                    .field("idle", &self.idle())
                    .field("mdone", &self.mdone())
                    .field("sdone", &self.sdone())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ComplU08 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ComplU08 {{ dten: {=bool:?}, mcen: {=bool:?}, scen: {=bool:?}, biden: {=bool:?}, timerr: {=bool:?}, dto: {=bool:?}, mcto: {=bool:?}, scto: {=bool:?}, chdl: {=bool:?}, chdh: {=bool:?}, ber: {=bool:?}, lab: {=bool:?}, snakr: {=bool:?}, str: {=bool:?}, sprot: {=bool:?}, rep_rd: {=bool:?}, rep_wr: {=bool:?}, mnakx: {=bool:?}, mtr: {=bool:?}, idle: {=bool:?}, mdone: {=bool:?}, sdone: {=bool:?} }}" , self . dten () , self . mcen () , self . scen () , self . biden () , self . timerr () , self . dto () , self . mcto () , self . scto () , self . chdl () , self . chdh () , self . ber () , self . lab () , self . snakr () , self . str () , self . sprot () , self . rep_rd () , self . rep_wr () , self . mnakx () , self . mtr () , self . idle () , self . mdone () , self . sdone ())
            }
        }
        #[doc = "Completion Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ComplU16(pub u16);
        impl ComplU16 {
            #[doc = "When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."]
            #[inline(always)]
            pub const fn dten(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."]
            #[inline(always)]
            pub fn set_dten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u16) & 0x01) << 2usize);
            }
            #[doc = "When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn mcen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_mcen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u16) & 0x01) << 3usize);
            }
            #[doc = "When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn scen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_scen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u16) & 0x01) << 4usize);
            }
            #[doc = "When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn biden(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_biden(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u16) & 0x01) << 5usize);
            }
            #[doc = "The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."]
            #[inline(always)]
            pub const fn timerr(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."]
            #[inline(always)]
            pub fn set_timerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u16) & 0x01) << 6usize);
            }
            #[doc = "DTO is the Device Time-out bit. (R/WC)"]
            #[inline(always)]
            pub const fn dto(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "DTO is the Device Time-out bit. (R/WC)"]
            #[inline(always)]
            pub fn set_dto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u16) & 0x01) << 8usize);
            }
            #[doc = "MCTO is the Master Cumulative Time-out bit. (R/WC)"]
            #[inline(always)]
            pub const fn mcto(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "MCTO is the Master Cumulative Time-out bit. (R/WC)"]
            #[inline(always)]
            pub fn set_mcto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u16) & 0x01) << 9usize);
            }
            #[doc = "SCTO is the Slave Cumulative Time-out bit(R/WC)"]
            #[inline(always)]
            pub const fn scto(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SCTO is the Slave Cumulative Time-out bit(R/WC)"]
            #[inline(always)]
            pub fn set_scto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u16) & 0x01) << 10usize);
            }
            #[doc = "CHDL is the clock high time-out detect bit(R/WC)"]
            #[inline(always)]
            pub const fn chdl(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "CHDL is the clock high time-out detect bit(R/WC)"]
            #[inline(always)]
            pub fn set_chdl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u16) & 0x01) << 11usize);
            }
            #[doc = "CHDH is the bus idle time-out detect bit(R/WC)"]
            #[inline(always)]
            pub const fn chdh(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "CHDH is the bus idle time-out detect bit(R/WC)"]
            #[inline(always)]
            pub fn set_chdh(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u16) & 0x01) << 12usize);
            }
            #[doc = "If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub const fn ber(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub fn set_ber(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u16) & 0x01) << 13usize);
            }
            #[doc = "If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub const fn lab(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub fn set_lab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u16) & 0x01) << 14usize);
            }
            #[doc = "If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."]
            #[inline(always)]
            pub const fn snakr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."]
            #[inline(always)]
            pub fn set_snakr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u16) & 0x01) << 16usize);
            }
            #[doc = "0: Slave has just finished the receive phase of a transaction. 1: Slave has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub const fn str(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "0: Slave has just finished the receive phase of a transaction. 1: Slave has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub fn set_str(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u16) & 0x01) << 17usize);
            }
            #[doc = "If this bit is 1, the WriteCount\\[7:0\\] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."]
            #[inline(always)]
            pub const fn sprot(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the WriteCount\\[7:0\\] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."]
            #[inline(always)]
            pub fn set_sprot(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u16) & 0x01) << 19usize);
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."]
            #[inline(always)]
            pub const fn rep_rd(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."]
            #[inline(always)]
            pub fn set_rep_rd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u16) & 0x01) << 20usize);
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."]
            #[inline(always)]
            pub const fn rep_wr(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."]
            #[inline(always)]
            pub fn set_rep_wr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u16) & 0x01) << 21usize);
            }
            #[doc = "If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"]
            #[inline(always)]
            pub const fn mnakx(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"]
            #[inline(always)]
            pub fn set_mnakx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u16) & 0x01) << 24usize);
            }
            #[doc = "0: Master has just finished the receive phase of a transaction. 1: Master has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub const fn mtr(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "0: Master has just finished the receive phase of a transaction. 1: Master has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub fn set_mtr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u16) & 0x01) << 25usize);
            }
            #[doc = "This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"]
            #[inline(always)]
            pub const fn idle(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"]
            #[inline(always)]
            pub fn set_idle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u16) & 0x01) << 29usize);
            }
            #[doc = "If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn mdone(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_mdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u16) & 0x01) << 30usize);
            }
            #[doc = "If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"]
            #[inline(always)]
            pub const fn sdone(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"]
            #[inline(always)]
            pub fn set_sdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u16) & 0x01) << 31usize);
            }
        }
        impl Default for ComplU16 {
            #[inline(always)]
            fn default() -> ComplU16 {
                ComplU16(0)
            }
        }
        impl core::fmt::Debug for ComplU16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ComplU16")
                    .field("dten", &self.dten())
                    .field("mcen", &self.mcen())
                    .field("scen", &self.scen())
                    .field("biden", &self.biden())
                    .field("timerr", &self.timerr())
                    .field("dto", &self.dto())
                    .field("mcto", &self.mcto())
                    .field("scto", &self.scto())
                    .field("chdl", &self.chdl())
                    .field("chdh", &self.chdh())
                    .field("ber", &self.ber())
                    .field("lab", &self.lab())
                    .field("snakr", &self.snakr())
                    .field("str", &self.str())
                    .field("sprot", &self.sprot())
                    .field("rep_rd", &self.rep_rd())
                    .field("rep_wr", &self.rep_wr())
                    .field("mnakx", &self.mnakx())
                    .field("mtr", &self.mtr())
                    .field("idle", &self.idle())
                    .field("mdone", &self.mdone())
                    .field("sdone", &self.sdone())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ComplU16 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ComplU16 {{ dten: {=bool:?}, mcen: {=bool:?}, scen: {=bool:?}, biden: {=bool:?}, timerr: {=bool:?}, dto: {=bool:?}, mcto: {=bool:?}, scto: {=bool:?}, chdl: {=bool:?}, chdh: {=bool:?}, ber: {=bool:?}, lab: {=bool:?}, snakr: {=bool:?}, str: {=bool:?}, sprot: {=bool:?}, rep_rd: {=bool:?}, rep_wr: {=bool:?}, mnakx: {=bool:?}, mtr: {=bool:?}, idle: {=bool:?}, mdone: {=bool:?}, sdone: {=bool:?} }}" , self . dten () , self . mcen () , self . scen () , self . biden () , self . timerr () , self . dto () , self . mcto () , self . scto () , self . chdl () , self . chdh () , self . ber () , self . lab () , self . snakr () , self . str () , self . sprot () , self . rep_rd () , self . rep_wr () , self . mnakx () , self . mtr () , self . idle () , self . mdone () , self . sdone ())
            }
        }
        #[doc = "Completion Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ComplU32(pub u32);
        impl ComplU32 {
            #[doc = "When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."]
            #[inline(always)]
            pub const fn dten(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled."]
            #[inline(always)]
            pub fn set_dten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn mcen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_mcen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn scen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_scen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."]
            #[inline(always)]
            pub const fn biden(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled."]
            #[inline(always)]
            pub fn set_biden(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."]
            #[inline(always)]
            pub const fn timerr(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted."]
            #[inline(always)]
            pub fn set_timerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "DTO is the Device Time-out bit. (R/WC)"]
            #[inline(always)]
            pub const fn dto(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "DTO is the Device Time-out bit. (R/WC)"]
            #[inline(always)]
            pub fn set_dto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "MCTO is the Master Cumulative Time-out bit. (R/WC)"]
            #[inline(always)]
            pub const fn mcto(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "MCTO is the Master Cumulative Time-out bit. (R/WC)"]
            #[inline(always)]
            pub fn set_mcto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "SCTO is the Slave Cumulative Time-out bit(R/WC)"]
            #[inline(always)]
            pub const fn scto(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "SCTO is the Slave Cumulative Time-out bit(R/WC)"]
            #[inline(always)]
            pub fn set_scto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "CHDL is the clock high time-out detect bit(R/WC)"]
            #[inline(always)]
            pub const fn chdl(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "CHDL is the clock high time-out detect bit(R/WC)"]
            #[inline(always)]
            pub fn set_chdl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "CHDH is the bus idle time-out detect bit(R/WC)"]
            #[inline(always)]
            pub const fn chdh(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "CHDH is the bus idle time-out detect bit(R/WC)"]
            #[inline(always)]
            pub fn set_chdh(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub const fn ber(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub fn set_ber(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub const fn lab(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)"]
            #[inline(always)]
            pub fn set_lab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."]
            #[inline(always)]
            pub const fn snakr(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface."]
            #[inline(always)]
            pub fn set_snakr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "0: Slave has just finished the receive phase of a transaction. 1: Slave has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub const fn str(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "0: Slave has just finished the receive phase of a transaction. 1: Slave has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub fn set_str(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "If this bit is 1, the WriteCount\\[7:0\\] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."]
            #[inline(always)]
            pub const fn sprot(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the WriteCount\\[7:0\\] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0."]
            #[inline(always)]
            pub fn set_sprot(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."]
            #[inline(always)]
            pub const fn rep_rd(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation."]
            #[inline(always)]
            pub fn set_rep_rd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."]
            #[inline(always)]
            pub const fn rep_wr(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit\\[0\\] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation."]
            #[inline(always)]
            pub fn set_rep_wr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"]
            #[inline(always)]
            pub const fn mnakx(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)"]
            #[inline(always)]
            pub fn set_mnakx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "0: Master has just finished the receive phase of a transaction. 1: Master has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub const fn mtr(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "0: Master has just finished the receive phase of a transaction. 1: Master has just finished the transmit phase of a transaction."]
            #[inline(always)]
            pub fn set_mtr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"]
            #[inline(always)]
            pub const fn idle(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)"]
            #[inline(always)]
            pub fn set_idle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn mdone(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_mdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"]
            #[inline(always)]
            pub const fn sdone(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)"]
            #[inline(always)]
            pub fn set_sdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for ComplU32 {
            #[inline(always)]
            fn default() -> ComplU32 {
                ComplU32(0)
            }
        }
        impl core::fmt::Debug for ComplU32 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ComplU32")
                    .field("dten", &self.dten())
                    .field("mcen", &self.mcen())
                    .field("scen", &self.scen())
                    .field("biden", &self.biden())
                    .field("timerr", &self.timerr())
                    .field("dto", &self.dto())
                    .field("mcto", &self.mcto())
                    .field("scto", &self.scto())
                    .field("chdl", &self.chdl())
                    .field("chdh", &self.chdh())
                    .field("ber", &self.ber())
                    .field("lab", &self.lab())
                    .field("snakr", &self.snakr())
                    .field("str", &self.str())
                    .field("sprot", &self.sprot())
                    .field("rep_rd", &self.rep_rd())
                    .field("rep_wr", &self.rep_wr())
                    .field("mnakx", &self.mnakx())
                    .field("mtr", &self.mtr())
                    .field("idle", &self.idle())
                    .field("mdone", &self.mdone())
                    .field("sdone", &self.sdone())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ComplU32 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ComplU32 {{ dten: {=bool:?}, mcen: {=bool:?}, scen: {=bool:?}, biden: {=bool:?}, timerr: {=bool:?}, dto: {=bool:?}, mcto: {=bool:?}, scto: {=bool:?}, chdl: {=bool:?}, chdh: {=bool:?}, ber: {=bool:?}, lab: {=bool:?}, snakr: {=bool:?}, str: {=bool:?}, sprot: {=bool:?}, rep_rd: {=bool:?}, rep_wr: {=bool:?}, mnakx: {=bool:?}, mtr: {=bool:?}, idle: {=bool:?}, mdone: {=bool:?}, sdone: {=bool:?} }}" , self . dten () , self . mcen () , self . scen () , self . biden () , self . timerr () , self . dto () , self . mcto () , self . scto () , self . chdl () , self . chdh () , self . ber () , self . lab () , self . snakr () , self . str () , self . sprot () , self . rep_rd () , self . rep_wr () , self . mnakx () , self . mtr () , self . idle () , self . mdone () , self . sdone ())
            }
        }
        #[doc = "Data Timing Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Datatm(pub u32);
        impl Datatm {
            #[doc = "The Data Hold \\[7:0\\] timer determines the SDAT hold time following SCLK driven low."]
            #[inline(always)]
            pub const fn data_hold(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The Data Hold \\[7:0\\] timer determines the SDAT hold time following SCLK driven low."]
            #[inline(always)]
            pub fn set_data_hold(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "The Restart Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition."]
            #[inline(always)]
            pub const fn restart_setup(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "The Restart Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition."]
            #[inline(always)]
            pub fn set_restart_setup(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "The Stop Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition."]
            #[inline(always)]
            pub const fn stop_setup(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "The Stop Setup \\[7:0\\] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition."]
            #[inline(always)]
            pub fn set_stop_setup(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register."]
            #[inline(always)]
            pub const fn first_start_hold(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register."]
            #[inline(always)]
            pub fn set_first_start_hold(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Datatm {
            #[inline(always)]
            fn default() -> Datatm {
                Datatm(0)
            }
        }
        impl core::fmt::Debug for Datatm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Datatm")
                    .field("data_hold", &self.data_hold())
                    .field("restart_setup", &self.restart_setup())
                    .field("stop_setup", &self.stop_setup())
                    .field("first_start_hold", &self.first_start_hold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Datatm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Datatm {{ data_hold: {=u8:?}, restart_setup: {=u8:?}, stop_setup: {=u8:?}, first_start_hold: {=u8:?} }}" , self . data_hold () , self . restart_setup () , self . stop_setup () , self . first_start_hold ())
            }
        }
        #[doc = "Idle Scaling Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Idlsc(pub u32);
        impl Idlsc {
            #[doc = "This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub const fn fair_bus_idl_min(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub fn set_fair_bus_idl_min(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub const fn fair_idl_dly(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x0fff;
                val as u16
            }
            #[doc = "This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus"]
            #[inline(always)]
            pub fn set_fair_idl_dly(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 16usize)) | (((val as u32) & 0x0fff) << 16usize);
            }
        }
        impl Default for Idlsc {
            #[inline(always)]
            fn default() -> Idlsc {
                Idlsc(0)
            }
        }
        impl core::fmt::Debug for Idlsc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Idlsc")
                    .field("fair_bus_idl_min", &self.fair_bus_idl_min())
                    .field("fair_idl_dly", &self.fair_idl_dly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Idlsc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Idlsc {{ fair_bus_idl_min: {=u16:?}, fair_idl_dly: {=u16:?} }}",
                    self.fair_bus_idl_min(),
                    self.fair_idl_dly()
                )
            }
        }
        #[doc = "SMBus Master Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct McmdU08(pub u8);
        impl McmdU08 {
            #[doc = "While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."]
            #[inline(always)]
            pub const fn mrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."]
            #[inline(always)]
            pub fn set_mrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."]
            #[inline(always)]
            pub const fn mproceed(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."]
            #[inline(always)]
            pub fn set_mproceed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub const fn start0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub fn set_start0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u8) & 0x01) << 8usize);
            }
            #[doc = "If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub const fn startn(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub fn set_startn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u8) & 0x01) << 9usize);
            }
            #[doc = "If this bit is 1, send a Stop bit after the transaction completes."]
            #[inline(always)]
            pub const fn stop(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Stop bit after the transaction completes."]
            #[inline(always)]
            pub fn set_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u8) & 0x01) << 10usize);
            }
            #[doc = "If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."]
            #[inline(always)]
            pub const fn pec_term(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."]
            #[inline(always)]
            pub fn set_pec_term(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u8) & 0x01) << 11usize);
            }
            #[doc = "If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount\\[7:0\\] is 1. After ReadCount\\[7:0\\] is updated, this bit is cleared to 0."]
            #[inline(always)]
            pub const fn readm(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount\\[7:0\\] is 1. After ReadCount\\[7:0\\] is updated, this bit is cleared to 0."]
            #[inline(always)]
            pub fn set_readm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u8) & 0x01) << 12usize);
            }
            #[doc = "If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."]
            #[inline(always)]
            pub const fn read_pec(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."]
            #[inline(always)]
            pub fn set_read_pec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u8) & 0x01) << 13usize);
            }
            #[doc = "This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."]
            #[inline(always)]
            pub const fn wr_cnt(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."]
            #[inline(always)]
            pub fn set_wr_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u8) & 0xff) << 16usize);
            }
            #[doc = "This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."]
            #[inline(always)]
            pub const fn rd_cnt(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."]
            #[inline(always)]
            pub fn set_rd_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u8) & 0xff) << 24usize);
            }
        }
        impl Default for McmdU08 {
            #[inline(always)]
            fn default() -> McmdU08 {
                McmdU08(0)
            }
        }
        impl core::fmt::Debug for McmdU08 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("McmdU08")
                    .field("mrun", &self.mrun())
                    .field("mproceed", &self.mproceed())
                    .field("start0", &self.start0())
                    .field("startn", &self.startn())
                    .field("stop", &self.stop())
                    .field("pec_term", &self.pec_term())
                    .field("readm", &self.readm())
                    .field("read_pec", &self.read_pec())
                    .field("wr_cnt", &self.wr_cnt())
                    .field("rd_cnt", &self.rd_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for McmdU08 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "McmdU08 {{ mrun: {=bool:?}, mproceed: {=bool:?}, start0: {=bool:?}, startn: {=bool:?}, stop: {=bool:?}, pec_term: {=bool:?}, readm: {=bool:?}, read_pec: {=bool:?}, wr_cnt: {=u8:?}, rd_cnt: {=u8:?} }}" , self . mrun () , self . mproceed () , self . start0 () , self . startn () , self . stop () , self . pec_term () , self . readm () , self . read_pec () , self . wr_cnt () , self . rd_cnt ())
            }
        }
        #[doc = "SMBus Master Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct McmdU16(pub u16);
        impl McmdU16 {
            #[doc = "While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."]
            #[inline(always)]
            pub const fn mrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."]
            #[inline(always)]
            pub fn set_mrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."]
            #[inline(always)]
            pub const fn mproceed(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."]
            #[inline(always)]
            pub fn set_mproceed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u16) & 0x01) << 1usize);
            }
            #[doc = "If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub const fn start0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub fn set_start0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u16) & 0x01) << 8usize);
            }
            #[doc = "If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub const fn startn(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub fn set_startn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u16) & 0x01) << 9usize);
            }
            #[doc = "If this bit is 1, send a Stop bit after the transaction completes."]
            #[inline(always)]
            pub const fn stop(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Stop bit after the transaction completes."]
            #[inline(always)]
            pub fn set_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u16) & 0x01) << 10usize);
            }
            #[doc = "If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."]
            #[inline(always)]
            pub const fn pec_term(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."]
            #[inline(always)]
            pub fn set_pec_term(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u16) & 0x01) << 11usize);
            }
            #[doc = "If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount\\[7:0\\] is 1. After ReadCount\\[7:0\\] is updated, this bit is cleared to 0."]
            #[inline(always)]
            pub const fn readm(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount\\[7:0\\] is 1. After ReadCount\\[7:0\\] is updated, this bit is cleared to 0."]
            #[inline(always)]
            pub fn set_readm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u16) & 0x01) << 12usize);
            }
            #[doc = "If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."]
            #[inline(always)]
            pub const fn read_pec(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."]
            #[inline(always)]
            pub fn set_read_pec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u16) & 0x01) << 13usize);
            }
            #[doc = "This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."]
            #[inline(always)]
            pub const fn wr_cnt(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."]
            #[inline(always)]
            pub fn set_wr_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u16) & 0xff) << 16usize);
            }
            #[doc = "This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."]
            #[inline(always)]
            pub const fn rd_cnt(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."]
            #[inline(always)]
            pub fn set_rd_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u16) & 0xff) << 24usize);
            }
        }
        impl Default for McmdU16 {
            #[inline(always)]
            fn default() -> McmdU16 {
                McmdU16(0)
            }
        }
        impl core::fmt::Debug for McmdU16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("McmdU16")
                    .field("mrun", &self.mrun())
                    .field("mproceed", &self.mproceed())
                    .field("start0", &self.start0())
                    .field("startn", &self.startn())
                    .field("stop", &self.stop())
                    .field("pec_term", &self.pec_term())
                    .field("readm", &self.readm())
                    .field("read_pec", &self.read_pec())
                    .field("wr_cnt", &self.wr_cnt())
                    .field("rd_cnt", &self.rd_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for McmdU16 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "McmdU16 {{ mrun: {=bool:?}, mproceed: {=bool:?}, start0: {=bool:?}, startn: {=bool:?}, stop: {=bool:?}, pec_term: {=bool:?}, readm: {=bool:?}, read_pec: {=bool:?}, wr_cnt: {=u8:?}, rd_cnt: {=u8:?} }}" , self . mrun () , self . mproceed () , self . start0 () , self . startn () , self . stop () , self . pec_term () , self . readm () , self . read_pec () , self . wr_cnt () , self . rd_cnt ())
            }
        }
        #[doc = "SMBus Master Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct McmdU32(pub u32);
        impl McmdU32 {
            #[doc = "While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."]
            #[inline(always)]
            pub const fn mrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented."]
            #[inline(always)]
            pub fn set_mrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."]
            #[inline(always)]
            pub const fn mproceed(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively."]
            #[inline(always)]
            pub fn set_mproceed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub const fn start0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub fn set_start0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub const fn startn(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter."]
            #[inline(always)]
            pub fn set_startn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "If this bit is 1, send a Stop bit after the transaction completes."]
            #[inline(always)]
            pub const fn stop(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, send a Stop bit after the transaction completes."]
            #[inline(always)]
            pub fn set_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."]
            #[inline(always)]
            pub const fn pec_term(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0."]
            #[inline(always)]
            pub fn set_pec_term(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount\\[7:0\\] is 1. After ReadCount\\[7:0\\] is updated, this bit is cleared to 0."]
            #[inline(always)]
            pub const fn readm(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount\\[7:0\\] is 1. After ReadCount\\[7:0\\] is updated, this bit is cleared to 0."]
            #[inline(always)]
            pub fn set_readm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."]
            #[inline(always)]
            pub const fn rd_pec(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte."]
            #[inline(always)]
            pub fn set_rd_pec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."]
            #[inline(always)]
            pub const fn wr_cnt(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register."]
            #[inline(always)]
            pub fn set_wr_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."]
            #[inline(always)]
            pub const fn rd_cnt(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus."]
            #[inline(always)]
            pub fn set_rd_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for McmdU32 {
            #[inline(always)]
            fn default() -> McmdU32 {
                McmdU32(0)
            }
        }
        impl core::fmt::Debug for McmdU32 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("McmdU32")
                    .field("mrun", &self.mrun())
                    .field("mproceed", &self.mproceed())
                    .field("start0", &self.start0())
                    .field("startn", &self.startn())
                    .field("stop", &self.stop())
                    .field("pec_term", &self.pec_term())
                    .field("readm", &self.readm())
                    .field("rd_pec", &self.rd_pec())
                    .field("wr_cnt", &self.wr_cnt())
                    .field("rd_cnt", &self.rd_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for McmdU32 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "McmdU32 {{ mrun: {=bool:?}, mproceed: {=bool:?}, start0: {=bool:?}, startn: {=bool:?}, stop: {=bool:?}, pec_term: {=bool:?}, readm: {=bool:?}, rd_pec: {=bool:?}, wr_cnt: {=u8:?}, rd_cnt: {=u8:?} }}" , self . mrun () , self . mproceed () , self . start0 () , self . startn () , self . stop () , self . pec_term () , self . readm () , self . rd_pec () , self . wr_cnt () , self . rd_cnt ())
            }
        }
        #[doc = "SMBus Master Receive Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtrRxb(pub u32);
        impl MtrRxb {
            #[doc = "MRXB"]
            #[inline(always)]
            pub const fn mrxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MRXB"]
            #[inline(always)]
            pub fn set_mrxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for MtrRxb {
            #[inline(always)]
            fn default() -> MtrRxb {
                MtrRxb(0)
            }
        }
        impl core::fmt::Debug for MtrRxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtrRxb").field("mrxb", &self.mrxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtrRxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MtrRxb {{ mrxb: {=u8:?} }}", self.mrxb())
            }
        }
        #[doc = "SMBus Master Transmit Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MtrTxb(pub u32);
        impl MtrTxb {
            #[doc = "MTXB"]
            #[inline(always)]
            pub const fn mtxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MTXB"]
            #[inline(always)]
            pub fn set_mtxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for MtrTxb {
            #[inline(always)]
            fn default() -> MtrTxb {
                MtrTxb(0)
            }
        }
        impl core::fmt::Debug for MtrTxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MtrTxb").field("mtxb", &self.mtxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MtrTxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MtrTxb {{ mtxb: {=u8:?} }}", self.mtxb())
            }
        }
        #[doc = "Own Address Register Note that the Data Register and Own Address fields are offset by one bit, so that programming Own Address 1 with a value of 55h will result in the value AAh being recognized as the SMB Controller Core slave address."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OwnAddr(pub u32);
        impl OwnAddr {
            #[doc = "The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub const fn addr1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub fn set_addr1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub const fn addr2(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x7f;
                val as u8
            }
            #[doc = "The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave."]
            #[inline(always)]
            pub fn set_addr2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 8usize)) | (((val as u32) & 0x7f) << 8usize);
            }
        }
        impl Default for OwnAddr {
            #[inline(always)]
            fn default() -> OwnAddr {
                OwnAddr(0)
            }
        }
        impl core::fmt::Debug for OwnAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OwnAddr")
                    .field("addr1", &self.addr1())
                    .field("addr2", &self.addr2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OwnAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "OwnAddr {{ addr1: {=u8:?}, addr2: {=u8:?} }}",
                    self.addr1(),
                    self.addr2()
                )
            }
        }
        #[doc = "Packet Error Check (PEC) Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pec(pub u32);
        impl Pec {
            #[doc = "The SMBus Packet Error Check (PEC) byte."]
            #[inline(always)]
            pub const fn pec(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The SMBus Packet Error Check (PEC) byte."]
            #[inline(always)]
            pub fn set_pec(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Pec {
            #[inline(always)]
            fn default() -> Pec {
                Pec(0)
            }
        }
        impl core::fmt::Debug for Pec {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pec").field("pec", &self.pec()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pec {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pec {{ pec: {=u8:?} }}", self.pec())
            }
        }
        #[doc = "Repeated Start Hold Time Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rshtm(pub u32);
        impl Rshtm {
            #[doc = "This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold the clock until the Hold Time for the repeated Start Bit has been satisfied."]
            #[inline(always)]
            pub const fn rshtm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold the clock until the Hold Time for the repeated Start Bit has been satisfied."]
            #[inline(always)]
            pub fn set_rshtm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Rshtm {
            #[inline(always)]
            fn default() -> Rshtm {
                Rshtm(0)
            }
        }
        impl core::fmt::Debug for Rshtm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rshtm").field("rshtm", &self.rshtm()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rshtm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rshtm {{ rshtm: {=u8:?} }}", self.rshtm())
            }
        }
        #[doc = "Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rsts(pub u32);
        impl Rsts {
            #[doc = "The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible."]
            #[inline(always)]
            pub const fn nbb(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible."]
            #[inline(always)]
            pub fn set_nbb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus"]
            #[inline(always)]
            pub const fn lab(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus"]
            #[inline(always)]
            pub fn set_lab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received"]
            #[inline(always)]
            pub const fn aas(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received"]
            #[inline(always)]
            pub fn set_aas(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "The Last Received Bit or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0'). When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus. When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave."]
            #[inline(always)]
            pub const fn lrb_ad0(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "The Last Received Bit or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0'). When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus. When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave."]
            #[inline(always)]
            pub fn set_lrb_ad0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected."]
            #[inline(always)]
            pub const fn ber(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected."]
            #[inline(always)]
            pub fn set_ber(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode."]
            #[inline(always)]
            pub const fn sts(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode."]
            #[inline(always)]
            pub fn set_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "SMBus Address Decoded (SAD)"]
            #[inline(always)]
            pub const fn sad(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "SMBus Address Decoded (SAD)"]
            #[inline(always)]
            pub fn set_sad(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Pending Interrupt bit"]
            #[inline(always)]
            pub const fn pin(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Pending Interrupt bit"]
            #[inline(always)]
            pub fn set_pin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Rsts {
            #[inline(always)]
            fn default() -> Rsts {
                Rsts(0)
            }
        }
        impl core::fmt::Debug for Rsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rsts")
                    .field("nbb", &self.nbb())
                    .field("lab", &self.lab())
                    .field("aas", &self.aas())
                    .field("lrb_ad0", &self.lrb_ad0())
                    .field("ber", &self.ber())
                    .field("sts", &self.sts())
                    .field("sad", &self.sad())
                    .field("pin", &self.pin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rsts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rsts {{ nbb: {=bool:?}, lab: {=bool:?}, aas: {=bool:?}, lrb_ad0: {=bool:?}, ber: {=bool:?}, sts: {=bool:?}, sad: {=bool:?}, pin: {=bool:?} }}" , self . nbb () , self . lab () , self . aas () , self . lrb_ad0 () , self . ber () , self . sts () , self . sad () , self . pin ())
            }
        }
        #[doc = "SMBus Slave Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ScmdU08(pub u8);
        impl ScmdU08 {
            #[doc = "Setting this bit to 1 enables the Slave State Machine to operate."]
            #[inline(always)]
            pub const fn srun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting this bit to 1 enables the Slave State Machine to operate."]
            #[inline(always)]
            pub fn set_srun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."]
            #[inline(always)]
            pub const fn sproceed(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."]
            #[inline(always)]
            pub fn set_sproceed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."]
            #[inline(always)]
            pub const fn pec(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."]
            #[inline(always)]
            pub fn set_pec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "This field is set to the number of bytes software expects to send to the Master."]
            #[inline(always)]
            pub const fn wr_cnt(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field is set to the number of bytes software expects to send to the Master."]
            #[inline(always)]
            pub fn set_wr_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u8) & 0xff) << 8usize);
            }
            #[doc = "This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."]
            #[inline(always)]
            pub const fn rd_cnt(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."]
            #[inline(always)]
            pub fn set_rd_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u8) & 0xff) << 16usize);
            }
        }
        impl Default for ScmdU08 {
            #[inline(always)]
            fn default() -> ScmdU08 {
                ScmdU08(0)
            }
        }
        impl core::fmt::Debug for ScmdU08 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ScmdU08")
                    .field("srun", &self.srun())
                    .field("sproceed", &self.sproceed())
                    .field("pec", &self.pec())
                    .field("wr_cnt", &self.wr_cnt())
                    .field("rd_cnt", &self.rd_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ScmdU08 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ScmdU08 {{ srun: {=bool:?}, sproceed: {=bool:?}, pec: {=bool:?}, wr_cnt: {=u8:?}, rd_cnt: {=u8:?} }}" , self . srun () , self . sproceed () , self . pec () , self . wr_cnt () , self . rd_cnt ())
            }
        }
        #[doc = "SMBus Slave Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ScmdU16(pub u16);
        impl ScmdU16 {
            #[doc = "Setting this bit to 1 enables the Slave State Machine to operate."]
            #[inline(always)]
            pub const fn srun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting this bit to 1 enables the Slave State Machine to operate."]
            #[inline(always)]
            pub fn set_srun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u16) & 0x01) << 0usize);
            }
            #[doc = "When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."]
            #[inline(always)]
            pub const fn sproceed(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."]
            #[inline(always)]
            pub fn set_sproceed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u16) & 0x01) << 1usize);
            }
            #[doc = "If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."]
            #[inline(always)]
            pub const fn pec(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."]
            #[inline(always)]
            pub fn set_pec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u16) & 0x01) << 2usize);
            }
            #[doc = "This field is set to the number of bytes software expects to send to the Master."]
            #[inline(always)]
            pub const fn wr_cnt(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field is set to the number of bytes software expects to send to the Master."]
            #[inline(always)]
            pub fn set_wr_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
            #[doc = "This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."]
            #[inline(always)]
            pub const fn rd_cnt(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."]
            #[inline(always)]
            pub fn set_rd_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u16) & 0xff) << 16usize);
            }
        }
        impl Default for ScmdU16 {
            #[inline(always)]
            fn default() -> ScmdU16 {
                ScmdU16(0)
            }
        }
        impl core::fmt::Debug for ScmdU16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ScmdU16")
                    .field("srun", &self.srun())
                    .field("sproceed", &self.sproceed())
                    .field("pec", &self.pec())
                    .field("wr_cnt", &self.wr_cnt())
                    .field("rd_cnt", &self.rd_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ScmdU16 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ScmdU16 {{ srun: {=bool:?}, sproceed: {=bool:?}, pec: {=bool:?}, wr_cnt: {=u8:?}, rd_cnt: {=u8:?} }}" , self . srun () , self . sproceed () , self . pec () , self . wr_cnt () , self . rd_cnt ())
            }
        }
        #[doc = "SMBus Slave Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ScmdU32(pub u32);
        impl ScmdU32 {
            #[doc = "Setting this bit to 1 enables the Slave State Machine to operate."]
            #[inline(always)]
            pub const fn srun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Setting this bit to 1 enables the Slave State Machine to operate."]
            #[inline(always)]
            pub fn set_srun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."]
            #[inline(always)]
            pub const fn sproceed(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively."]
            #[inline(always)]
            pub fn set_sproceed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."]
            #[inline(always)]
            pub const fn pec(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0."]
            #[inline(always)]
            pub fn set_pec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This field is set to the number of bytes software expects to send to the Master."]
            #[inline(always)]
            pub const fn wr_cnt(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "This field is set to the number of bytes software expects to send to the Master."]
            #[inline(always)]
            pub fn set_wr_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."]
            #[inline(always)]
            pub const fn rd_cnt(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register."]
            #[inline(always)]
            pub fn set_rd_cnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for ScmdU32 {
            #[inline(always)]
            fn default() -> ScmdU32 {
                ScmdU32(0)
            }
        }
        impl core::fmt::Debug for ScmdU32 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ScmdU32")
                    .field("srun", &self.srun())
                    .field("sproceed", &self.sproceed())
                    .field("pec", &self.pec())
                    .field("wr_cnt", &self.wr_cnt())
                    .field("rd_cnt", &self.rd_cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ScmdU32 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ScmdU32 {{ srun: {=bool:?}, sproceed: {=bool:?}, pec: {=bool:?}, wr_cnt: {=u8:?}, rd_cnt: {=u8:?} }}" , self . srun () , self . sproceed () , self . pec () , self . wr_cnt () , self . rd_cnt ())
            }
        }
        #[doc = "SMBus Slave Receive Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlvRxb(pub u32);
        impl SlvRxb {
            #[doc = "SRXB"]
            #[inline(always)]
            pub const fn srxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "SRXB"]
            #[inline(always)]
            pub fn set_srxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for SlvRxb {
            #[inline(always)]
            fn default() -> SlvRxb {
                SlvRxb(0)
            }
        }
        impl core::fmt::Debug for SlvRxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlvRxb").field("srxb", &self.srxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlvRxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SlvRxb {{ srxb: {=u8:?} }}", self.srxb())
            }
        }
        #[doc = "SMBus Slave Transmit Buffer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SlvTxb(pub u32);
        impl SlvTxb {
            #[doc = "STXB"]
            #[inline(always)]
            pub const fn stxb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "STXB"]
            #[inline(always)]
            pub fn set_stxb(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for SlvTxb {
            #[inline(always)]
            fn default() -> SlvTxb {
                SlvTxb(0)
            }
        }
        impl core::fmt::Debug for SlvTxb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SlvTxb").field("stxb", &self.stxb()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SlvTxb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SlvTxb {{ stxb: {=u8:?} }}", self.stxb())
            }
        }
        #[doc = "Test"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Test(pub u8);
        impl Test {
            #[doc = "This register must not be written, or undesirable results may occur."]
            #[inline(always)]
            pub const fn test(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "This register must not be written, or undesirable results may occur."]
            #[inline(always)]
            pub fn set_test(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Test {
            #[inline(always)]
            fn default() -> Test {
                Test(0)
            }
        }
        impl core::fmt::Debug for Test {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Test").field("test", &self.test()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Test {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Test {{ test: {=u8:?} }}", self.test())
            }
        }
        #[doc = "Time-Out Scaling Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmoutsc(pub u32);
        impl Tmoutsc {
            #[doc = "Clock High time out period = Clock High Time-Out \\[7:0\\] x Baud_Clock_Period x 2"]
            #[inline(always)]
            pub const fn clk_high_tim_out(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Clock High time out period = Clock High Time-Out \\[7:0\\] x Baud_Clock_Period x 2"]
            #[inline(always)]
            pub fn set_clk_high_tim_out(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Slave Cumulative Time-Out duration = Slave Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 1024"]
            #[inline(always)]
            pub const fn slv_cum_tim_out(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Slave Cumulative Time-Out duration = Slave Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 1024"]
            #[inline(always)]
            pub fn set_slv_cum_tim_out(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Master Cumulative Time-Out duration = Master Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 512"]
            #[inline(always)]
            pub const fn mast_cum_tim_out(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Master Cumulative Time-Out duration = Master Cum Time-Out \\[7:0\\] x Baud_Clock_Period x 512"]
            #[inline(always)]
            pub fn set_mast_cum_tim_out(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Bus Idle Minimum time = Bus Idle Min \\[7:0\\] x Baud_Clock_Period"]
            #[inline(always)]
            pub const fn bus_idle_min(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Bus Idle Minimum time = Bus Idle Min \\[7:0\\] x Baud_Clock_Period"]
            #[inline(always)]
            pub fn set_bus_idle_min(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tmoutsc {
            #[inline(always)]
            fn default() -> Tmoutsc {
                Tmoutsc(0)
            }
        }
        impl core::fmt::Debug for Tmoutsc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmoutsc")
                    .field("clk_high_tim_out", &self.clk_high_tim_out())
                    .field("slv_cum_tim_out", &self.slv_cum_tim_out())
                    .field("mast_cum_tim_out", &self.mast_cum_tim_out())
                    .field("bus_idle_min", &self.bus_idle_min())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmoutsc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Tmoutsc {{ clk_high_tim_out: {=u8:?}, slv_cum_tim_out: {=u8:?}, mast_cum_tim_out: {=u8:?}, bus_idle_min: {=u8:?} }}" , self . clk_high_tim_out () , self . slv_cum_tim_out () , self . mast_cum_tim_out () , self . bus_idle_min ())
            }
        }
        #[doc = "WAKE ENABLE Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WakeEn(pub u32);
        impl WakeEn {
            #[doc = "Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable. 1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled"]
            #[inline(always)]
            pub const fn start_det_int_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable. 1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled"]
            #[inline(always)]
            pub fn set_start_det_int_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for WakeEn {
            #[inline(always)]
            fn default() -> WakeEn {
                WakeEn(0)
            }
        }
        impl core::fmt::Debug for WakeEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WakeEn")
                    .field("start_det_int_en", &self.start_det_int_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WakeEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WakeEn {{ start_det_int_en: {=bool:?} }}", self.start_det_int_en())
            }
        }
        #[doc = "WAKE STATUS Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct WakeSts(pub u32);
        impl WakeSts {
            #[doc = "This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when written with a '1'. Writes of '0' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn start_bit_det(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when written with a '1'. Writes of '0' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_start_bit_det(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for WakeSts {
            #[inline(always)]
            fn default() -> WakeSts {
                WakeSts(0)
            }
        }
        impl core::fmt::Debug for WakeSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WakeSts")
                    .field("start_bit_det", &self.start_bit_det())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for WakeSts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "WakeSts {{ start_bit_det: {=bool:?} }}", self.start_bit_det())
            }
        }
        #[doc = "Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wctrl(pub u32);
        impl Wctrl {
            #[doc = "The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device."]
            #[inline(always)]
            pub const fn ack(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device."]
            #[inline(always)]
            pub fn set_ack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "See STA description"]
            #[inline(always)]
            pub const fn sto(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "See STA description"]
            #[inline(always)]
            pub fn set_sto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition"]
            #[inline(always)]
            pub const fn sta(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition"]
            #[inline(always)]
            pub fn set_sta(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable Interrupt bit (ENI) controls the Interrupt Interface"]
            #[inline(always)]
            pub const fn eni(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Interrupt bit (ENI) controls the Interrupt Interface"]
            #[inline(always)]
            pub fn set_eni(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)"]
            #[inline(always)]
            pub const fn eso(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)"]
            #[inline(always)]
            pub fn set_eso(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect."]
            #[inline(always)]
            pub const fn pin(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect."]
            #[inline(always)]
            pub fn set_pin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Wctrl {
            #[inline(always)]
            fn default() -> Wctrl {
                Wctrl(0)
            }
        }
        impl core::fmt::Debug for Wctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wctrl")
                    .field("ack", &self.ack())
                    .field("sto", &self.sto())
                    .field("sta", &self.sta())
                    .field("eni", &self.eni())
                    .field("eso", &self.eso())
                    .field("pin", &self.pin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Wctrl {{ ack: {=bool:?}, sto: {=bool:?}, sta: {=bool:?}, eni: {=bool:?}, eso: {=bool:?}, pin: {=bool:?} }}" , self . ack () , self . sto () , self . sta () , self . eni () , self . eso () , self . pin ())
            }
        }
    }
}
pub mod tach0 {
    #[doc = "This block monitors TACH output signals (or locked rotor signals) from various types of fans, and determines their speed."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tach0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Tach0 {}
    unsafe impl Sync for Tach0 {}
    impl Tach0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "TACHx Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "TACHx Status Register"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "TACH HIGH LIMIT Register"]
        #[inline(always)]
        pub const fn lim_hi(self) -> crate::common::Reg<regs::LimHi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "TACHx Low Limit Register"]
        #[inline(always)]
        pub const fn lim_lo(self) -> crate::common::Reg<regs::LimLo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "TACHx Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "OUTOF_LIM_EN This bit is used to enable the TACH_OUT_OF_LIMIT_STATUS bit in the TACHx Status Register to generate an interrupt event. 1=Enable interrupt output from Tach block 0=Disable interrupt output from Tach block (default)"]
            #[inline(always)]
            pub const fn outof_lim_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "OUTOF_LIM_EN This bit is used to enable the TACH_OUT_OF_LIMIT_STATUS bit in the TACHx Status Register to generate an interrupt event. 1=Enable interrupt output from Tach block 0=Disable interrupt output from Tach block (default)"]
            #[inline(always)]
            pub fn set_outof_lim_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "EN 1= TACH Monitoring enabled, clocks enabled. 0= TACH Idle, clocks gated"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "EN 1= TACH Monitoring enabled, clocks enabled. 0= TACH Idle, clocks gated"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "FILT_EN This filter is used to remove high frequency glitches from Tach Input. When this filter is enabled, Tach input pulses less than two 100kHz_- Clk periods wide get filtered. 1= Filter enabled 0= Filter disabled (default) It is recommended that the Tach input filter always be enabled."]
            #[inline(always)]
            pub const fn filt_en(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "FILT_EN This filter is used to remove high frequency glitches from Tach Input. When this filter is enabled, Tach input pulses less than two 100kHz_- Clk periods wide get filtered. 1= Filter enabled 0= Filter disabled (default) It is recommended that the Tach input filter always be enabled."]
            #[inline(always)]
            pub fn set_filt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "RD_MOD_SEL 1=Counter is incremented on the rising edge of the 100kHz_Clk input. The counter is latched into the TACHX_COUNTER field and reset when the programmed number of edges is detected. 0=Counter is incremented when Tach Input transitions from low-tohigh state (default)"]
            #[inline(always)]
            pub const fn rd_mod_sel(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "RD_MOD_SEL 1=Counter is incremented on the rising edge of the 100kHz_Clk input. The counter is latched into the TACHX_COUNTER field and reset when the programmed number of edges is detected. 0=Counter is incremented when Tach Input transitions from low-tohigh state (default)"]
            #[inline(always)]
            pub fn set_rd_mod_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "EDGES A Tach signal is a square wave with a 50% duty cycle. Typically, two Tach periods represents one revolution of the fan. A Tach period consists of three Tach edges. This programmed value represents the number of Tach edges that will be used to determine the interval for which the number of 100kHz_Clk pulses will be counted 11b=9 Tach edges (4 Tach periods) 10b=5 Tach edges (2 Tach periods) 01b=3 Tach edges (1 Tach period) 00b=2 Tach edges (1/2 Tach period)"]
            #[inline(always)]
            pub const fn edges(&self) -> u8 {
                let val = (self.0 >> 11usize) & 0x03;
                val as u8
            }
            #[doc = "EDGES A Tach signal is a square wave with a 50% duty cycle. Typically, two Tach periods represents one revolution of the fan. A Tach period consists of three Tach edges. This programmed value represents the number of Tach edges that will be used to determine the interval for which the number of 100kHz_Clk pulses will be counted 11b=9 Tach edges (4 Tach periods) 10b=5 Tach edges (2 Tach periods) 01b=3 Tach edges (1 Tach period) 00b=2 Tach edges (1/2 Tach period)"]
            #[inline(always)]
            pub fn set_edges(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 11usize)) | (((val as u32) & 0x03) << 11usize);
            }
            #[doc = "CNT_RDY_INT_EN 1=Enable Count Ready interrupt from Tach block, 0=Disable Count Ready interrupt from Tach block"]
            #[inline(always)]
            pub const fn cnt_rdy_int_en(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_RDY_INT_EN 1=Enable Count Ready interrupt from Tach block, 0=Disable Count Ready interrupt from Tach block"]
            #[inline(always)]
            pub fn set_cnt_rdy_int_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "IN_INT_EN 1=Enable Tach Input toggle interrupt from Tach block, 0=Disable Tach Input toggle interrupt from Tach block"]
            #[inline(always)]
            pub const fn in_int_en(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "IN_INT_EN 1=Enable Tach Input toggle interrupt from Tach block, 0=Disable Tach Input toggle interrupt from Tach block"]
            #[inline(always)]
            pub fn set_in_int_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "This 16-bit field contains the latched value of the internal Tach pulse counter, which may be configured by the Tach Reading Mode Select field to operate as a free-running counter or to be gated by the Tach input signal."]
            #[inline(always)]
            pub const fn cntr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This 16-bit field contains the latched value of the internal Tach pulse counter, which may be configured by the Tach Reading Mode Select field to operate as a free-running counter or to be gated by the Tach input signal."]
            #[inline(always)]
            pub fn set_cntr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("outof_lim_en", &self.outof_lim_en())
                    .field("en", &self.en())
                    .field("filt_en", &self.filt_en())
                    .field("rd_mod_sel", &self.rd_mod_sel())
                    .field("edges", &self.edges())
                    .field("cnt_rdy_int_en", &self.cnt_rdy_int_en())
                    .field("in_int_en", &self.in_int_en())
                    .field("cntr", &self.cntr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ outof_lim_en: {=bool:?}, en: {=bool:?}, filt_en: {=bool:?}, rd_mod_sel: {=bool:?}, edges: {=u8:?}, cnt_rdy_int_en: {=bool:?}, in_int_en: {=bool:?}, cntr: {=u16:?} }}" , self . outof_lim_en () , self . en () , self . filt_en () , self . rd_mod_sel () , self . edges () , self . cnt_rdy_int_en () , self . in_int_en () , self . cntr ())
            }
        }
        #[doc = "TACH HIGH LIMIT Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LimHi(pub u32);
        impl LimHi {
            #[doc = "This value is compared with the value in the TACHX_COUNTER field. If the value in the counter is greater than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS status event may be enabled to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx Control Register."]
            #[inline(always)]
            pub const fn t_high(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This value is compared with the value in the TACHX_COUNTER field. If the value in the counter is greater than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS status event may be enabled to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx Control Register."]
            #[inline(always)]
            pub fn set_t_high(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for LimHi {
            #[inline(always)]
            fn default() -> LimHi {
                LimHi(0)
            }
        }
        impl core::fmt::Debug for LimHi {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LimHi").field("t_high", &self.t_high()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LimHi {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LimHi {{ t_high: {=u16:?} }}", self.t_high())
            }
        }
        #[doc = "TACHx Low Limit Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LimLo(pub u32);
        impl LimLo {
            #[doc = "This value is compared with the value in the TACHX_COUNTER field of the TACHx Control Register. If the value in the counter is less than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS status event may be enabled to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx Control Register To disable the TACH_OUT_OF_LIMIT_STATUS low event, program 0000h into this register."]
            #[inline(always)]
            pub const fn t_low(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "This value is compared with the value in the TACHX_COUNTER field of the TACHx Control Register. If the value in the counter is less than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS status event may be enabled to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx Control Register To disable the TACH_OUT_OF_LIMIT_STATUS low event, program 0000h into this register."]
            #[inline(always)]
            pub fn set_t_low(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for LimLo {
            #[inline(always)]
            fn default() -> LimLo {
                LimLo(0)
            }
        }
        impl core::fmt::Debug for LimLo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LimLo").field("t_low", &self.t_low()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LimLo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LimLo {{ t_low: {=u16:?} }}", self.t_low())
            }
        }
        #[doc = "TACHx Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "OUTOF_LIM_STS 1=Tach is outside of limits, 0=Tach is within limits (R/WC)"]
            #[inline(always)]
            pub const fn outof_lim_sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "OUTOF_LIM_STS 1=Tach is outside of limits, 0=Tach is within limits (R/WC)"]
            #[inline(always)]
            pub fn set_outof_lim_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PIN_STS 1= Tach Input is high, 0= Tach Input is low"]
            #[inline(always)]
            pub const fn pin_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PIN_STS 1= Tach Input is high, 0= Tach Input is low"]
            #[inline(always)]
            pub fn set_pin_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "TOG_STS 1=Tach Input changed state (this bit is set on a low-to-high or high-tolow transition), 0=Tach stable (R/WC)"]
            #[inline(always)]
            pub const fn tog_sts(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "TOG_STS 1=Tach Input changed state (this bit is set on a low-to-high or high-tolow transition), 0=Tach stable (R/WC)"]
            #[inline(always)]
            pub fn set_tog_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CNT_RDY_STS 1=Reading ready, 0=Reading not ready"]
            #[inline(always)]
            pub const fn cnt_rdy_sts(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "CNT_RDY_STS 1=Reading ready, 0=Reading not ready"]
            #[inline(always)]
            pub fn set_cnt_rdy_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("outof_lim_sts", &self.outof_lim_sts())
                    .field("pin_sts", &self.pin_sts())
                    .field("tog_sts", &self.tog_sts())
                    .field("cnt_rdy_sts", &self.cnt_rdy_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sts {{ outof_lim_sts: {=bool:?}, pin_sts: {=bool:?}, tog_sts: {=bool:?}, cnt_rdy_sts: {=bool:?} }}" , self . outof_lim_sts () , self . pin_sts () , self . tog_sts () , self . cnt_rdy_sts ())
            }
        }
    }
}
pub mod tfdp {
    #[doc = "The TFDP serially transmits Embedded Controller (EC)-originated diagnostic vectors to an external debug trace system."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tfdp {
        ptr: *mut u8,
    }
    unsafe impl Send for Tfdp {}
    unsafe impl Sync for Tfdp {}
    impl Tfdp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Debug data to be shifted out on the TFDP Debug port. While data is being shifted out, the Host Interface will 'hold-off' additional writes to the data register until the transfer is complete."]
        #[inline(always)]
        pub const fn msdata(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Debug Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Debug Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u8);
        impl Ctrl {
            #[doc = "Enable. 1=Clock enabled, 0=Clock is disabled (Default)"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable. 1=Clock enabled, 0=Clock is disabled (Default)"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "1= Data is shifted out on the falling edge of the debug clock, 0= Data is shifted out on the rising edge of the debug clock (Default)"]
            #[inline(always)]
            pub const fn edge_sel(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "1= Data is shifted out on the falling edge of the debug clock, 0= Data is shifted out on the rising edge of the debug clock (Default)"]
            #[inline(always)]
            pub fn set_edge_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Clock Divider Select."]
            #[inline(always)]
            pub const fn divsel(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "Clock Divider Select."]
            #[inline(always)]
            pub fn set_divsel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "Inter-packet Delay. The delay is in terms of TFDP Debug output clocks."]
            #[inline(always)]
            pub const fn ip_dly(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "Inter-packet Delay. The delay is in terms of TFDP Debug output clocks."]
            #[inline(always)]
            pub fn set_ip_dly(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("en", &self.en())
                    .field("edge_sel", &self.edge_sel())
                    .field("divsel", &self.divsel())
                    .field("ip_dly", &self.ip_dly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl {{ en: {=bool:?}, edge_sel: {=bool:?}, divsel: {=u8:?}, ip_dly: {=u8:?} }}",
                    self.en(),
                    self.edge_sel(),
                    self.divsel(),
                    self.ip_dly()
                )
            }
        }
    }
}
pub mod timer16_0 {
    #[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits. The name of the timer instance indicates the size of the timer."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Timer160 {
        ptr: *mut u8,
    }
    unsafe impl Send for Timer160 {}
    unsafe impl Sync for Timer160 {}
    impl Timer160 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This is the value of the Timer counter. This is updated by Hardware but may be set by Firmware."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the value of the Timer pre-load for the counter. This is used by H/W when the counter is to be restarted automatically; this will become the new value of the counter upon restart."]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the interrupt status that fires when the timer reaches its limit"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Timer Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This enables the block for operation. 1=This block will function normally; 0=This block will gate its clock and go into its lowest power state"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the block for operation. 1=This block will function normally; 0=This block will gate its clock and go into its lowest power state"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment; 0=The counter will decrement"]
            #[inline(always)]
            pub const fn cnt_up(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment; 0=The counter will decrement"]
            #[inline(always)]
            pub fn set_cnt_up(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This will select the action taken upon completing a count. 1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register. The interrupt will be set in edge mode 0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."]
            #[inline(always)]
            pub const fn au_restrt(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This will select the action taken upon completing a count. 1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register. The interrupt will be set in edge mode 0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."]
            #[inline(always)]
            pub fn set_au_restrt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need to wait before reconfiguring the Basic Timer following soft reset."]
            #[inline(always)]
            pub const fn sft_rst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need to wait before reconfiguring the Basic Timer following soft reset."]
            #[inline(always)]
            pub fn set_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so this bit will never clear. Clearing this bit will halt the timer counter."]
            #[inline(always)]
            pub const fn strt(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so this bit will never clear. Clearing this bit will halt the timer counter."]
            #[inline(always)]
            pub fn set_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit reloads the counter without interrupting it operation. This will not function if the timer has already completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an event occurs. Usage while the timer is off may result in erroneous behaviour."]
            #[inline(always)]
            pub const fn rld(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reloads the counter without interrupting it operation. This will not function if the timer has already completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an event occurs. Usage while the timer is off may result in erroneous behaviour."]
            #[inline(always)]
            pub fn set_rld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."]
            #[inline(always)]
            pub const fn hlt(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."]
            #[inline(always)]
            pub fn set_hlt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts. The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1 runs at half speed."]
            #[inline(always)]
            pub const fn prescale(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts. The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1 runs at half speed."]
            #[inline(always)]
            pub fn set_prescale(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("en", &self.en())
                    .field("cnt_up", &self.cnt_up())
                    .field("au_restrt", &self.au_restrt())
                    .field("sft_rst", &self.sft_rst())
                    .field("strt", &self.strt())
                    .field("rld", &self.rld())
                    .field("hlt", &self.hlt())
                    .field("prescale", &self.prescale())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ en: {=bool:?}, cnt_up: {=bool:?}, au_restrt: {=bool:?}, sft_rst: {=bool:?}, strt: {=bool:?}, rld: {=bool:?}, hlt: {=bool:?}, prescale: {=u16:?} }}" , self . en () , self . cnt_up () , self . au_restrt () , self . sft_rst () , self . strt () , self . rld () , self . hlt () , self . prescale ())
            }
        }
        #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u32);
        impl Ien {
            #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ien {{ en: {=bool:?} }}", self.en())
            }
        }
        #[doc = "This is the interrupt status that fires when the timer reaches its limit"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)"]
            #[inline(always)]
            pub const fn evt_int(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)"]
            #[inline(always)]
            pub fn set_evt_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts").field("evt_int", &self.evt_int()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sts {{ evt_int: {=bool:?} }}", self.evt_int())
            }
        }
    }
}
pub mod timer32_0 {
    #[doc = "This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 32 bits. The name of the timer instance indicates the size of the timer."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Timer320 {
        ptr: *mut u8,
    }
    unsafe impl Send for Timer320 {}
    unsafe impl Sync for Timer320 {}
    impl Timer320 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This is the value of the Timer counter. This is updated by Hardware but may be set by Firmware."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This is the value of the Timer pre-load for the counter. This is used by H/W when the counter is to be restarted automatically; this will become the new value of the counter upon restart."]
        #[inline(always)]
        pub const fn prld(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "This is the interrupt status that fires when the timer reaches its limit"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Timer Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "This enables the block for operation. 1=This block will function normally; 0=This block will gate its clock and go into its lowest power state"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This enables the block for operation. 1=This block will function normally; 0=This block will gate its clock and go into its lowest power state"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment; 0=The counter will decrement"]
            #[inline(always)]
            pub const fn cnt_up(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment; 0=The counter will decrement"]
            #[inline(always)]
            pub fn set_cnt_up(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This will select the action taken upon completing a count. 1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register. The interrupt will be set in edge mode 0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."]
            #[inline(always)]
            pub const fn au_restrt(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This will select the action taken upon completing a count. 1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register. The interrupt will be set in edge mode 0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode."]
            #[inline(always)]
            pub fn set_au_restrt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need to wait before reconfiguring the Basic Timer following soft reset."]
            #[inline(always)]
            pub const fn sft_rst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need to wait before reconfiguring the Basic Timer following soft reset."]
            #[inline(always)]
            pub fn set_sft_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so this bit will never clear. Clearing this bit will halt the timer counter."]
            #[inline(always)]
            pub const fn strt(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so this bit will never clear. Clearing this bit will halt the timer counter."]
            #[inline(always)]
            pub fn set_strt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit reloads the counter without interrupting it operation. This will not function if the timer has already completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an event occurs. Usage while the timer is off may result in erroneous behaviour."]
            #[inline(always)]
            pub const fn rld(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reloads the counter without interrupting it operation. This will not function if the timer has already completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an event occurs. Usage while the timer is off may result in erroneous behaviour."]
            #[inline(always)]
            pub fn set_rld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."]
            #[inline(always)]
            pub const fn hlt(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally."]
            #[inline(always)]
            pub fn set_hlt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts. The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1 runs at half speed."]
            #[inline(always)]
            pub const fn prescale(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts. The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1 runs at half speed."]
            #[inline(always)]
            pub fn set_prescale(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("en", &self.en())
                    .field("cnt_up", &self.cnt_up())
                    .field("au_restrt", &self.au_restrt())
                    .field("sft_rst", &self.sft_rst())
                    .field("strt", &self.strt())
                    .field("rld", &self.rld())
                    .field("hlt", &self.hlt())
                    .field("prescale", &self.prescale())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ en: {=bool:?}, cnt_up: {=bool:?}, au_restrt: {=bool:?}, sft_rst: {=bool:?}, strt: {=bool:?}, rld: {=bool:?}, hlt: {=bool:?}, prescale: {=u16:?} }}" , self . en () , self . cnt_up () , self . au_restrt () , self . sft_rst () , self . strt () , self . rld () , self . hlt () , self . prescale ())
            }
        }
        #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u32);
        impl Ien {
            #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register."]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ien {{ en: {=bool:?} }}", self.en())
            }
        }
        #[doc = "This is the interrupt status that fires when the timer reaches its limit"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)"]
            #[inline(always)]
            pub const fn evt_int(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)"]
            #[inline(always)]
            pub fn set_evt_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts").field("evt_int", &self.evt_int()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sts {{ evt_int: {=bool:?} }}", self.evt_int())
            }
        }
    }
}
pub mod uart0 {
    #[doc = "UART when DLAB=0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Data {
        ptr: *mut u8,
    }
    unsafe impl Send for Data {}
    unsafe impl Sync for Data {}
    impl Data {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "UART Receive (Read) Buffer Register (DLAB=0)"]
        #[inline(always)]
        pub const fn rx_dat(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART Transmit (Write) Buffer Register (DLAB=0)"]
        #[inline(always)]
        pub const fn tx_dat(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART Interrupt Enable Register (DLAB=0)"]
        #[inline(always)]
        pub const fn ien(self) -> crate::common::Reg<regs::Ien, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "UART FIFO Control Register"]
        #[inline(always)]
        pub const fn fifo_cr(self) -> crate::common::Reg<regs::DataFifoCr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[inline(always)]
        pub const fn int_id(self) -> crate::common::Reg<regs::DataIntId, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Line Control Register"]
        #[inline(always)]
        pub const fn lcr(self) -> crate::common::Reg<regs::DataLcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "UART Modem Control Register"]
        #[inline(always)]
        pub const fn mcr(self) -> crate::common::Reg<regs::DataMcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "UART Line Status Register"]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::DataLsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "UART Modem Status Register"]
        #[inline(always)]
        pub const fn msr(self) -> crate::common::Reg<regs::DataMsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "UART Scratchpad Register This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily."]
        #[inline(always)]
        pub const fn scr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "UART Activate Register. \\[0:0\\] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "UART Config Select Register"]
        #[inline(always)]
        pub const fn cfg_sel(self) -> crate::common::Reg<regs::DataCfgSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03f0usize) as _) }
        }
    }
    #[doc = "UART when DLAB=1"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dlab {
        ptr: *mut u8,
    }
    unsafe impl Send for Dlab {}
    unsafe impl Sync for Dlab {}
    impl Dlab {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "UART Programmable BAUD Rate Generator (LSB) Register (DLAB=1)"]
        #[inline(always)]
        pub const fn baudrt_lsb(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART Programmable BAUD Rate Generator (MSB) Register (DLAB=1)\\[6:0\\] BAUD_RATE_DIVISOR_MSB, \\[7:7\\] BAUD_CLK_SEL 1=If CLK_SRC is '0', the baud clock is derived from the 1.8432MHz_Clk. If CLK_SRC is '1', this bit has no effect 0=If CLK_SRC is '0', the baud clock is derived from the 24MHz_Clk. If CLK_SRC is '1', this bit has no effect"]
        #[inline(always)]
        pub const fn baudrt_msb(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "UART FIFO Control Register"]
        #[inline(always)]
        pub const fn fifo_cr(self) -> crate::common::Reg<regs::DlabFifoCr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[inline(always)]
        pub const fn int_id(self) -> crate::common::Reg<regs::DlabIntId, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "UART Line Control Register"]
        #[inline(always)]
        pub const fn lcr(self) -> crate::common::Reg<regs::DlabLcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "UART Modem Control Register"]
        #[inline(always)]
        pub const fn mcr(self) -> crate::common::Reg<regs::DlabMcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "UART Line Status Register"]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::DlabLsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "UART Modem Status Register"]
        #[inline(always)]
        pub const fn msr(self) -> crate::common::Reg<regs::DlabMsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "UART Scratchpad Register This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily."]
        #[inline(always)]
        pub const fn scr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "UART Activate Register. \\[0:0\\] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive."]
        #[inline(always)]
        pub const fn activate(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "UART Config Select Register"]
        #[inline(always)]
        pub const fn cfg_sel(self) -> crate::common::Reg<regs::DlabCfgSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03f0usize) as _) }
        }
    }
    #[doc = "The 16550 UART (Universal Asynchronous Receiver/Transmitter) is a full-function Two Pin Serial Port that supports the standard RS-232 Interface."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uart0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Uart0 {}
    unsafe impl Sync for Uart0 {}
    impl Uart0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "UART when DLAB=0"]
        #[inline(always)]
        pub const fn data(self) -> Data {
            unsafe { Data::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "UART when DLAB=1"]
        #[inline(always)]
        pub const fn dlab(self) -> Dlab {
            unsafe { Dlab::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "UART Config Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataCfgSel(pub u8);
        impl DataCfgSel {
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub const fn clk_src(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub fn set_clk_src(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub const fn pwr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub fn set_pwr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub const fn polar(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub fn set_polar(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for DataCfgSel {
            #[inline(always)]
            fn default() -> DataCfgSel {
                DataCfgSel(0)
            }
        }
        impl core::fmt::Debug for DataCfgSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataCfgSel")
                    .field("clk_src", &self.clk_src())
                    .field("pwr", &self.pwr())
                    .field("polar", &self.polar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataCfgSel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DataCfgSel {{ clk_src: {=bool:?}, pwr: {=bool:?}, polar: {=bool:?} }}",
                    self.clk_src(),
                    self.pwr(),
                    self.polar()
                )
            }
        }
        #[doc = "UART FIFO Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataFifoCr(pub u8);
        impl DataFifoCr {
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub const fn exrf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub fn set_exrf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub const fn clr_recv_fifo(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub fn set_clr_recv_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub const fn clr_xmit_fifo(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub fn set_clr_xmit_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub const fn dma_mode_sel(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub fn set_dma_mode_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub const fn recv_fifo_trig_lvl(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub fn set_recv_fifo_trig_lvl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DataFifoCr {
            #[inline(always)]
            fn default() -> DataFifoCr {
                DataFifoCr(0)
            }
        }
        impl core::fmt::Debug for DataFifoCr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataFifoCr")
                    .field("exrf", &self.exrf())
                    .field("clr_recv_fifo", &self.clr_recv_fifo())
                    .field("clr_xmit_fifo", &self.clr_xmit_fifo())
                    .field("dma_mode_sel", &self.dma_mode_sel())
                    .field("recv_fifo_trig_lvl", &self.recv_fifo_trig_lvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataFifoCr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataFifoCr {{ exrf: {=bool:?}, clr_recv_fifo: {=bool:?}, clr_xmit_fifo: {=bool:?}, dma_mode_sel: {=bool:?}, recv_fifo_trig_lvl: {=u8:?} }}" , self . exrf () , self . clr_recv_fifo () , self . clr_xmit_fifo () , self . dma_mode_sel () , self . recv_fifo_trig_lvl ())
            }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataIntId(pub u8);
        impl DataIntId {
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub const fn ipend(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub fn set_ipend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub const fn intid(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub fn set_intid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u8) & 0x07) << 1usize);
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub const fn fifo_en(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub fn set_fifo_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DataIntId {
            #[inline(always)]
            fn default() -> DataIntId {
                DataIntId(0)
            }
        }
        impl core::fmt::Debug for DataIntId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataIntId")
                    .field("ipend", &self.ipend())
                    .field("intid", &self.intid())
                    .field("fifo_en", &self.fifo_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataIntId {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DataIntId {{ ipend: {=bool:?}, intid: {=u8:?}, fifo_en: {=u8:?} }}",
                    self.ipend(),
                    self.intid(),
                    self.fifo_en()
                )
            }
        }
        #[doc = "UART Line Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataLcr(pub u8);
        impl DataLcr {
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn word_len(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_word_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn stop_bits(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_stop_bits(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub const fn en_par(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub fn set_en_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub const fn par_sel(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub fn set_par_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub const fn stick_par(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub fn set_stick_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub const fn brk_ctrl(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub fn set_brk_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub const fn dlab(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub fn set_dlab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DataLcr {
            #[inline(always)]
            fn default() -> DataLcr {
                DataLcr(0)
            }
        }
        impl core::fmt::Debug for DataLcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataLcr")
                    .field("word_len", &self.word_len())
                    .field("stop_bits", &self.stop_bits())
                    .field("en_par", &self.en_par())
                    .field("par_sel", &self.par_sel())
                    .field("stick_par", &self.stick_par())
                    .field("brk_ctrl", &self.brk_ctrl())
                    .field("dlab", &self.dlab())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataLcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataLcr {{ word_len: {=u8:?}, stop_bits: {=bool:?}, en_par: {=bool:?}, par_sel: {=bool:?}, stick_par: {=bool:?}, brk_ctrl: {=bool:?}, dlab: {=bool:?} }}" , self . word_len () , self . stop_bits () , self . en_par () , self . par_sel () , self . stick_par () , self . brk_ctrl () , self . dlab ())
            }
        }
        #[doc = "UART Line Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataLsr(pub u8);
        impl DataLsr {
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub const fn data_ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub fn set_data_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub const fn pe(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub fn set_pe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub const fn frame_err(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub fn set_frame_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub const fn brk_intr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub fn set_brk_intr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub const fn trans_empty(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub fn set_trans_empty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub const fn trans_err(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub fn set_trans_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub const fn fifo_err(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub fn set_fifo_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DataLsr {
            #[inline(always)]
            fn default() -> DataLsr {
                DataLsr(0)
            }
        }
        impl core::fmt::Debug for DataLsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataLsr")
                    .field("data_ready", &self.data_ready())
                    .field("overrun", &self.overrun())
                    .field("pe", &self.pe())
                    .field("frame_err", &self.frame_err())
                    .field("brk_intr", &self.brk_intr())
                    .field("trans_empty", &self.trans_empty())
                    .field("trans_err", &self.trans_err())
                    .field("fifo_err", &self.fifo_err())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataLsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataLsr {{ data_ready: {=bool:?}, overrun: {=bool:?}, pe: {=bool:?}, frame_err: {=bool:?}, brk_intr: {=bool:?}, trans_empty: {=bool:?}, trans_err: {=bool:?}, fifo_err: {=bool:?} }}" , self . data_ready () , self . overrun () , self . pe () , self . frame_err () , self . brk_intr () , self . trans_empty () , self . trans_err () , self . fifo_err ())
            }
        }
        #[doc = "UART Modem Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataMcr(pub u8);
        impl DataMcr {
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub const fn dtr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub fn set_dtr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub const fn rts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub fn set_rts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub const fn out1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub fn set_out1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub const fn out2(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub fn set_out2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub const fn loopback(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub fn set_loopback(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for DataMcr {
            #[inline(always)]
            fn default() -> DataMcr {
                DataMcr(0)
            }
        }
        impl core::fmt::Debug for DataMcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataMcr")
                    .field("dtr", &self.dtr())
                    .field("rts", &self.rts())
                    .field("out1", &self.out1())
                    .field("out2", &self.out2())
                    .field("loopback", &self.loopback())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataMcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataMcr {{ dtr: {=bool:?}, rts: {=bool:?}, out1: {=bool:?}, out2: {=bool:?}, loopback: {=bool:?} }}" , self . dtr () , self . rts () , self . out1 () , self . out2 () , self . loopback ())
            }
        }
        #[doc = "UART Modem Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DataMsr(pub u8);
        impl DataMsr {
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub const fn cts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub fn set_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub const fn dsr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub fn set_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub const fn ri(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub fn set_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub const fn dcd(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub fn set_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub const fn n_cts(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub fn set_n_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub const fn n_dsr(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub fn set_n_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub const fn n_ri(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub fn set_n_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub const fn n_dcd(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub fn set_n_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DataMsr {
            #[inline(always)]
            fn default() -> DataMsr {
                DataMsr(0)
            }
        }
        impl core::fmt::Debug for DataMsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DataMsr")
                    .field("cts", &self.cts())
                    .field("dsr", &self.dsr())
                    .field("ri", &self.ri())
                    .field("dcd", &self.dcd())
                    .field("n_cts", &self.n_cts())
                    .field("n_dsr", &self.n_dsr())
                    .field("n_ri", &self.n_ri())
                    .field("n_dcd", &self.n_dcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DataMsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DataMsr {{ cts: {=bool:?}, dsr: {=bool:?}, ri: {=bool:?}, dcd: {=bool:?}, n_cts: {=bool:?}, n_dsr: {=bool:?}, n_ri: {=bool:?}, n_dcd: {=bool:?} }}" , self . cts () , self . dsr () , self . ri () , self . dcd () , self . n_cts () , self . n_dsr () , self . n_ri () , self . n_dcd ())
            }
        }
        #[doc = "UART Config Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabCfgSel(pub u8);
        impl DlabCfgSel {
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub const fn clk_src(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CLK_SRC 1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources"]
            #[inline(always)]
            pub fn set_clk_src(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub const fn pwr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "POWER 1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET"]
            #[inline(always)]
            pub fn set_pwr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub const fn polar(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "POLARITY 1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted"]
            #[inline(always)]
            pub fn set_polar(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
        }
        impl Default for DlabCfgSel {
            #[inline(always)]
            fn default() -> DlabCfgSel {
                DlabCfgSel(0)
            }
        }
        impl core::fmt::Debug for DlabCfgSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabCfgSel")
                    .field("clk_src", &self.clk_src())
                    .field("pwr", &self.pwr())
                    .field("polar", &self.polar())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabCfgSel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DlabCfgSel {{ clk_src: {=bool:?}, pwr: {=bool:?}, polar: {=bool:?} }}",
                    self.clk_src(),
                    self.pwr(),
                    self.polar()
                )
            }
        }
        #[doc = "UART FIFO Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabFifoCr(pub u8);
        impl DlabFifoCr {
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub const fn exrf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "EXRF Enable XMIT and RECV FIFO."]
            #[inline(always)]
            pub fn set_exrf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub const fn clr_recv_fifo(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_RECV_FIFO Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'."]
            #[inline(always)]
            pub fn set_clr_recv_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub const fn clr_xmit_fifo(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing."]
            #[inline(always)]
            pub fn set_clr_xmit_fifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub const fn dma_mode_sel(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DMA_MODE_SELECT Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip."]
            #[inline(always)]
            pub fn set_dma_mode_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub const fn recv_fifo_trig_lvl(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt."]
            #[inline(always)]
            pub fn set_recv_fifo_trig_lvl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DlabFifoCr {
            #[inline(always)]
            fn default() -> DlabFifoCr {
                DlabFifoCr(0)
            }
        }
        impl core::fmt::Debug for DlabFifoCr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabFifoCr")
                    .field("exrf", &self.exrf())
                    .field("clr_recv_fifo", &self.clr_recv_fifo())
                    .field("clr_xmit_fifo", &self.clr_xmit_fifo())
                    .field("dma_mode_sel", &self.dma_mode_sel())
                    .field("recv_fifo_trig_lvl", &self.recv_fifo_trig_lvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabFifoCr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabFifoCr {{ exrf: {=bool:?}, clr_recv_fifo: {=bool:?}, clr_xmit_fifo: {=bool:?}, dma_mode_sel: {=bool:?}, recv_fifo_trig_lvl: {=u8:?} }}" , self . exrf () , self . clr_recv_fifo () , self . clr_xmit_fifo () , self . dma_mode_sel () , self . recv_fifo_trig_lvl ())
            }
        }
        #[doc = "UART Interrupt Identification Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabIntId(pub u8);
        impl DlabIntId {
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub const fn ipend(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "IPEND This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending."]
            #[inline(always)]
            pub fn set_ipend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub const fn intid(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x07;
                val as u8
            }
            #[doc = "INTID These bits identify the highest priority interrupt pending"]
            #[inline(always)]
            pub fn set_intid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val as u8) & 0x07) << 1usize);
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub const fn fifo_en(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "These two bits are set when the FIFO CONTROL Register bit 0 equals 1."]
            #[inline(always)]
            pub fn set_fifo_en(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u8) & 0x03) << 6usize);
            }
        }
        impl Default for DlabIntId {
            #[inline(always)]
            fn default() -> DlabIntId {
                DlabIntId(0)
            }
        }
        impl core::fmt::Debug for DlabIntId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabIntId")
                    .field("ipend", &self.ipend())
                    .field("intid", &self.intid())
                    .field("fifo_en", &self.fifo_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabIntId {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DlabIntId {{ ipend: {=bool:?}, intid: {=u8:?}, fifo_en: {=u8:?} }}",
                    self.ipend(),
                    self.intid(),
                    self.fifo_en()
                )
            }
        }
        #[doc = "UART Line Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabLcr(pub u8);
        impl DlabLcr {
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn word_len(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_word_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u8) & 0x03) << 0usize);
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub const fn stop_bits(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "STOP_BITS This bit specifies the number of stop bits in each transmitted or received serial character."]
            #[inline(always)]
            pub fn set_stop_bits(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub const fn en_par(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "ENABLE_PARITY Parity Enable bit."]
            #[inline(always)]
            pub fn set_en_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub const fn par_sel(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "PARITY_SELECT Even Parity Select bit."]
            #[inline(always)]
            pub fn set_par_sel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub const fn stick_par(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "STICK_PARITY Stick Parity bit."]
            #[inline(always)]
            pub fn set_stick_par(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub const fn brk_ctrl(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_CONTROL Set Break Control bit"]
            #[inline(always)]
            pub fn set_brk_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub const fn dlab(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "DLAB Divisor Latch Access Bit (DLAB)."]
            #[inline(always)]
            pub fn set_dlab(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DlabLcr {
            #[inline(always)]
            fn default() -> DlabLcr {
                DlabLcr(0)
            }
        }
        impl core::fmt::Debug for DlabLcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabLcr")
                    .field("word_len", &self.word_len())
                    .field("stop_bits", &self.stop_bits())
                    .field("en_par", &self.en_par())
                    .field("par_sel", &self.par_sel())
                    .field("stick_par", &self.stick_par())
                    .field("brk_ctrl", &self.brk_ctrl())
                    .field("dlab", &self.dlab())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabLcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabLcr {{ word_len: {=u8:?}, stop_bits: {=bool:?}, en_par: {=bool:?}, par_sel: {=bool:?}, stick_par: {=bool:?}, brk_ctrl: {=bool:?}, dlab: {=bool:?} }}" , self . word_len () , self . stop_bits () , self . en_par () , self . par_sel () , self . stick_par () , self . brk_ctrl () , self . dlab ())
            }
        }
        #[doc = "UART Line Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabLsr(pub u8);
        impl DlabLsr {
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub const fn data_ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DATA_READY Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO"]
            #[inline(always)]
            pub fn set_data_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "OVERRUN Overrun Error."]
            #[inline(always)]
            pub fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub const fn pe(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "PARITY ERROR Parity Error."]
            #[inline(always)]
            pub fn set_pe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub const fn frame_err(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "FRAME_ERROR Framing Error."]
            #[inline(always)]
            pub fn set_frame_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub const fn brk_intr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "BREAK_INTERRUPT Break Interrupt."]
            #[inline(always)]
            pub fn set_brk_intr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub const fn trans_empty(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "TRANSMIT_EMPTY Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission."]
            #[inline(always)]
            pub fn set_trans_empty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub const fn trans_err(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty."]
            #[inline(always)]
            pub fn set_trans_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub const fn fifo_err(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO_ERROR"]
            #[inline(always)]
            pub fn set_fifo_err(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DlabLsr {
            #[inline(always)]
            fn default() -> DlabLsr {
                DlabLsr(0)
            }
        }
        impl core::fmt::Debug for DlabLsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabLsr")
                    .field("data_ready", &self.data_ready())
                    .field("overrun", &self.overrun())
                    .field("pe", &self.pe())
                    .field("frame_err", &self.frame_err())
                    .field("brk_intr", &self.brk_intr())
                    .field("trans_empty", &self.trans_empty())
                    .field("trans_err", &self.trans_err())
                    .field("fifo_err", &self.fifo_err())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabLsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabLsr {{ data_ready: {=bool:?}, overrun: {=bool:?}, pe: {=bool:?}, frame_err: {=bool:?}, brk_intr: {=bool:?}, trans_empty: {=bool:?}, trans_err: {=bool:?}, fifo_err: {=bool:?} }}" , self . data_ready () , self . overrun () , self . pe () , self . frame_err () , self . brk_intr () , self . trans_empty () , self . trans_err () , self . fifo_err ())
            }
        }
        #[doc = "UART Modem Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabMcr(pub u8);
        impl DlabMcr {
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub const fn dtr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DTR This bit controls the Data Terminal Ready (nDTR) output."]
            #[inline(always)]
            pub fn set_dtr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub const fn rts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RTS This bit controls the Request To Send (nRTS) output."]
            #[inline(always)]
            pub fn set_rts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub const fn out1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "OUT1 This bit controls the Output 1 (OUT1) bit."]
            #[inline(always)]
            pub fn set_out1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub const fn out2(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "OUT2 This bit is used to enable an UART interrupt."]
            #[inline(always)]
            pub fn set_out2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub const fn loopback(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "LOOPBACK This bit provides the loopback feature for diagnostic testing of the Serial Port."]
            #[inline(always)]
            pub fn set_loopback(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for DlabMcr {
            #[inline(always)]
            fn default() -> DlabMcr {
                DlabMcr(0)
            }
        }
        impl core::fmt::Debug for DlabMcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabMcr")
                    .field("dtr", &self.dtr())
                    .field("rts", &self.rts())
                    .field("out1", &self.out1())
                    .field("out2", &self.out2())
                    .field("loopback", &self.loopback())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabMcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabMcr {{ dtr: {=bool:?}, rts: {=bool:?}, out1: {=bool:?}, out2: {=bool:?}, loopback: {=bool:?} }}" , self . dtr () , self . rts () , self . out1 () , self . out2 () , self . loopback ())
            }
        }
        #[doc = "UART Modem Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DlabMsr(pub u8);
        impl DlabMsr {
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub const fn cts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CTS Delta Clear To Send (DCTS)."]
            #[inline(always)]
            pub fn set_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub const fn dsr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "DSR Delta Data Set Ready (DDSR)."]
            #[inline(always)]
            pub fn set_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub const fn ri(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "RI Trailing Edge of Ring Indicator (TERI)."]
            #[inline(always)]
            pub fn set_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub const fn dcd(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "DCD Delta Data Carrier Detect (DDCD)."]
            #[inline(always)]
            pub fn set_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub const fn n_cts(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "nCTS This bit is the complement of the Clear To Send (nCTS) input."]
            #[inline(always)]
            pub fn set_n_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub const fn n_dsr(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is the complement of the Data Set Ready (nDSR) input."]
            #[inline(always)]
            pub fn set_n_dsr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub const fn n_ri(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "nRI This bit is the complement of the Ring Indicator (nRI) input."]
            #[inline(always)]
            pub fn set_n_ri(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub const fn n_dcd(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "nDCD This bit is the complement of the Data Carrier Detect (nDCD) input."]
            #[inline(always)]
            pub fn set_n_dcd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for DlabMsr {
            #[inline(always)]
            fn default() -> DlabMsr {
                DlabMsr(0)
            }
        }
        impl core::fmt::Debug for DlabMsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DlabMsr")
                    .field("cts", &self.cts())
                    .field("dsr", &self.dsr())
                    .field("ri", &self.ri())
                    .field("dcd", &self.dcd())
                    .field("n_cts", &self.n_cts())
                    .field("n_dsr", &self.n_dsr())
                    .field("n_ri", &self.n_ri())
                    .field("n_dcd", &self.n_dcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DlabMsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DlabMsr {{ cts: {=bool:?}, dsr: {=bool:?}, ri: {=bool:?}, dcd: {=bool:?}, n_cts: {=bool:?}, n_dsr: {=bool:?}, n_ri: {=bool:?}, n_dcd: {=bool:?} }}" , self . cts () , self . dsr () , self . ri () , self . dcd () , self . n_cts () , self . n_dsr () , self . n_ri () , self . n_dcd ())
            }
        }
        #[doc = "UART Interrupt Enable Register (DLAB=0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ien(pub u8);
        impl Ien {
            #[doc = "ERDAI This bit enables the Received Data Available Interrupt (and timeout interrupts in the FIFO mode) when set to logic '1'."]
            #[inline(always)]
            pub const fn erdai(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "ERDAI This bit enables the Received Data Available Interrupt (and timeout interrupts in the FIFO mode) when set to logic '1'."]
            #[inline(always)]
            pub fn set_erdai(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "ETHREI This bit enables the Transmitter Holding Register Empty Interrupt when set to logic '1'."]
            #[inline(always)]
            pub const fn ethrei(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "ETHREI This bit enables the Transmitter Holding Register Empty Interrupt when set to logic '1'."]
            #[inline(always)]
            pub fn set_ethrei(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "ELSI This bit enables the Received Line Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub const fn elsi(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "ELSI This bit enables the Received Line Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub fn set_elsi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "EMSI This bit enables the MODEM Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub const fn emsi(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "EMSI This bit enables the MODEM Status Interrupt when set to logic '1'."]
            #[inline(always)]
            pub fn set_emsi(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
        }
        impl Default for Ien {
            #[inline(always)]
            fn default() -> Ien {
                Ien(0)
            }
        }
        impl core::fmt::Debug for Ien {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ien")
                    .field("erdai", &self.erdai())
                    .field("ethrei", &self.ethrei())
                    .field("elsi", &self.elsi())
                    .field("emsi", &self.emsi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ien {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ien {{ erdai: {=bool:?}, ethrei: {=bool:?}, elsi: {=bool:?}, emsi: {=bool:?} }}",
                    self.erdai(),
                    self.ethrei(),
                    self.elsi(),
                    self.emsi()
                )
            }
        }
    }
}
pub mod vbat {
    #[doc = "The VBAT Register Bank block is a block implemented for aggregating miscellaneous battery-backed registers required the host and by the Embedded Controller (EC) Subsystem that are not unique to a block implemented in the EC subsystem."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vbat {
        ptr: *mut u8,
    }
    unsafe impl Send for Vbat {}
    unsafe impl Sync for Vbat {}
    impl Vbat {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The Power-Fail and Reset Status Register collects and retains the VBAT RST and WDT event status when VCC1 is unpowered."]
        #[inline(always)]
        pub const fn pfrs(self) -> crate::common::Reg<regs::Pfrs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "CLOCK ENABLE"]
        #[inline(always)]
        pub const fn clk32_en(self) -> crate::common::Reg<regs::Clk32en, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "MONOTONIC COUNTER"]
        #[inline(always)]
        pub const fn mcnt_lo(self) -> crate::common::Reg<regs::McntLo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "COUNTER HIWORD"]
        #[inline(always)]
        pub const fn mcnt_hi(self) -> crate::common::Reg<regs::McntHi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "VWR_BCKP"]
        #[inline(always)]
        pub const fn vwr_bckp(self) -> crate::common::Reg<regs::VwrBckp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CLOCK ENABLE"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clk32en(pub u32);
        impl Clk32en {
            #[doc = "1=32KHz clock domain is off while VTR is off (i.e., while on VBAT only). The 32KHz domain is always on while VTR is on, so the PLL always has a reference. 0=32KHz clock domain is enabled while VTR is off (i.e., while on VBAT only). The clock source for the 32KHz domain is determined by the other bits in this register"]
            #[inline(always)]
            pub const fn c32k_suppress(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "1=32KHz clock domain is off while VTR is off (i.e., while on VBAT only). The 32KHz domain is always on while VTR is on, so the PLL always has a reference. 0=32KHz clock domain is enabled while VTR is off (i.e., while on VBAT only). The clock source for the 32KHz domain is determined by the other bits in this register"]
            #[inline(always)]
            pub fn set_c32k_suppress(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit selects the source for the 32KHz clock domain. 1=The 32KHZ_IN VTR-powered pin is used as a source for the 32KHz clock domain. If an activity detector does not detect a clock on the selected source, the always-on 32KHz internal clock source is automatically selected 0=The always-on32Khz clock source is used as the source for the 32KHz clock domain."]
            #[inline(always)]
            pub const fn ext_32k(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects the source for the 32KHz clock domain. 1=The 32KHZ_IN VTR-powered pin is used as a source for the 32KHz clock domain. If an activity detector does not detect a clock on the selected source, the always-on 32KHz internal clock source is automatically selected 0=The always-on32Khz clock source is used as the source for the 32KHz clock domain."]
            #[inline(always)]
            pub fn set_ext_32k(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "This field determines the source for the always-on 32KHz internal clock source. If set to '1b', this bit will only take effect if an active clock has been detected on the crystal pins. Once the 32KHz source has been switched, activity detection on the crystal no longer functions. Therefore, if the crystal oscillator uses a single-ended input, once started that input must not stop while this bit is '1b'. 1=Crystal Oscillator. The selection between a singled-ended input or a resonant crystal is determined by XOSEL in this register 0=Silicon Oscillator."]
            #[inline(always)]
            pub const fn c32khz_src(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This field determines the source for the always-on 32KHz internal clock source. If set to '1b', this bit will only take effect if an active clock has been detected on the crystal pins. Once the 32KHz source has been switched, activity detection on the crystal no longer functions. Therefore, if the crystal oscillator uses a single-ended input, once started that input must not stop while this bit is '1b'. 1=Crystal Oscillator. The selection between a singled-ended input or a resonant crystal is determined by XOSEL in this register 0=Silicon Oscillator."]
            #[inline(always)]
            pub fn set_c32khz_src(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "This bit selects between a single-ended clock source for the crystal oscillator or an external parallel crystal. 1= the Crystal Oscillator is driven by a single-ended 32KHz clock source connected to the XTAL2 pin. 0= the Crystal Oscillator requires a 32KHz parallel resonant crystal connected between the XTAL1 and XTAL2 pins (default)."]
            #[inline(always)]
            pub const fn xosel(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit selects between a single-ended clock source for the crystal oscillator or an external parallel crystal. 1= the Crystal Oscillator is driven by a single-ended 32KHz clock source connected to the XTAL2 pin. 0= the Crystal Oscillator requires a 32KHz parallel resonant crystal connected between the XTAL1 and XTAL2 pins (default)."]
            #[inline(always)]
            pub fn set_xosel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Clk32en {
            #[inline(always)]
            fn default() -> Clk32en {
                Clk32en(0)
            }
        }
        impl core::fmt::Debug for Clk32en {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clk32en")
                    .field("c32k_suppress", &self.c32k_suppress())
                    .field("ext_32k", &self.ext_32k())
                    .field("c32khz_src", &self.c32khz_src())
                    .field("xosel", &self.xosel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clk32en {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Clk32en {{ c32k_suppress: {=bool:?}, ext_32k: {=bool:?}, c32khz_src: {=bool:?}, xosel: {=bool:?} }}" , self . c32k_suppress () , self . ext_32k () , self . c32khz_src () , self . xosel ())
            }
        }
        #[doc = "COUNTER HIWORD"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct McntHi(pub u32);
        impl McntHi {
            #[doc = "Thirty-two bit read/write register. If software sets this register to an incrementing value, based on an external non-volatile store, this register may be combined with the Monotonic Counter Register to form a 64-bit monotonic counter."]
            #[inline(always)]
            pub const fn cnt_hwrd(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Thirty-two bit read/write register. If software sets this register to an incrementing value, based on an external non-volatile store, this register may be combined with the Monotonic Counter Register to form a 64-bit monotonic counter."]
            #[inline(always)]
            pub fn set_cnt_hwrd(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for McntHi {
            #[inline(always)]
            fn default() -> McntHi {
                McntHi(0)
            }
        }
        impl core::fmt::Debug for McntHi {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("McntHi").field("cnt_hwrd", &self.cnt_hwrd()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for McntHi {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "McntHi {{ cnt_hwrd: {=u32:?} }}", self.cnt_hwrd())
            }
        }
        #[doc = "MONOTONIC COUNTER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct McntLo(pub u32);
        impl McntLo {
            #[doc = "Read-only register that increments by 1 every time it is read. It is reset to 0 on a VBAT Power On Reset."]
            #[inline(always)]
            pub const fn mon_cnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Read-only register that increments by 1 every time it is read. It is reset to 0 on a VBAT Power On Reset."]
            #[inline(always)]
            pub fn set_mon_cnt(&mut self, val: u32) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for McntLo {
            #[inline(always)]
            fn default() -> McntLo {
                McntLo(0)
            }
        }
        impl core::fmt::Debug for McntLo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("McntLo").field("mon_cnt", &self.mon_cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for McntLo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "McntLo {{ mon_cnt: {=u32:?} }}", self.mon_cnt())
            }
        }
        #[doc = "The Power-Fail and Reset Status Register collects and retains the VBAT RST and WDT event status when VCC1 is unpowered."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pfrs(pub u8);
        impl Pfrs {
            #[doc = "This bit is set to '1b' if a was triggered by an assertion of the SOFT_SYS_RESET bit in the System Reset Register. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn soft(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a was triggered by an assertion of the SOFT_SYS_RESET bit in the System Reset Register. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_soft(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Test"]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Test"]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a low signal on the RSTI# input pin. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn rsti(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a low signal on the RSTI# input pin. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_rsti(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a Watchdog Timer event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn wdt_evt(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by a Watchdog Timer event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_wdt_evt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by an ARM SYS_RSTREQ event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub const fn sys_rstreq(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to '1b' if a RESET_SYS was triggered by an ARM SYS_RSTREQ event. This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)"]
            #[inline(always)]
            pub fn set_sys_rstreq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "The VBAT RST bit is set to '1' by hardware when a RESET_VBAT is detected. This is the register default value. To clear VBAT RST EC firmware must write a '1' to this bit; writing a '0' to VBAT RST has no affect.(R/WC)"]
            #[inline(always)]
            pub const fn vbat_rst(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The VBAT RST bit is set to '1' by hardware when a RESET_VBAT is detected. This is the register default value. To clear VBAT RST EC firmware must write a '1' to this bit; writing a '0' to VBAT RST has no affect.(R/WC)"]
            #[inline(always)]
            pub fn set_vbat_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Pfrs {
            #[inline(always)]
            fn default() -> Pfrs {
                Pfrs(0)
            }
        }
        impl core::fmt::Debug for Pfrs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pfrs")
                    .field("soft", &self.soft())
                    .field("test", &self.test())
                    .field("rsti", &self.rsti())
                    .field("wdt_evt", &self.wdt_evt())
                    .field("sys_rstreq", &self.sys_rstreq())
                    .field("vbat_rst", &self.vbat_rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pfrs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pfrs {{ soft: {=bool:?}, test: {=bool:?}, rsti: {=bool:?}, wdt_evt: {=bool:?}, sys_rstreq: {=bool:?}, vbat_rst: {=bool:?} }}" , self . soft () , self . test () , self . rsti () , self . wdt_evt () , self . sys_rstreq () , self . vbat_rst ())
            }
        }
        #[doc = "VWR_BCKP"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct VwrBckp(pub u32);
        impl VwrBckp {
            #[doc = "The Boot ROM firmware will copy this field into the SRC3 to SRC0 bits of the Master-to-Slave Virtual Wire Register that corresponds to Virtual Wire Index 2h on a RESET_SYS. If software always saves the state of the Index 2h SRC bits on the falling edge of the SUSWARN# virtual wire, the state of the four SRC bits will be synchronized to the state of the four bits in the core logic."]
            #[inline(always)]
            pub const fn m2s_2h_backup(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The Boot ROM firmware will copy this field into the SRC3 to SRC0 bits of the Master-to-Slave Virtual Wire Register that corresponds to Virtual Wire Index 2h on a RESET_SYS. If software always saves the state of the Index 2h SRC bits on the falling edge of the SUSWARN# virtual wire, the state of the four SRC bits will be synchronized to the state of the four bits in the core logic."]
            #[inline(always)]
            pub fn set_m2s_2h_backup(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "The Boot ROM firmware will copy this field into the SRC3 to SRC0 bits of the Master-to-Slave Virtual Wire Register that corresponds to Virtual Wire Index 42h on a RESET_SYS. If software always saves the state of the Index 2h SRC bits on the falling edge of the SUSWARN# virtual wire, the state of the four SRC bits will be synchronized to the state of the four bits in the core logic."]
            #[inline(always)]
            pub const fn m2s_42h_backup(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "The Boot ROM firmware will copy this field into the SRC3 to SRC0 bits of the Master-to-Slave Virtual Wire Register that corresponds to Virtual Wire Index 42h on a RESET_SYS. If software always saves the state of the Index 2h SRC bits on the falling edge of the SUSWARN# virtual wire, the state of the four SRC bits will be synchronized to the state of the four bits in the core logic."]
            #[inline(always)]
            pub fn set_m2s_42h_backup(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for VwrBckp {
            #[inline(always)]
            fn default() -> VwrBckp {
                VwrBckp(0)
            }
        }
        impl core::fmt::Debug for VwrBckp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VwrBckp")
                    .field("m2s_2h_backup", &self.m2s_2h_backup())
                    .field("m2s_42h_backup", &self.m2s_42h_backup())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for VwrBckp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "VwrBckp {{ m2s_2h_backup: {=u8:?}, m2s_42h_backup: {=u8:?} }}",
                    self.m2s_2h_backup(),
                    self.m2s_42h_backup()
                )
            }
        }
    }
}
pub mod vbat_ram {
    #[doc = "The VBAT Powered RAM provides a 128 Byte Random Accessed Memory that is operational while the main power rail is operational, and will retain its values powered by battery power while the main rail is unpowered."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct VbatRam {
        ptr: *mut u8,
    }
    unsafe impl Send for VbatRam {}
    unsafe impl Sync for VbatRam {}
    impl VbatRam {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "32-bits of VBAT powered RAM."]
        #[inline(always)]
        pub const fn mem_u32(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
}
pub mod vci {
    #[doc = "The VBAT-Powered Control Interface has VBAT-powered combinational logic and input and output signal pins. The block interfaces with the RTC With Date and DST Adjustment as well as the Week Alarm."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vci {
        ptr: *mut u8,
    }
    unsafe impl Send for Vci {}
    unsafe impl Sync for Vci {}
    impl Vci {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "VCI Register"]
        #[inline(always)]
        pub const fn ctrl_sts(self) -> crate::common::Reg<regs::CtrlSts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Latch Enable Register"]
        #[inline(always)]
        pub const fn latch_en(self) -> crate::common::Reg<regs::LatchEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Latch Resets Register"]
        #[inline(always)]
        pub const fn latch_rst(self) -> crate::common::Reg<regs::LatchRst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "VCI Input Enable Register"]
        #[inline(always)]
        pub const fn input_en(self) -> crate::common::Reg<regs::InputEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Holdoff Count Register"]
        #[inline(always)]
        pub const fn hldoff_cnt(self) -> crate::common::Reg<regs::HldoffCnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "VCI Polarity Register"]
        #[inline(always)]
        pub const fn polarity(self) -> crate::common::Reg<regs::Polarity, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "VCI Posedge Detect Register"]
        #[inline(always)]
        pub const fn pedge_det(self) -> crate::common::Reg<regs::PedgeDet, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "VCI Negedge Detect Register"]
        #[inline(always)]
        pub const fn nedge_det(self) -> crate::common::Reg<regs::NedgeDet, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "VCI Buffer Enable Register"]
        #[inline(always)]
        pub const fn buffer_en(self) -> crate::common::Reg<regs::BufferEn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "VCI Buffer Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BufferEn(pub u32);
        impl BufferEn {
            #[doc = "Input Buffer enable. After changing the buffer enable for a VCI input, firmware should reset the input latch and clear any potential interrupt that may have been triggered by the input, as changing the buffer may cause the internal status to change. This register has no effect when VTR is powered. When VTR is on, the input buffers are enabled only by the IE bit. For each bit in the field: 1=VCI_IN# input buffer enabled independent of the IE bit. The edge detection latches for this input are always enabled 0=VCI_IN# input buffer enabled by the IE bit. The edge detection latches are only enabled when the IE bit is 1 (default)."]
            #[inline(always)]
            pub const fn v_buf(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Input Buffer enable. After changing the buffer enable for a VCI input, firmware should reset the input latch and clear any potential interrupt that may have been triggered by the input, as changing the buffer may cause the internal status to change. This register has no effect when VTR is powered. When VTR is on, the input buffers are enabled only by the IE bit. For each bit in the field: 1=VCI_IN# input buffer enabled independent of the IE bit. The edge detection latches for this input are always enabled 0=VCI_IN# input buffer enabled by the IE bit. The edge detection latches are only enabled when the IE bit is 1 (default)."]
            #[inline(always)]
            pub fn set_v_buf(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for BufferEn {
            #[inline(always)]
            fn default() -> BufferEn {
                BufferEn(0)
            }
        }
        impl core::fmt::Debug for BufferEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BufferEn").field("v_buf", &self.v_buf()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BufferEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BufferEn {{ v_buf: {=u8:?} }}", self.v_buf())
            }
        }
        #[doc = "VCI Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CtrlSts(pub u32);
        impl CtrlSts {
            #[doc = "These bits provide the latched state of the associated VCI_IN# pin, if latching is enabled or the current state of the pin if latching is not enabled. In both cases, the value is determined after the action of the VCI Polarity Register. Note: The VCI_IN\\[6:0\\]# bits default to the state of their respective input pins."]
            #[inline(always)]
            pub const fn vci_in(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits provide the latched state of the associated VCI_IN# pin, if latching is enabled or the current state of the pin if latching is not enabled. In both cases, the value is determined after the action of the VCI Polarity Register. Note: The VCI_IN\\[6:0\\]# bits default to the state of their respective input pins."]
            #[inline(always)]
            pub fn set_vci_in(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "This bit provides the current status of the VCI_OVRD_IN pin. Note: The VCI_OVRD_IN bit defaults to the state of the respective input pin."]
            #[inline(always)]
            pub const fn vci_ovrd_in(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "This bit provides the current status of the VCI_OVRD_IN pin. Note: The VCI_OVRD_IN bit defaults to the state of the respective input pin."]
            #[inline(always)]
            pub fn set_vci_ovrd_in(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "This bit provides the current status of the VCI_OUT pin."]
            #[inline(always)]
            pub const fn vci_out(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "This bit provides the current status of the VCI_OUT pin."]
            #[inline(always)]
            pub fn set_vci_out(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "This bit can allow EC firmware to control the state of the VCI_OUT pin. For example, when VTR_PWRGD is asserted and the FW_EXT bit is 1, clearing the VCI_FW_CNTRL bit de-asserts the active high VCI_OUT pin. BIOS must set this bit to 1 prior to setting the FW_EXT bit to 1 on power up, in order to avoid glitches on the VCI_OUT pin."]
            #[inline(always)]
            pub const fn vci_fw_ctrl(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "This bit can allow EC firmware to control the state of the VCI_OUT pin. For example, when VTR_PWRGD is asserted and the FW_EXT bit is 1, clearing the VCI_FW_CNTRL bit de-asserts the active high VCI_OUT pin. BIOS must set this bit to 1 prior to setting the FW_EXT bit to 1 on power up, in order to avoid glitches on the VCI_OUT pin."]
            #[inline(always)]
            pub fn set_vci_fw_ctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This bit controls selecting between the external VBAT-Powered Control Interface inputs, or the VCI_FW_CNTRL bit output to control the VCI_OUT pin. 1=VCI_OUT is determined by the VCI_FW_CNTRL field, when VTR is active 0=VCI_OUT is determined by the external inputs. Note: This bit used to be called GPO/nEXT. The name was changed to distinguish it from the BGPOs, which are elsewhere, and to remove a / in a bit name."]
            #[inline(always)]
            pub const fn fw_ext(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls selecting between the external VBAT-Powered Control Interface inputs, or the VCI_FW_CNTRL bit output to control the VCI_OUT pin. 1=VCI_OUT is determined by the VCI_FW_CNTRL field, when VTR is active 0=VCI_OUT is determined by the external inputs. Note: This bit used to be called GPO/nEXT. The name was changed to distinguish it from the BGPOs, which are elsewhere, and to remove a / in a bit name."]
            #[inline(always)]
            pub fn set_fw_ext(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "The Filters Bypass bit is used to enable and disable the input filters on the VCI_IN# pins. 1=Filters disabled; 0=Filters enabled (default)."]
            #[inline(always)]
            pub const fn fltrs_bypass(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "The Filters Bypass bit is used to enable and disable the input filters on the VCI_IN# pins. 1=Filters disabled; 0=Filters enabled (default)."]
            #[inline(always)]
            pub fn set_fltrs_bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "If enabled by WK_ALRM_LE, this bit is set to 1 if the Week Alarm signal is asserted. It is reset by writes to WK_ALRM_LS."]
            #[inline(always)]
            pub const fn wk_alrm(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "If enabled by WK_ALRM_LE, this bit is set to 1 if the Week Alarm signal is asserted. It is reset by writes to WK_ALRM_LS."]
            #[inline(always)]
            pub fn set_wk_alrm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "If enabled by RTC_ALRM_LE, this bit is set to 1 if the RTC Alarm signal is asserted. It is reset by writes to RTC_ALRM_LS."]
            #[inline(always)]
            pub const fn rtc_alrm(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "If enabled by RTC_ALRM_LE, this bit is set to 1 if the RTC Alarm signal is asserted. It is reset by writes to RTC_ALRM_LS."]
            #[inline(always)]
            pub fn set_rtc_alrm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for CtrlSts {
            #[inline(always)]
            fn default() -> CtrlSts {
                CtrlSts(0)
            }
        }
        impl core::fmt::Debug for CtrlSts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CtrlSts")
                    .field("vci_in", &self.vci_in())
                    .field("vci_ovrd_in", &self.vci_ovrd_in())
                    .field("vci_out", &self.vci_out())
                    .field("vci_fw_ctrl", &self.vci_fw_ctrl())
                    .field("fw_ext", &self.fw_ext())
                    .field("fltrs_bypass", &self.fltrs_bypass())
                    .field("wk_alrm", &self.wk_alrm())
                    .field("rtc_alrm", &self.rtc_alrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CtrlSts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CtrlSts {{ vci_in: {=u8:?}, vci_ovrd_in: {=bool:?}, vci_out: {=bool:?}, vci_fw_ctrl: {=bool:?}, fw_ext: {=bool:?}, fltrs_bypass: {=bool:?}, wk_alrm: {=bool:?}, rtc_alrm: {=bool:?} }}" , self . vci_in () , self . vci_ovrd_in () , self . vci_out () , self . vci_fw_ctrl () , self . fw_ext () , self . fltrs_bypass () , self . wk_alrm () , self . rtc_alrm ())
            }
        }
        #[doc = "Holdoff Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HldoffCnt(pub u32);
        impl HldoffCnt {
            #[doc = "These bits determine the period of time the VCI_OUT logic is inhibited from re-asserting VCI_OUT after a SYS_SHDN# event. FFh-01h=The Power On Inhibit Holdoff Time is set to a period between 125ms and 31.875 seconds. 0=The Power On Inhibit function is disabled."]
            #[inline(always)]
            pub const fn time(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "These bits determine the period of time the VCI_OUT logic is inhibited from re-asserting VCI_OUT after a SYS_SHDN# event. FFh-01h=The Power On Inhibit Holdoff Time is set to a period between 125ms and 31.875 seconds. 0=The Power On Inhibit function is disabled."]
            #[inline(always)]
            pub fn set_time(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for HldoffCnt {
            #[inline(always)]
            fn default() -> HldoffCnt {
                HldoffCnt(0)
            }
        }
        impl core::fmt::Debug for HldoffCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HldoffCnt").field("time", &self.time()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HldoffCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HldoffCnt {{ time: {=u8:?} }}", self.time())
            }
        }
        #[doc = "VCI Input Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct InputEn(pub u32);
        impl InputEn {
            #[doc = "Input Enables for VCI_IN# signals. After changing the input enable for a VCI input, firmware should reset the input latch and clear any potential interrupt that may have been triggered by the input, as changing the enable may cause the internal status to change. For each bit in the field: 1=Enabled. The corresponding VCI_IN# input is not gated and toggling the pin will affect the VCI_OUT pin 0=Not Enabled. the corresponding VCI_IN# input does not affect the VCI_OUT pin, even if the input is '0'. Unless the corresponding bit in the VCI Buffer Enable Register is 1, latches are not asserted, even if the VCI_IN# pin is low, during a VBAT power transition"]
            #[inline(always)]
            pub const fn ie(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Input Enables for VCI_IN# signals. After changing the input enable for a VCI input, firmware should reset the input latch and clear any potential interrupt that may have been triggered by the input, as changing the enable may cause the internal status to change. For each bit in the field: 1=Enabled. The corresponding VCI_IN# input is not gated and toggling the pin will affect the VCI_OUT pin 0=Not Enabled. the corresponding VCI_IN# input does not affect the VCI_OUT pin, even if the input is '0'. Unless the corresponding bit in the VCI Buffer Enable Register is 1, latches are not asserted, even if the VCI_IN# pin is low, during a VBAT power transition"]
            #[inline(always)]
            pub fn set_ie(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for InputEn {
            #[inline(always)]
            fn default() -> InputEn {
                InputEn(0)
            }
        }
        impl core::fmt::Debug for InputEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("InputEn").field("ie", &self.ie()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for InputEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "InputEn {{ ie: {=u8:?} }}", self.ie())
            }
        }
        #[doc = "Latch Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LatchEn(pub u32);
        impl LatchEn {
            #[doc = "Latching Enables. Latching occurs after the Polarity configuration, so a VCI_INi# pin is asserted when it is '0' if VCI_IN_POL is '0', and asserted when it is '1' if VCI_IN_POL is '1'. For each bit in the field: 1=Enabled. Assertions of the VCI_INi# pin are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The VCI_INi# signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub const fn le(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Latching Enables. Latching occurs after the Polarity configuration, so a VCI_INi# pin is asserted when it is '0' if VCI_IN_POL is '0', and asserted when it is '1' if VCI_IN_POL is '1'. For each bit in the field: 1=Enabled. Assertions of the VCI_INi# pin are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The VCI_INi# signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub fn set_le(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Latch enable for the Week Alarm Power-Up signal. 1=Enabled. Assertions of the Week Alarm are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The Week Alarm signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub const fn wk_alrm_le(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Latch enable for the Week Alarm Power-Up signal. 1=Enabled. Assertions of the Week Alarm are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The Week Alarm signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub fn set_wk_alrm_le(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Latch enable for the RTC Power-Up signal. 1=Enabled. Assertions of the RTC Alarm are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The RTC Alarm signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub const fn rtc_alrm_le(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Latch enable for the RTC Power-Up signal. 1=Enabled. Assertions of the RTC Alarm are held until the latch is reset by writing the corresponding LS bit 0=Not Enabled. The RTC Alarm signal is not latched but passed directly to the VCI_OUT logic"]
            #[inline(always)]
            pub fn set_rtc_alrm_le(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for LatchEn {
            #[inline(always)]
            fn default() -> LatchEn {
                LatchEn(0)
            }
        }
        impl core::fmt::Debug for LatchEn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LatchEn")
                    .field("le", &self.le())
                    .field("wk_alrm_le", &self.wk_alrm_le())
                    .field("rtc_alrm_le", &self.rtc_alrm_le())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LatchEn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "LatchEn {{ le: {=u8:?}, wk_alrm_le: {=bool:?}, rtc_alrm_le: {=bool:?} }}",
                    self.le(),
                    self.wk_alrm_le(),
                    self.rtc_alrm_le()
                )
            }
        }
        #[doc = "Latch Resets Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LatchRst(pub u32);
        impl LatchRst {
            #[doc = "Latch Resets. When a Latch Resets bit is written with a '1', the corresponding VCI_INi# latch is de-asserted ('1'). The VCI_INi# input to the latch has priority over the Latch Reset input, so firmware cannot reset the latch while the VCI_INi# pin is asserted. Firmware should sample the state of the pin in the VCI Register before attempting to reset the latch. As noted in the Latch Enable Register, the assertion level is determined by the VCI_IN_POL bit. Reads of this register are undefined."]
            #[inline(always)]
            pub const fn ls(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Latch Resets. When a Latch Resets bit is written with a '1', the corresponding VCI_INi# latch is de-asserted ('1'). The VCI_INi# input to the latch has priority over the Latch Reset input, so firmware cannot reset the latch while the VCI_INi# pin is asserted. Firmware should sample the state of the pin in the VCI Register before attempting to reset the latch. As noted in the Latch Enable Register, the assertion level is determined by the VCI_IN_POL bit. Reads of this register are undefined."]
            #[inline(always)]
            pub fn set_ls(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Week Alarm Latch Reset. When this bit is written with a '1', the Week Alarm Event latch is reset. The Week Alarm input to the latch has priority over the Reset input Reads of this register are undefined."]
            #[inline(always)]
            pub const fn wk_alrm_ls(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Week Alarm Latch Reset. When this bit is written with a '1', the Week Alarm Event latch is reset. The Week Alarm input to the latch has priority over the Reset input Reads of this register are undefined."]
            #[inline(always)]
            pub fn set_wk_alrm_ls(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "RTC Alarm Latch Reset. When this bit is written with a '1', the RTC Alarm Event latch is reset. The RTC Alarm input to the latch has priority over the Reset input Reads of this register are undefined."]
            #[inline(always)]
            pub const fn rtc_alrm_ls(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "RTC Alarm Latch Reset. When this bit is written with a '1', the RTC Alarm Event latch is reset. The RTC Alarm input to the latch has priority over the Reset input Reads of this register are undefined."]
            #[inline(always)]
            pub fn set_rtc_alrm_ls(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for LatchRst {
            #[inline(always)]
            fn default() -> LatchRst {
                LatchRst(0)
            }
        }
        impl core::fmt::Debug for LatchRst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LatchRst")
                    .field("ls", &self.ls())
                    .field("wk_alrm_ls", &self.wk_alrm_ls())
                    .field("rtc_alrm_ls", &self.rtc_alrm_ls())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LatchRst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "LatchRst {{ ls: {=u8:?}, wk_alrm_ls: {=bool:?}, rtc_alrm_ls: {=bool:?} }}",
                    self.ls(),
                    self.wk_alrm_ls(),
                    self.rtc_alrm_ls()
                )
            }
        }
        #[doc = "VCI Negedge Detect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct NedgeDet(pub u32);
        impl NedgeDet {
            #[doc = "These bits record a high to low transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field: 1=Negative Edge Detected; 0=No edge detected."]
            #[inline(always)]
            pub const fn vci_in(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits record a high to low transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field: 1=Negative Edge Detected; 0=No edge detected."]
            #[inline(always)]
            pub fn set_vci_in(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for NedgeDet {
            #[inline(always)]
            fn default() -> NedgeDet {
                NedgeDet(0)
            }
        }
        impl core::fmt::Debug for NedgeDet {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("NedgeDet").field("vci_in", &self.vci_in()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NedgeDet {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "NedgeDet {{ vci_in: {=u8:?} }}", self.vci_in())
            }
        }
        #[doc = "VCI Posedge Detect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PedgeDet(pub u32);
        impl PedgeDet {
            #[doc = "These bits record a low to high transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field: 1=Positive Edge Detected; 0=No edge detected."]
            #[inline(always)]
            pub const fn vci_in(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits record a low to high transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field: 1=Positive Edge Detected; 0=No edge detected."]
            #[inline(always)]
            pub fn set_vci_in(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for PedgeDet {
            #[inline(always)]
            fn default() -> PedgeDet {
                PedgeDet(0)
            }
        }
        impl core::fmt::Debug for PedgeDet {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PedgeDet").field("vci_in", &self.vci_in()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PedgeDet {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PedgeDet {{ vci_in: {=u8:?} }}", self.vci_in())
            }
        }
        #[doc = "VCI Polarity Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Polarity(pub u32);
        impl Polarity {
            #[doc = "These bits determine the polarity of the VCI_IN input signals: For each bit in the field: 1=Active High. The value on the pins is inverted before use 0=Active Low (default)."]
            #[inline(always)]
            pub const fn vci_in(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "These bits determine the polarity of the VCI_IN input signals: For each bit in the field: 1=Active High. The value on the pins is inverted before use 0=Active Low (default)."]
            #[inline(always)]
            pub fn set_vci_in(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Polarity {
            #[inline(always)]
            fn default() -> Polarity {
                Polarity(0)
            }
        }
        impl core::fmt::Debug for Polarity {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Polarity").field("vci_in", &self.vci_in()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Polarity {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Polarity {{ vci_in: {=u8:?} }}", self.vci_in())
            }
        }
    }
}
pub mod wdt {
    #[doc = "The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed. When enabled, the Watchdog Timer (WDT) circuit will generate a WDT Event if the user program fails to reload the WDT within a specified length of time known as the WDT Interval."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Wdt {}
    unsafe impl Sync for Wdt {}
    impl Wdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Writing this field reloads the Watch Dog Timer counter."]
        #[inline(always)]
        pub const fn load(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "WDT Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The WDT Kick Register is a strobe. Reads of this register return 0. Writes to this register cause the WDT to reload the WDT Load Register value and start decrementing when the WDT_ENABLE bit in the WDT Control Register is set to '1'. When the WDT_ENABLE bit in the WDT Control Register is cleared to '0', writes to the WDT Kick Register have no effect."]
        #[inline(always)]
        pub const fn kick(self) -> crate::common::Reg<u8, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "This read-only register provides the current WDT count."]
        #[inline(always)]
        pub const fn cnt(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "WDT Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u8);
        impl Ctrl {
            #[doc = "WDT Block enabled"]
            #[inline(always)]
            pub const fn wdt_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "WDT Block enabled"]
            #[inline(always)]
            pub fn set_wdt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "WDT_STS is set by hardware if the last reset of the device was caused by an underflow of the WDT. This bit must be cleared by the EC firmware writing a '1' to this bit. Writing a '0' to this bit has no effect."]
            #[inline(always)]
            pub const fn wdt_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "WDT_STS is set by hardware if the last reset of the device was caused by an underflow of the WDT. This bit must be cleared by the EC firmware writing a '1' to this bit. Writing a '0' to this bit has no effect."]
            #[inline(always)]
            pub fn set_wdt_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "This bit enables the WDT Stall function if the Hibernation Timer 0 is active. 1=The WDT is stalled while the Hibernation Timer 0 is active 0=The WDT is not affected by Hibernation Timer 0."]
            #[inline(always)]
            pub const fn hib_tmr0_stl(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the WDT Stall function if the Hibernation Timer 0 is active. 1=The WDT is stalled while the Hibernation Timer 0 is active 0=The WDT is not affected by Hibernation Timer 0."]
            #[inline(always)]
            pub fn set_hib_tmr0_stl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "This bit enables the WDT Stall function if the Week Timer is active. 1=The WDT is stalled while the Week Timer is active 0=The WDT is not affected by the Week Timer."]
            #[inline(always)]
            pub const fn wk_tmr_stl(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the WDT Stall function if the Week Timer is active. 1=The WDT is stalled while the Week Timer is active 0=The WDT is not affected by the Week Timer."]
            #[inline(always)]
            pub fn set_wk_tmr_stl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "This bit enables the WDT Stall function if JTAG or SWD debug functions are active 1=The WDT is stalled while either JTAG or SWD is active 0=The WDT is not affected by the JTAG debug interface."]
            #[inline(always)]
            pub const fn jtag_stl(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "This bit enables the WDT Stall function if JTAG or SWD debug functions are active 1=The WDT is stalled while either JTAG or SWD is active 0=The WDT is not affected by the JTAG debug interface."]
            #[inline(always)]
            pub fn set_jtag_stl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("wdt_en", &self.wdt_en())
                    .field("wdt_sts", &self.wdt_sts())
                    .field("hib_tmr0_stl", &self.hib_tmr0_stl())
                    .field("wk_tmr_stl", &self.wk_tmr_stl())
                    .field("jtag_stl", &self.jtag_stl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ wdt_en: {=bool:?}, wdt_sts: {=bool:?}, hib_tmr0_stl: {=bool:?}, wk_tmr_stl: {=bool:?}, jtag_stl: {=bool:?} }}" , self . wdt_en () , self . wdt_sts () , self . hib_tmr0_stl () , self . wk_tmr_stl () , self . jtag_stl ())
            }
        }
    }
}
pub mod week {
    #[doc = "The Week Alarm Interface provides two timekeeping functions: a Week Timer and a Sub-Week Timer. Both the Week Timer and the Sub-Week Timer assert the Power-Up Event Output which automatically powers-up the system from the G3 state."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Week {
        ptr: *mut u8,
    }
    unsafe impl Send for Week {}
    unsafe impl Sync for Week {}
    impl Week {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control Register"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Week Alarm Counter Register"]
        #[inline(always)]
        pub const fn alarm_cnt(self) -> crate::common::Reg<regs::AlarmCnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Week Timer Compare Register"]
        #[inline(always)]
        pub const fn tmr_comp(self) -> crate::common::Reg<regs::TmrComp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Clock Divider Register"]
        #[inline(always)]
        pub const fn clkdiv(self) -> crate::common::Reg<regs::Clkdiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Sub-Second Programmable Interrupt Select Register"]
        #[inline(always)]
        pub const fn ss_intr_sel(self) -> crate::common::Reg<regs::SsIntrSel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Sub-Week Control Register"]
        #[inline(always)]
        pub const fn swk_ctrl(self) -> crate::common::Reg<regs::SwkCtrl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Sub-Week Alarm Counter Register"]
        #[inline(always)]
        pub const fn swk_alarm(self) -> crate::common::Reg<regs::SwkAlarm, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "BGPO Data Register"]
        #[inline(always)]
        pub const fn bgpo_data(self) -> crate::common::Reg<regs::BgpoData, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "BGPO Power Register"]
        #[inline(always)]
        pub const fn bgpo_pwr(self) -> crate::common::Reg<regs::BgpoPwr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "BGPO Reset Register"]
        #[inline(always)]
        pub const fn bgpo_rst(self) -> crate::common::Reg<regs::BgpoRst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Week Alarm Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AlarmCnt(pub u32);
        impl AlarmCnt {
            #[doc = "While the WT_ENABLE bit is 1, this register is incremented at a 1 Hz rate. Writes of this register may require one second to take effect. Reads return the current state of the register. Reads and writes complete independently of the state of WT_ENABLE."]
            #[inline(always)]
            pub const fn wk_cntr(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0fff_ffff;
                val as u32
            }
            #[doc = "While the WT_ENABLE bit is 1, this register is incremented at a 1 Hz rate. Writes of this register may require one second to take effect. Reads return the current state of the register. Reads and writes complete independently of the state of WT_ENABLE."]
            #[inline(always)]
            pub fn set_wk_cntr(&mut self, val: u32) {
                self.0 = (self.0 & !(0x0fff_ffff << 0usize)) | (((val as u32) & 0x0fff_ffff) << 0usize);
            }
        }
        impl Default for AlarmCnt {
            #[inline(always)]
            fn default() -> AlarmCnt {
                AlarmCnt(0)
            }
        }
        impl core::fmt::Debug for AlarmCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AlarmCnt").field("wk_cntr", &self.wk_cntr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AlarmCnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AlarmCnt {{ wk_cntr: {=u32:?} }}", self.wk_cntr())
            }
        }
        #[doc = "BGPO Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BgpoData(pub u32);
        impl BgpoData {
            #[doc = "Battery powered General Purpose Output. Each output pin may be individually configured to be either a VBAT-power BGPO or a VTR powered GPIO, based on the corresponding settings in the BGPO Power Register. Additionally, each output pin may be individually configured to reset to 0 on either RESET_VTR or RESET_SYS, based on the corresponding settings in the BGPO Reset Register. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] output is high; 0=BGPO\\[i\\] output is low."]
            #[inline(always)]
            pub const fn bgpo(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Battery powered General Purpose Output. Each output pin may be individually configured to be either a VBAT-power BGPO or a VTR powered GPIO, based on the corresponding settings in the BGPO Power Register. Additionally, each output pin may be individually configured to reset to 0 on either RESET_VTR or RESET_SYS, based on the corresponding settings in the BGPO Reset Register. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] output is high; 0=BGPO\\[i\\] output is low."]
            #[inline(always)]
            pub fn set_bgpo(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for BgpoData {
            #[inline(always)]
            fn default() -> BgpoData {
                BgpoData(0)
            }
        }
        impl core::fmt::Debug for BgpoData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BgpoData").field("bgpo", &self.bgpo()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BgpoData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BgpoData {{ bgpo: {=u16:?} }}", self.bgpo())
            }
        }
        #[doc = "BGPO Power Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BgpoPwr(pub u32);
        impl BgpoPwr {
            #[doc = "Battery powered General Purpose Output power source. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] is powered by VBAT. The BGPO\\[i\\] pin is always determined by the corresponding bit in the BGPO Data Register. The GPIO Input register for the GPIO that is multiplexed with the BGPO always returns a '1b'. 0=The pin for BGPO\\[i\\] functions as a GPIO. When VTR is powered, the pin associated with BGPO\\[i\\] is determined by the GPIO associated with the pin. When VTR is unpowered, the pin is tristated."]
            #[inline(always)]
            pub const fn bgpo_power(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x1f;
                val as u8
            }
            #[doc = "Battery powered General Purpose Output power source. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] is powered by VBAT. The BGPO\\[i\\] pin is always determined by the corresponding bit in the BGPO Data Register. The GPIO Input register for the GPIO that is multiplexed with the BGPO always returns a '1b'. 0=The pin for BGPO\\[i\\] functions as a GPIO. When VTR is powered, the pin associated with BGPO\\[i\\] is determined by the GPIO associated with the pin. When VTR is unpowered, the pin is tristated."]
            #[inline(always)]
            pub fn set_bgpo_power(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 1usize)) | (((val as u32) & 0x1f) << 1usize);
            }
        }
        impl Default for BgpoPwr {
            #[inline(always)]
            fn default() -> BgpoPwr {
                BgpoPwr(0)
            }
        }
        impl core::fmt::Debug for BgpoPwr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BgpoPwr")
                    .field("bgpo_power", &self.bgpo_power())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BgpoPwr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BgpoPwr {{ bgpo_power: {=u8:?} }}", self.bgpo_power())
            }
        }
        #[doc = "BGPO Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct BgpoRst(pub u32);
        impl BgpoRst {
            #[doc = "Battery powered General Purpose Output reset event. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] is reset to 0 on RESET_VTR; 0=BGPO\\[i\\] is reset to 0 on RESET_SYS."]
            #[inline(always)]
            pub const fn bgpo_reset(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Battery powered General Purpose Output reset event. For each bit \\[i\\] in the field: 1=BGPO\\[i\\] is reset to 0 on RESET_VTR; 0=BGPO\\[i\\] is reset to 0 on RESET_SYS."]
            #[inline(always)]
            pub fn set_bgpo_reset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for BgpoRst {
            #[inline(always)]
            fn default() -> BgpoRst {
                BgpoRst(0)
            }
        }
        impl core::fmt::Debug for BgpoRst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BgpoRst")
                    .field("bgpo_reset", &self.bgpo_reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for BgpoRst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "BgpoRst {{ bgpo_reset: {=u16:?} }}", self.bgpo_reset())
            }
        }
        #[doc = "Clock Divider Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clkdiv(pub u32);
        impl Clkdiv {
            #[doc = "Reads of this register return the current state of the Week Timer 15- bit clock divider."]
            #[inline(always)]
            pub const fn div(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Reads of this register return the current state of the Week Timer 15- bit clock divider."]
            #[inline(always)]
            pub fn set_div(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Clkdiv {
            #[inline(always)]
            fn default() -> Clkdiv {
                Clkdiv(0)
            }
        }
        impl core::fmt::Debug for Clkdiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clkdiv").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clkdiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Clkdiv {{ div: {=u16:?} }}", self.div())
            }
        }
        #[doc = "Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "The WT_EN bit is used to start and stop the Week Alarm Counter Register and the Clock Divider Register. The value in the Counter Register is held when the WT_ENABLE bit is not asserted (0) and the count is resumed from the last value when the bit is asserted (1). The 15-Bit Clock Divider is reset to 00h and the Week Alarm Interface is in its lowest power consumption state when the WT_ENABLE bit is not asserted."]
            #[inline(always)]
            pub const fn wt_en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The WT_EN bit is used to start and stop the Week Alarm Counter Register and the Clock Divider Register. The value in the Counter Register is held when the WT_ENABLE bit is not asserted (0) and the count is resumed from the last value when the bit is asserted (1). The 15-Bit Clock Divider is reset to 00h and the Week Alarm Interface is in its lowest power consumption state when the WT_ENABLE bit is not asserted."]
            #[inline(always)]
            pub fn set_wt_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit controls the state of the Power-Up Event Output and enables Week POWER-UP Event decoding in the VBAT-Powered Control Interface. 1=Power-Up Event Output Enabled 0=Power-Up Event Output Disabled and Reset"]
            #[inline(always)]
            pub const fn pwrup_en(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit controls the state of the Power-Up Event Output and enables Week POWER-UP Event decoding in the VBAT-Powered Control Interface. 1=Power-Up Event Output Enabled 0=Power-Up Event Output Disabled and Reset"]
            #[inline(always)]
            pub fn set_pwrup_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("wt_en", &self.wt_en())
                    .field("pwrup_en", &self.pwrup_en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctrl {{ wt_en: {=bool:?}, pwrup_en: {=bool:?} }}",
                    self.wt_en(),
                    self.pwrup_en()
                )
            }
        }
        #[doc = "Sub-Second Programmable Interrupt Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SsIntrSel(pub u32);
        impl SsIntrSel {
            #[doc = "This field determines the rate at which Sub-Second interrupt events are generated."]
            #[inline(always)]
            pub const fn spisr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This field determines the rate at which Sub-Second interrupt events are generated."]
            #[inline(always)]
            pub fn set_spisr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for SsIntrSel {
            #[inline(always)]
            fn default() -> SsIntrSel {
                SsIntrSel(0)
            }
        }
        impl core::fmt::Debug for SsIntrSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SsIntrSel").field("spisr", &self.spisr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SsIntrSel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SsIntrSel {{ spisr: {=u8:?} }}", self.spisr())
            }
        }
        #[doc = "Sub-Week Alarm Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SwkAlarm(pub u32);
        impl SwkAlarm {
            #[doc = "Writes with a non-zero value to this field reload the 9-bit Sub-Week Alarm counter. Writes of 0 disable the counter. If the Sub-Week Alarm counter decrements to 0 and the AUTO_RELOAD bit is set, the value in this field is automatically loaded into the Sub-Week Alarm counter."]
            #[inline(always)]
            pub const fn cntr_load(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Writes with a non-zero value to this field reload the 9-bit Sub-Week Alarm counter. Writes of 0 disable the counter. If the Sub-Week Alarm counter decrements to 0 and the AUTO_RELOAD bit is set, the value in this field is automatically loaded into the Sub-Week Alarm counter."]
            #[inline(always)]
            pub fn set_cntr_load(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Reads of this register return the current state of the 9-bit Sub-Week Alarm counter."]
            #[inline(always)]
            pub const fn cntr_sts(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x01ff;
                val as u16
            }
            #[doc = "Reads of this register return the current state of the 9-bit Sub-Week Alarm counter."]
            #[inline(always)]
            pub fn set_cntr_sts(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 16usize)) | (((val as u32) & 0x01ff) << 16usize);
            }
        }
        impl Default for SwkAlarm {
            #[inline(always)]
            fn default() -> SwkAlarm {
                SwkAlarm(0)
            }
        }
        impl core::fmt::Debug for SwkAlarm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SwkAlarm")
                    .field("cntr_load", &self.cntr_load())
                    .field("cntr_sts", &self.cntr_sts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SwkAlarm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SwkAlarm {{ cntr_load: {=u16:?}, cntr_sts: {=u16:?} }}",
                    self.cntr_load(),
                    self.cntr_sts()
                )
            }
        }
        #[doc = "Sub-Week Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SwkCtrl(pub u32);
        impl SwkCtrl {
            #[doc = "This bit is set to 1 when the Sub-Week Alarm Counter Register decrements from 1 to 0 and the POWERUP_EN is 1. Writes of 1 clear this bit. Writes of 0 have no effect. Note: This bit MUST be cleared to remove a Sub-Week Timer Power-Up Event."]
            #[inline(always)]
            pub const fn swktmr_pwrup_evt_sts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 when the Sub-Week Alarm Counter Register decrements from 1 to 0 and the POWERUP_EN is 1. Writes of 1 clear this bit. Writes of 0 have no effect. Note: This bit MUST be cleared to remove a Sub-Week Timer Power-Up Event."]
            #[inline(always)]
            pub fn set_swktmr_pwrup_evt_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is set to 1 when the Week Alarm Counter Register is greater than or equal the contents of the Week Timer Compare Register and the POWERUP_EN is 1. Writes of 1 clear this bit. Writes of 0 have no effect. Note: This bit does not have to be cleared to remove a Week Timer Power-Up Event."]
            #[inline(always)]
            pub const fn wktmr_pwrup_evt_sts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is set to 1 when the Week Alarm Counter Register is greater than or equal the contents of the Week Timer Compare Register and the POWERUP_EN is 1. Writes of 1 clear this bit. Writes of 0 have no effect. Note: This bit does not have to be cleared to remove a Week Timer Power-Up Event."]
            #[inline(always)]
            pub fn set_wktmr_pwrup_evt_sts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Test"]
            #[inline(always)]
            pub const fn test(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Test"]
            #[inline(always)]
            pub fn set_test(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Test"]
            #[inline(always)]
            pub const fn test0(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Test"]
            #[inline(always)]
            pub fn set_test0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "1= No reload occurs when the Sub-Week Counter expires 0= Reloads the SUBWEEK_COUNTER_LOAD field into the Sub- Week Counter when the counter expires."]
            #[inline(always)]
            pub const fn au_rld(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "1= No reload occurs when the Sub-Week Counter expires 0= Reloads the SUBWEEK_COUNTER_LOAD field into the Sub- Week Counter when the counter expires."]
            #[inline(always)]
            pub fn set_au_rld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "This field selects the clock source for the Sub-Week Counter."]
            #[inline(always)]
            pub const fn swk_tick(&self) -> u8 {
                let val = (self.0 >> 7usize) & 0x07;
                val as u8
            }
            #[doc = "This field selects the clock source for the Sub-Week Counter."]
            #[inline(always)]
            pub fn set_swk_tick(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 7usize)) | (((val as u32) & 0x07) << 7usize);
            }
        }
        impl Default for SwkCtrl {
            #[inline(always)]
            fn default() -> SwkCtrl {
                SwkCtrl(0)
            }
        }
        impl core::fmt::Debug for SwkCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SwkCtrl")
                    .field("swktmr_pwrup_evt_sts", &self.swktmr_pwrup_evt_sts())
                    .field("wktmr_pwrup_evt_sts", &self.wktmr_pwrup_evt_sts())
                    .field("test", &self.test())
                    .field("test0", &self.test0())
                    .field("au_rld", &self.au_rld())
                    .field("swk_tick", &self.swk_tick())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SwkCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SwkCtrl {{ swktmr_pwrup_evt_sts: {=bool:?}, wktmr_pwrup_evt_sts: {=bool:?}, test: {=bool:?}, test0: {=bool:?}, au_rld: {=bool:?}, swk_tick: {=u8:?} }}" , self . swktmr_pwrup_evt_sts () , self . wktmr_pwrup_evt_sts () , self . test () , self . test0 () , self . au_rld () , self . swk_tick ())
            }
        }
        #[doc = "Week Timer Compare Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TmrComp(pub u32);
        impl TmrComp {
            #[doc = "A Week Alarm Interrupt and a Week Alarm Power-Up Event are asserted when the Week Alarm Counter Register is greater than or equal to the contents of this register. Reads and writes complete independently of the state of WT_ENABLE."]
            #[inline(always)]
            pub const fn wk_comp(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0fff_ffff;
                val as u32
            }
            #[doc = "A Week Alarm Interrupt and a Week Alarm Power-Up Event are asserted when the Week Alarm Counter Register is greater than or equal to the contents of this register. Reads and writes complete independently of the state of WT_ENABLE."]
            #[inline(always)]
            pub fn set_wk_comp(&mut self, val: u32) {
                self.0 = (self.0 & !(0x0fff_ffff << 0usize)) | (((val as u32) & 0x0fff_ffff) << 0usize);
            }
        }
        impl Default for TmrComp {
            #[inline(always)]
            fn default() -> TmrComp {
                TmrComp(0)
            }
        }
        impl core::fmt::Debug for TmrComp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TmrComp").field("wk_comp", &self.wk_comp()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TmrComp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TmrComp {{ wk_comp: {=u32:?} }}", self.wk_comp())
            }
        }
    }
}
