<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright (c) 2023 Microchip Technology Inc.

 SPDX-License-Identifier: Apache-2.0

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
         schemaVersion="1.3"
         xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
   <vendor>Microchip Technology</vendor>
   <vendorID>MCHP</vendorID>
   <name>MEC1727N_B0_SZ</name>
   <series>MEC172x</series>
   <version>0</version>
   <description>Microchip MEC1727N_B0_SZ Microcontroller</description>
   <cpu>
      <name>CM4</name>
      <revision>r1p0</revision>
      <endian>little</endian>
      <mpuPresent>true</mpuPresent>
      <fpuPresent>true</fpuPresent>
      <fpuDP>false</fpuDP>
      <nvicPrioBits>3</nvicPrioBits>
      <vendorSystickConfig>false</vendorSystickConfig>
      <deviceNumInterrupts>172</deviceNumInterrupts>
   </cpu>
   <addressUnitBits>8</addressUnitBits>
   <width>32</width>
   <size>32</size>
   <access>read-write</access>
   <resetValue>0x00000000</resetValue>
   <resetMask>0xFFFFFFFF</resetMask>
   <peripherals>
      <peripheral>
         <name>PCR</name>
         <version>1001.0</version>
         <description>The Power, Clocks, and Resets (PCR) Section identifies clock sources, and reset inputs to the chip.</description>
         <baseAddress>0x40080100</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xEC</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>SYS_SLP_CTRL</name>
               <description>System Sleep Control</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SL_MOD</name>
                     <description>Selects the System Sleep mode</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REG_STNDBY_EN</name>
                     <description>Regulator Standby Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLP_ALL</name>
                     <description>Initiates the System Sleep mode</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PROC_CLK_CTRL</name>
               <description>Processor Clock Control Register [7:0] Processor Clock Divide Value (PROC_DIV)</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000004</resetValue>
               <fields>
                  <field>
                     <name>DIV</name>
                     <description>Selects the EC clock rate</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                     <enumeratedValues>
                        <name>DIVSelect</name>
                        <enumeratedValue>
                           <name>DIVIDE_BY_1</name>
                           <description>1: divide 48 MHz Ring Oscillator by 1</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIVIDE_BY_3</name>
                           <description>3: divide 48 MHz Ring Oscillator by 3</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIVIDE_BY_4</name>
                           <description>4: divide 48 MHz Ring Oscillator by 4</description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIVIDE_BY_16</name>
                           <description>16: divide 48 MHz Ring Oscillator by 16</description>
                           <value>0x10</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIVIDE_BY_48</name>
                           <description>48: divide 48 MHz Ring Oscillator by 48</description>
                           <value>0x30</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLOW_CLK_CTRL</name>
               <description>Configures the EC_CLK clock domain</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x000001E0</resetValue>
               <fields>
                  <field>
                     <name>DIV</name>
                     <description>SLOW_CLOCK_DIVIDE. n=Divide by n; 0=Clock off</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>10</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OSC_ID</name>
               <description>Oscillator ID Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TEST</name>
                     <description>Test bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>PLL_LOCK</name>
                     <description>PLL Lock Status</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PWR_RST_STS</name>
               <description>PCR Power Reset Status Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000050</resetValue>
               <fields>
                  <field>
                     <name>VCC_PWRGD_STS</name>
                     <description>Indicates the status of VCC_PWRGD. 0 = PWRGD not asserted. 1 = PWRGD asserte.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST_H_STS</name>
                     <description>Indicates the status of RESET_VCC. 0 = reset active. 1 = reset not active.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST_VTR_STS</name>
                     <description>Indicates the status of RESET_VTR. 0 = reset active. 1 = reset not active.(R/W1C)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VBAT_RST_STS</name>
                     <description>VBAT reset status 0 = No reset occurred while VTR was off or since the last time this bit was cleared. 1 = A reset occurred.(R/WC)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST_SYS_STS</name>
                     <description>Indicates the status of RESET_SYS.(R/W1C)                0 = No reset occurred since the last time this bit was cleared.                1 = A reset occurred.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>JTAG_RST_STS</name>
                     <description>Indicates status of JTAG_TRST# pin.                0 = No JTAG reset occurred since the last time this bit was cleared.                1 = A reset occurred because of a JTAG command.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_EVENT</name>
                     <description>Indicates that a WDT_EVENT happened. (R/W1C)                0 = Not active.                1 = A WDT_EVENT occured.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACTIVE_32K</name>
                     <description>32K ACTIVE (ACTIVE_32K)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PCICLK_ACTIVE</name>
                     <description>PCICLK_ACTIVE (PCICLK_ACTIVE)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESPI_CLK_ACTIVE</name>
                     <description>ESPI_CLK_ACTIVE</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PWR_RST_CTRL</name>
               <description>Power Reset Control Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000101</resetValue>
               <fields>
                  <field>
                     <name>PWR_INV</name>
                     <description>Used by FW to control internal RESET_VCC signal function and external PWROK pin. This bit is read-only when VCC_PWRGD      is de-asserted low.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>H_RST_SEL</name>
                     <description>Determines what generates the internal platform reset signal. 1=LRESET# pin; 0=eSPI PLTRST# VWire</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SYS_RST</name>
               <description>System Reset Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SOFT_SYS_RST</name>
                     <description>A write of a 1 forces an assertion of the RESET_SYS reset signal, resetting the device. A write of 0 has no effect.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLP_EN_0</name>
               <description>Sleep Enable 0 Register</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OTP_SLP_EN</name>
                     <description>OTP Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IMSPI_SLP_EN</name>
                     <description>IMSPI Sleep Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLP_EN_1</name>
               <description>Sleep Enable 1 Register</description>
               <addressOffset>0x34</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>INT_SLP_EN</name>
                     <description>Interrupt Sleep Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PECI_SLP_EN</name>
                     <description>PECI Sleep Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH0_SLP_EN</name>
                     <description>TACH0 Sleep Enable (TACH0_SLP_EN)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM0_SLP_EN</name>
                     <description>PWM0 Sleep Enable (PWM0_SLP_EN)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PMC_SLP_EN</name>
                     <description>PMC Sleep Enable (PMC_SLP_EN)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DMA_SLP_EN</name>
                     <description>DMA Sleep Enable (DMA_SLP_EN)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TFDP_SLP_EN</name>
                     <description>TFDP Sleep Enable (TFDP_SLP_EN)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PROC_SLP_EN</name>
                     <description>PROCESSOR Sleep Enable (PROCESSOR_SLP_EN)</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB0_SLP_EN</name>
                     <description>SMB0 Sleep Enable (SMB0_SLP_EN)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH1_SLP_EN</name>
                     <description>TACH1 Sleep Enable (TACH1_SLP_EN)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH2_SLP_EN</name>
                     <description>TACH2 Sleep Enable (TACH2_SLP_EN)</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH3_SLP_EN</name>
                     <description>TACH3 Sleep Enable (TACH3_SLP_EN)</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM1_SLP_EN</name>
                     <description>PWM1 Sleep Enable (PWM1_SLP_EN)</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM2_SLP_EN</name>
                     <description>PWM2 Sleep Enable (PWM2_SLP_EN)</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM3_SLP_EN</name>
                     <description>PWM3 Sleep Enable (PWM3_SLP_EN)</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM4_SLP_EN</name>
                     <description>PWM4 Sleep Enable (PWM4_SLP_EN)</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM5_SLP_EN</name>
                     <description>PWM5 Sleep Enable (PWM5_SLP_EN)</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM6_SLP_EN</name>
                     <description>PWM6 Sleep Enable (PWM6_SLP_EN)</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM7_SLP_EN</name>
                     <description>PWM7 Sleep Enable (PWM7_SLP_EN)</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM8_SLP_EN</name>
                     <description>PWM8 Sleep Enable (PWM8_SLP_EN)</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_REG_BANK_SLP_EN</name>
                     <description>EC_REG_BANK Sleep Enable (EC_REG_BANK_SLP_EN)</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_0_SLP_EN</name>
                     <description>TIMER16_0 Sleep Enable (TIMER16_0_SLP_EN)</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_1_SLP_EN</name>
                     <description>TIMER16_1 Sleep Enable (TIMER16_1_SLP_EN)</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLP_EN_2</name>
               <description>Sleep Enable 2 Register</description>
               <addressOffset>0x38</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>UART0_SLP_EN</name>
                     <description>UART 0 Sleep Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART1_SLP_EN</name>
                     <description>UART 1 Sleep Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESPI_SLP_EN</name>
                     <description>eSPI Sleep Enable</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_BRDG_SLP_EN</name>
                     <description>SAF BRIDGE Sleep Enable</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GLUE_SLP_EN</name>
                     <description>GLUE Sleep Enable</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLP_EN_3</name>
               <description>Sleep Enable 3 Register</description>
               <addressOffset>0x3C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADC_SLP_EN</name>
                     <description>ADC Sleep Enable (ADC_SLP_EN)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_0_SLP_EN</name>
                     <description>PS2_0 Sleep Enable (PS2_0_SLP_EN)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPSPI_0_SLP_EN</name>
                     <description>GPSPI 0 Sleep Enable (GPSPI_0_SLP_EN)</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTM_0_SLP_EN</name>
                     <description>Hibernation Timer 0 Sleep Enable (HTM_0_SLP_EN)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB1_SLP_EN</name>
                     <description>SMB1 Sleep Enable (SMB1_SLP_EN)</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB2_SLP_EN</name>
                     <description>SMB2 Sleep Enable (SMB2_SLP_EN)</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB3_SLP_EN</name>
                     <description>SMB3 Sleep Enable (SMB3_SLP_EN)</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED0_SLP_EN</name>
                     <description>LED0 Sleep Enable (LED0_SLP_EN)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED1_SLP_EN</name>
                     <description>LED1 Sleep Enable (LED1_SLP_EN)</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED2_SLP_EN</name>
                     <description>LED2 Sleep Enable (LED2_SLP_EN)</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BC_LINK0_SLP_EN</name>
                     <description>BC_LINK0 Sleep Enable (BC_LINK0_SLP_EN)</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB4_SLP_EN</name>
                     <description>SMB4 Sleep Enable (SMB4_SLP_EN)</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_2_SLP_EN</name>
                     <description>TIMER16_2 Sleep Enable (TIMER16_2_SLP_EN)</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_3_SLP_EN</name>
                     <description>TIMER16_3 Sleep Enable (TIMER16_3_SLP_EN)</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_0_SLP_EN</name>
                     <description>TIMER32_0 Sleep Enable (TIMER32_0_SLP_EN)</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_1_SLP_EN</name>
                     <description>TIMER32_1 Sleep Enable (TIMER32_1_SLP_EN)</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED3_SLP_EN</name>
                     <description>LED3 Sleep Enable (LED3_SLP_EN)</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PKE_SLP_EN</name>
                     <description>PKE Sleep Enable</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RNG_SLP_EN</name>
                     <description>RNG Sleep Enable</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AES_HASH_SLP_EN</name>
                     <description>AES_HASH Sleep Enable</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTM_1_SLP_EN</name>
                     <description>Hibernation TIMER 1 Sleep Enable (HTM_1_SLP_EN)</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CCT_SLP_EN</name>
                     <description>Capture Compare Timer Sleep Enable (CCTIMER_SLP_EN)</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM9_SLP_EN</name>
                     <description>PWM9 Sleep Enable (PWM9_SLP_EN)</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLP_EN_4</name>
               <description>Sleep Enable 4 Register</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWM10_SLP_EN</name>
                     <description>PWM10 Sleep Enable (PWM10_SLP_EN)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM11_SLP_EN</name>
                     <description>PWM11 Sleep Enable (PWM11_SLP_EN)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>QMSPI_SLP_EN</name>
                     <description>Quad Master SPI Sleep Enable</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID0_SLP_EN</name>
                     <description>RC_ID0 Sleep Enable (RC_ID0_SLP_EN)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID1_SLP_EN</name>
                     <description>RC_ID1 Sleep Enable (RC_ID1_SLP_EN)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID2_SLP_EN</name>
                     <description>RC_ID2 Sleep Enable (RC_ID2_SLP_EN)</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPSPI_1_SLP_EN</name>
                     <description>GPSPI 1 Sleep Enable (GPSPI_1_SLP_EN)</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_REQ_0</name>
               <description>Clock Required 0 Register</description>
               <addressOffset>0x50</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTAG_STAP_CLK_REQ</name>
                     <description>JTAG STAP Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OTP_CLK_REQ</name>
                     <description>OTP Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IMSPI_CLK_REQ</name>
                     <description>IMSPI Sleep clock Required</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_REQ_1</name>
               <description>Clock Required 1 Register</description>
               <addressOffset>0x54</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>INT_CLK_REQ</name>
                     <description>Interrupt Clock Required</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PECI_CLK_REQ</name>
                     <description>PECI Clock Required</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH0_CLK_REQ</name>
                     <description>TACH0 Clock Required (TACH0_CLK_REQ)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM0_CLK_REQ</name>
                     <description>PWM0 Clock Required (PWM0_CLK_REQ)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PMC_CLK_REQ</name>
                     <description>PMC Clock Required (PMC_CLK_REQ)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DMA_CLK_REQ</name>
                     <description>DMA Clock Required (DMA_CLK_REQ)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TFDP_CLK_REQ</name>
                     <description>TFDP Clock Required (TFDP_CLK_REQ)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PROC_CLK_REQ</name>
                     <description>PROCESSOR Clock Required (PROCESSOR_CLK_REQ)</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_CLK_REQ</name>
                     <description>WDT Clock Required (WDT_CLK_REQ)</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB0_CLK_REQ</name>
                     <description>SMB0 Clock Required (SMB0_CLK_REQ)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH1_CLK_REQ</name>
                     <description>TACH1 Clock Required (TACH1_CLK_REQ)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH2_CLK_REQ</name>
                     <description>TACH2 Clock Required (TACH2_CLK_REQ)</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH3_CLK_REQ</name>
                     <description>TACH3 Clock Required (TACH3_CLK_REQ)</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM1_CLK_REQ</name>
                     <description>PWM1 Clock Required (PWM1_CLK_REQ)</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM2_CLK_REQ</name>
                     <description>PWM2 Clock Required (PWM2_CLK_REQ)</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM3_CLK_REQ</name>
                     <description>PWM3 Clock Required (PWM3_CLK_REQ)</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM4_CLK_REQ</name>
                     <description>PWM4 Clock Required (PWM4_CLK_REQ)</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM5_CLK_REQ</name>
                     <description>PWM5 Clock Required (PWM5_CLK_REQ)</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM6_CLK_REQ</name>
                     <description>PWM6 Clock Required (PWM6_CLK_REQ)</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM7_CLK_REQ</name>
                     <description>PWM7 Clock Required (PWM7_CLK_REQ)</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM8_CLK_REQ</name>
                     <description>PWM8 Clock Required (PWM8_CLK_REQ)</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_REG_BANK_CLK_REQ</name>
                     <description>EC_REG_BANK Clock Required (EC_REG_BANK_CLK_REQ)</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_0_CLK_REQ</name>
                     <description>TIMER16_0 Clock Required (TIMER16_0_CLK_REQ)</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_1_CLK_REQ</name>
                     <description>TIMER16_1 Clock Required (TIMER16_1_CLK_REQ)</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_REQ_2</name>
               <description>Clock Required 2 Register</description>
               <addressOffset>0x58</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IMAP_CLK_REQ</name>
                     <description>IMAP Clock Required (IMAP_CLK_REQ)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART0_CLK_REQ</name>
                     <description>UART 0 Clock Required</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART1_CLK_REQ</name>
                     <description>UART 1 Clock Required</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GLBL_CFG_CLK_REQ</name>
                     <description>GLBL_CFG (GLBL_CFG_CLK_REQ)</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KBCEM_CLK_REQ</name>
                     <description>8042EM Clock Required (8042EM_CLK_REQ)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_CLK_REQ</name>
                     <description>RTC Clock Required (RTC_CLK_REQ)</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESPI_CLK_REQ</name>
                     <description>eSPI Clock Required</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ASIF_CLK_REQ</name>
                     <description>ASIF Clock Required</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_BRDG_CLK_REQ</name>
                     <description>SAF BRIDGE Clock Required</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_REQ_3</name>
               <description>Clock Required 3 Register</description>
               <addressOffset>0x5C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADC_CLK_REQ</name>
                     <description>ADC Clock Required (ADC_CLK_REQ)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_0_CLK_REQ</name>
                     <description>PS2_0 Clock Required (PS2_0_CLK_REQ)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPSPI_0_CLK_REQ</name>
                     <description>GPSPI 0 Clock Required (GPSPI_0_CLK_REQ)</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTM0_CLK_REQ</name>
                     <description>Hibernation TIMER 0 Clock Required (HTM_0_CLK_REQ)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KMS_CLK_REQ</name>
                     <description>KEYSCAN Clock Required (KMS_CLK_REQ)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB1_CLK_REQ</name>
                     <description>SMB1 Clock Required (SMB1_CLK_REQ)</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB2_CLK_REQ</name>
                     <description>SMB2 Clock Required (SMB2_CLK_REQ)</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB3_CLK_REQ</name>
                     <description>SMB3 Clock Required (SMB3_CLK_REQ)</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED0_CLK_REQ</name>
                     <description>LED0 Clock Required (LED0_CLK_REQ)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED1_CLK_REQ</name>
                     <description>LED1 Clock Required (LED1_CLK_REQ)</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED2_CLK_REQ</name>
                     <description>LED2 Clock Required (LED2_CLK_REQ)</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BC_LINK0_CLK_REQ</name>
                     <description>BC_LINK0 Clock Required (BC_LINK0_CLK_REQ)</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB_4_CLK_REQ</name>
                     <description>SMB 4 Clock Required (SMB_4_CLK_REQ)</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_2_CLK_REQ</name>
                     <description>TIMER16_2 Clock Required (TIMER16_2_CLK_REQ)</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_3_CLK_REQ</name>
                     <description>TIMER16_3 Clock Required (TIMER16_3_CLK_REQ)</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_0_CLK_REQ</name>
                     <description>TIMER32_0 Clock Required (TIMER32_0_CLK_REQ)</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_1_CLK_REQ</name>
                     <description>TIMER32_1 Clock Required (TIMER32_1_CLK_REQ)</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED3_CLK_REQ</name>
                     <description>LED3 Clock Required (LED3_CLK_REQ)</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PKE_CLK_REQ</name>
                     <description>PKE Clock Required</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RNG_CLK_REQ</name>
                     <description>RNG Clock Required</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AES_HASH_CLK_REQ</name>
                     <description>AES_HASH Clock Required</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTM_1_CLK_REQ</name>
                     <description>Hibernation TIMER 1 Clock Required (HTM_1_CLK_REQ)</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CCTIMER_CLK_REQ</name>
                     <description>Capture Compare Timer Clock Required (CCTIMER_CLK_REQ)</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM9_CLK_REQ</name>
                     <description>PWM9 Clock Required (PWM9_CLK_REQ)</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_REQ_4</name>
               <description>Clock Required 4 Register</description>
               <addressOffset>0x60</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWM10_CLK_REQ</name>
                     <description>PWM10 Clock Required (PWM10_CLK_REQ)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM11_CLK_REQ</name>
                     <description>PWM11 Clock Required (PWM11_CLK_REQ)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTOS_CLK_REQ</name>
                     <description>RTOS Clock Required (RTOS_CLK_REQ)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>QMSPI_CLK_REQ</name>
                     <description>Quad Master SPI Clock Required</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID0_CLK_REQ</name>
                     <description>RC_ID0 Clock Required (RC_ID0_CLK_REQ)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID1_CLK_REQ</name>
                     <description>RC_ID1 Clock Required (RC_ID1_CLK_REQ)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID2_CLK_REQ</name>
                     <description>RC_ID2 Clock Required (RC_ID2_CLK_REQ)</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPI_SLAVE_CLK_REQ</name>
                     <description>SPI SLAVE Clock Required (SPI_SLAVE_CLK_REQ)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPSPI_1_CLK_REQ</name>
                     <description>GPSPI 1 Clock Required (GPSPI_1_CLK_REQ)</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RST_EN_0</name>
               <description>Reset Enable 0 Register</description>
               <addressOffset>0x70</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OTP_RST_EN</name>
                     <description>OTP Reset Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RST_EN_1</name>
               <description>Reset Enable 1 Register</description>
               <addressOffset>0x74</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>INT_RST_EN</name>
                     <description>Interrupt Reset Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PECI_RST_EN</name>
                     <description>PECI Reset Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH0_RST_EN</name>
                     <description>TACH0 Reset Enable (TACH0_RST_EN)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM0_RST_EN</name>
                     <description>PWM0 Reset Enable (PWM0_RST_EN)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DMA_RST_EN</name>
                     <description>DMA Reset Enable (DMA_RST_EN)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TFDP_RST_EN</name>
                     <description>TFDP Reset Enable (TFDP_RST_EN)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_RST_EN</name>
                     <description>WDT Reset Enable (WDT_RST_EN)</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB0_RST_EN</name>
                     <description>SMB0 Reset Enable (SMB0_RST_EN)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH1_RST_EN</name>
                     <description>TACH1 Reset Enable (TACH1_RST_EN)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH2_RST_EN</name>
                     <description>TACH2 Reset Enable (TACH2_RST_EN)</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH3_RST_EN</name>
                     <description>TACH3 Reset Enable (TACH3_RST_EN)</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM1_RST_EN</name>
                     <description>PWM1 Reset Enable (PWM1_RST_EN)</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM2_RST_EN</name>
                     <description>PWM2 Reset Enable (PWM2_RST_EN)</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM3_RST_EN</name>
                     <description>PWM3 Reset Enable (PWM3_RST_EN)</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM4_RST_EN</name>
                     <description>PWM4 Reset Enable (PWM4_RST_EN)</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM5_RST_EN</name>
                     <description>PWM5 Reset Enable (PWM5_RST_EN)</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM6_RST_EN</name>
                     <description>PWM6 Reset Enable (PWM6_RST_EN)</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM7_RST_EN</name>
                     <description>PWM7 Reset Enable (PWM7_RST_EN)</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM8_RST_EN</name>
                     <description>PWM8 Reset Enable (PWM8_RST_EN)</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_0_RST_EN</name>
                     <description>TIMER16_0 Reset Enable (TIMER16_0_RST_EN)</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_1_RST_EN</name>
                     <description>TIMER16_1 Reset Enable (TIMER16_1_RST_EN)</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RST_EN_2</name>
               <description>Reset Enable 2 Register</description>
               <addressOffset>0x78</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IMAP_RST_EN</name>
                     <description>IMAP Reset Enable (IMAP_RST_EN)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART0_RST_EN</name>
                     <description>UART 0 Reset Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART1_RST_EN</name>
                     <description>UART 1 Reset Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC0_RST_EN</name>
                     <description>ACPI EC 0 Reset Enable (ACPI_EC_0_RST_EN)</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC1_RST_EN</name>
                     <description>ACPI EC 1 Reset Enable (ACPI_EC_1_RST_EN)</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_PM1_RST_EN</name>
                     <description>ACPI PM1 Reset Enable (ACPI_PM1_RST_EN)</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KBCEM_RST_EN</name>
                     <description>8042EM Reset Enable (8042EM_RST_EN)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MBX_RST_EN</name>
                     <description>Mailbox Reset Enable (MBX_RST_EN)</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_RST_EN</name>
                     <description>RTC Reset Enable (RTC_RST_EN)</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCRATCH_32_RST_EN</name>
                     <description>SCRATCH 32 Reset Enable</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_2_RST_EN</name>
                     <description>ACPI EC 2 Reset Enable (ACPI_EC_2_RST_EN)</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_3_RST_EN</name>
                     <description>ACPI EC 3 Reset Enable (ACPI_EC_3_RST_EN)</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ASIF_RST_EN</name>
                     <description>ASIF Reset Enable</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PORT_80_0_RST_EN</name>
                     <description>Port 80 0 Reset Enable</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RST_EN_3</name>
               <description>Reset Enable 3 Register</description>
               <addressOffset>0x7C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADC_RST_EN</name>
                     <description>ADC Reset Enable (ADC_RST_EN)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_0_RST_EN</name>
                     <description>PS2_0 Reset Enable (PS2_0_RST_EN)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPSPI_0_RST_EN</name>
                     <description>GPSPI 0 Reset Enable (GPSPI_0_RST_EN)</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTM_0_RST_EN</name>
                     <description>Hibernation TIMER 0 Reset Enable (HTM_0_RST_EN)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KMS_RST_EN</name>
                     <description>KEYSCAN Reset Enable (KMS_RST_EN)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB1_RST_EN</name>
                     <description>SMB1 Reset Enable (SMB1_RST_EN)</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB2_RST_EN</name>
                     <description>SMB2 Reset Enable (SMB2_RST_EN)</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB3_RST_EN</name>
                     <description>SMB3 Reset Enable (SMB3_RST_EN)</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED0_RST_EN</name>
                     <description>LED0 Reset Enable (LED0_RST_EN)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED1_RST_EN</name>
                     <description>LED1 Reset Enable (LED1_RST_EN)</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED2_RST_EN</name>
                     <description>LED2 Reset Enable (LED2_RST_EN)</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BC_LINK0_RST_EN</name>
                     <description>BC_LINK0 Reset Enable (BC_LINK0_RST_EN)</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB_4_RST_EN</name>
                     <description>SMB 4 Reset Enable (SMB_4_RST_EN)</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_2_RST_EN</name>
                     <description>TIMER16_2 Reset Enable (TIMER16_2_RST_EN)</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_3_RST_EN</name>
                     <description>TIMER16_3 Reset Enable (TIMER16_3_RST_EN)</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_0_RST_EN</name>
                     <description>TIMER32_0 Reset Enable (TIMER32_0_RST_EN)</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_1_RST_EN</name>
                     <description>TIMER32_1 Reset Enable (TIMER32_1_RST_EN)</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED3_RST_EN</name>
                     <description>LED3 Reset Enable (LED3_RST_EN)</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PKE_RST_EN</name>
                     <description>PKE Reset Enable</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RNG_RST_EN</name>
                     <description>RNG Reset Enable</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AES_HASH_RST_EN</name>
                     <description>AES_HASH Reset Enable</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTM_1_RST_EN</name>
                     <description>Hibernation TIMER 1 Reset Enable (HTM_1_RST_EN)</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CCTIMER_RST_EN</name>
                     <description>Capture Compare Timer Reset Enable (CCTIMER_RST_EN)</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM9_RST_EN</name>
                     <description>PWM9 Reset Enable (PWM9_RST_EN)</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RST_EN_4</name>
               <description>Reset Enable 4 Register</description>
               <addressOffset>0x80</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWM10_RST_EN</name>
                     <description>PWM10 Reset Enable (PWM10_RST_EN)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM11_RST_EN</name>
                     <description>PWM11 Reset Enable (PWM11_RST_EN)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTOS_RST_EN</name>
                     <description>RTOS Reset Enable (RTOS_RST_EN)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>QMSPI_RST_EN</name>
                     <description>Quad Master SPI Reset Enable</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID0_RST_EN</name>
                     <description>RC_ID0 Reset Enable (RC_ID0_RST_EN)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID1_RST_EN</name>
                     <description>RC_ID1 Reset Enable (RC_ID1_RST_EN)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID2_RST_EN</name>
                     <description>RC_ID2 Reset Enable (RC_ID2_RST_EN)</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPI_SLAVE_RST_EN</name>
                     <description>SPI SLAVE Reset Enable (SPI_SLAVE_RST_EN)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPSPI_1_RST_EN</name>
                     <description>GPSPI 1 Reset Enable (GPSPI_1_RST_EN)</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LOCK_REG</name>
               <description>LOCK Register</description>
               <addressOffset>0x84</addressOffset>
               <size>32</size>
               <resetValue>0xA6382D4D</resetValue>
               <fields>
                  <field>
                     <name>PCR_RST_EN_LOCK</name>
                     <description>PCR Reset Enable Lock Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SFT_VBAT_POR</name>
               <description>SOFT VBAT Register</description>
               <addressOffset>0x88</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SFT_VBAT_POR</name>
                     <description>SOFT VBAT POWER ON RESET.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PLL_REF</name>
               <description>PLL reference clock select.</description>
               <addressOffset>0x8C</addressOffset>
               <size>32</size>
               <resetValue>0x00000003</resetValue>
               <fields>
                  <field>
                     <name>PLL_REF</name>
                     <description>Source 32kHz MUX Select for the PLL reference clock source.     0 = Internal Silicon Oscillator    1 = XTAL    2 = VTR PIN 32KHZ_IN    3 = NONE-OFF</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>REG_CTRL_RUN</name>
               <description>Regulator Control Running Register</description>
               <addressOffset>0x94</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CTRL_RUN</name>
                     <description>Regulator Control Running Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>REG_CTRL_SLP</name>
               <description>Regulator Control Sleeping Register</description>
               <addressOffset>0x98</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CTRL_SLP</name>
                     <description>Regulator Control Running Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>REG_TIM</name>
               <description>Regulator Time Register</description>
               <addressOffset>0x9C</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWRUP_DLY</name>
                     <description>Regulator Power Up delay Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>14</bitWidth>
                  </field>
                  <field>
                     <name>PWRDN_DLY</name>
                     <description>Regulator Power Down delay Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>14</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BNDGP_CTRL_RUN</name>
               <description>Bandgap Control Running Register</description>
               <addressOffset>0xA4</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CTRL_RUN</name>
                     <description>Regulator Control Running Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BNDGP_CTRL_SLP</name>
               <description>Bandgap Control Sleeping Register</description>
               <addressOffset>0xA8</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CTRL_SLP</name>
                     <description>Regulator Control Running Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_PRD</name>
               <description>32KHz Period Counter Register</description>
               <addressOffset>0xC0</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CLK_PRD</name>
                     <description>Counter 32khz period Counts system clock cycles between 2 positive edges of an 32kHz clock.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_HGHPLS</name>
               <description>32KHz Clock High Pulse Register</description>
               <addressOffset>0xC4</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CLK_HGHPLS</name>
                     <description>Counter 32khz High Counts how many system clock cycles the 32kHz clock remains HIGH for.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_MINPRD</name>
               <description>32KHz Clock Min Period Register</description>
               <addressOffset>0xC8</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CLK_MINPRD</name>
                     <description>This is the minimum period count that is acceptable for the 32kHz counter to flag a PASS status.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_MAXPRD</name>
               <description>32KHz Clock Max Period Register</description>
               <addressOffset>0xCC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CLK_MAXPRD</name>
                     <description>This is the maximum period count that is acceptable for the 32kHz counter to flag a PASS status.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_DTYVRTN</name>
               <description>32KHz Clock Duty Variation Register</description>
               <addressOffset>0xD0</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CLK_DTYVRTN</name>
                     <description>This is the difference in system clocks between the 32kHz clocks High Pulse Width and its Low Pulse Width.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_MAXDTYVRTN</name>
               <description>32KHz Maximum Clock Duty Variation Register</description>
               <addressOffset>0xD4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CLK_MAXDTYVRTN</name>
                     <description>This is the difference maximum variation allowed to generate a PASS condition for the 32kHz clock</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_VLDCNT</name>
               <description>32KHz Clock Valid Count Register</description>
               <addressOffset>0xD8</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CLK_VLDCNT</name>
                     <description>This counts the number of valid 32kHz periods and pulse width variations measured in a row. This count increments on a PASS and will reset on a FAIL.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_VLDMIN</name>
               <description>32KHz Clock Valid Minimum Count Register</description>
               <addressOffset>0xDC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CLK_VLDMIN</name>
                     <description>This is the minimum value of Counter 32kHz Valid Count that will flag the status Counter Valid.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_32KHZ_CTRL</name>
               <description>32KHz Clock Control Register</description>
               <addressOffset>0xE0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PRD_EN</name>
                     <description>Enables the Period Counter.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DTY_EN</name>
                     <description>Enables the Duty cycle Counter.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VLD_EN</name>
                     <description>Enables the Counter for Valid count.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC_SEL</name>
                     <description>Counter 32kHz Source Selects the source 32kHz clock that is measured.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLR_CNT</name>
                     <description>Counter 32kHz Clear Clears the counters.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_STS</name>
               <description>32KHz Clock Monitor Status Register</description>
               <addressOffset>0xE4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PULSE_RDY</name>
                     <description>Counter 32kHz Pulse Ready Status.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PASS_PRD</name>
                     <description>Counter 32kHz Pass Period Status.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PASS_DTY</name>
                     <description>Counter 32kHz Pass Duty Status.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAIL</name>
                     <description>Counter 32kHz Fail Status.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STALL</name>
                     <description>Counter 32kHz Stall Status.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VLD</name>
                     <description>Counter 32kHz Valid Status.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>NVL</name>
                     <description>Counter 32kHz Unwell Status.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_INT_EN</name>
               <description>32KHz Clock Monitor Interrupt Enable Register</description>
               <addressOffset>0xE8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PULSE_RDY_IE</name>
                     <description>Counter 32kHz Pulse Ready Interrupt Enable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PASS_PRD_IE</name>
                     <description>Counter 32kHz Pass Period Interrupt Enable.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PASS_DTY_IE</name>
                     <description>Counter 32kHz Pass Duty Interrupt Enable.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAIL_IE</name>
                     <description>Counter 32kHz Fail Interrupt Enable.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STALL_IE</name>
                     <description>Counter 32kHz Stall Interrupt Enable.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VLD_IE</name>
                     <description>Counter 32kHz Valid Interrupt Enable.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>NVL_IE</name>
                     <description>Counter 32kHz Unwell Interrupt Enable.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>DMA_MAIN</name>
         <version>85a1.0</version>
         <description>DMA Main Registers</description>
         <baseAddress>0x40002400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x8</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>ACTRST</name>
               <description>Soft reset the entire module. Enable the blocks operation.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>Enable the blocks operation. (R/WS)                1=Enable block. Each individual channel must be enabled separately.                0=Disable all channels.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RST</name>
                     <description>Soft reset the entire module. This bit is self-clearing.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DATA_PKT</name>
               <description>Debug register that has the data that is stored in the Data Packet. This data is read data from the currently active transfer source.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>DMA_CHAN00</name>
         <version>85b1.0</version>
         <description>DMA Channel 00 Registers</description>
         <baseAddress>0x40002440</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x2C</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ14</name>
            <value>6</value>
         </interrupt>
         <interrupt>
            <name>DMA_CH00</name>
            <value>24</value>
         </interrupt>
         <registers>
            <register>
               <name>ACTIVATE</name>
               <description>Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CHN</name>
                     <description>Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSTART</name>
               <description>This is the starting address for the Memory device.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MEND</name>
               <description>This is the ending address for the Memory device.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>DSTART</name>
               <description>This is the Master Device address.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>DMA Channel N Control</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RUN</name>
                     <description>This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REQ</name>
                     <description>This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS</name>
                     <description>This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>STSSelect</name>
                        <enumeratedValue>
                           <name>ERROR</name>
                           <description>3: Error detected by the DMA</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>EXT_DONE</name>
                           <description>2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>LOC_DONE</name>
                           <description>1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIS</name>
                           <description>0: DMA Channel Control:Run is Disabled (0x0)</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>BUSY</name>
                     <description>This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_DIR</name>
                     <description>This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HW_FLOW_CTRL_DEV</name>
                     <description>This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>INC_MEM_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INC_DEV_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK</name>
                     <description>This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions).</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIS_HW_FLOW_CTRL</name>
                     <description>This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_SIZE</name>
                     <description>This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_GO</name>
                     <description>This is used for the Firmware Flow Control DMA transfer.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_ABORT</name>
                     <description>This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ISTS</name>
               <description>DMA Channel N Interrupt Status</description>
               <addressOffset>0x14</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>BUS_ERR</name>
                     <description>This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLOW_CTRL</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>DMA CHANNEL N INTERRUPT ENABLE</description>
               <addressOffset>0x18</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>STS_EN_BUS_ERR</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_FLOW_CTRL</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_DONE</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CRC_EN</name>
               <description>DMA CHANNEL N CRC ENABLE</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MODE</name>
                     <description>1=Enable the calculation of CRC-32 for DMA Channel N     0=Disable the calculation of CRC-32 for DMA Channel N</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POST_TRANS</name>
                     <description>The bit enables the transfer of the calculated CRC-32 after the completion of the DMA transaction.     If the DMA transaction is aborted by either firmware or an internal bus error, the transfer will not occur.     If the target of the DMA transfer is a device and the device signaled the termination of the DMA transaction,     the CRC post transfer will not occur.     1=Enable the transfer of CRC-32 for DMA Channel N after the DMA transaction completes     0=Disable the automatic transfer of the CRC</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CRC_DATA</name>
               <description>DMA CHANNEL N CRC DATA</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CRC</name>
                     <description>Writes to this register initialize the CRC generator. Reads from this register return the output of the     CRC that is calculated from the data transferred by DMA Channel N. The output of the CRC generator is bit-reversed     and inverted on reads, as required by the CRC-32-IEEE definition. A CRC can be accumulated across multiple DMA transactions     on Channel N. If it is necessary to save the intermediate CRC value, the result of the read of this register must be     bit-reversed and inverted before being written back to this register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CRC_POST_STS</name>
               <description>DMA CHANNEL N CRC POST STATUS</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CRC_DONE</name>
                     <description>This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination.     It is cleared to '0b' when the DMA controller starts a new transfer on the channel.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CRC_RUNNING</name>
                     <description>This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC.     It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared     to '0b' when the post-transfer completes.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CRC_DATA_DONE</name>
                     <description>This bit is set to '1b' when the DMA controller has completed the post-transfer of the CRC data.     This bit is cleared to '0b' when the a new DMA transfer starts.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CRC_DATA_READY</name>
                     <description>This bit is set to '1b' when the DMA controller is processing the post-transfer of the CRC data.     This bit is cleared to '0b' when the post-transfer completes.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>DMA_CHAN01</name>
         <version>85c1.0</version>
         <description>DMA Channel 01 Registers</description>
         <baseAddress>0x40002480</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x2C</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>DMA_CH01</name>
            <value>25</value>
         </interrupt>
         <registers>
            <register>
               <name>ACTIVATE</name>
               <description>Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CHN</name>
                     <description>Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSTART</name>
               <description>This is the starting address for the Memory device.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MEND</name>
               <description>This is the ending address for the Memory device.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>DSTART</name>
               <description>This is the Master Device address.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>DMA Channel N Control</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RUN</name>
                     <description>This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REQ</name>
                     <description>This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS</name>
                     <description>This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>STSSelect</name>
                        <enumeratedValue>
                           <name>ERROR</name>
                           <description>3: Error detected by the DMA</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>EXT_DONE</name>
                           <description>2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>LOC_DONE</name>
                           <description>1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIS</name>
                           <description>0: DMA Channel Control:Run is Disabled (0x0)</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>BUSY</name>
                     <description>This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_DIR</name>
                     <description>This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HW_FLOW_CTRL_DEV</name>
                     <description>This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>INC_MEM_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INC_DEV_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK</name>
                     <description>This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions).</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIS_HW_FLOW_CTRL</name>
                     <description>This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_SIZE</name>
                     <description>This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_GO</name>
                     <description>This is used for the Firmware Flow Control DMA transfer.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_ABORT</name>
                     <description>This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ISTS</name>
               <description>DMA Channel N Interrupt Status</description>
               <addressOffset>0x14</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>BUS_ERROR</name>
                     <description>This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLOW_CTRL</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>DMA CHANNEL N INTERRUPT ENABLE</description>
               <addressOffset>0x18</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>STS_EN_BUS_ERR</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_FLOW_CTRL</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_DONE</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FILL_EN</name>
               <description>DMA CHANNEL N FILL ENABLE</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MODE</name>
                     <description>1=Enable the DMA Channel Fill Engine N     0=Disable the DMA Channel Fill Engine</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FILL_DATA</name>
               <description>DMA CHANNEL N FILL DATA</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DATA</name>
                     <description>This is the data pattern used to fill memory.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FILL_STS</name>
               <description>DMA CHANNEL N FILL STATUS</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DONE</name>
                     <description>This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination.     It is cleared to '0b' when the DMA controller starts a new transfer on the channel.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RUNNING</name>
                     <description>This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC.     It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared     to '0b' when the post-transfer completes.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>DMA_CHAN02</name>
         <version>85d1.0</version>
         <description>DMA Channel 02 Registers</description>
         <baseAddress>0x400024C0</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x19</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>DMA_CH02</name>
            <value>26</value>
         </interrupt>
         <registers>
            <register>
               <name>ACTIVATE</name>
               <description>Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CHN</name>
                     <description>Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.                  1=Enable channel(block). Each individual channel must be enabled separately.                  0=Disable channel(block).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSTART</name>
               <description>This is the starting address for the Memory device.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MEND</name>
               <description>This is the ending address for the Memory device.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>DSTART</name>
               <description>This is the Master Device address.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>DMA Channel N Control</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RUN</name>
                     <description>This is a control field. Note: This bit only applies to Hardware Flow Control mode.                  1= This channel is enabled and will service transfer requests                  0=This channel is disabled. All transfer requests are ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REQ</name>
                     <description>This is a status field.                  1= There is a transfer request from the Master Device                  0= There is no transfer request from the Master Device</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is a status signal. It is only valid while DMA Channel Control: Run is Enabled.                   This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.                  1=Channel is done                  0=Channel is not done or it is OFF</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS</name>
                     <description>This is a status signal. The status decode is listed in priority order with the highest priority first.                  3: Error detected by the DMA                  2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term                  1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address                  0: DMA Channel Control:Run is Disabled (0x0)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>STSSelect</name>
                        <enumeratedValue>
                           <name>ERROR</name>
                           <description>3: Error detected by the DMA</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>EXT_DONE</name>
                           <description>2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>LOC_DONE</name>
                           <description>1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIS</name>
                           <description>0: DMA Channel Control:Run is Disabled (0x0)</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>BUSY</name>
                     <description>This is a status signal.                  1=The DMA Channel is busy (FSM is not IDLE)                  0=The DMA Channel is not busy (FSM is IDLE)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_DIR</name>
                     <description>This determines the direction of the DMA Transfer.                  1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address                  0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HW_FLOW_CTRL_DEV</name>
                     <description>This is the device that is connected to this channel as its Hardware Flow Control master.                  The Flow Control Interface is a bus with each master concatenated onto it.                  This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.                  The Flow Control Interface Port list is dma_req, dma_term, and dma_done.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>INC_MEM_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Memory Address.                  1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0=Do nothing</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INC_DEV_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Device Address.                  1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer                  0: Do nothing</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK</name>
                     <description>This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions).</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIS_HW_FLOW_CTRL</name>
                     <description>This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_SIZE</name>
                     <description>This is the transfer size in Bytes of each Data Packet transfer.                  Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_GO</name>
                     <description>This is used for the Firmware Flow Control DMA transfer.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_ABORT</name>
                     <description>This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ISTS</name>
               <description>DMA Channel N Interrupt Status</description>
               <addressOffset>0x14</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>BUS_ERR</name>
                     <description>This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.                  1: Error detected. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLOW_CTRL</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request     after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.                  1=Hardware Flow Control is requesting after the transfer has completed                  0=No Hardware Flow Control event</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.     A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.     A completion due to a Hardware Flow Control Terminate will not flag this interrupt.                  1=Memory Start Address equals Memory End Address                  0=Memory Start Address does not equal Memory End Address</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>DMA CHANNEL N INTERRUPT ENABLE</description>
               <addressOffset>0x18</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>STS_EN_BUS_ERR</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.                  1=Enable Interrupt                  0=Disable Interrupt</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_FLOW_CTRL</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.                  1=Enable Interrupt                  0=Disable Interrupt</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_DONE</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Done.                  1=Enable Interrupt                  0=Disable Interrupt</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN03</name>
         <baseAddress>0x40002500</baseAddress>
         <interrupt>
            <name>DMA_CH03</name>
            <value>27</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN04</name>
         <baseAddress>0x40002540</baseAddress>
         <interrupt>
            <name>DMA_CH04</name>
            <value>28</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN05</name>
         <baseAddress>0x40002580</baseAddress>
         <interrupt>
            <name>DMA_CH05</name>
            <value>29</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN06</name>
         <baseAddress>0x400025C0</baseAddress>
         <interrupt>
            <name>DMA_CH06</name>
            <value>30</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN07</name>
         <baseAddress>0x40002600</baseAddress>
         <interrupt>
            <name>DMA_CH07</name>
            <value>31</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN08</name>
         <baseAddress>0x40002640</baseAddress>
         <interrupt>
            <name>DMA_CH08</name>
            <value>32</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN09</name>
         <baseAddress>0x40002680</baseAddress>
         <interrupt>
            <name>DMA_CH09</name>
            <value>33</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN10</name>
         <baseAddress>0x400026C0</baseAddress>
         <interrupt>
            <name>DMA_CH10</name>
            <value>34</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN11</name>
         <baseAddress>0x40002700</baseAddress>
         <interrupt>
            <name>DMA_CH11</name>
            <value>35</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN12</name>
         <baseAddress>0x40002740</baseAddress>
         <interrupt>
            <name>DMA_CH12</name>
            <value>36</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN13</name>
         <baseAddress>0x40002780</baseAddress>
         <interrupt>
            <name>DMA_CH13</name>
            <value>37</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN14</name>
         <baseAddress>0x400027C0</baseAddress>
         <interrupt>
            <name>DMA_CH14</name>
            <value>38</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN15</name>
         <baseAddress>0x40002800</baseAddress>
         <interrupt>
            <name>DMA_CH15</name>
            <value>39</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>ECIA</name>
         <version>2001.0</version>
         <description>The ECIA works in conjunction with the processor interrupt interface to handle hardware interrupts andd exceptions.</description>
         <baseAddress>0x4000E000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x20C</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>SRC8</name>
               <description>GIRQ8 SOURCE</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET8</name>
               <description>GIRQ8 ENABLE SET</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT8</name>
               <description>GIRQ8 RESULT</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR8</name>
               <description>GIRQ8 ENABLE CLEAR</description>
               <addressOffset>0xc</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC9</name>
               <description>GIRQ9 SOURCE</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET9</name>
               <description>GIRQ9 ENABLE SET</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT9</name>
               <description>GIRQ9 RESULT</description>
               <addressOffset>0x1c</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR9</name>
               <description>GIRQ9 ENABLE CLEAR</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC10</name>
               <description>GIRQ10 SOURCE</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET10</name>
               <description>GIRQ10 ENABLE SET</description>
               <addressOffset>0x2c</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT10</name>
               <description>GIRQ10 RESULT</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR10</name>
               <description>GIRQ10 ENABLE CLEAR</description>
               <addressOffset>0x34</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC11</name>
               <description>GIRQ11 SOURCE</description>
               <addressOffset>0x3c</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET11</name>
               <description>GIRQ11 ENABLE SET</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT11</name>
               <description>GIRQ11 RESULT</description>
               <addressOffset>0x44</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR11</name>
               <description>GIRQ11 ENABLE CLEAR</description>
               <addressOffset>0x48</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC12</name>
               <description>GIRQ12 SOURCE</description>
               <addressOffset>0x50</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET12</name>
               <description>GIRQ12 ENABLE SET</description>
               <addressOffset>0x54</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT12</name>
               <description>GIRQ12 RESULT</description>
               <addressOffset>0x58</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR12</name>
               <description>GIRQ12 ENABLE CLEAR</description>
               <addressOffset>0x5c</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC13</name>
               <description>GIRQ13 SOURCE</description>
               <addressOffset>0x64</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET13</name>
               <description>GIRQ13 ENABLE SET</description>
               <addressOffset>0x68</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT13</name>
               <description>GIRQ13 RESULT</description>
               <addressOffset>0x6c</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR13</name>
               <description>GIRQ13 ENABLE CLEAR</description>
               <addressOffset>0x70</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC14</name>
               <description>GIRQ14 SOURCE</description>
               <addressOffset>0x78</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET14</name>
               <description>GIRQ14 ENABLE SET</description>
               <addressOffset>0x7c</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT14</name>
               <description>GIRQ14 RESULT</description>
               <addressOffset>0x80</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR14</name>
               <description>GIRQ14 ENABLE CLEAR</description>
               <addressOffset>0x84</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC15</name>
               <description>GIRQ15 SOURCE</description>
               <addressOffset>0x8c</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET15</name>
               <description>GIRQ15 ENABLE SET</description>
               <addressOffset>0x90</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT15</name>
               <description>GIRQ15 RESULT</description>
               <addressOffset>0x94</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR15</name>
               <description>GIRQ15 ENABLE CLEAR</description>
               <addressOffset>0x98</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC16</name>
               <description>GIRQ16 SOURCE</description>
               <addressOffset>0xa0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET16</name>
               <description>GIRQ16 ENABLE SET</description>
               <addressOffset>0xa4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT16</name>
               <description>GIRQ16 RESULT</description>
               <addressOffset>0xa8</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR16</name>
               <description>GIRQ16 ENABLE CLEAR</description>
               <addressOffset>0xac</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC17</name>
               <description>GIRQ17 SOURCE</description>
               <addressOffset>0xb4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET17</name>
               <description>GIRQ17 ENABLE SET</description>
               <addressOffset>0xb8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT17</name>
               <description>GIRQ17 RESULT</description>
               <addressOffset>0xbc</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR17</name>
               <description>GIRQ17 ENABLE CLEAR</description>
               <addressOffset>0xc0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC18</name>
               <description>GIRQ18 SOURCE</description>
               <addressOffset>0xc8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET18</name>
               <description>GIRQ18 ENABLE SET</description>
               <addressOffset>0xcc</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT18</name>
               <description>GIRQ18 RESULT</description>
               <addressOffset>0xd0</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR18</name>
               <description>GIRQ18 ENABLE CLEAR</description>
               <addressOffset>0xd4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC19</name>
               <description>GIRQ19 SOURCE</description>
               <addressOffset>0xdc</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET19</name>
               <description>GIRQ19 ENABLE SET</description>
               <addressOffset>0xe0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT19</name>
               <description>GIRQ19 RESULT</description>
               <addressOffset>0xe4</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR19</name>
               <description>GIRQ19 ENABLE CLEAR</description>
               <addressOffset>0xe8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC20</name>
               <description>GIRQ20 SOURCE</description>
               <addressOffset>0xf0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET20</name>
               <description>GIRQ20 ENABLE SET</description>
               <addressOffset>0xf4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT20</name>
               <description>GIRQ20 RESULT</description>
               <addressOffset>0xf8</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR20</name>
               <description>GIRQ20 ENABLE CLEAR</description>
               <addressOffset>0xfc</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC21</name>
               <description>GIRQ21 SOURCE</description>
               <addressOffset>0x104</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET21</name>
               <description>GIRQ21 ENABLE SET</description>
               <addressOffset>0x108</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT21</name>
               <description>GIRQ21 RESULT</description>
               <addressOffset>0x10c</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR21</name>
               <description>GIRQ21 ENABLE CLEAR</description>
               <addressOffset>0x110</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC22</name>
               <description>GIRQ22 SOURCE</description>
               <addressOffset>0x118</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET22</name>
               <description>GIRQ22 ENABLE SET</description>
               <addressOffset>0x11c</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT22</name>
               <description>GIRQ22 RESULT</description>
               <addressOffset>0x120</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR22</name>
               <description>GIRQ22 ENABLE CLEAR</description>
               <addressOffset>0x124</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC23</name>
               <description>GIRQ23 SOURCE</description>
               <addressOffset>0x12c</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET23</name>
               <description>GIRQ23 ENABLE SET</description>
               <addressOffset>0x130</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT23</name>
               <description>GIRQ23 RESULT</description>
               <addressOffset>0x134</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR23</name>
               <description>GIRQ23 ENABLE CLEAR</description>
               <addressOffset>0x138</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC24</name>
               <description>GIRQ24 SOURCE</description>
               <addressOffset>0x140</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET24</name>
               <description>GIRQ24 ENABLE SET</description>
               <addressOffset>0x144</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT24</name>
               <description>GIRQ24 RESULT</description>
               <addressOffset>0x148</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR24</name>
               <description>GIRQ24 ENABLE CLEAR</description>
               <addressOffset>0x14c</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC25</name>
               <description>GIRQ25 SOURCE</description>
               <addressOffset>0x154</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET25</name>
               <description>GIRQ25 ENABLE SET</description>
               <addressOffset>0x158</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT25</name>
               <description>GIRQ25 RESULT</description>
               <addressOffset>0x15c</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR25</name>
               <description>GIRQ25 ENABLE CLEAR</description>
               <addressOffset>0x160</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>SRC26</name>
               <description>GIRQ26 SOURCE</description>
               <addressOffset>0x168</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_SET26</name>
               <description>GIRQ26 ENABLE SET</description>
               <addressOffset>0x16c</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RESULT26</name>
               <description>GIRQ26 RESULT</description>
               <addressOffset>0x170</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EN_CLR26</name>
               <description>GIRQ26 ENABLE CLEAR</description>
               <addressOffset>0x174</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>BLK_EN_SET</name>
               <description>Block Enable Set Register</description>
               <addressOffset>0x200</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VTOR_EN_SET</name>
                     <description>Each GIRQx bit can be individually enabled to assert an interrupt event.      Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by      the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WS)      1=Interrupts in the GIRQx Source Register may be enabled      0=No effect.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>31</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BLK_EN_CLR</name>
               <description>Block Enable Clear Register.</description>
               <addressOffset>0x204</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VTOR_EN_CLR</name>
                     <description>Each GIRQx bit can be individually disabled to inhibit an interrupt event.      Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by      the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_CLEAR bit. (0=disabled, 1=enabled) (R/WC)      1=All interrupts in the GIRQx Source Register are disabled      0=No effect.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>31</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BLK_IRQ_VTOR</name>
               <description>Block IRQ Vector Register</description>
               <addressOffset>0x208</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VTOR</name>
                     <description>Each bit in this field reports the status of the group GIRQ interrupt assertion to the NVIC. If the GIRQx interrupt      is disabled as a group, by the Block Enable Clear Register, then the corresponding bit will be '0'b and no interrupt will be asserted.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>25</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>CACHE</name>
         <version>2011.0</version>
         <description>This is the CACHE Controller</description>
         <baseAddress>0x40010000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x1190</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>MODE</name>
               <description>CACHE MODE register.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000001</resetValue>
               <fields>
                  <field>
                     <name>ACTIVATE</name>
                     <description>ACTIVATE 0: Disable block. 1: Enable block.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RESET</name>
                     <description>Soft reset the Cache Controller module. This is self clearing bit. Write Only bit</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPI_ENABLE</name>
                     <description>CACHE SPI Enable. 0: Standard register access. 1: Cache takes over the register interface of eSPI SAF EC</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CONNECT_MODE</name>
                     <description>CACHE connection mode. 0: eSPI SAF EC.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FULL_LINE_RD_EN</name>
                     <description>Full line read enable. 0: Critical section, first and early termination enabled. 1: Critical section, first and early termination disabled.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INVALIDATE_ALL</name>
                     <description>INVALIDATE all CACHE lines.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SPI_BANK</name>
               <description>CSPI Bank. This is ORed into the access address from the processor to create the address sent over to the SPI Flash.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>TAG_VLDT</name>
               <description>CACHE TAG VALIDATE register.</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <resetValue>0x00000001</resetValue>
               <fields>
                  <field>
                     <name>TAG_FORCE</name>
                     <description>Tag Force. This bit will allow the cache select a Tag line and allocate the Cache Tag Validate Address to it.     0: No action. 1: A tag line will be allocated</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TAG_FORCE_LOCK</name>
                     <description>Tag Force Lock. Will lock the cache line.           0: Line will not be locked. 1: Line will be locked.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TAG_FORCE_FILL</name>
                     <description>Tag Force Fill. Will cause the cache to immediately fill this cache line.           0: Line will not be filled until it is Miss/Fill. 1: Line will auto fill immediately</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TAG_FORCE_INVALIID</name>
                     <description>Tag Force Invalid. Will invalidate the address pointed by Tag Validate Address register.           0: No action. 1: Invalidate address.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TAG_VLDT_ADDR</name>
               <description>Tag Force Address.   This is the address that will be stored in the Tag Line and accessed over SPI if a Tag Force is issued. This address is still used          in conjunction with the Cache SPI Bank.This is meant to be an address from the processors perspective. 4 Byte Boundary aligned</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>STS</name>
               <description>CACHE STATUS register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALIDATE_DONE</name>
                     <description>Validate Done. This bit is set when Validate command has completed.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INVALIDATE_DONE</name>
                     <description>Invalidate Done. This bit is set when invalidate command has completed.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPI_ERR</name>
                     <description>Indicates CACHE Line Fill error from Flash memory</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HIT_HI</name>
               <description>Hit count Hi. Stores the Hit Count [63:32] of the Cache</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>HIT_LOW</name>
               <description>Hit count low. Stores the Hit Count [31:0] of the Cache</description>
               <addressOffset>0x44</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MISS_HI</name>
               <description>Miss count Hi. Stores the Miss Count [63:32] of the Cache</description>
               <addressOffset>0x50</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MISS_LOW</name>
               <description>Miss count low. Stores the Miss Count [31:0] of the Cache</description>
               <addressOffset>0x54</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>FILL_HI</name>
               <description>Fill count Hi. Stores the Fill Count [63:32] of the Cache</description>
               <addressOffset>0x60</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>FILL_LOW</name>
               <description>Fill count low. Stores the Fill Count [31:0] of the Cache</description>
               <addressOffset>0x64</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <dim>16</dim>
               <dimIncrement>4</dimIncrement>
               <name>RX_BUFFER[%s]</name>
               <description>Rx Buffer0.</description>
               <addressOffset>0xC0</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>TAG_LOCK0</name>
               <description>Tag Lock0. 0: Tag is not Locked. 1: Tag is Locked.</description>
               <addressOffset>0x800</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>TAG_LOCK1</name>
               <description>Tag Lock1. 0: Tag is not Locked. 1: Tag is Locked.</description>
               <addressOffset>0x804</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>TAG_VALID0</name>
               <description>Tag Valid0. Tells Line has valid data in the cache. 0: Line is empty. 1: Line is full.</description>
               <addressOffset>0xC00</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>TAG_VALID1</name>
               <description>Tag Valid1. Tells Line has valid data in the cache. 0: Line is empty. 1: Line is full.</description>
               <addressOffset>0xC04</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <dim>64</dim>
               <dimIncrement>4</dimIncrement>
               <name>TAG_ADDR[%s]</name>
               <description>Tag Address0.</description>
               <addressOffset>0x1000</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>ESPI_IO</name>
         <version>143a1.0</version>
         <description>The ESPI is used by the system host to configure the chip and communicate with the logical devices implemented in the design.</description>
         <baseAddress>0x400F3400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x3F1</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ19</name>
            <value>11</value>
         </interrupt>
         <interrupt>
            <name>INTR_PC</name>
            <value>103</value>
         </interrupt>
         <interrupt>
            <name>INTR_BM1</name>
            <value>104</value>
         </interrupt>
         <interrupt>
            <name>INTR_BM2</name>
            <value>105</value>
         </interrupt>
         <interrupt>
            <name>INTR_LTR</name>
            <value>106</value>
         </interrupt>
         <interrupt>
            <name>INTR_OOB_UP</name>
            <value>107</value>
         </interrupt>
         <interrupt>
            <name>INTR_OOB_DOWN</name>
            <value>108</value>
         </interrupt>
         <interrupt>
            <name>INTR_FLASH</name>
            <value>109</value>
         </interrupt>
         <interrupt>
            <name>ESPI_RESET</name>
            <value>110</value>
         </interrupt>
         <interrupt>
            <name>ESPI_VWIRE</name>
            <value>156</value>
         </interrupt>
         <registers>
            <register>
               <name>IND</name>
               <description>The INDEX register, which is part of the Configuration Port, is used as a pointer to a Configuration Register Address.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>DAT_REG</name>
               <description>The DATA register, which is part of the Configuration Port, is used to read or write data to the register currently being selected by the INDEX Register.</description>
               <addressOffset>0x1</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>PC_LC_ADDR_LSW</name>
               <description>Peripheral Channel Last Cycle Register (DWord 0)</description>
               <addressOffset>0x100</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LADR</name>
                     <description>This field records bits[31:0] of the 64 bit address of the most recent eSPI transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PC_LC_ADDR_MSW</name>
               <description>Peripheral Channel Last Cycle Register (DWord 1)</description>
               <addressOffset>0x104</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MADR</name>
                     <description>This field records bits[63:32] of the 64 bit address of the most recent eSPI transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PC_LC_LEN_TYPE_TAG</name>
               <description>Peripheral Channel Last Cycle Register (DWord 2)</description>
               <addressOffset>0x108</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PC_LEN</name>
                     <description>This field records the length of the most recent eSPI transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>PC_CY_TYPE</name>
                     <description>This field records the cycle type of the most recent eSPI transaction.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>PC_TAG</name>
                     <description>This field records the tag of the most recent eSPI transaction.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PC_ERR_ADDR_LSW</name>
               <description>Peripheral Channel Error Address Register (DWord 0)</description>
               <addressOffset>0x10C</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LSDW</name>
                     <description>This field records bits[31:0] of the 64 bit address of the most recent eSPI transaction that incurred an error.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PC_ERR_ADDR_MSW</name>
               <description>Peripheral Channel Error Address Register (DWord 1)</description>
               <addressOffset>0x110</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MSDW</name>
                     <description>This field records bits[63:32] of the 64 bit  address of the most recent eSPI transaction that incurred an error.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PC_STATUS</name>
               <description>Peripheral Channel Status Register</description>
               <addressOffset>0x114</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VIR_RD</name>
                     <description>This bit is set whenever a eSPI read transaction targeting a Logical Device with an I/O BAR or a Memory BAR in which the VIRTUALIZED bit      is set. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VIR_WR</name>
                     <description>This bit is set whenever a eSPI write transaction targeting a Logical Device with an I/O BAR or a Memory BAR in which the VIRTUALIZED bit      is set. (R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VIR_TYP</name>
                     <description>This bit returns the type of Virtualized eSPI transaction that is      1=Peripheral Channel Memory Address access      0=Peripheral Channel I/O Address access.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VIR_BAR_LDN</name>
                     <description>This field returns the Logical Device Number of the device targeted by the most recent virtual transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>PC_BUS_ERROR</name>
                     <description>This bit is set to '1' whenever an eSPI access causes an internal bus error. Once set, it remains set until cleared by being written      with a 1. (R/WC)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BAR_CONFL</name>
                     <description>This bit is set to '1' whenever a BAR conflict occurs on an eSPI address. A BAR conflict occurs when more than one BAR matches      the address of an eSPI transaction. Once set, it remains set until cleared by being written with a 1. (R/WC)</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHN_EN_STS</name>
                     <description>This bit reflects the Host writable configuration field.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_CHNG</name>
                     <description>This bit is set to '1' whenever the field PC_CHANNEL_ENABLE_STATUS in this register changes. Once set, it remains set until cleared by being written with a 1. (R/WC)</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>M_EN_STS</name>
                     <description>This bit is 1 if three bits in the Peripheral Channel Capabilities and Configurations register, Peripheral Channel Mastering Enable,      Peripheral Channel Ready and Peripheral Channel Enable, are all 1, and 0 otherwise.</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>M_EN_CHNG</name>
                     <description>This bit is set to '1' whenever the field PC_MASTERING_ENABLE_STATUS in this register changes. Once set, it remains set until cleared by being written with a 1 (R/WC)</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PC_IEN</name>
               <description>Peripheral Channel Interrupt Enable Register</description>
               <addressOffset>0x118</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VIR_RD_EN</name>
                     <description>When this bit is '1' an interrupt is generated when the bit PC_VIRTUAL_READ in the Peripheral Channel Status Register is 1.      When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VIR_WR_EN</name>
                     <description>When this bit is '1' an interrupt is generated when the bit PC_VIRTUAL_WRITE in the Peripheral Channel Status Register is 1.      When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BUS_ERR_EN</name>
                     <description>When this bit is '1' an interrupt is generated when the bit PC_BUS_ERROR in the Peripheral Channel Status Register is 1.      When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BAR_CONFL_EN</name>
                     <description>When this bit is '1' an interrupt is generated when the bit BAR_CONFLICT in the Peripheral Channel Status Register is 1.      When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_CHNG_EN</name>
                     <description>When this bit is '1' an interrupt is generated when the bit PC_ENABLE_CHANGE in the Peripheral Channel Status Register is 1.      When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>M_EN_CHNG_EN</name>
                     <description>When this bit is '1' an interrupt is generated when the bit PC_MASTERING_ENABLE_CHANGE in the Peripheral Channel Status Register is 1.      When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IOBAR_INH_LSW</name>
               <description>BAR Inhibit Register (DWord 0)</description>
               <addressOffset>0x120</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LSDW</name>
                     <description>When bit Di of BAR_Inhibit is 1, the BAR for Logical Device i is disabled and its addresses will not be claimed on the eSPI      bus, independent of the value of the Valid bit in the BAR. The BAR Inhibit function applies to both I/O transactions and Memory transactions.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IOBAR_INH_MSW</name>
               <description>BAR Inhibit Register (DWord 1)</description>
               <addressOffset>0x124</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MSDW</name>
                     <description>When bit Di of BAR_Inhibit is 1, the BAR for Logical Device i is disabled and its addresses will not be claimed on the eSPI      bus, independent of the value of the Valid bit in the BAR. The BAR Inhibit function applies to both I/O transactions and Memory transactions.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IOBAR_INIT</name>
               <description>eSPI BAR Init Register</description>
               <addressOffset>0x128</addressOffset>
               <size>32</size>
               <resetValue>0x0000002E</resetValue>
               <fields>
                  <field>
                     <name>INIT</name>
                     <description>This field is loaded into the Base Address Register register for Logical Device Ch (eSPI, I/O Configuration Port) on RESET_SIO.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_CTRL_IRQ</name>
               <description>EC IRQ Register</description>
               <addressOffset>0x12C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>This bit can be used as a firmware-controlled interrupt source for the EC. When the EC entry in the IRQ Assignment Table is set to a      valid IRQ number, changes in this bit will be transmitted to the Host over a Virtual Wire IRQ channel.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BASE_ADDR</name>
               <description>eSPI I/O Base Address Register</description>
               <addressOffset>0x134</addressOffset>
               <size>32</size>
               <resetValue>0x00000D01</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ESPI_MEM_BASE_ADDR</name>
               <description>eSPI Memory Base Address Register</description>
               <addressOffset>0x138</addressOffset>
               <size>32</size>
               <resetValue>0x00000E00</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MBX_BASE_ADDR</name>
               <description>Mailbox BAR  Register</description>
               <addressOffset>0x13C</addressOffset>
               <size>32</size>
               <resetValue>0x00000001</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EM8042_BASE_ADDR</name>
               <description>8042 Emulated Keyboard Controller BAR Register</description>
               <addressOffset>0x140</addressOffset>
               <size>32</size>
               <resetValue>0x00000104</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC_0_BASE_ADDR</name>
               <description>ACPI EC Channel 0 Register</description>
               <addressOffset>0x144</addressOffset>
               <size>32</size>
               <resetValue>0x00000204</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC_1_BASE_ADDR</name>
               <description>ACPI EC Channel 1 BAR Register</description>
               <addressOffset>0x148</addressOffset>
               <size>32</size>
               <resetValue>0x00000307</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC_2_BASE_ADDR</name>
               <description>ACPI EC Channel 2 BAR Register</description>
               <addressOffset>0x14C</addressOffset>
               <size>32</size>
               <resetValue>0x00000407</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC_3_BASE_ADDR</name>
               <description>ACPI EC Channel 3 BAR Register</description>
               <addressOffset>0x150</addressOffset>
               <size>32</size>
               <resetValue>0x00000507</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC_4_BASE_ADDR</name>
               <description>ACPI EC Channel 4 BAR Register</description>
               <addressOffset>0x154</addressOffset>
               <size>32</size>
               <resetValue>0x00000607</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_PM1_BASE_ADDR</name>
               <description>I/O Base Address Register</description>
               <addressOffset>0x158</addressOffset>
               <size>32</size>
               <resetValue>0x00000707</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FAST_KDB_BASE_ADDR</name>
               <description>Legacy (Fast Keyboard) BAR Register</description>
               <addressOffset>0x15C</addressOffset>
               <size>32</size>
               <resetValue>0x00000800</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>UART_0_BASE_ADDR</name>
               <description>UART 0 BAR Register</description>
               <addressOffset>0x160</addressOffset>
               <size>32</size>
               <resetValue>0x00000907</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>UART_1_BASE_ADDR</name>
               <description>UART 1 BAR Register</description>
               <addressOffset>0x164</addressOffset>
               <size>32</size>
               <resetValue>0x00000A07</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_0_BASE_ADDR</name>
               <description>Embedded Memory Interface (EMI) 0 BAR Register</description>
               <addressOffset>0x168</addressOffset>
               <size>32</size>
               <resetValue>0x0000101F</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_1_BASE_ADDR</name>
               <description>Embedded Memory Interface (EMI) 1 BAR Register</description>
               <addressOffset>0x16C</addressOffset>
               <size>32</size>
               <resetValue>0x0000111F</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_2_BASE_ADDR</name>
               <description>Embedded Memory Interface (EMI) 2 BAR Register</description>
               <addressOffset>0x170</addressOffset>
               <size>32</size>
               <resetValue>0x0000121F</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PORT80_0_BASE_ADDR</name>
               <description>BIOS Debug Port (Port 80) 0 BAR Register</description>
               <addressOffset>0x174</addressOffset>
               <size>32</size>
               <resetValue>0x00002003</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PORT80_1_BASE_ADDR</name>
               <description>BIOS Debug Port (Port 80) 1 BAR Register</description>
               <addressOffset>0x178</addressOffset>
               <size>32</size>
               <resetValue>0x00002100</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RTC_BASE_ADDR</name>
               <description>RTC Base Address Register</description>
               <addressOffset>0x17C</addressOffset>
               <size>32</size>
               <resetValue>0x0000141F</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>GLUE_BASE_ADDR</name>
               <description>GLUE Base Address Register</description>
               <addressOffset>0x18C</addressOffset>
               <size>32</size>
               <resetValue>0x00000F07</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LTR_STS</name>
               <description>LTR Peripheral Status Register</description>
               <addressOffset>0x220</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_DON_STS</name>
                     <description>This bit is set to '1' whenever a Transmit operation terminates (the TRANSMIT_DONE bit in this register goes from 1 to 0). (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT_OVRUN_STS</name>
                     <description>A Start was attempted while the TRANSMIT_BUSY bit in this register was '1'. Any Transmit in progress is immediately terminated. (R/WC)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIS_H_STS</name>
                     <description>A '1' in this bit indicates that the last requested Transmit operation was aborted because Bus Mastering has been disabled by the Host.      Bus Mastering is disabled whenever the Peripheral Channel Mastering Enable bit in that register is '0', or the Peripheral Channel Enable bit is '0'.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUSY</name>
                     <description>This bit is set to '1' when firmware writes '1' to the LTR_START (ltr_initiate) bit in the LTR Peripheral Control Register. It is cleared      by hardware when the transfer is sufficiently complete so that another packet can be transmitted. If the LTR_START bit is written to '1' while this bit      is also '1', then START_OVERRUN_STATUS in this register will be set to '1' and the transfer will terminate immediately.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LTR_EN</name>
               <description>LTR Peripheral Enable Register</description>
               <addressOffset>0x224</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_DONE_IEN</name>
                     <description>When this bit is '1' an interrupt is generated when the bit TRANSMIT_DONE_STATUS in the LTR Peripheral Status Register is 1.      When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LTR_CTRL</name>
               <description>LTR Peripheral Control Register</description>
               <addressOffset>0x228</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>STRT</name>
                     <description>Writing '1' to this bit triggers the transmission of an LTR packet defined by the LTR Peripheral Message register. Writing '0' to this bit has no effect.      The transmission will be inhibited if the Peripheral channel is not Ready, as defined in the eSPI Peripheral Channel Ready Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUTG_TAG</name>
                     <description>This 4-bit value will be inserted as the TAG number in the next transmitted LTR packet. According to current understanding of Intel      specs, this field should be kept zero by firmware.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LTR_MESG</name>
               <description>LTR Peripheral Message Register</description>
               <addressOffset>0x22C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VAL</name>
                     <description>This field declares a time, in units expressed by the Scale field. Zero in both this field and the Scale field (zero time) demands best      possible effort (minimal latency) by the chipset.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>10</bitWidth>
                  </field>
                  <field>
                     <name>SCAL</name>
                     <description>This field declares the time unit expressed by each count of the Value field of this register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>RES_TX_BITS</name>
                     <description>These bits are Read/Write, but are undefined in the 16-bit LTR message format. These bits are transmitted, but according to current      specs they must always be kept as zeros when writing this register.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>REQ_BIT</name>
                     <description>1 = Maximum latency tolerated is defined by the Scale and Length fields of this register. 0 = No Requirement. Infinite latency tolerated. (Default).</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_RX_ADDR_LSW</name>
               <description>OOB Channel Receive Address Register</description>
               <addressOffset>0x240</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RX_BUF</name>
                     <description>This field must be initialized to contain the Base Address for accepting the next OOB packet.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>30</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_TX_ADDR_LSW</name>
               <description>OOB Channel Transmit Address Register</description>
               <addressOffset>0x248</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_BUF</name>
                     <description>Before starting an OOB Transmit, this field must be initialized to contain the Base Address of the buffer in SRAM.      The contents of the transmit buffer should not be modified while TRANSMIT_BUSY is asserted.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>30</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_RX_LEN</name>
               <description>OOB Channel Receive Length Register</description>
               <addressOffset>0x250</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MSG</name>
                     <description>This 13-bit read-only field reports how many bytes were received into SRAM in the last packet. This is necessary, independent of      any 'byte count' in the packet itself to distinguish between an SMBus packet with or without a PEC byte.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
                  <field>
                     <name>BUF</name>
                     <description>Before setting the Receive Enable bit to allow incoming traffic to the Receive Buffer area, this 13-bit field must be initialized to      contain the length in bytes of the receiving buffer in SRAM. This limits the number of bytes that can be received into SRAM. Any additional incoming      bytes must be discarded by hardware, posting the Data Overrun error flag. Practically, the maximum value that can be placed in this field is the      configured Max Packet Length. This limit, or anything higher, is legal, but will effectively disable the limit check.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_TX_LEN</name>
               <description>OOB Channel Transmit Length Register</description>
               <addressOffset>0x254</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MSG</name>
                     <description>This 13-bit field declares how many bytes are to be transmitted from the Tramsit Buffer memory. A value of zero,      or a value greater than the defined Max Packet Size (73 decimal, or 4Dh, by default) is illegal, and will trigger Bad Request handling.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_RX_CTRL</name>
               <description>OOB Channel Receive Control Register</description>
               <addressOffset>0x258</addressOffset>
               <size>32</size>
               <resetValue>0x00010000</resetValue>
               <fields>
                  <field>
                     <name>SET_RX_AVAIL</name>
                     <description>Firmware sets this bit to '1' to indicate that an SRAM buffer is available to receive the next Down OOB packet. This      forces the bit RECEIVE_ENABLE bit in the OOB Channel Receive Status Register register to be set to '1'. The OOB Channel Receive      Address Register and OOB Channel Receive Length Register must have already been initialized before setting this bit.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHN_EN</name>
                     <description>This allows firmware to read the OOB Message Channel Enabled field in the eSPI Configuration register. The Master      sets the bit to '1' to enable the OOB channel.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MAX_PAYLD_SIZE_SEL</name>
                     <description>This allows firmware to read the correspondingly-named field in the eSPI Configuration register. The 001b default      code selects 64-byte mode, which is actually a 73-byte max payload size for eSPI (64 bytes plus MCTP wrapper bytes).</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_RX_IEN</name>
               <description>OOB Channel Receive Interrupt Enable Register</description>
               <addressOffset>0x25C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RX_IEN</name>
                     <description>When this bit is '1' an interrupt is generated when the bit RECEIVE_DONE_STATUS in the OOB Channel Receive Status      Register is 1. When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_RX_STS</name>
               <description>OOB Channel Receive Status Register</description>
               <addressOffset>0x260</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DONE</name>
                     <description>This bit is set to '1' whenever the RECEIVE_ENABLE bit in this register is cleared to '0' by hardware when an incoming      packet is completely transferred to SRAM. This bit is also set whenever either OVERRUN_STATUS or INTERNAL_BUS_ERROR_STATUS in      this register are set to '1'. (R/WC).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INT_BUS_ERR_STS</name>
                     <description>This bit is set to '1' whenever the channel tries to write an incoming byte into an invalid area of the internal      addressing space. This could happen if the OOB Channel Receive Address Register was set to something invalid by firmware. If      this error occurs mid-packet(crossing a boundary into an invalid space), then the remaining data is discarded. (R/WC).</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OVRUN_STS</name>
                     <description>This bit is set to '1' whenever an incoming packet is truncated because it was longer than the RECEIVE_BUFFER_LENGTH      field. Incoming extra bytes are discarded when this error is triggered, but the buffer receives the data up to its limit, for      debugging purposes. (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_EN</name>
                     <description>This bit is set to '1' when firmware sets the bit SET_RECEIVE_AVAILABLE in the OOB Channel Receive Control Register      to '1', to indicate that an SRAM buffer is available to receive the next Down OOB packet. The OOB Channel Receive Address      Register and OOB Channel Receive Length Register must have already been initialized before setting this bit.      This bit is cleared by hardware when the next packet is received. The RECEIVE_DONE_STATUS bit is set to '1' after this bit is      cleared. A '0' in this bit does not necessarily present 'Not Free' status to the eSPI Master. As long as FIFO space is available      for a complete OOB packet, the packet can be input and held in the FIFO until this bit is again set by firmware.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IN_TAG</name>
                     <description>This field holds the 4-bit TAG in the last message received from the Master.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_TX_CTRL</name>
               <description>OOB Channel Transmit Control Register</description>
               <addressOffset>0x264</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_STRT</name>
                     <description>A write of '1' to this bit starts the transmission of an OOB packet defined by the OOB Channel Transmit Address Register and OOB      Channel Transmit Length Register registers. A write of '0' has no effect.      The transmission will be inhibited if the OOB channel is not Ready, as defined in the eSPI OOB Channel Ready Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUTG_TAG</name>
                     <description>This 4-bit value will be inserted as the TAG number in the next transmitted OOB packet. This field must be 0.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_TX_IEN</name>
               <description>OOB Channel Transmit Interrupt Enable Register</description>
               <addressOffset>0x268</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DONE</name>
                     <description>When this bit is '1' an interrupt is generated when the bit TRANSMIT_DONE_STATUS in the OOB Channel Transmit Status      Register is 1. When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHN_EN_CHNG</name>
                     <description>When this bit is '1' an interrupt is generated when the bit CHANNEL_ENABLE_CHANGE_STATUS in the OOB Channel Transmit      Status Register is 1. When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_TX_STS</name>
               <description>OOB Channel Transmit Status Register</description>
               <addressOffset>0x26C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DONE</name>
                     <description>This bit is set to '1' whenever a Transmit operation terminates (TRANSMIT_BUSY in this register goes from '1' to '0'). (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHN_EN_CHNG_STS</name>
                     <description>This bit is set to '1' whenever the eSPI Master changes the state of the OOB Message Channel Enable bit in the OOB      Channel Capabilities and Configurations Master register. (R/WC).</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INT_BUS_ERR_STS</name>
                     <description>This error flag indicates an internal bus violation occurred in trying to transmit. (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT_OVRUN_STS</name>
                     <description>This error flag indicates a Start was attempted while the channel was Busy. Any Transmit in progress is      immediately halted. (R/WC)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BAD_REQ</name>
                     <description>This bit is intended for any situation where a firmware request cannot be started because it expresses      something impossible. This bit will be set for a request to Transmit 0 bytes or if a Transmit length is more than the      selected Max Payload Length. This condition brings the state machine to the Done state, as if something had actually      finished, with everything including the Done interrupt triggered. (R/WC)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUSY</name>
                     <description>This bit is set to '1' when firmware writes '1' to the TRANSMIT_START bit. It is cleared by hardware when      the transfer is complete. If the TRANSMIT_START bit is written '1' while this bit is also '1', then this will set the      START_OVERRUN_STATUS bit to '1' and terminate the transfer attempt immediately (Transmit Done).</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHN_EN_IMG</name>
                     <description>This bit is an image of the OOB Channel Enabled bit in the OOB Channel Receive Control Register register.      It is provided here so that it can be seen with the CHANNEL_ENABLE_CHANGE_STATUS Interrupt Status bit for efficiency.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_FLASH_ADDR_LSW</name>
               <description>Flash Access Channel Flash Address Register</description>
               <addressOffset>0x280</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>FLSW</name>
                     <description>Before starting a Flash access, this field must be initialized to contain the value used by eSPI for addressing the Flash contents.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_BUF_ADDR_LSW</name>
               <description>Flash Access Channel Buffer Address Register</description>
               <addressOffset>0x288</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BLSW</name>
                     <description>Before starting a Flash access, this field must be initialized with the address of the data buffer in the EC's memory space.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_XFR_LEN</name>
               <description>Flash Access Channel Transfer Length Register</description>
               <addressOffset>0x290</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TLEN</name>
                     <description>Before starting a Flash access, this field must be initialized with the total number of bytes to be transferred in the      requested transaction sequence. If the Master attempts to transfer more bytes than this in Read Completions, the transfer is faulted      and the DATA_OVERRUN bit in the Flash Access Channel Status Register register is asserted.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_CTRL</name>
               <description>Flash Access Channel Control Register</description>
               <addressOffset>0x294</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>FSTRT</name>
                     <description>A write of '1' to this bit starts the transmission and sets the Busy status bit. A write of '0' has no effect.      The transmission will be inhibited if the OOB channel is not Ready, as defined in the eSPI Flash Channel Ready Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FUNC</name>
                     <description>This bit selects the requested Flash function as follows:      11=Erase Flash Range=Larger of two ranges, if a choice exists      10=Erase Flash Range=Smaller of two ranges, if a choice exists      01=Write to Flash      00=Read from Flash.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>TAG</name>
                     <description>This field should always be written to zero, which is the only expected Tag value for Flash Access traffic. It provides      the 4-bit TAG value in the eSPI Transaction Header sent by the EC. Completion traffic from the Master is required to match this field also.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>ABRT</name>
                     <description>By writing '1' to this bit while Busy==1, the transaction sequence last triggered by the Start bit is terminated, and the      Busy bit is cleared, at the next protocol-compliant opportunity. The clearing of the Busy bit will set the DONE status bit and the      ABORTED_BY_SLAVE status bit is set to '1' to acknowledge this specific action as the cause. The action of writing '1' to this bit is      ignored while Busy==0. This bit reads as '0' always.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_IEN</name>
               <description>Flash Access Channel Interrupt Enable Register</description>
               <addressOffset>0x298</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DONE</name>
                     <description>When this bit is '1' an interrupt is generated when the bit DONE in the Flash Access Channel Status Register is 1.      When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_STS_CHNG</name>
                     <description>When this bit is '1' an interrupt is generated when the bit CHANNEL_ENABLE_CHANGE_STATUS in the Flash Access Channel      Status Register is 1. When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_CFG</name>
               <description>Flash Access Channel Configuration Register</description>
               <addressOffset>0x29C</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00001100</resetValue>
               <fields>
                  <field>
                     <name>BUSY</name>
                     <description>This bit is set to '1' when a '1' is written to the FLASH_START bit, and cleared either by hardware completion of the      requested operation or by firmware writing '1' to the ABORT_ACCESS bit. 1=The Channel is busy. 0=The Channel is not busy.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERAS_BLK_SIZE</name>
                     <description>This is a read-only image of the equivalent field of the eSPI Configuration register. This field is set by the Master to      define what the Erase block size is for the Flash being used, and whether there is a choice available to firmware.      111b = Reserved      110b = Reserved      101b = 256K      100b = 128K      010b = 64K      011b = Both 4K and 64K allowed (see FUNCTION field)      001b = 4K      000b = Reserved.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>MAX_PAYLD_SEL</name>
                     <description>This is a read-only image of the equivalent field of the eSPI Configuration register, set by the Master to declare the      maximum number of bytes that can be used in a single Flash payload, in either direction. It will never be set greater than the value      provided by the EC in the FLASH_MAXIMUM_PAYLOAD_SIZE_SUPPORTED field in the eSPI Flash Channel Capabilities Register.      100b -- 111b = Reserved      011b = 256 bytes      010b = 128 bytes      001b = 64 bytes      000b = Reserved.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>MAX_RD_REQ</name>
                     <description>This comes read-only from the eSPI Configuration register, set by the Master to declare the maximum number of bytes      that can be requested by the EC in a single Flash Read request packet.      111b = 4K bytes      110b = 2K bytes      101b = 1K bytes      100b = 512 bytes      011b = 256 bytes      010b = 128 bytes      001b = 64 bytes      000b = Reserved.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_STS</name>
               <description>Flash Access Channel Status Register</description>
               <addressOffset>0x2A0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CHN_EN</name>
                     <description>This bit is a Read-only image of the bit Flash Access Channel Enable in the eSPI Configuration space. Rising or      falling edges of this bit will set the CHANNEL_ENABLE_CHANGE_STATUS bit to 1, and may be used to trigger interrupts. A falling edge      on this bit, while Busy==1, will also clear the Busy bit and set the DONE bit, with DISABLED_BY_MASTER status.      1=Flash Access Channel Enable bit = 1. 0=Flash Access Channel Enable bit = 0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHN_EN_CHNG</name>
                     <description>0=Flash Access Enable bit in eSPI Configuration space has not been changed since this bit was last cleared.      1=Flash Access Enable bit in eSPI Configuration space has been changed since this bit was last cleared.      The current state of the Flash Access Enable bit can be seen as the read-only bit CHANNEL_ENABLE_STATUS in this register.      This bit is cleared by writing '1'. (R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>1=Channel is done=Busy bit has been cleared since this bit was last cleared. It is cleared by writing '1'. (R/WC)      0=Channel is not done=Busy bit has not been cleared since this bit was last cleared.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIS_MAST</name>
                     <description>This bit is set to '1' if the Flash Channel is disabled by the Master while the Busy bit is '1'. It is cleared by writing '1'. (R/WC)      1=The command finished because the Enable bit became 0. 0=The command finished without a change in the Enable bit.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INT_BUS_ERR</name>
                     <description>This bit is set to '1' if the internal bus master associated with the Flash Access Channel encounters a Bus Fault condition.      It is cleared by writing '1'. (R/WC)      1=Bus Error detected. 0=The command finished without a Bus Error.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ABORT_SLAVE</name>
                     <description>This bit is set to '1' if the Abort bit is set to '1' by firmware while the Busy bit is '1', thereby clearing Busy status.      It is cleared by writing '1'. (R/WC)      1=The command finished because of the Abort bit. 0=The command finished without an Abort bit activation.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DAT_OVRUN</name>
                     <description>This bit is set to '1' by a SUCCESSFUL COMPLETION response by the eSPI Master to a Read sequence, but either without      indicating Final Completion when the requested byte count is reached or with too many bytes provided while indicating Final Completion.      It is cleared by writing '1'. (R/WC)      1=The eSPI Master finished with too much data. 0=The eSPI Master finished without too much data.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INCMPL</name>
                     <description>This bit is set to '1' by a SUCCESSFUL COMPLETION Read response from the eSPI Master, indicating a Final Completion, but      with too few bytes provided for the Transaction step that was issued by the eSPI Slave. It is cleared by writing '1'.      This bit is cleared by writing '1'. (R/WC)      1=The eSPI Master finished with too little data. 0=The eSPI Master finished with at least enough data.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAIL</name>
                     <description>This bit is set to '1' by an explicit UNSUCCESSFUL COMPLETION response from the eSPI Master, which also terminates      the transaction sequence. This may occur if an invalid or illegal section of Flash memory is accessed, and only at Runtime (post-boot).      This bit is cleared by writing '1'. (R/WC)      1=The eSPI Master indicated unsuccessful completion.      0=The eSPI Master indicated successful completion.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT_OVRFLW</name>
                     <description>This bit is set if a command (initiated by setting the Start bit) has been ignored because the Busy bit was already on.      The transfer in progress is also brought to the Done state at the next opportunity allowed by the eSPI protocol, as if the Abort bit      had been set by the firmware, so that this bit will be present at a Done interrupt. This bit is cleared by writing '1'. (R/WC)      This flag represents a serious mis-communication between the firmware and hardware, and should be handled cautiously as a      special case by firmware.      1=Start Overflow. Firmware has attempted to trigger a transaction sequence before allowing the previous sequence to finish and      without using the Abort bit to terminate it first      0=No Start Overflow detected.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BAD_REQ</name>
                     <description>This bit is set to '1' when a firmware Flash Access request is invalid. For example, this bit is set for a request      to Read or Write 0 bytes. This bit is cleared by writing '1'. (R/WC)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>VW_EN_STS</name>
               <description>Virtual Wire Status Register</description>
               <addressOffset>0x2B0</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CHN_EN_STS</name>
                     <description>This bit is a Read-only image of the bit Virtual Wire Channel Enable in the eSPI Configuration space.      1=Virtual Wire Channel Enable bit = 1; 0=Virtual Wire Channel Enable bit = 0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP_ID</name>
               <description>eSPI Capabilities ID Register</description>
               <addressOffset>0x2E0</addressOffset>
               <size>8</size>
               <resetValue>0x01</resetValue>
               <fields>
                  <field>
                     <name>ESP_DEVID</name>
                     <description>The default value should not be changed.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>GLB_CAP0</name>
               <description>eSPI Capabilities Global Capabilities 0 Register</description>
               <addressOffset>0x2E1</addressOffset>
               <size>8</size>
               <resetValue>0x0F</resetValue>
               <fields>
                  <field>
                     <name>PHL_CHN</name>
                     <description>1=Peripheral Channel is supported by the slave; 0=Peripheral Channel not supported by the slave.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VW_CHN</name>
                     <description>1=Virtual Wire Channel is supported by the slave; 0=Virtual Wire Channel Channel not supported by the slave.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OOB_MSG_CHN</name>
                     <description>1=OOB Message Channel is supported by the slave; 0=OOB Message Channel not supported by the slave.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FC_CHN</name>
                     <description>1=Flash Access Channel is supported by the slave; 0=Flash Access Channel not supported by the slave.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>GLB_CAP1</name>
               <description>eSPI Capabilities Global Capabilities 1 Register</description>
               <addressOffset>0x2E2</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>MAX_FREQ</name>
                     <description>This field identifies the maximum frequency of operation supported by the slave. It corresponds to the field      Maximum Frequency Supported, bits [18:16] of the eSPI General Capabilities and Configurations register.      111b - 101b=Reserved      100b=66 MHz      011b=50 MHz      010b=33 MHz      001b=25 MHz      000b=20 MHz (default).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>ALERT</name>
                     <description>This field is a read-only copy of the ALERT Mode field, bit 28 of the Config Offset 8h=General Capabilities      and Configurations Register.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IO_MODE</name>
                     <description>This field identifies the I/O modes supported by the slave. It corresponds to the field I/O Mode Support,      bits [25:24] of the eSPI General Capabilities and Configurations register.      11b=Single, Dual and Quad I/O      10b=Single and Quad I/O      01b=Single and Dual I/O      00b=Single I/O (default).</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PC_CAP</name>
               <description>eSPI Peripheral Channel Capabilities Register</description>
               <addressOffset>0x2E3</addressOffset>
               <size>8</size>
               <resetValue>0x01</resetValue>
               <fields>
                  <field>
                     <name>MAX_PAYLD_SIZE</name>
                     <description>This field identifies the maximum payload size supported by the slave. It corresponds to the field      Peripheral Channel Maximum Payload Size Supported, bits [6:4] of the Peripheral Channel Capabilities and Configurations Register.      111b - 100b=Reserved      011b=256 bytes address aligned max payload size      010b=128 bytes address aligned max payload size      001b=64 bytes address aligned max payload size      000b=Reserved.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>VW_CAP</name>
               <description>eSPI Virtual Wire Channel Capabilities Register</description>
               <addressOffset>0x2E4</addressOffset>
               <size>8</size>
               <resetValue>0x3F</resetValue>
               <fields>
                  <field>
                     <name>MAX_CNT</name>
                     <description>This field identifies the maximum Virtual Wire Count supported by the slave. It corresponds to the field      Maximum Virtual Wire Count Supported, bits [13:8] of the Virtual Wire Channel Capabilities and Configurations Register.      This field must be set to a number greater than or equal to 7h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_CAP</name>
               <description>eSPI OOB Channel Capabilities Register</description>
               <addressOffset>0x2E5</addressOffset>
               <size>8</size>
               <resetValue>0x01</resetValue>
               <fields>
                  <field>
                     <name>MAX_PAYLD_SIZ</name>
                     <description>This field identifies the maximum payload size supported by the slave. It corresponds to the field OOB Message      Channel Maximum Payload Size Supported, bits [6:4] of the OOB Channel Capabilities and Configurations Register.      111b - 100b=Reserved      011b=265 bytes address max payload size      010b=137 bytes address max payload size      001b=73 bytes address max payload size      000b=Reserved.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_CAP</name>
               <description>eSPI Flash Channel Capabilities Register</description>
               <addressOffset>0x2E6</addressOffset>
               <size>8</size>
               <resetValue>0x21</resetValue>
               <fields>
                  <field>
                     <name>MAX_PAY_LD</name>
                     <description>This field identifies the maximum payload size supported by the slave. It corresponds to the field Flash Access      Channel Maximum Payload Size Supported, bits [7:0] of the Flash Channel Capabilities and Configurations Register.      111b - 100b=Reserved      011b=256 bytes address aligned max payload size      010b=128 bytes address aligned max payload size      001b=64 bytes address aligned max payload size      000b=Reserved.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SHAR_MODE</name>
                     <description>This field identifies the flash sharing scheme supported by the slave. It corresponds to the field Flash Sharing Mode,      bit [11] of the Flash Channel Capabilities and Configurations Register.      1=Slave attached flash sharing      0=Master attached flash sharing</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PC_READY</name>
               <description>eSPI Peripheral Channel Ready Register</description>
               <addressOffset>0x2E7</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>PHL_CHN_RDY</name>
                     <description>Firmware sets this bit to '1' to inform the Master than the Peripheral channel is ready for transactions. It corresponds to      the field Peripheral Channel Ready, bit 1 of the Config Offset 10h=Peripheral Channel Capabilities and Configurations Register. It is      forced to '0' while the Peripheral Channel Enabled bit in the Capabilities and Configurations register is 0. Once set to '1' it cannot      be set to '0' by firmware. It is only set to '0' by a reset, or when the Master changes the Enabled bit to '0'.      While this bit is '0' all Bus Master and LTR transactions initiated by the Slave are inhibited.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OOB_READY</name>
               <description>eSPI OOB Channel Ready Register</description>
               <addressOffset>0x2E8</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CHN</name>
                     <description>Firmware sets this bit to '1' to inform the Master that the OOB channel is ready for transactions. It corresponds to      the field OOB Message Channel Ready, bit 1 of Config Offset 30h=OOB ChannelCapabilities and Configurations Register. It is      forced to '0' while the OOB Message Channel Enabled bit in the Capabilities and Configurations register is 0. Once set to '1'      it cannot be set to '0' by firmware. It is only set to '0' by a reset, or when the Master changes the Enabled bit to '0'.      While this bit is '0' all OOB up transactions initiated by the Slave are inhibited.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_READY</name>
               <description>eSPI Flash Channel Ready Register</description>
               <addressOffset>0x2E9</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CHN</name>
                     <description>Firmware sets this bit to '1' to inform the Master that the Flash channel is ready for transactions. It corresponds to      the field Flash Channel Ready, bit 1 of Config Offset 40h=Flash Channel Capabilities and Configurations Register. It is      forced to '0' while the Flash Channel Enabled bit in the Capabilities and Configurations register is 0. Once set to '1'      it cannot be set to '0' by firmware. It is only set to '0'by a reset, or when the Master changes the Enabled bit to '0'.      While this bit is '0' all Flash transactions initiated by the Slave are inhibited.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RESET_STS</name>
               <description>eSPI Reset Interrupt Status Register</description>
               <addressOffset>0x2EA</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ESP_INTR</name>
                     <description>This bit is set to '1' whenever the ESPI_RESET_PIN_STATE bit in this register changes state. It is cleared to      '0' whenever it is written with a '1'. Writes of a '0' have no effect. (R/WC) This bit is the source for the eSPI_RESET Interrupt.      The interrupt is asserted when both this bit and the ESPI_RESET_INTERRUPT_ENABLE bit in the eSPI Reset Interrupt Enable Register are '1'.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESPI_RST_PIN_STATE</name>
                     <description>This field reflects the current state of the eSPI_RESET# pin.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RESET_IEN</name>
               <description>eSPI Reset Interrupt Enable Register</description>
               <addressOffset>0x2EB</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ESP_RIEN</name>
                     <description>1=The RESET_ESPI Interrupt will be asserted when the ESPI_RESET_INTERRUPT_STATUS bit in the eSPI Reset Interrupt      Status Register register is '1'      0=The RESET_ESPI Interrupt will not be asserted.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PLTRST_SRC</name>
               <description>PLTRST Source Register</description>
               <addressOffset>0x2EC</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>SRC</name>
                     <description>1=The PLTRST reset signal is determined a signal external to the eSPI block. The PLTRST# virtual wire is ignored      0=The PLTRST reset signal is determined by the PLTRST# virtual wire.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>VW_READY</name>
               <description>eSPI Virtual Wire Channel Ready Register</description>
               <addressOffset>0x2ED</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CHN</name>
                     <description>Firmware sets this bit to '1' to inform the Master than the Virtual Wire channel is ready for transactions. It corresponds to      the field Virtual Wire Channel Ready, bit 1 of the Config Offset 20h=Channel 1 Capabilities and Configurations Register. It is      forced to '0' while the Virtual Wire Channel Enable bit in the Capabilities and Configurations register is 0. Once set to '1' it cannot      be set to '0' by firmware. It is only set to '0' by a reset, or when the Master changes the Enabled bit to '0'.      While this bit is '0' all Virtual Wire transactions initiated by the Slave are inhibited.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RPMC_OP_DISP_RW</name>
               <description>RPMC OP1 Opcode Display Configuration Register</description>
               <addressOffset>0x300</addressOffset>
               <size>32</size>
               <resetValue>0xFFFFFFFF</resetValue>
               <fields>
                  <field>
                     <name>CS0_DISP048</name>
                     <description>RPMC CS0 display 048 Sel</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS0_DISP848</name>
                     <description>RPMC CS0 display 848 Sel</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS1_DISP048</name>
                     <description>RPMC CS1 display 048 Sel</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS1_DISP848</name>
                     <description>RPMC CS1 display 848 Sel</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TOTAL</name>
                     <description>RPMC Total</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RPMC_NUM_DISP_RW</name>
               <description>RPMC OP1 Opcode Num Counter Register</description>
               <addressOffset>0x304</addressOffset>
               <size>32</size>
               <resetValue>0xFFFFFFFF</resetValue>
               <fields>
                  <field>
                     <name>CS0_OP1</name>
                     <description>RPMC CS0 OP1</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CS0_CNT</name>
                     <description>RPMC CS0 Count</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
                  <field>
                     <name>CS1_OP1</name>
                     <description>RPMC CS1 OP1</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CS1_CNT</name>
                     <description>RPMC CS1 Count</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACTIVATE</name>
               <description>eSPI Activate Register</description>
               <addressOffset>0x330</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>1=Activate. When this bit is '1', the eSPI Logical Device is powered and functional.      0=Deactivate. When this bit is 0, the logical device is powered down and inactive.      Except for the eSPI Activate Register itself, clocks to the block are gated and the eSPI Logical Device will permit the      main oscillator to be shut down.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ADDR</name>
               <description>eSPI I/O Base Address Configuration Register</description>
               <addressOffset>0x334</addressOffset>
               <size>32</size>
               <resetValue>0x002E0000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ESPI_MEM_ADDR</name>
               <description>eSPI Memory Base Address Configuration Register</description>
               <addressOffset>0x338</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MBX_ADDR</name>
               <description>Mailbox Base Address Configuration Register</description>
               <addressOffset>0x33C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EM8042_ADDR</name>
               <description>8042 Emulated Keyboard Controller Base Address Configuration Register</description>
               <addressOffset>0x340</addressOffset>
               <size>32</size>
               <resetValue>0x00600000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC0_ADDR</name>
               <description>ACPI EC 0 Base Address Configuration Register</description>
               <addressOffset>0x344</addressOffset>
               <size>32</size>
               <resetValue>0x00620000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC1_ADDR</name>
               <description>ACPI EC 1 Base Address Configuration Register</description>
               <addressOffset>0x348</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC2_ADDR</name>
               <description>ACPI EC 2 Base Address Configuration Register</description>
               <addressOffset>0x34C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC3_ADDR</name>
               <description>ACPI EC 3 Base Address Configuration Register</description>
               <addressOffset>0x350</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC4_ADDR</name>
               <description>ACPI EC 4 Base Address Configuration Register</description>
               <addressOffset>0x354</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_PM1_ADDR</name>
               <description>ACPI PM1 Base Address Configuration Register</description>
               <addressOffset>0x358</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FAST_KBD_ADDR</name>
               <description>I/O Base Address Configuration Register</description>
               <addressOffset>0x35C</addressOffset>
               <size>32</size>
               <resetValue>0x00920000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>UART0_ADDR</name>
               <description>UART 0 Base Address Configuration Register</description>
               <addressOffset>0x360</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>UART1_ADDR</name>
               <description>UART 1 Base Address Configuration Register</description>
               <addressOffset>0x364</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART1_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI0_ADDR</name>
               <description>Embedded Memory Interface (EMI) 0 BAR Config Register</description>
               <addressOffset>0x368</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI1_ADDR</name>
               <description>Embedded Memory Interface (EMI) 1 BAR Config Register</description>
               <addressOffset>0x36C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI2_ADDR</name>
               <description>Embedded Memory Interface (EMI) 2 BAR Config Register</description>
               <addressOffset>0x370</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PORT80_0_ADDR</name>
               <description>BIOS Debug Port (Port 80) 0 BAR Config Register</description>
               <addressOffset>0x374</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PORT80_1_ADDR</name>
               <description>BIOS Debug Port (Port 80) 1 BAR Config Register</description>
               <addressOffset>0x378</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESP_H_ADDR</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RTC_ADDR</name>
               <description>RTC BAR Config Register</description>
               <addressOffset>0x37C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESPI_HOST_ADDRESS</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>GLUE_ADDR</name>
               <description>GLUE Base Address Configuration Register</description>
               <addressOffset>0x38C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESPI_HOST_ADDRESS</name>
                     <description>These 16 bits are used to match eSPI I/O addresses.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MBX_HOST_SIRQ_IRQ</name>
               <description>Mailbox (MBX_Host_SIRQ Interrupt) Selection Register</description>
               <addressOffset>0x3AC</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MBX_HOST_SMI_IRQ</name>
               <description>Mailbox (MBX_Host_SMI Interrupt) Selection Register</description>
               <addressOffset>0x3AD</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>KIRQ_8042_IRQ</name>
               <description>8042 (KIRQ Interrupt) Selection Register</description>
               <addressOffset>0x3AE</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MIRQ_8042_IRQ</name>
               <description>8042 (MIRQ Interrupt) Selection Register</description>
               <addressOffset>0x3AF</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC0_OBF_IRQ</name>
               <description>ACPI EC 0 (EC_OBF Interrupt) Selection Register</description>
               <addressOffset>0x3B0</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC1_OBF_IRQ</name>
               <description>ACPI EC 1 (EC_OBF Interrupt) Selection Register</description>
               <addressOffset>0x3B1</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC2_OBF_IRQ</name>
               <description>ACPI EC 2 (EC_OBF Interrupt) Selection Register</description>
               <addressOffset>0x3B2</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC3_OBF_IRQ</name>
               <description>ACPI EC 3 (EC_OBF Interrupt) Selection Register</description>
               <addressOffset>0x3B3</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACPI_EC4_OBF_IRQ</name>
               <description>ACPI EC 4 (EC_OBF Interrupt) Selection Register</description>
               <addressOffset>0x3B4</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>UART0_IRQ</name>
               <description>UART 0 (UART Interrupt) Selection Register</description>
               <addressOffset>0x3B5</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>UART1_IRQ</name>
               <description>UART 1 (UART Interrupt) Selection Register</description>
               <addressOffset>0x3B6</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI0_HOST_IRQ</name>
               <description>EMI 0 (Host Event Interrupt) Selection Register</description>
               <addressOffset>0x3B7</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI0_EC_HOST_IRQ</name>
               <description>EMI 0 (EC-to-Host Interrupt) Selection Register</description>
               <addressOffset>0x3B8</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI1_HOST_IRQ</name>
               <description>EMI 1 (Host Event Interrupt) Selection Register</description>
               <addressOffset>0x3B9</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI1_EC_HOST_IRQ</name>
               <description>EMI 1 (EC-to-Host Interrupt) Selection Register</description>
               <addressOffset>0x3BA</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI2_HOST_IRQ</name>
               <description>EMI 2 (Host Event Interrupt) Selection Register</description>
               <addressOffset>0x3BB</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI2_EC_HOST_IRQ</name>
               <description>EMI 2 (EC-to-Host Interrupt) Selection Register</description>
               <addressOffset>0x3BC</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RTC_IRQ</name>
               <description>RTC (RTC Interrupt) Selection Register</description>
               <addressOffset>0x3BD</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_IRQ</name>
               <description>EC (EC_IRQ Interrupt) Selection Register</description>
               <addressOffset>0x3BE</addressOffset>
               <size>8</size>
               <resetValue>0xFF</resetValue>
               <fields>
                  <field>
                     <name>IRQ</name>
                     <description>FFh= IRQ generation from this device is disabled.      FEh-0=Changes in the value of the signal associated with this register are sent as a Virtual Wire transaction to the Master.      The Virtual Wire index is 0 for IRQ values 7Fh to 0h, and the index is 1 for IRQ values FEh to 80h.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RPMC_NUM_DISP_R</name>
               <description>RPMC OP1 Opcode Num Counter Register</description>
               <addressOffset>0x3E4</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0xFFFFFFFF</resetValue>
               <fields>
                  <field>
                     <name>CS0_OP1</name>
                     <description>RPMC CS0 OP1</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CS0_CNT</name>
                     <description>RPMC CS0 Count</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
                  <field>
                     <name>CS1_OP1</name>
                     <description>RPMC CS1 OP1</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CS1_CNT</name>
                     <description>RPMC CS1 Count</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ESPI_VW_ERR</name>
               <description>eSPI Virtual Wire Errors Register</description>
               <addressOffset>0x3F0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>FTL_STS</name>
                     <description>This bit is a Master-readable copy of the Virtual Wire ERROR_FATAL (bit 1 in Slave-to-Master Virtual Wire Index 5h).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLR_FTL_STATUS</name>
                     <description>When this field is written with a 1 the Virtual Wire ERROR_FATAL (bit 1 in Slave-to-Master Virtual Wire Index 5h)      is cleared to 0. Because clearing the status bit changes its state, a Virtual Wire packet reporting the new state will be sent      to the Master. Writes of 0 to this bit have no effect. Reads of this bit always return '0'.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>NFTL_STS</name>
                     <description>This bit is a Master-readable copy of the Virtual Wire ERROR_NON_FATAL (bit 2 in Slave-to-Master Virtual Wire Index 5h).</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLR_NFTL_STS</name>
                     <description>When this field is written with a 1 the Virtual Wire ERROR_NON_- FATAL (bit 2 in Slave-to-Master Virtual Wire Index 5h)      is cleared to 0. Because clearing the status bit changes its state, a Virtual Wire packet reporting the new state will be sent to      the Master. Writes of 0 to this bit have no effect. Reads of this bit always return '0'.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>ESPI_MEMORY</name>
         <version>143b1.0</version>
         <description>The eSPI Memory Component is one of two Logical Devices (along with the I/O Component) that provide access to all the registers in the device.</description>
         <baseAddress>0x400F3800</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x3C0</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>BAR_LDI_MBX_H0</name>
               <description>Mailbox Memory Base Address</description>
               <addressOffset>0x130</addressOffset>
               <size>32</size>
               <resetValue>0x00000001</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_ACPI_EC0_H0</name>
               <description>ACPI EC Channel 0 Memory BAR (LSB)</description>
               <addressOffset>0x13A</addressOffset>
               <size>16</size>
               <resetValue>0x0204</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_ACPI_EC0_H1</name>
               <description>ACPI EC Channel 0 Memory BAR (MSB)</description>
               <addressOffset>0x13C</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_ACPI_EC1_H0</name>
               <description>ACPI EC Channel 1 Memory BAR</description>
               <addressOffset>0x144</addressOffset>
               <size>32</size>
               <resetValue>0x00000307</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_ACPI_EC2_H0</name>
               <description>ACPI EC Channel 2 Memory BAR (LSB)</description>
               <addressOffset>0x14E</addressOffset>
               <size>16</size>
               <resetValue>0x0407</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_ACPI_EC2_H1</name>
               <description>ACPI EC Channel 2 Memory BAR (MSB)</description>
               <addressOffset>0x150</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_ACPI_EC3_H0</name>
               <description>ACPI EC Channel 3 Memory BAR</description>
               <addressOffset>0x158</addressOffset>
               <size>32</size>
               <resetValue>0x00000507</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_ACPI_EC4_H0</name>
               <description>ACPI EC Channel 4 Memory BAR</description>
               <addressOffset>0x15C</addressOffset>
               <size>32</size>
               <resetValue>0x00000607</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_ACPI_EC4_H1</name>
               <description>ACPI EC Channel 4 Memory BAR (MSB)</description>
               <addressOffset>0x160</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_EM0_H0</name>
               <description>Embedded Memory Interface (EMI) 0 Memory Base Address</description>
               <addressOffset>0x16C</addressOffset>
               <size>32</size>
               <resetValue>0x0000101F</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_EM1_H0</name>
               <description>Embedded Memory Interface (EMI) 1 Memory Base Address (LSB)</description>
               <addressOffset>0x176</addressOffset>
               <size>16</size>
               <resetValue>0x111F</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_EM1_H1</name>
               <description>Embedded Memory Interface (EMI) 1 Memory Base Address (MSB)</description>
               <addressOffset>0x178</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDI_EM2_H0</name>
               <description>Embedded Memory Interface (EMI) 2 Memory Base Address</description>
               <addressOffset>0x180</addressOffset>
               <size>32</size>
               <resetValue>0x0000121F</resetValue>
               <fields>
                  <field>
                     <name>MASK</name>
                     <description>These 8 bits are used to mask off address bits in the address match between an eSPI I/O address and the Host Address field of the BARs.      A block of up to 256 8-bit registers can be assigned to one base address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LDN</name>
                     <description>These 6 bits are used to specify a logical device number within a bus. This field is multiplied by 400h to provide the address within the      peripheral bus address. Logical Device Numbers that do not corresponding to logical devices that are present on the device are invalid.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>VIR</name>
                     <description>1=Peripheral Channel I/O for this device is virtualized, and reads and writes are handled in firmware      0=All Peripheral Channel I/O Reads and Writes for this device are completed by hardware.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_SRAM0_H0</name>
               <description>SRAM 0 Memory Base Address Config</description>
               <addressOffset>0x1AC</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACCESS</name>
                     <description>These 2 bits define the access type of access to this SRAM region.      3=Host has Read/write access to the region      2=Host has Write-only access to the region      1=Host has Read-only access to the region      0=Host has no access to this region</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SIZE</name>
                     <description>This field defines the size of the region mapped from Host Memory address space into the internal address space, in powers of 2.      15=The region is 64KB in extent      14=The region is 32KB in extent      ...      1=The region is 2B in extent      0=The region is 1B in extent.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_SRAM0_H1</name>
               <description>SRAM 0 Memory Base Address LSB</description>
               <addressOffset>0x1AE</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ADDR</name>
                     <description>This is the LSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses      to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_SRAM0_H2</name>
               <description>SRAM 0 Memory Base Address MSB</description>
               <addressOffset>0x1B0</addressOffset>
               <size>32</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ADDR</name>
                     <description>This is the MSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses      to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_SRAM1_H0</name>
               <description>SRAM 1 Memory Base Address Config</description>
               <addressOffset>0x1B6</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches.      0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACCESS</name>
                     <description>These 2 bits define the access type of access to this SRAM region.      3=Host has Read/write access to the region      2=Host has Write-only access to the region      1=Host has Read-only access to the region      0=Host has no access to this region</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SIZE</name>
                     <description>This field defines the size of the region mapped from Host Memory address space into the internal address space, in powers of 2.      15=The region is 64KB in extent      14=The region is 32KB in extent      ...      1=The region is 2B in extent      0=The region is 1B in extent.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_SRAM1_H1</name>
               <description>SRAM 1 Memory Base Address LSB</description>
               <addressOffset>0x1B8</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ADDR</name>
                     <description>This is the LSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses      to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_SRAM1_H2</name>
               <description>SRAM 1 Memory Base Address MSB</description>
               <addressOffset>0x1BA</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ADDR</name>
                     <description>This the MSB of the 32-bit field that defines the base address of the internal memory region to which Host accesses      to the region starting at RAM eSPI Host Address are mapped. The least significant 2**RAM SIZE bits are ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BM_STS</name>
               <description>Bus Master Status Register</description>
               <addressOffset>0x200</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_DONE1</name>
                     <description>This bit is set to '1' when a START transfer on Bus Master Channel 1 has completed, and occurs simultaneously with      the clearing of the BM1_BUSY bit. This may happen normally, but it is also guaranteed to happen if any of the Error bits in this      register section (bits[11:2]) is set by an error condition. At the time that this bit is set to '1', the Error bits are guaranteed      to be in their final states, and can be examined. Firmware is required to clear this bit, by writing '1' to this bit position, before      altering any BM1 registers or making a new START request, otherwise interrupts from this block will be unreliable. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BUSY1</name>
                     <description>Hardware sets this bit to 1 when the control bit BM1_START in the Bus Master 1 Control Register is written with a 1.      This bit is cleared when the transfer completes. This may happen normally, but it is guaranteed to happen also if any of the Error bits      in this register section (bits[11:2]) is set by an error condition.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ABORT1_EC</name>
                     <description>This bit is set when the control bit BM1_ABORT in the Bus Master 1 Control Register is written with a 1 during an active      transfer. (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ABORT1_H</name>
                     <description>A '1' in this bit indicates that the last requested Mastering operation was aborted because Bus Mastering has been      disabled by the Host. Bus Mastering is disabled whenever the Peripheral Channel Mastering Enable bit in that register is '0', or the      Peripheral Channel Enable bit is '0'. (R/WC)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ABORT_CH2_ERR</name>
                     <description>This bit is set if an error occurs on Bus Master Channel 2 while a Channel 1 transfer is in progress, if the two channels      are linked. Linkage occurs when bit BM1_WAIT_BM2_NOT_BUSY in register Bus Master 1 Control Register is set to '1'. No traffic will occur      from this channel before the error is posted and the BM1_TRANSFER_DONE bit is set. (R/WC)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT1_OVRFLW</name>
                     <description>This bit is set if the bit BM1_START in the Bus Master 1 Control Register is written with a 1 while the bit BM1_BUSY is 1.      This condition immediately halts the transfer in progress also (BM1_TRANSFER_DONE=1). (R/WC)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DAT1_OVRUN</name>
                     <description>This bit is set if the transfer on Bus Master Channel 1 completed but too many bytes were delivered by the eSPI Host.      Some of the data will not be delivered on the internal bus. (R/WC)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INCMPL1</name>
                     <description>This bit is set if the transfer on Bus Master Channel 1 completed but an insufficient number of bytes were transferred.      Some of the data will not be delivered on the internal bus. (R/WC)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAIL1</name>
                     <description>This bit is set if a Layer 3 transaction from Bus Master Channel 1 completes with an Unsuccessful Completion packet from      the eSPI Host. For example, this will happen if the START request attempts to read from a forbidden or unmapped address in System Memory.      Bad Writes, however, cannot be flagged this way, and will be silently dropped by the eSPI Host without setting this bit. (R/WC)</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INTR1_BUS_ERR</name>
                     <description>This bit is set if a transfer on Bus Master Channel 1 is terminated due to a bus error internal to the EC. This can happen      if an invalid address is provided in the Bus Master 1 internal Address register. (R/WC)</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BAD1_REQ</name>
                     <description>This bit is set, and the START request is terminated immediately (BM1_TRANSFER_DONE=1) without triggering traffic, if      register contents are invalid at the time the BM1_START bit is written to '1' by firmware.  (R/WC)      Examples of a Bad Request are:      Length of zero      Length greater than 4K (1000h)      Host Address and Length together specifying a request that crosses a 4KByte boundary. This might violate the Scatter/Gather structure      of the Host memory, so is not allowed.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_DONE2</name>
                     <description>This bit is set to '1' when a START transfer on Bus Master Channel 2 has completed, and occurs simultaneously with the      clearing of the BM2_BUSY bit. This may happen normally, but it is guaranteed to happen also if any of the Error bits in this register      section (bits[27:18]) is set by an error condition. At the time that this bit is set to '1', the Error bits are guaranteed to be in their      final states, and can be examined. (R/WC)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BUSY2</name>
                     <description>Hardware sets this bit to 1 when the control bit BM2_START in the Bus Master 2 Control Register is written with a 1.      This bit is cleared when the transfer completes. This may happen normally, but it is guaranteed to happen also if any of the Error bits      in this register section (bits[27:18]) is set by an error condition.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ABORT2_EC</name>
                     <description>This bit is set when the control bit BM2_ABORT in the Bus Master 2 Control Register is written with a 1 during an active transfer. (R/WC)</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ABORT2_H</name>
                     <description>A '1' in this bit indicates that the last requested Mastering operation was aborted because Bus Mastering has been disabled      by the Host. Bus Mastering is disabled whenever the Peripheral Channel Mastering Enable bit in that register is '0', or the Peripheral      Channel Enable bit is '0'. (R/WC)</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ABORT_CH1_ERR</name>
                     <description>This bit is set if an error occurs on Bus Master Channel 1 while a Channel 2 transfer is in progress, if the two channels      are linked. Linkage occurs when bit BM2_WAIT_BM1_NOT_BUSY in register Bus Master 2 Control Register is set to '1'. No traffic will occur      from this channel before the error is posted and the BM2_TRANSFER_DONE bit is set. (R/WC)</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT2_OVRFLW</name>
                     <description>This bit is set if the bit BM2_START in the Bus Master 2 Control Register is written with a 1 while the bit BM2_BUSY is 1.      This condition immediately halts the transfer in progress also (BM2_TRANSFER_DONE=1). (R/WC)</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DAT2_OVRUN</name>
                     <description>This bit is set if the transfer on Bus Master Channel 2 completed but too many bytes were delivered by the eSPI Host.      Some of the data will not be delivered on the internal bus. (R/WC)</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INCMPL2</name>
                     <description>This bit is set if the transfer on Bus Master Channel 2 completed but an insufficient number of bytes were transferred.      Some of the data will not be delivered on the internal bus. (R/WC)</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAIL2</name>
                     <description>This bit is set if a Layer 3 transaction from Bus Master Channel 2 completes with an Unsuccessful Completion packet from the      eSPI Host. For example, this will happen if the START request attempts to read from a forbidden or unmapped address in System Memory.      Bad Writes, however, cannot be flagged this way, and will be silently dropped by the eSPI Host without setting this bit. (R/WC)</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INTR2_BUS_ERR</name>
                     <description>This bit is set if a transfer on Bus Master Channel 2 is terminated due to a bus error internal to the EC. This can happen      if an invalid address is provided in the Bus Master 2 internal Address register. (R/WC)</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BAD2_REQ</name>
                     <description>This bit is set, and the START request is terminated immediately (BM2_TRANSFER_DONE=1) without triggering traffic, if      register contents are invalid at the time the BM2_START bit is written to '1' by firmware. (R/WC)      Examples of a Bad Request are:      Length of zero, or Length greater than 4K (1000h)      Host Address and Length together specifying a request that crosses a 4KByte boundary. This might violate the Scatter/Gather      structure of the Host memory, so is not allowed.</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BM_IEN</name>
               <description>Bus Master Interrupt Enable Register</description>
               <addressOffset>0x204</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX1_DONE_EN</name>
                     <description>When this bit is '1' an interrupt is generated when the bit BM1_TRANSFER_DONE in the Bus Master Status Register is 1.      When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX2_DONE_EN</name>
                     <description>When this bit is '1' an interrupt is generated when the bit BM2_TRANSFER_DONE in the Bus Master Status Register is 1.      When this bit is '0', the status bit will not generate an interrupt.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BM_CFG</name>
               <description>Bus Master Configuration Register</description>
               <addressOffset>0x208</addressOffset>
               <size>32</size>
               <resetValue>0x00010000</resetValue>
               <fields>
                  <field>
                     <name>TAG1</name>
                     <description>This 4-bit Tag value is included in all eSPI traffic originating from the BM1 Bus Master instance.      This bit should not be modified while the bit BM1_BUSY in the Bus Master Status Register is '1'.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>TAG2</name>
                     <description>This 4-bit Tag value is included in all eSPI traffic originating from the BM2 Bus Master instance.      This bit should not be modified while the bit BM2_BUSY in the Bus Master Status Register is '1'.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BM1_CTRL</name>
               <description>Bus Master 1 Control Register</description>
               <addressOffset>0x210</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>START</name>
                     <description>A write of '1' to this bit starts a Bus Master transfer on Bus Master Channel 1. A write of 0 has no effect. Reads of this bit       return 0. The transmission will be inhibited if the Peripheral channel is not Ready, as defined in the eSPI Peripheral Channel Ready Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ABORT</name>
                     <description>A write of '1' to this bit will cause an active transfer on Bus Master Channel 1 to terminate at the next point allowed by      the eSPI protocol. A write of 0 has no effect. Reads of this bit return 0. If this bit is written to 1 by firmware, there is no guarantee      that any data will have been transferred.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_INTER_INCR</name>
                     <description>1=The internal address will be incremented after each transfer to eSPI      0=The internal address will remain fixed for the entire Bus Master transfer. This may be used to transfer data to or from an on-chip      FIFO instead of a region of memory, or to fill a region of Host memory from a single byte value.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BM1WAIT_BM2NOTBUSY</name>
                     <description>1=The transfer on Bus Master Channel 1 will be held until a transfer in progress on Bus Master Channel 2 has completed.      If that transfer completes unsuccessfully, then this transfer will also terminate, before generating any traffic, with the      BM1_ABORTED_BY_CH2_ERROR flag set.      0=The transfer on Bus Master Channel 1 will proceed independently of the status of Bus Master Channel 2.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CYC_TYPE</name>
                     <description>This field provides the cycle type to use inside the eSPI transaction header:      11b=Memory Write, 64-bit addressing      10b=Memory Read, 64-bit addressing      01b=Memory Write, 32-bit addressing      00b=Memory Read, 32-bit addressing.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>LEN</name>
                     <description>This field sets the length in bytes of a transfer on Bus Master Channel 1. A value of zero, or a value greater than exactly      4K (0x1000) is illegal. Any length which, in combination with the Bus Master 1 Host Address register, will cause the transfer to cross      a 4K-byte boundary in System Memory is also illegal. These illegal settings will cause a request to terminate immediately, with no      traffic, and with Bad Request error status posted.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BM1_HOST_ADDR_LSW</name>
               <description>Bus Master 1 Host Address Register (DWord 0)</description>
               <addressOffset>0x214</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LSDW</name>
                     <description>This register sets bits [31:0] of the Host address used for a transfer on Bus Master Channel 1. This address, combined with      the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BM1_HOST_ADDR_MSW</name>
               <description>Bus Master 1 Host Address Register (DWord 1)</description>
               <addressOffset>0x218</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MSDW</name>
                     <description>This register sets bits [63:32] of the Host address used for a transfer on Bus Master Channel 1. This address, combined with      the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BM1_EC_ADDR_LSW</name>
               <description>Bus Master 1 Internal Address Register</description>
               <addressOffset>0x21C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IN_ADDR</name>
                     <description>This register sets the internal address to be used for a transfer on Bus Master Channel 1.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>30</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BM2_CTRL</name>
               <description>Bus Master 2 Control Register</description>
               <addressOffset>0x224</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>START</name>
                     <description>A write of '1' to this bit starts a Bus Master transfer on Bus Master Channel 2. A write of 0 has no effect. Reads of this bit       return 0. The transmission will be inhibited if the Peripheral channel is not Ready, as defined in the eSPI Peripheral Channel Ready Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ABORT</name>
                     <description>A write of '1' to this bit will cause an active transfer on Bus Master Channel 2 to terminate at the next point allowed by      the eSPI protocol. A write of 0 has no effect. Reads of this bit return 0. If this bit is written to 1 by firmware, there is no guarantee      that any data will have been transferred.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_INTER_INCR</name>
                     <description>1=The internal address will be incremented after each transfer to eSPI      0=The internal address will remain fixed for the entire Bus Master transfer. This may be used to transfer data to or from an on-chip      FIFO instead of a region of memory, or to fill a region of Host memory from a single byte value.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BM2WAIT_BM1NOTBUSY</name>
                     <description>1=The transfer on Bus Master Channel 2 will be held until a transfer in progress on Bus Master Channel 1 has completed.      If that transfer completes unsuccessfully, then this transfer will also terminate, before generating any traffic, with the      BM2_ABORTED_BY_CH1_ERROR flag set.      0=The transfer on Bus Master Channel 2 will proceed independently of the status of Bus Master Channel 1.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CYC_TYPE</name>
                     <description>This field provides the cycle type to use inside the eSPI transaction header:      11b=Memory Write, 64-bit addressing      10b=Memory Read, 64-bit addressing      01b=Memory Write, 32-bit addressing      00b=Memory Read, 32-bit addressing.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>LEN</name>
                     <description>This field sets the length in bytes of a transfer on Bus Master Channel 2. A value of zero, or a value greater than exactly      4K (0x1000) is illegal. Any length which, in combination with the Bus Master 2 Host Address register, will cause the transfer to cross      a 4K-byte boundary in System Memory is also illegal. These illegal settings will cause a request to terminate immediately, with no      traffic, and with Bad Request error status posted.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BM2_HOST_ADDR_LSW</name>
               <description>Bus Master 2 Host Address Register (DWord 0)</description>
               <addressOffset>0x228</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LSDW</name>
                     <description>This register sets bits [31:0] of the Host address used for a transfer on Bus Master Channel 2. This address, combined with      the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BM2_HOST_ADDR_MSW</name>
               <description>Bus Master 2 Host Address Register (DWord 1)</description>
               <addressOffset>0x22C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MSDW</name>
                     <description>This register sets bits [63:32] of the Host address used for a transfer on Bus Master Channel 2. This address, combined with      the Length, must not cross a 4K boundary, or else the START request will terminate without traffic, posting the Bad Request error status.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BM2_EC_ADDR_LSW</name>
               <description>Bus Master 2 Internal Address Register</description>
               <addressOffset>0x230</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IN_ADDR</name>
                     <description>This register sets the internal address to be used for a transfer on Bus Master Channel 2.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>30</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_MBX_H0</name>
               <description>Mailbox Memory BAR Configuration Register (Word 0)</description>
               <addressOffset>0x330</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_MBX_H1</name>
               <description>Mailbox Memory BAR Configuration Register (Word 1)</description>
               <addressOffset>0x332</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W0</name>
                     <description>Bits[15:0] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_MBX_H2</name>
               <description>Mailbox Memory BAR Configuration Register (Word 2)</description>
               <addressOffset>0x334</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W1</name>
                     <description>Bits[31:16] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_MBX_H3</name>
               <description>Mailbox Memory BAR Configuration Register (Word 3)</description>
               <addressOffset>0x336</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W2</name>
                     <description>Bits[47:32] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_MBX_H4</name>
               <description>Mailbox Memory BAR Configuration Register (Word 4)</description>
               <addressOffset>0x338</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W3</name>
                     <description>Bits[63:48] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC0_H0</name>
               <description>ACPI EC Channel 0 Memory BAR Configuration Register (Word 0)</description>
               <addressOffset>0x33A</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC0_H1</name>
               <description>ACPI EC Channel 0 Memory BAR Configuration Register (Word 1)</description>
               <addressOffset>0x33C</addressOffset>
               <size>16</size>
               <resetValue>0x0062</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W0</name>
                     <description>Bits[15:0] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC0_H2</name>
               <description>ACPI EC Channel 0 Memory BAR Configuration Register (Word 2)</description>
               <addressOffset>0x33E</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W1</name>
                     <description>Bits[31:16] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC0_H3</name>
               <description>ACPI EC Channel 0 Memory BAR Configuration Register (Word 3)</description>
               <addressOffset>0x340</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W2</name>
                     <description>Bits[47:32] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC0_H4</name>
               <description>ACPI EC Channel 0 Memory BAR Configuration Register (Word 4)</description>
               <addressOffset>0x342</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W3</name>
                     <description>Bits[63:48] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC1_H0</name>
               <description>ACPI EC Channel 1 Memory BAR Configuration Register (Word 0)</description>
               <addressOffset>0x344</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC1_H1</name>
               <description>ACPI EC Channel 1 Memory BAR Configuration Register (Word 1)</description>
               <addressOffset>0x346</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W0</name>
                     <description>Bits[15:0] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC1_H2</name>
               <description>ACPI EC Channel 1 Memory BAR Configuration Register (Word 2)</description>
               <addressOffset>0x348</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W1</name>
                     <description>Bits[31:16] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC1_H3</name>
               <description>ACPI EC Channel 1 Memory BAR Configuration Register (Word 3)</description>
               <addressOffset>0x34A</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W2</name>
                     <description>Bits[47:32] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC1_H4</name>
               <description>ACPI EC Channel 1 Memory BAR Configuration Register (Word 4)</description>
               <addressOffset>0x34C</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W3</name>
                     <description>Bits[63:48] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC2_H0</name>
               <description>ACPI EC Channel 2 Memory BAR Configuration Register (Word 0)</description>
               <addressOffset>0x34E</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC2_H1</name>
               <description>ACPI EC Channel 2 Memory BAR Configuration Register (Word 1)</description>
               <addressOffset>0x350</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W0</name>
                     <description>Bits[15:0] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC2_H2</name>
               <description>ACPI EC Channel 2 Memory BAR Configuration Register (Word 2)</description>
               <addressOffset>0x352</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W1</name>
                     <description>Bits[31:16] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC2_H3</name>
               <description>ACPI EC Channel 2 Memory BAR Configuration Register (Word 3)</description>
               <addressOffset>0x354</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W2</name>
                     <description>Bits[47:32] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC2_H4</name>
               <description>ACPI EC Channel 2 Memory BAR Configuration Register (Word 4)</description>
               <addressOffset>0x356</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W3</name>
                     <description>Bits[63:48] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC3_H0</name>
               <description>ACPI EC Channel 3 Memory BAR Configuration Register (Word 0)</description>
               <addressOffset>0x358</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC3_H1</name>
               <description>ACPI EC Channel 3 Memory BAR Configuration Register (Word 1)</description>
               <addressOffset>0x35A</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W0</name>
                     <description>Bits[15:0] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC3_H2</name>
               <description>ACPI EC Channel 3 Memory BAR Configuration Register (Word 2)</description>
               <addressOffset>0x35C</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W1</name>
                     <description>Bits[31:16] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC3_H3</name>
               <description>ACPI EC Channel 3 Memory BAR Configuration Register (Word 3)</description>
               <addressOffset>0x35E</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W2</name>
                     <description>Bits[47:32] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC3_H4</name>
               <description>ACPI EC Channel 3 Memory BAR Configuration Register (Word 4)</description>
               <addressOffset>0x360</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W3</name>
                     <description>Bits[63:48] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC4_H0</name>
               <description>ACPI EC Channel 4 Memory BAR Configuration Register (Word 0)</description>
               <addressOffset>0x362</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC4_H1</name>
               <description>ACPI EC Channel 4 Memory BAR Configuration Register (Word 1)</description>
               <addressOffset>0x364</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W0</name>
                     <description>Bits[15:0] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC4_H2</name>
               <description>ACPI EC Channel 4 Memory BAR Configuration Register (Word 2)</description>
               <addressOffset>0x366</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W1</name>
                     <description>Bits[31:16] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC4_H3</name>
               <description>ACPI EC Channel 4 Memory BAR Configuration Register (Word 3)</description>
               <addressOffset>0x368</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W2</name>
                     <description>Bits[47:32] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_ACPI_EC4_H4</name>
               <description>ACPI EC Channel 4 Memory BAR Configuration Register (Word 4)</description>
               <addressOffset>0x36A</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W3</name>
                     <description>Bits[63:48] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_EM0_H0</name>
               <description>EMI 0 Memory BAR Configuration Register (Word 0)</description>
               <addressOffset>0x36C</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_EM0_H1</name>
               <description>EMI 0 Memory BAR Configuration Address Register  (Word 1)</description>
               <addressOffset>0x36E</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W0</name>
                     <description>Bits[15:0] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BAR_LDH_EM0_H2</name>
               <description>EMI 0 Memory BAR Configuration Address Register  (Word 2)</description>
               <addressOffset>0x370</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESP_H_ADDR_W1</name>
                     <description>Bits[31:16] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_0_MEM_BAR_CFG_W3</name>
               <description>EMI 0 Memory BAR Configuration Address Register  (Word 3)</description>
               <addressOffset>0x372</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W2</name>
                     <description>Bits[47:32] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_0_MEM_BAR_CFG_W4</name>
               <description>EMI 0 Memory BAR Configuration Address Register  (Word 4)</description>
               <addressOffset>0x374</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W3</name>
                     <description>Bits[63:48] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_1_MEM_BAR_CFG_W0</name>
               <description>EMI 1 Memory BAR Configuration Register (Word 0) )</description>
               <addressOffset>0x376</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_1_MEM_BAR_CFG_W1</name>
               <description>EMI 1 Memory BAR Configuration Register (Word 1) )</description>
               <addressOffset>0x378</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W0</name>
                     <description>Bits[15:0] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_1_MEM_BAR_CFG_W2</name>
               <description>EMI 1 Memory BAR Configuration Register (Word 2) )</description>
               <addressOffset>0x37A</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W1</name>
                     <description>Bits[31:16] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_1_MEM_BAR_CFG_W3</name>
               <description>EMI 1 Memory BAR Configuration Register (Word 3) )</description>
               <addressOffset>0x37C</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W2</name>
                     <description>Bits[47:32] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_1_MEM_BAR_CFG_W4</name>
               <description>EMI 1 Memory BAR Configuration Register (Word 4) )</description>
               <addressOffset>0x37E</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W3</name>
                     <description>Bits[63:48] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_2_MEM_BAR_CFG_W0</name>
               <description>EMI 2 Memory BAR Configuration Register (Word 0) )</description>
               <addressOffset>0x380</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_2_MEM_BAR_CFG_W1</name>
               <description>EMI 2 Memory BAR Configuration Register (Word 1) )</description>
               <addressOffset>0x382</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W0</name>
                     <description>Bits[15:0] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_2_MEM_BAR_CFG_W2</name>
               <description>EMI 2 Memory BAR Configuration Register (Word 2) )</description>
               <addressOffset>0x384</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W1</name>
                     <description>Bits[31:16] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_2_MEM_BAR_CFG_W3</name>
               <description>EMI 2 Memory BAR Configuration Register (Word 3) )</description>
               <addressOffset>0x386</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W2</name>
                     <description>Bits[47:32] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMI_2_MEM_BAR_CFG_W4</name>
               <description>EMI 2 Memory BAR Configuration Register (Word 4) )</description>
               <addressOffset>0x388</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W3</name>
                     <description>Bits[63:48] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SRAM_0_MEM_BAR_CFG_W0</name>
               <description>SRAM BAR 0 Configuration Register (Word 0) )</description>
               <addressOffset>0x3AC</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SRAM_0_MEM_BAR_CFG_W1</name>
               <description>SRAM BAR 0 Configuration Register (Word 1) )</description>
               <addressOffset>0x3AE</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W0</name>
                     <description>Bits[15:0] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SRAM_0_MEM_BAR_CFG_W2</name>
               <description>SRAM BAR 0 Configuration Register (Word 2) )</description>
               <addressOffset>0x3B0</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W1</name>
                     <description>Bits[31:16] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SRAM_0_MEM_BAR_CFG_W3</name>
               <description>SRAM BAR 0 Configuration Register (Word 3) )</description>
               <addressOffset>0x3B2</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W2</name>
                     <description>Bits[47:32] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SRAM_0_MEM_BAR_CFG_W4</name>
               <description>SRAM BAR 0 Configuration Register (Word 4) )</description>
               <addressOffset>0x3B4</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W3</name>
                     <description>Bits[63:48] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SRAM_1_MEM_BAR_CFG_W0</name>
               <description>SRAM BAR 1 Configuration Register (Word 0) )</description>
               <addressOffset>0x3B6</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VALID</name>
                     <description>1=The BAR is valid and will participate in eSPI matches. 0=The BAR is ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SRAM_1_MEM_BAR_CFG_W1</name>
               <description>SRAM BAR 1 Configuration Register (Word 1) )</description>
               <addressOffset>0x3B8</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W0</name>
                     <description>Bits[15:0] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SRAM_1_MEM_BAR_CFG_W2</name>
               <description>SRAM BAR 1 Configuration Register (Word 2) )</description>
               <addressOffset>0x3BA</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W1</name>
                     <description>Bits[31:16] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SRAM_1_MEM_BAR_CFG_W3</name>
               <description>SRAM BAR 1 Configuration Register (Word 3) )</description>
               <addressOffset>0x3BC</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W2</name>
                     <description>Bits[47:32] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SRAM_1_MEM_BAR_CFG_W4</name>
               <description>SRAM BAR 1 Configuration Register (Word 4) )</description>
               <addressOffset>0x3BE</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ESPI_HOST_ADDRESS_W3</name>
                     <description>Bits[63:48] of the 64 bits that are used to match eSPI memory addresses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>ESPI_MSVW00_06</name>
         <version>143c1.0</version>
         <description>The Virtual Wire Channel permits the System to emulate a set of wires that interconnect the system Core Logic with the EC.</description>
         <baseAddress>0x400F9C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x54</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ24</name>
            <value>15</value>
         </interrupt>
         <registers>
            <register>
               <name>MSVW00_DW0</name>
               <description>Master-to-Slave Virtual Wire 0 Register (DW 0)</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000002</resetValue>
               <fields>
                  <field>
                     <name>M2S_2H_BACKUP</name>
                     <description>The Boot ROM firmware will copy this field into the SRC3 to SRC0 bits of the Master-to-Slave Virtual Wire Register      that corresponds to Virtual Wire Index 2h on a RESET_SYS. If software always saves the state of the Index 2h SRC bits on the falling      edge of the SUSWARN# virtual wire, the state of the four SRC bits will be synchronized to the state of the four bits in the core logic.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>INDEX</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction      matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the      transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the      INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is      asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW00_DW1</name>
               <description>Master-to-Slave Virtual Wire 0 Register (DW 1)</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x04040404</resetValue>
               <fields>
                  <field>
                     <name>SRC0IRQ_SEL</name>
                     <description>A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC1IRQ_SEL</name>
                     <description>A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC2IRQ_SEL</name>
                     <description>A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC3IRQ_SEL</name>
                     <description>A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW00_DW2</name>
               <description>Master-to-Slave Virtual Wire 0 Register (DW 2)</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW01_DW0</name>
               <description>Master-to-Slave Virtual Wire 1 Register (DW 0)</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000003</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction      matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the      transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the      INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is      asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW01_DW1</name>
               <description>Master-to-Slave Virtual Wire 1 Register  (DW 1)</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x04040404</resetValue>
               <fields>
                  <field>
                     <name>SRC0IRQ_SEL</name>
                     <description>A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC1IRQ_SEL</name>
                     <description>A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC2IRQ_SEL</name>
                     <description>A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC3IRQ_SEL</name>
                     <description>A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW01_DW2</name>
               <description>Master-to-Slave Virtual Wire 1 Register (DW 2)</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW02_DW0</name>
               <description>Master-to-Slave Virtual Wire 2 Register (DW 0)</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000307</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction      matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the      transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the      INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is      asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW02_DW1</name>
               <description>Master-to-Slave Virtual Wire 2 Register (DW 1)</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x04040404</resetValue>
               <fields>
                  <field>
                     <name>SRC0IRQ_SEL</name>
                     <description>A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC1IRQ_SEL</name>
                     <description>A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC2IRQ_SEL</name>
                     <description>A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC3IRQ_SEL</name>
                     <description>A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW02_DW2</name>
               <description>Master-to-Slave Virtual Wire 2 Register (DW 2)</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW03_DW0</name>
               <description>Master-to-Slave Virtual Wire 3 Register (DW 0)</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000041</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction      matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the      transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the      INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is      asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW03_DW1</name>
               <description>Master-to-Slave Virtual Wire 3 Register (DW 1)</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x04040404</resetValue>
               <fields>
                  <field>
                     <name>SRC0IRQ_SEL</name>
                     <description>A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC1IRQ_SEL</name>
                     <description>A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC2IRQ_SEL</name>
                     <description>A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC3IRQ_SEL</name>
                     <description>A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW03_DW2</name>
               <description>Master-to-Slave Virtual Wire 3 Register (DW 2)</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW04_DW0</name>
               <description>Master-to-Slave Virtual Wire 4 Register (DW 0)</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <resetValue>0x00000042</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction      matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the      transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the      INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is      asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW04_DW1</name>
               <description>Master-to-Slave Virtual Wire 4 Register (DW 1)</description>
               <addressOffset>0x34</addressOffset>
               <size>32</size>
               <resetValue>0x04040404</resetValue>
               <fields>
                  <field>
                     <name>SRC0IRQ_SEL</name>
                     <description>A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC1IRQ_SEL</name>
                     <description>A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC2IRQ_SEL</name>
                     <description>A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC3IRQ_SEL</name>
                     <description>A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW04_DW2</name>
               <description>Master-to-Slave Virtual Wire 4 Register (DW 2)</description>
               <addressOffset>0x38</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW05_DW0</name>
               <description>Master-to-Slave Virtual Wire 5 Register (DW 0)</description>
               <addressOffset>0x3C</addressOffset>
               <size>32</size>
               <resetValue>0x00000043</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction      matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the      transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the      INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is      asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW05_DW1</name>
               <description>Master-to-Slave Virtual Wire 5 Register (DW 1)</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x04040404</resetValue>
               <fields>
                  <field>
                     <name>SRC0IRQ_SEL</name>
                     <description>A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC1IRQ_SEL</name>
                     <description>A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC2IRQ_SEL</name>
                     <description>A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC3IRQ_SEL</name>
                     <description>A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW05_DW2</name>
               <description>Master-to-Slave Virtual Wire 5 Register (DW 2)</description>
               <addressOffset>0x44</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW06_DW0</name>
               <description>Master-to-Slave Virtual Wire 6 Register (DW 0)</description>
               <addressOffset>0x48</addressOffset>
               <size>32</size>
               <resetValue>0x00000044</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction      matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the      transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the      INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is      asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW06_DW1</name>
               <description>Master-to-Slave Virtual Wire 6 Register (DW 1)</description>
               <addressOffset>0x4C</addressOffset>
               <size>32</size>
               <resetValue>0x04040404</resetValue>
               <fields>
                  <field>
                     <name>SRC0IRQ_SEL</name>
                     <description>A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC1IRQ_SEL</name>
                     <description>A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC2IRQ_SEL</name>
                     <description>A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC3IRQ_SEL</name>
                     <description>A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW06_DW2</name>
               <description>Master-to-Slave Virtual Wire 6 Register (DW 2)</description>
               <addressOffset>0x50</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>ESPI_MSVW07_10</name>
         <version>143d1.0</version>
         <description>The ESPI VW Channel permits the System to emulate a set of wires that interconnect the system Core Logic with the EC.</description>
         <groupName>ESPI_MSVW07_1</groupName>
         <prependToName>ESPI_MSVW07_1_</prependToName>
         <baseAddress>0x400F9C54</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x30</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ25</name>
            <value>16</value>
         </interrupt>
         <registers>
            <register>
               <name>MSVW07_DW0</name>
               <description>Master-to-Slave Virtual Wire 7 Register (DW 0)</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000347</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction      matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the      transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the      INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is      asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW07_DW1</name>
               <description>Master-to-Slave Virtual Wire 7 Register (DW 1)</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x04040404</resetValue>
               <fields>
                  <field>
                     <name>SRC0IRQ_SEL</name>
                     <description>A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC1IRQ_SEL</name>
                     <description>A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC2IRQ_SEL</name>
                     <description>A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC3IRQ_SEL</name>
                     <description>A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW07_DW2</name>
               <description>Master-to-Slave Virtual Wire 7 Register (DW 2)</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW08_DW0</name>
               <description>Master-to-Slave Virtual Wire 8 Register (DW 0)</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x0000004A</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction      matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the      transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the      INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is      asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW08_DW1</name>
               <description>Master-to-Slave Virtual Wire 8 Register (DW 1)</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x04040404</resetValue>
               <fields>
                  <field>
                     <name>SRC0IRQ_SEL</name>
                     <description>A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC1IRQ_SEL</name>
                     <description>A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC2IRQ_SEL</name>
                     <description>A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC3IRQ_SEL</name>
                     <description>A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW08_DW2</name>
               <description>Master-to-Slave Virtual Wire 8 Register (DW 2)</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW09_DW0</name>
               <description>Master-to-Slave Virtual Wire 9 Register (DW 0)</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction      matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the      transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the      INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is      asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW09_DW1</name>
               <description>Master-to-Slave Virtual Wire 9 Register (DW 1)</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x04040404</resetValue>
               <fields>
                  <field>
                     <name>SRC0IRQ_SEL</name>
                     <description>A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC1IRQ_SEL</name>
                     <description>A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC2IRQ_SEL</name>
                     <description>A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC3IRQ_SEL</name>
                     <description>A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW09_DW2</name>
               <description>Master-to-Slave Virtual Wire 9 Register (DW 2)</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW10_DW0</name>
               <description>Master-to-Slave Virtual Wire 10 Register (DW 0)</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. When the Index field of an incoming Master-to-Slave Virtual Wire transaction      matches this value, the fields SRC0, SRC1, SRC2 and SRC3 are updated by the data contained in the respective bit positions in the      transaction. Setting the INDEX field to 0 disables the register from accepting any Virtual Wire traffic from the Master. Setting the      INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>MTOS_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by M2S RESET SRC is      asserted. If MTOS_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW10_DW1</name>
               <description>Master-to-Slave Virtual Wire 10 Register (DW 1)</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x04040404</resetValue>
               <fields>
                  <field>
                     <name>SRC0IRQ_SEL</name>
                     <description>A change in the value of SRC0 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC1IRQ_SEL</name>
                     <description>A change in the value of SRC1 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC2IRQ_SEL</name>
                     <description>A change in the value of SRC2 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRC3IRQ_SEL</name>
                     <description>A change in the value of SRC3 will generate an interrupt to the EC. Changes in the SRC register value caused by a Reset Event      do not generate an interrupt.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSVW10_DW2</name>
               <description>Master-to-Slave Virtual Wire 10 Register (DW 2)</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Master-to-Slave data for Bit Position 0 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Master-to-Slave data for Bit Position 1 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Master-to-Slave data for Bit Position 2 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Master-to-Slave data for Bit Position 3 for the virtual wire associated with the index defined by INDEX.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>ESPI_SMVW00_10</name>
         <version>143e1.0</version>
         <description>The ESPI VW Channel permits the System to emulate a set of wires that interconnect the system Core Logic with the EC.</description>
         <groupName>ESPI_SMVW00_1</groupName>
         <prependToName>ESPI_SMVW00_1_</prependToName>
         <baseAddress>0x400F9E00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x58</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>SMVW00_DW0</name>
               <description>Slave-to-Master Virtual Wire 0 Register (DWord 0)</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x0000C004</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1,      SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register      from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOM_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOM_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is      asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CHNG0</name>
                     <description>This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG1</name>
                     <description>This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG2</name>
                     <description>This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG3</name>
                     <description>This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW00_DW1</name>
               <description>Slave-to-Master Virtual Wire 0 Register (DWord 1)</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x01010000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW01_DW0</name>
               <description>Slave-to-Master Virtual Wire 1 Register (DWord 0)</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000005</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1,      SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register      from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOM_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOM_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is      asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CHNG0</name>
                     <description>This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG1</name>
                     <description>This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG2</name>
                     <description>This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG3</name>
                     <description>This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW01_DW1</name>
               <description>Slave-to-Master Virtual Wire 1 Register (DWord 1)</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW02_DW0</name>
               <description>Slave-to-Master Virtual Wire 2 Register (DWord 0)</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00007306</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1,      SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register      from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOM_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOM_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is      asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CHNG0</name>
                     <description>This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG1</name>
                     <description>This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG2</name>
                     <description>This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG3</name>
                     <description>This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW02_DW1</name>
               <description>Slave-to-Master Virtual Wire 2 Register (DWord 1)</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00010101</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW03_DW0</name>
               <description>Slave-to-Master Virtual Wire 3 Register (DWord 0)</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000040</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1,      SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register      from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOM_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOM_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is      asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CHNG0</name>
                     <description>This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG1</name>
                     <description>This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG2</name>
                     <description>This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG3</name>
                     <description>This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW03_DW1</name>
               <description>Slave-to-Master Virtual Wire 3 Register (DWord 1)</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW04_DW0</name>
               <description>Slave-to-Master Virtual Wire 4 Register (DWord 0)</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000045</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1,      SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register      from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOM_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOM_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is      asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CHNG0</name>
                     <description>This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG1</name>
                     <description>This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG2</name>
                     <description>This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG3</name>
                     <description>This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW04_DW1</name>
               <description>Slave-to-Master Virtual Wire 4 Register (DWord 1)</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW05_DW0</name>
               <description>Slave-to-Master Virtual Wire 5 Register (DWord 0)</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000046</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1,      SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register      from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOM_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOM_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is      asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CHNG0</name>
                     <description>This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG1</name>
                     <description>This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG2</name>
                     <description>This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG3</name>
                     <description>This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW05_DW1</name>
               <description>Slave-to-Master Virtual Wire 5 Register (DWord 1)</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW06_DW0</name>
               <description>Slave-to-Master Virtual Wire 6 Register (DWord 0)</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1,      SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register      from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOM_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOM_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is      asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CHNG0</name>
                     <description>This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG1</name>
                     <description>This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG2</name>
                     <description>This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG3</name>
                     <description>This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW06_DW1</name>
               <description>Slave-to-Master Virtual Wire 6 Register (DWord 1)</description>
               <addressOffset>0x34</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW07_DW0</name>
               <description>Slave-to-Master Virtual Wire 7 Register (DWord 0)</description>
               <addressOffset>0x38</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1,      SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register      from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOM_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOM_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is      asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CHNG0</name>
                     <description>This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG1</name>
                     <description>This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG2</name>
                     <description>This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG3</name>
                     <description>This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW07_DW1</name>
               <description>Slave-to-Master Virtual Wire 7 Register (DWord 1)</description>
               <addressOffset>0x3C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW08_DW0</name>
               <description>Slave-to-Master Virtual Wire 8 Register (DWord 0)</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1,      SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register      from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOM_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOM_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is      asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CHNG0</name>
                     <description>This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG1</name>
                     <description>This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG2</name>
                     <description>This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG3</name>
                     <description>This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW08_DW1</name>
               <description>Slave-to-Master Virtual Wire 8 Register (DWord 1)</description>
               <addressOffset>0x44</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW09_DW0</name>
               <description>Slave-to-Master Virtual Wire 9 Register (DWord 0)</description>
               <addressOffset>0x48</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1,      SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register      from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOM_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOM_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is      asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CHNG0</name>
                     <description>This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG1</name>
                     <description>This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG2</name>
                     <description>This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG3</name>
                     <description>This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW09_DW1</name>
               <description>Slave-to-Master Virtual Wire 9 Register (DWord 1)</description>
               <addressOffset>0x4C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW10_DW0</name>
               <description>Slave-to-Master Virtual Wire 10 Register (DWord 0)</description>
               <addressOffset>0x50</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IND</name>
                     <description>The Index for SRC0, SRC1, SRC2 and SRC3. A write to this register that changes the value of any one or more of SRC0, SRC1,      SRC2 or SRC3 will generate a Slave-to-Master Virtual Wire transaction with this index. Setting the INDEX field to 0 disables the register      from generating any Virtual Wire traffic to the Master. Setting the INDEX field to 1 is illegal, since INDEX=1 is reserved for Serial IRQ.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOM_SRC</name>
                     <description>This field determines which reset signal in addition to RESET_SYS resets SRC[3:0] in this register:      3=PLTRST      2=RESET_SIO      1=RESET_SYS. This is the only reset signal that will reset the SRC fields.      0=RESET_ESPI.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOM_R_STATE</name>
                     <description>The four bits in this field are loaded into SRC0, SRC1, SRC2 and SRC3 when the reset signal selected by S2M RESET SRC is      asserted. If STOM_SRC is set for RESET_SYS, the SRC bits are set to the default value of this field, rather than its programmed value,      since this field is also reset on RESET_SYS.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CHNG0</name>
                     <description>This bit is set to 1 whenever the value in Bit0 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG1</name>
                     <description>This bit is set to 1 whenever the value in Bit1 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG2</name>
                     <description>This bit is set to 1 whenever the value in Bit2 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHNG3</name>
                     <description>This bit is set to 1 whenever the value in Bit3 in this register changes. This bit is set to 0 whenever the 4 data bits in      this register are transmitted to the Host by a Slave-to-Master Virtual Wire transaction. It is also set to 0 when this entire register is      reset, ignoring any change in the data bit value caused by the reset event.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMVW10_DW1</name>
               <description>Slave-to-Master Virtual Wire 10 Register (DWord 1)</description>
               <addressOffset>0x54</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRC0</name>
                     <description>Slave-to-Master data for Bit Position 0 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC1</name>
                     <description>Slave-to-Master data for Bit Position 1 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC2</name>
                     <description>Slave-to-Master data for Bit Position 2 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SRC3</name>
                     <description>Slave-to-Master data for Bit Position 3 for the virtual wire associated with the index defined by INDEX. The most recent value      of this bit is transmitted to the Master, even if the bit changes multiple times before the Master issues the Virtual Wire read transaction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>GCR</name>
         <version>1011.0</version>
         <description>The Logical Device Configuration registers support motherboard designs in        which the resources required by their components are known and assigned by the BIOS        at POST.</description>
         <baseAddress>0x400FFF00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x27</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>LDN</name>
               <description>A write to this register selects the current logical device. This allows access to the control and configuration     registers for each logical device. Note: The Activate command operates only on the selected logical device.</description>
               <addressOffset>0x7</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>DEV_REV</name>
               <description>A read-only register which provides device revision information.</description>
               <addressOffset>0x1C</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0xA0</resetValue>
            </register>
            <register>
               <name>DEV_SUBID</name>
               <description>A read-only register which provides device sub ID information.</description>
               <addressOffset>0x1D</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x74</resetValue>
            </register>
            <register>
               <name>DEV_ID</name>
               <description>A read-only register which provides device identification LSB.</description>
               <addressOffset>0x1E</addressOffset>
               <size>16</size>
               <access>read-only</access>
               <resetValue>0x0022</resetValue>
            </register>
            <register>
               <name>LEG_DEV_ID</name>
               <description>A read-only register which provides legacy device identification.</description>
               <addressOffset>0x20</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0xFE</resetValue>
            </register>
            <register>
               <name>LEG_DEV_REV</name>
               <description>A read-only register which provides legacy device revision information.</description>
               <addressOffset>0x21</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0xA0</resetValue>
            </register>
            <register>
               <name>OTP_ID</name>
               <description>A read-only register which provides OTP ID information.</description>
               <addressOffset>0x24</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>VLD_ID</name>
               <description>A read-only register which provides Validation ID information.</description>
               <addressOffset>0x25</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>BR_REV_ID</name>
               <description>A read-only register which provides Boot ROM Revision ID information.</description>
               <addressOffset>0x26</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>KBC</name>
         <version>321.0</version>
         <description>The Keyboard Controller is a Host/EC Message Interface with hardware assists to emulate 8042 behavior.</description>
         <baseAddress>0x400F0400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x331</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>KBC_OBE</name>
            <value>58</value>
         </interrupt>
         <interrupt>
            <name>KBC_IBF</name>
            <value>59</value>
         </interrupt>
         <registers>
            <register>
               <name>HOST_DATA</name>
               <description>READ_DATA. This 8-bit register is read-only. When read by the Host, the PCOBF and/or AUXOBF interrupts are cleared and the     OBF flag in the status register is cleared.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HOST_EC_DATA</name>
               <description>WRITE_DATA. This 8-bit register is write-only. When written, the C/D bit in the Keyboard Status Read Register is cleared     to '0', signifying data, and the IBF in the same register is set to '1'. When the Runtime Register at offset 0h is read by the Host,     it functions as the EC_HOST Data / AUX Data Register.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HOST_WC</name>
               <description>WRITE_CMD. This 8-bit register is write-only and is an alias of the register at offset 0h. When written, the C/D bit in the     Keyboard Status Read Register is set to '1', signifying a command, and the IBF in the same register is set to '1'. When the Runtime     Register at offset 4h is read by the Host, it functions as the Keyboard Status Read Register.</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HOST_RS</name>
               <description>Keyboard Status Read Register. This register is a read-only alias of the EC Keyboard Status Register.</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>OBF</name>
                     <description>Output Buffer Full.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF</name>
                     <description>Input Buffer Full.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD0</name>
                     <description>User-defined data.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMD_DAT</name>
                     <description>Command Data. This bit specifies whether the input data register contains data or a command ('0' = data, '1' = command).</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD1</name>
                     <description>User-defined data.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AUXOBF</name>
                     <description>Auxiliary Output Buffer Full.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD2</name>
                     <description>User-defined data.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>H2EC_DATA</name>
               <description>Host_EC Data/Cmd Register  This register is an alias of the HOST_EC Data / CMD Register. When read at the EC-Only offset     of 0h, it returns the data written by the Host to either Runtime Register offset 0h or Runtime Register offset 04h.</description>
               <addressOffset>0x100</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>EC_DATA</name>
               <description>EC_Host Data Register</description>
               <addressOffset>0x100</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>EC_KBD_STS</name>
               <description>Keyboard Status Register</description>
               <addressOffset>0x104</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>OBF</name>
                     <description>Output Buffer Full.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF</name>
                     <description>Input Buffer Full.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD0</name>
                     <description>User-defined data.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMD_DAT</name>
                     <description>Command Data. This bit specifies whether the input data register contains data or a command ('0' = data, '1' = command).</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD1</name>
                     <description>User-defined data.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AUXOBF</name>
                     <description>Auxiliary Output Buffer Full.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD2</name>
                     <description>User-defined data.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>KBCTRL</name>
               <description>Keyboard Control Register</description>
               <addressOffset>0x108</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>UD3</name>
                     <description>User-defined data.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAEN</name>
                     <description>Software-assist enable. 1=This bit allows control of the GATEA20 signal via firmware      0=GATEA20 corresponds to either the last Host-initiated control of GATEA20 or the firmware write to the Keyboard Control Register or the EC AUX Data Register.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PCOBFEN</name>
                     <description>1= reflects the value written to the PCOBF Register, 0=PCOBF reflects the status of writes to the EC Data Register</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD4</name>
                     <description>User-defined data.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>OBFEN</name>
                     <description>When this bit is '1', the system interrupt signal KIRQ is driven by the bit PCOBF and MIRQ is driven by AUXOBF. When this      bit is '0', KIRQ and MIRQ are driven low. This bit must not be changed when OBF of the status register is equal to '1'.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD5</name>
                     <description>User-defined data.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AUXH</name>
                     <description>AUX in Hardware. 1=AUXOBF of the Keyboard Status Read Register is set in hardware by a write to the EC AUX Data Register                0=AUXOBF is not modified in hardware, but can be read and written by the EC using the EC-Only alias of the EC Keyboard Status Register</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_AUX_DATA</name>
               <description>EC_Host Aux Register. This 8-bit register is write-only. When written, the C/D in the Keyboard Status Read Register is cleared     to '0', signifying data, and the IBF in the same register is set to '1'. When the Runtime Register at offset 0h is read by the Host, it     functions as the EC_HOST Data / AUX Data Register.</description>
               <addressOffset>0x10C</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>PCOBF</name>
               <description>8042 Emulated Keyboard Controller PCOBF Register</description>
               <addressOffset>0x114</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>PCOBF</name>
                     <description>PCOBF Register: If enabled by the bit OBFEN, the bit PCOBF is gated onto KIRQ. The KIRQ signal is a system interrupt      which signifies that the EC has written to the HOST2EC Data Register (EC-Only offset 0h).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACTIVATE</name>
               <description>Activate Register</description>
               <addressOffset>0x330</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>1=The 8042 Interface is powered and functional. 0=The 8042 Interface is powered down and inactive.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>PORT92</name>
         <version>441.0</version>
         <description>The registers listed in the Configuration Register Summary table are for a single instance of the Legacy Port92/GATEA20 logic.</description>
         <baseAddress>0x400F2000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x331</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>RT_PORT92</name>
               <description>PORT92 Register: The registers listed in the Runtime Register Summary table are for a single instance of the Legacy Port92/GATEA20 logic.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ALT_CPU_RST</name>
                     <description>This bit provides an alternate means to generate a CPU_RESET pulse.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GATE_A20</name>
                     <description>This bit provides an alternate means for system control of the GATEA20 pin. ALT_A20 low drives GATEA20 low, if A20 from the      keyboard controller is also low. When Port 92 is enabled, writing a 1 to this bit forces ALT_A20 high. ALT_A20 high drives GATEA20      high regardless of the state of A20 from the keyboard controller. 0=ALT_A20 is driven low; 1=ALT_A20 is driven high</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>GATEA20</name>
               <description>GATEA20 Control Register</description>
               <addressOffset>0x100</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>GATEA20</name>
                     <description>0=The GATEA20 output is driven low, 1=The GATEA20 output is driven high.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SETGA20L</name>
               <description>SETGA20L Register. A write to this register sets GATEA20 in the GATEA20 Control Register.</description>
               <addressOffset>0x108</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>RSTGA20L</name>
               <description>RSTGA20L Register. A write to this register sets GATEA20 in the GATEA20 Control Register.</description>
               <addressOffset>0x10C</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>EN</name>
               <description>PORT92 Enable Register</description>
               <addressOffset>0x330</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>When this bit is '1', the Port92h Register is enabled. When this bit is '0', the Port92h Register is disabled, and Host      writes to Host address 92h are ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>ACPI_EC0</name>
         <version>11.0</version>
         <description>The ACPI-ECI provides a four byte full duplex data interface.</description>
         <groupName>ACPI_EC</groupName>
         <prependToName>ACPI_EC_</prependToName>
         <baseAddress>0x400F0800</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10C</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>AEC0_IBF</name>
            <value>45</value>
         </interrupt>
         <interrupt>
            <name>AEC0_OBE</name>
            <value>46</value>
         </interrupt>
         <registers>
            <register>
               <name>OS_DATA</name>
               <description>This is byte n of the 32-bit ACPI-OS DATA BYTES[3:0]. Writes by the ACPI_OS to the ACPI-OS DATA BYTES[n] are aliased    to the OS2EC DATA BYTES[n]. Reads by the ACPI_OS from the ACPI-OS DATA BYTES[n] are aliased to the EC2OS DATA BYTES[n].</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>OS_CMD</name>
               <description>Writes to the this register are aliased in the OS2EC Data EC Byte 0 Register.              Writes to this register also set the CMD and IBF bits in the OS STATUS OS Register</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>OS_STS</name>
               <description>OS STATUS</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>OBF</name>
                     <description>The Output Buffer Full bit is set to indicate that a the ACPI_EC has written a data to the ACPI_OS and that data is ready.     This bit is automatically cleared when all the data has been read by the ACPI_OS.     Note: The setting and clearing of this OBF varies depending on the setting FOUR_BYTE_ACCESS bit in the OS Byte Control Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF</name>
                     <description>The Input Buffer Full bit is set to indicate that a the ACPI_OS has written a command or data to the ACPI_EC and that     data is ready. This bit is automatically cleared when data has been read by the ACPI_EC.     Note: The setting and clearing of this IBF varies depending on the setting of the following bits: CMD bit in this register     and FOUR_BYTE_ACCESS bit in the OS Byte Control Register.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD1B</name>
                     <description>User Defined</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMD</name>
                     <description>This bit is set when the OS2EC Data EC Byte 0 Register contains a command byte written into ACPI OS COMMAND Register;     this bit is cleared when the OS2EC DATA BYTES[3:0] contains a data byte written into the ACPI-OS DATA BYTES[3:0].     This bit is hardware controlled:     ACPI_OS writes to any of the four ACPI-OS DATA BYTES[3:0] bytes clears this bit     ACPI_OS writes to the ACPI OS COMMAND Register sets this bit.     Note: This bit allows the embedded controller to differentiate the start of a command sequence from a data byte write operation.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BURST</name>
                     <description>The BURST bit is set when the ACPI_EC is in Burst Mode for polled command processing; the BURST bit is cleared when the     ACPI_EC is in Normal mode for interrupt-driven command processing. The BURST bit is is an ACPI_EC-maintained software flag that     indicates the embedded controller has received the Burst Enable command from the host, has halted normal processing, and is     waiting for a series of commands to be sent from the host.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCI_EVT</name>
                     <description>This bit is set by software when an SCI event is pending; i.e., the ACPI_EC is requesting an SCI query; SCI Event flag     is clear when no SCI events are pending. This bit is an ACPI_EC-maintained software flag that is set when the embedded controller     has detected an internal event that requires operating system attention. The ACPI_EC sets this bit before generating an SCI to the OS.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMI_EVT</name>
                     <description>This bit is set when an SMI event is pending; i.e., the ACPI_EC is requesting an SMI query; This bit is cleared when     no SMI events are pending. This bit is an ACPI_EC-maintained software flag that is set when the ACPI_EC has detected an internal     event that requires system management interrupt handler attention. The ACPI_EC sets this bit before generating an SMI.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD0B</name>
                     <description>User Defined</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OS_BYTE_CTRL</name>
               <description>OS Byte Control Register</description>
               <addressOffset>0x5</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>FOUR_BYTE_ACCESS</name>
                     <description>When this bit is set to '1', the ACPI Embedded Controller Interface (ACPI-ECI) accesses four bytes through the     ACPI-OS DATA BYTES[3:0]. When this bit is cleared to '0', the ACPI Embedded Controller Interface (ACPI-ECI) accesses one byte     through the ACPI OS Data Register Byte 0 Register. This corresponds to Legacy Mode. This bit effects the behaviour of the IBF     and OBF bits in the OS STATUS OS Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC2OS_DATA</name>
               <description>This is byte n of the 32-bit EC2OS DATA BYTES[3:0]. Writes by the ACPI_EC to the EC2OS DATA BYTES[3:0] are aliased to the    ACPI-OS DATA BYTES[3:0].</description>
               <addressOffset>0x100</addressOffset>
               <size>32</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>EC_STATUS</name>
               <description>EC STATUS</description>
               <addressOffset>0x104</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>OBF</name>
                     <description>The Output Buffer Full bit is set to indicate that a the ACPI_EC has written a data to the ACPI_OS and that data is ready.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF</name>
                     <description>The Input Buffer Full bit is set to indicate that a the ACPI_OS has written a command or data to the ACPI_EC and that data is ready.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD1A</name>
                     <description>UD1A User Defined</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMD</name>
                     <description>This bit is set when the OS2EC Data EC Byte 0 Register contains a command byte written into ACPI OS COMMAND Register</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BURST</name>
                     <description>The BURST bit is set when the ACPI_EC is in Burst Mode</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCI_EVT</name>
                     <description>This bit is set by software when an SCI event is pending</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMI_EVT</name>
                     <description>This bit is set when an SMI event is pending</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD0A</name>
                     <description>User Defined</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_BYTE_CTRL</name>
               <description>Byte Control EC-Register</description>
               <addressOffset>0x105</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>FOUR_BYTE_ACCESS</name>
                     <description>When this bit is set to '1', the ACPI Embedded Controller Interface (ACPI-ECI) accesses four bytes through the     ACPI-OS DATA BYTES[3:0]. When this bit is cleared to '0', the ACPI Embedded Controller Interface (ACPI-ECI) accesses one byte     through the ACPI OS Data Register Byte 0 Register. This corresponds to Legacy Mode. This bit effects the behaviour of the IBF     and OBF bits in the OS STATUS OS Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OS2EC_DATA</name>
               <description>OS_TO_EC_DATA_BYTE_n. This is byte n of the 32-bit OS2EC DATA BYTES[3:0]. When the CMD bit in the OS STATUS OS Register    is cleared to '0', reads by the ACPI_EC from the OS2EC DATA BYTES[3:0] are aliased to the ACPI-OS DATA BYTES[3:0].</description>
               <addressOffset>0x108</addressOffset>
               <size>32</size>
               <resetValue>0x00</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="ACPI_EC0">
         <name>ACPI_EC1</name>
         <baseAddress>0x400F0C00</baseAddress>
         <interrupt>
            <name>AEC1_IBF</name>
            <value>47</value>
         </interrupt>
         <interrupt>
            <name>AEC1_OBE</name>
            <value>48</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="ACPI_EC0">
         <name>ACPI_EC2</name>
         <baseAddress>0x400F1000</baseAddress>
         <interrupt>
            <name>AEC2_IBF</name>
            <value>49</value>
         </interrupt>
         <interrupt>
            <name>AEC2_OBE</name>
            <value>50</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="ACPI_EC0">
         <name>ACPI_EC3</name>
         <baseAddress>0x400F1400</baseAddress>
         <interrupt>
            <name>AEC3_IBF</name>
            <value>51</value>
         </interrupt>
         <interrupt>
            <name>AEC3_OBE</name>
            <value>52</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="ACPI_EC0">
         <name>ACPI_EC4</name>
         <baseAddress>0x400F1800</baseAddress>
         <interrupt>
            <name>AEC4_IBF</name>
            <value>53</value>
         </interrupt>
         <interrupt>
            <name>AEC4_OBE</name>
            <value>54</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>PM1</name>
         <version>21.0</version>
         <description>These features comply with the ACPI Specification through a combination of hardware and EC software.</description>
         <baseAddress>0x400F1C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x111</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>APM1_CTL</name>
            <value>55</value>
         </interrupt>
         <interrupt>
            <name>APM1_EN</name>
            <value>56</value>
         </interrupt>
         <interrupt>
            <name>APM1_STS</name>
            <value>57</value>
         </interrupt>
         <registers>
            <register>
               <name>H_PM1_STS2</name>
               <description>PM1 Status 2</description>
               <addressOffset>0x1</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>PWRBTN_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Power button status if the power is controlled by the EC.      The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLPBTN_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Sleep button status if the sleep state is controlled by      the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software      control.(R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a RTC status. The Host writing a one to this bit can also      clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWRBTNOR_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Power button override event status if the power      is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated hardware      event under software control.(R/WC)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WAK_STS</name>
                     <description>This bit can be set or cleared by the EC. The Host writing a one to this bit can also clear this bit. (R/WC)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>H_PM1_EN2</name>
               <description>PM1 Enable 2</description>
               <addressOffset>0x3</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>PWRBTN_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLPBTN_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>H_PM1_CTRL2</name>
               <description>PM1 Control 2</description>
               <addressOffset>0x5</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>PWRBTNOR_EN</name>
                     <description>This bit can be set or cleared by the Host, read by the EC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLP_TYP</name>
                     <description>These bits can be set or cleared by the Host, read by the EC.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SLP_EN</name>
                     <description>SLP_EN</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_PM1_STS2</name>
               <description>PM1 Status 2</description>
               <addressOffset>0x101</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWRBTN_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Power button status if the power is controlled by the EC.      The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLPBTN_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Sleep button status if the sleep state is controlled by      the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software      control.(R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a RTC status. The Host writing a one to this bit can also      clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWRBTNOR_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Power button override event status if the power      is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated hardware      event under software control.(R/WC)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WAK_STS</name>
                     <description>This bit can be set or cleared by the EC. The Host writing a one to this bit can also clear this bit. (R/WC)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_PM1_EN2</name>
               <description>PM1 Enable 2</description>
               <addressOffset>0x103</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWRBTN_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLPBTN_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_PM1_CTRL2</name>
               <description>PM1 Control 2</description>
               <addressOffset>0x105</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWRBTNOR_EN</name>
                     <description>This bit can be set or cleared by the Host, read by the EC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLP_TYP</name>
                     <description>These bits can be set or cleared by the Host, read by the EC.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SLP_EN</name>
                     <description>SLP_EN</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_PM_STS</name>
               <description>PM1 EC PM Status</description>
               <addressOffset>0x110</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_SCI_STS</name>
                     <description>If the EC_SCI_STS bit is '1', an interrupt is generated on the EC_SCI# pin.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD</name>
                     <description>User Defined</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>EMI0</name>
         <version>841.0</version>
         <description>The EMI provides a communication between system host and Embedded Controller.</description>
         <groupName>EMI</groupName>
         <prependToName>EMI_</prependToName>
         <baseAddress>0x400F4000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x140</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>EMI0</name>
            <value>42</value>
         </interrupt>
         <registers>
            <register>
               <name>RT_HOST2EC</name>
               <description>Host-to-EC Mailbox Register</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>RT_EC2HOST</name>
               <description>EC-to-Host Mailbox Register</description>
               <addressOffset>0x1</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>RT_EC_ADDR_LSB</name>
               <description>EC Address Access Control Register</description>
               <addressOffset>0x2</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ACCESS_TYPE</name>
                     <description>This field defines the type of access that occurs when the EC Data Register is read or written.                11b=Auto-increment 32-bit access. 10b=32-bit access. 01b=16-bit access. 00b=8-bit access.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>ADDR</name>
                     <description>This field defines bits[7:2] of EC_Address [15:0]. Bits[1:0] of the EC_Address are always forced to 00b.      The EC_Address is aligned on a DWord boundary. It is the address of the memory being accessed by EC Data Byte 0 Register, which is      an offset from the programmed base address of the selected REGION.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RT_EC_ADDR_MSB</name>
               <description>EC Address Access Control Register</description>
               <addressOffset>0x3</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ADDR</name>
                     <description>This field defines bits[14:8] of EC_Address. Bits[1:0] of the EC_Address are always forced to 00b.      The EC_Address is aligned on a DWord boundary. It is the address of the memory being accessed by EC Data Byte 0 Register, which is      an offset from the programmed base address of the selected REGION.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
                  <field>
                     <name>REGION</name>
                     <description>The field specifies which of two segments in the 32-bit internal address space is to be accessed by the EC_Address[14:2]      to generate accesses to the memory.      1=The address defined by EC_Address[14:2] is relative to the base address specified by the Memory Base Address 1 Register.      0=The address defined by EC_Address[14:2] is relative to the base address specified by the Memory Base Address 0 Register.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RT_DATA</name>
               <description>EC Data Byte Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>RT_INTR_SRC_LSB</name>
               <description>Interrupt Source LSB Register</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_WR</name>
                     <description>EC Mailbox Write. This bit is set when the EC-to-HOST Mailbox Register has been written by the EC at offset 01h      of the EC-Only registers. Note: there is no corresponding mask bit in the Interrupt Mask LSB Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_SWI_LSB</name>
                     <description>EC Software Interrupt Least Significant Bits. These bits are software interrupt bits that may be set by the EC to      notify the host of an event. The meaning of these bits is dependent on the firmware implementation. Each bit in this field is cleared      when written with a '1b'. The ability to clear the bit can be disabled by the EC if the corresponding bit in the Host Clear Enable      Register is set to '0b'. This may be used by firmware for events that cannot be cleared while the event is still active.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RT_INTR_SRC_MSB</name>
               <description>Interrupt Source MSB Register</description>
               <addressOffset>0x9</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_SWI_MSB</name>
                     <description>EC Software Interrupt Most Significant Bits. These bits are software interrupt bits that may be set by the EC to      notify the host of an event. The meaning of these bits is dependent on the firmware implementation. Each bit in this field is cleared      when written with a '1b'. The ability to clear the bit can be disabled by the EC if the corresponding bit in the Host Clear Enable      Register is set to '0b'. This may be used by firmware for events that cannot be cleared while the event is still active.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RT_INTR_MASK_LSB</name>
               <description>Interrupt Mask LSB Register</description>
               <addressOffset>0xA</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>TEST</name>
                     <description>Test Bit.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_SWI_EN_LSB</name>
                     <description>EC Software Interrupt Enable Least Significant Bits. Each bit that is set to '1b' in this field enables the generation      of a Host Event interrupt by the corresponding bit in the EC_SWI field in the Interrupt Source LSB Register.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RT_INTR_MASK_MSB</name>
               <description>Interrupt Mask MSB Register</description>
               <addressOffset>0xB</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_SWI_EN_MSB</name>
                     <description>EC Software Interrupt Enable Most Significant Bits. Each bit that is set to '1b' in this field enables the generation      of a Host Event interrupt by the corresponding bit in the EC_SWI field in the Interrupt Source MSB Register.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RT_APP_ID</name>
               <description>Application ID Register, APPLICATION_ID When this field is 00h it can be written with any value. When set to a non-zero value, writing that value will clear this register to 00h. When set to a non-zero value, writing any value other than the current contents will have no effect.</description>
               <addressOffset>0xC</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>APP_ID_ASGN</name>
               <description>Application ID Assignment Register.</description>
               <addressOffset>0x10</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HOST2EC</name>
               <description>Host-to-EC Mailbox Register, 8-bit mailbox used communicate information from the system host to the embedded controller. Writing this register generates an event to notify the embedded controller. (R/WC)</description>
               <addressOffset>0x100</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>EC2HOST</name>
               <description>EC-to-Host Mailbox Register, 8-bit mailbox used communicate information from the embedded controller to the system host. Writing this register generates an event to notify the system host.</description>
               <addressOffset>0x101</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>MEM0_BASE</name>
               <description>Memory Base Address 0 Register [31:2] This memory base address defines the beginning of region 0 in the Embedded Controller's 32-bit internal address space. Memory allocated to region 0 is intended to be shared between the Host and the EC. The region defined by this base register is used when bit 15 of the EC Address Register is 0. The access will be to a memory location at an offset defined by the EC_Address relative to the beginning of the region defined by this register. Therefore, a read or write to the memory that is triggered by the EC Data Register will occur at Memory_Base_Address_0 + EC_Address.</description>
               <addressOffset>0x104</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MEM0_RD_LIMITS</name>
               <description>Memory Read Limit 0 Register [14:2] Whenever a read of any byte in the EC Data Register is attempted, and bit 15 of EC_Address is 0, the field EC_Address[14:2] in the EC_Address_Register is compared to this field. As long as EC_Address[14:2] is less than this field the EC_Data_Register will be loaded from the 24-bit internal address space.</description>
               <addressOffset>0x108</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>MEM0_WR_LIMITS</name>
               <description>Memory Write Limit 0 Register [14:2] Whenever a write of any byte in EC DATA Register is attempted and bit 15 of EC_Address is 0, the field EC_ADDRESS_MSB in the EC_Address Register is compared to this field. As long as EC_Address[14:2] is less than Memory_Write_Limit_0[14:2] the addressed bytes in the EC DATA Register will be written into the internal 24-bit address space. If EC_Address[14:2] is greater than or equal to the Memory_Write_Limit_0[14:2] no writes will take place.</description>
               <addressOffset>0x10A</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>MEM1_BASE</name>
               <description>Memory Base Address 1 Register. [31:2] This memory base address defines the beginning of region 1 in the Embedded Controller's 32-bit internal address space. Memory allocated to region 1 is intended to be shared between the Host and the EC. The region defined by this base register is used when bit 15 of the EC Address Register is 1. The access will be to a memory location at an offset defined by the EC_Address relative to the beginning of the region defined by this register. Therefore, a read or write to the memory that is triggered by the EC Data Register will occur at Memory_Base_Address_1 + EC_Address.</description>
               <addressOffset>0x10C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MEM1_RD_LIMITS</name>
               <description>Memory Read Limit 1 Register, [14:2]: Whenever a read of any byte in the EC Data Register is attempted, and bit 15 of EC_ADDRESS is 1, the field EC_ADDRESS in the EC_Address_Register is compared to this field. As long as EC_ADDRESS is less than this value, the EC_Data_Register will be loaded from the 24-bit internal address space.</description>
               <addressOffset>0x110</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>MEM1_WR_LIMITS</name>
               <description>Memory Write Limit 1 Register, [14:2]: Whenever a write of any byte in EC DATA Register is attempted and bit 15 of EC_Address is 1, the field EC_Address[14:2] in the EC_Address Register is compared to this field. As long as EC_Address[14:2] is less than Memory_Write_Limit_1[14:2] the addressed bytes in the EC DATA Register will be written into the internal 24-bit address space. If EC_Address[14:2] is greater than or equal to the Memory_Write_Limit_1[14:2] no writes will take place.</description>
               <addressOffset>0x112</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>INTR_SET</name>
               <description>[15:1] Interrupt Set Register, Writing a bit in this field with a '1b' sets the corresponding bit in the Interrupt Source Register to '1b'. Writing a bit in this field with a '0b' has no effect. Reading this field returns the current contents of the Interrupt Source Register.</description>
               <addressOffset>0x114</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>HOST_CLR_EN</name>
               <description>[15:1] Host Clear Enable Register, When a bit in this field is '0b', the corresponding bit in the Interrupt Source Register cannot be cleared by writes to the Interrupt Source Register. When a bit in this field is '1b', the corresponding bit in the Interrupt Source Register can be cleared when that register bit is written with a '1b'.</description>
               <addressOffset>0x116</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>APP_ID_STS0</name>
               <description>Application ID Status register [31:0]</description>
               <addressOffset>0x120</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>APP_ID_STS1</name>
               <description>Application ID Status register [63:32]</description>
               <addressOffset>0x124</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>APP_ID_STS2</name>
               <description>Application ID Status register [95:64]</description>
               <addressOffset>0x128</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>APP_ID_STS3</name>
               <description>Application ID Status register [127:96]</description>
               <addressOffset>0x12C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>APP_ID_STS4</name>
               <description>Application ID Status register [159:128]</description>
               <addressOffset>0x130</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>APP_ID_STS5</name>
               <description>Application ID Status register [191:160]</description>
               <addressOffset>0x134</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>APP_ID_STS6</name>
               <description>Application ID Status register [223:192]</description>
               <addressOffset>0x138</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>APP_ID_STS7</name>
               <description>Application ID Status register [255:224]</description>
               <addressOffset>0x13C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="EMI0">
         <name>EMI1</name>
         <baseAddress>0x400F4400</baseAddress>
         <interrupt>
            <name>EMI1</name>
            <value>43</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="EMI0">
         <name>EMI2</name>
         <baseAddress>0x400F4800</baseAddress>
         <interrupt>
            <name>EMI2</name>
            <value>44</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>MBX</name>
         <version>1501.0</version>
         <description>The Mailbox provides a standard run-time mechanism for the host to communicate with the Embedded Controller (EC).</description>
         <baseAddress>0x400F0000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x130</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>MBOX</name>
            <value>60</value>
         </interrupt>
         <registers>
            <register>
               <name>RT_IDX</name>
               <description>MBX_Index Register</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>RT_DATA</name>
               <description>MBX_Data_Register</description>
               <addressOffset>0x1</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>H2EC</name>
               <description>If enabled, an interrupt to the EC marked by the MBX_DATA bit in the Interrupt Aggregator will be generated whenever the Host writes this register. This register is cleared when written with FFh.</description>
               <addressOffset>0x100</addressOffset>
               <size>32</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>EC2H</name>
               <description>An EC write to this register will set bit EC_WR in the SMI Interrupt Source Register to '1b'. If enabled, this will generate a Host SMI. This register is cleared when written with FFh.</description>
               <addressOffset>0x104</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>SMI_SRC</name>
               <description>SMI Interrupt Source Register</description>
               <addressOffset>0x108</addressOffset>
               <size>32</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_WR</name>
                     <description>EC Mailbox Write. This bit is set automatically when the EC-to-Host Mailbox Register has been written. An SMI or SIRQ      to the Host is generated when n this bit is '1b' and the corresponding bit in the SMI Interrupt Mask Register register is '1b'.      This bit is automatically cleared by a read of the EC-to-Host Mailbox Register through the Host Access Port.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_SWI</name>
                     <description>EC Software Interrupt. An SIRQ to the Host is generated when any bit in this register when this bit is set to '1b' and      the corresponding bit in the SMI Interrupt Mask Register register is '1b'.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMI_MASK</name>
               <description>SMI Interrupt Mask Register</description>
               <addressOffset>0x10C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ECWR_EN</name>
                     <description>EC Mailbox Write.Interrupt Enable. Each bit in this field that is '1b' enables the generation of SIRQ interrupts when the      corresponding bit in the EC_SWI field in the SMI Interrupt Source Register is '1b'.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ECSWI_EN</name>
                     <description>EC Software Interrupt Enable. If this bit is '1b', the bit EC_WR in the SMI Interrupt Source Register is enabled for the      generation of SIRQ or nSMI events.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <cluster>
               <dim>8</dim>
               <dimIncrement>0x4</dimIncrement>
               <name>MBX_REG[%s]</name>
               <description/>
               <addressOffset>0x110</addressOffset>
               <register>
                  <name>u32</name>
                  <description>SOURCE</description>
                  <addressOffset>0x0</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000000</resetValue>
               </register>
               <register>
                  <dim>2</dim>
                  <dimIncrement>2</dimIncrement>
                  <name>u16[%s]</name>
                  <description>ENABLE SET</description>
                  <addressOffset>0x0</addressOffset>
                  <size>16</size>
                  <resetValue>0x00000000</resetValue>
               </register>
               <register>
                  <dim>4</dim>
                  <dimIncrement>1</dimIncrement>
                  <name>u08[%s]</name>
                  <description>RESULT</description>
                  <addressOffset>0x0</addressOffset>
                  <size>8</size>
                  <resetValue>0x00000000</resetValue>
               </register>
            </cluster>
         </registers>
      </peripheral>
      <peripheral>
         <name>UART0</name>
         <version>391.0</version>
         <description>The 16550 UART is a full-function Two Pin Serial Port that supports the standard RS-232 Interface.</description>
         <groupName>UART</groupName>
         <prependToName>UART_</prependToName>
         <baseAddress>0x400F2400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x3F1</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ15</name>
            <value>7</value>
         </interrupt>
         <interrupt>
            <name>UART0</name>
            <value>40</value>
         </interrupt>
         <registers>
            <cluster>
               <name>DATA</name>
               <description>UART when DLAB=0</description>
               <headerStructName>UartData</headerStructName>
               <addressOffset>0x0</addressOffset>
               <register>
                  <name>RX_DAT</name>
                  <description>UART Receive (Read) Buffer Register (DLAB=0)</description>
                  <addressOffset>0x0</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>TX_DAT</name>
                  <description>UART Transmit (Write) Buffer Register (DLAB=0)</description>
                  <addressOffset>0x0</addressOffset>
                  <size>8</size>
                  <access>write-only</access>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>IEN</name>
                  <description>UART Interrupt Enable Register (DLAB=0)</description>
                  <addressOffset>0x1</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>ERDAI</name>
                        <description>ERDAI This bit enables the Received Data Available Interrupt (and timeout interrupts in the FIFO mode) when set to logic '1'.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>ETHREI</name>
                        <description>ETHREI This bit enables the Transmitter Holding Register Empty Interrupt when set to logic '1'.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>ELSI</name>
                        <description>ELSI This bit enables the Received Line Status Interrupt when set to logic '1'.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>EMSI</name>
                        <description>EMSI  This bit enables the MODEM Status Interrupt when set to logic '1'.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>FIFO_CR</name>
                  <description>UART FIFO Control Register</description>
                  <addressOffset>0x2</addressOffset>
                  <size>8</size>
                  <access>write-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>EXRF</name>
                        <description>EXRF Enable XMIT and RECV FIFO.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>CLR_RECV_FIFO</name>
                        <description>CLEAR_RECV_FIFO  Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>CLR_XMIT_FIFO</name>
                        <description>CLEAR_XMIT_FIFO  Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DMA_MODE_SEL</name>
                        <description>DMA_MODE_SELECT  Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RECV_FIFO_TRIG_LVL</name>
                        <description>RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>INT_ID</name>
                  <description>UART Interrupt Identification Register</description>
                  <addressOffset>0x2</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>IPEND</name>
                        <description>IPEND  This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>INTID</name>
                        <description>INTID  These bits identify the highest priority interrupt pending</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>3</bitWidth>
                     </field>
                     <field>
                        <name>FIFO_EN</name>
                        <description>These two bits are set when the FIFO CONTROL Register bit 0 equals 1.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LCR</name>
                  <description>UART Line Control Register</description>
                  <addressOffset>0x3</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>WORD_LEN</name>
                        <description>WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                     <field>
                        <name>STOP_BITS</name>
                        <description>STOP_BITS  This bit specifies the number of stop bits in each transmitted or received serial character.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>EN_PAR</name>
                        <description>ENABLE_PARITY  Parity Enable bit.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PAR_SEL</name>
                        <description>PARITY_SELECT Even Parity Select bit.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>STICK_PAR</name>
                        <description>STICK_PARITY  Stick Parity bit.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>BRK_CTRL</name>
                        <description>BREAK_CONTROL Set Break Control bit</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DLAB</name>
                        <description>DLAB Divisor Latch Access Bit (DLAB).</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>MCR</name>
                  <description>UART Modem Control Register</description>
                  <addressOffset>0x4</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>DTR</name>
                        <description>DTR  This bit controls the Data Terminal Ready (nDTR) output.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RTS</name>
                        <description>RTS  This bit controls the Request To Send (nRTS) output.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OUT1</name>
                        <description>OUT1 This bit controls the Output 1 (OUT1) bit.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OUT2</name>
                        <description>OUT2  This bit is used to enable an UART interrupt.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>LOOPBACK</name>
                        <description>LOOPBACK  This bit provides the loopback feature for diagnostic testing of the Serial Port.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LSR</name>
                  <description>UART Line Status Register</description>
                  <addressOffset>0x5</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>DATA_READY</name>
                        <description>DATA_READY  Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OVERRUN</name>
                        <description>OVERRUN  Overrun Error.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PE</name>
                        <description>PARITY ERROR  Parity Error.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>FRAME_ERR</name>
                        <description>FRAME_ERROR Framing Error.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>BRK_INTR</name>
                        <description>BREAK_INTERRUPT   Break Interrupt.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>TRANS_EMPTY</name>
                        <description>TRANSMIT_EMPTY  Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>TRANS_ERR</name>
                        <description>Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>FIFO_ERR</name>
                        <description>FIFO_ERROR</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>MSR</name>
                  <description>UART Modem Status Register</description>
                  <addressOffset>0x6</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>CTS</name>
                        <description>CTS  Delta Clear To Send (DCTS).</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DSR</name>
                        <description>DSR  Delta Data Set Ready (DDSR).</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RI</name>
                        <description>RI  Trailing Edge of Ring Indicator (TERI).</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DCD</name>
                        <description>DCD  Delta Data Carrier Detect (DDCD).</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nCTS</name>
                        <description>nCTS  This bit is the complement of the Clear To Send (nCTS) input.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nDSR</name>
                        <description>This bit is the complement of the Data Set Ready (nDSR) input.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nRI</name>
                        <description>nRI This bit is the complement of the Ring Indicator (nRI) input.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nDCD</name>
                        <description>nDCD   This bit is the complement of the Data Carrier Detect (nDCD) input.</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>SCR</name>
                  <description>UART Scratchpad Register    This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily.</description>
                  <addressOffset>0x7</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>ACTIVATE</name>
                  <description>UART Activate Register. [0:0] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive.</description>
                  <addressOffset>0x330</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>CFG_SEL</name>
                  <description>UART Config Select Register</description>
                  <addressOffset>0x3F0</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>CLK_SRC</name>
                        <description>CLK_SRC  1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PWR</name>
                        <description>POWER  1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>POLAR</name>
                        <description>POLARITY  1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
            </cluster>
            <cluster>
               <name>DLAB</name>
               <description>UART when DLAB=1</description>
               <alternateCluster>DATA</alternateCluster>
               <headerStructName>UartDlab</headerStructName>
               <addressOffset>0x0</addressOffset>
               <register>
                  <name>BAUDRT_LSB</name>
                  <description>UART Programmable BAUD Rate Generator (LSB) Register (DLAB=1)</description>
                  <addressOffset>0x0</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>BAUDRT_MSB</name>
                  <description>UART Programmable BAUD Rate Generator (MSB) Register (DLAB=1). [6:0] BAUD_RATE_DIVISOR_MSB, [7:7] BAUD_CLK_SEL             1=If CLK_SRC is '0', the baud clock is derived from the 1.8432MHz_Clk. If CLK_SRC is '1', this bit has no effect            0=If CLK_SRC is '0', the baud clock is derived from the 24MHz_Clk. If CLK_SRC is '1', this bit has no effect</description>
                  <addressOffset>0x1</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>FIFO_CR</name>
                  <description>UART FIFO Control Register</description>
                  <addressOffset>0x2</addressOffset>
                  <size>8</size>
                  <access>write-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>EXRF</name>
                        <description>EXRF Enable XMIT and RECV FIFO.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>CLR_RECV_FIFO</name>
                        <description>CLEAR_RECV_FIFO  Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>CLR_XMIT_FIFO</name>
                        <description>CLEAR_XMIT_FIFO  Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DMA_MODE_SEL</name>
                        <description>DMA_MODE_SELECT  Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RECV_FIFO_TRIG_LVL</name>
                        <description>RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>INT_ID</name>
                  <description>UART Interrupt Identification Register</description>
                  <addressOffset>0x2</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>IPEND</name>
                        <description>IPEND  This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>INTID</name>
                        <description>INTID  These bits identify the highest priority interrupt pending</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>3</bitWidth>
                     </field>
                     <field>
                        <name>FIFO_EN</name>
                        <description>These two bits are set when the FIFO CONTROL Register bit 0 equals 1.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LCR</name>
                  <description>UART Line Control Register</description>
                  <addressOffset>0x3</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>WORD_LEN</name>
                        <description>WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                     <field>
                        <name>STOP_BITS</name>
                        <description>STOP_BITS  This bit specifies the number of stop bits in each transmitted or received serial character.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>EN_PAR</name>
                        <description>ENABLE_PARITY  Parity Enable bit.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PAR_SEL</name>
                        <description>PARITY_SELECT Even Parity Select bit.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>STICK_PAR</name>
                        <description>STICK_PARITY  Stick Parity bit.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>BRK_CTRL</name>
                        <description>BREAK_CONTROL Set Break Control bit</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DLAB</name>
                        <description>DLAB Divisor Latch Access Bit (DLAB).</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>MCR</name>
                  <description>UART Modem Control Register</description>
                  <addressOffset>0x4</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>DTR</name>
                        <description>DTR  This bit controls the Data Terminal Ready (nDTR) output.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RTS</name>
                        <description>RTS  This bit controls the Request To Send (nRTS) output.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OUT1</name>
                        <description>OUT1 This bit controls the Output 1 (OUT1) bit.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OUT2</name>
                        <description>OUT2  This bit is used to enable an UART interrupt.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>LOOPBACK</name>
                        <description>LOOPBACK  This bit provides the loopback feature for diagnostic testing of the Serial Port.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LSR</name>
                  <description>UART Line Status Register</description>
                  <addressOffset>0x5</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>DATA_READY</name>
                        <description>DATA_READY  Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OVERRUN</name>
                        <description>OVERRUN  Overrun Error.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PE</name>
                        <description>PARITY ERROR  Parity Error.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>FRAME_ERR</name>
                        <description>FRAME_ERROR Framing Error.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>BRK_INTR</name>
                        <description>BREAK_INTERRUPT   Break Interrupt.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>TRANS_EMPTY</name>
                        <description>TRANSMIT_EMPTY  Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>TRANS_ERR</name>
                        <description>Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>FIFO_ERR</name>
                        <description>FIFO_ERROR</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>MSR</name>
                  <description>UART Modem Status Register</description>
                  <addressOffset>0x6</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>CTS</name>
                        <description>CTS  Delta Clear To Send (DCTS).</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DSR</name>
                        <description>DSR  Delta Data Set Ready (DDSR).</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RI</name>
                        <description>RI  Trailing Edge of Ring Indicator (TERI).</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DCD</name>
                        <description>DCD  Delta Data Carrier Detect (DDCD).</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nCTS</name>
                        <description>nCTS  This bit is the complement of the Clear To Send (nCTS) input.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nDSR</name>
                        <description>This bit is the complement of the Data Set Ready (nDSR) input.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nRI</name>
                        <description>nRI This bit is the complement of the Ring Indicator (nRI) input.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nDCD</name>
                        <description>nDCD   This bit is the complement of the Data Carrier Detect (nDCD) input.</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>SCR</name>
                  <description>UART Scratchpad Register    This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily.</description>
                  <addressOffset>0x7</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>ACTIVATE</name>
                  <description>UART Activate Register. [0:0] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive.</description>
                  <addressOffset>0x330</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>CFG_SEL</name>
                  <description>UART Config Select Register</description>
                  <addressOffset>0x3F0</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>CLK_SRC</name>
                        <description>CLK_SRC  1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PWR</name>
                        <description>POWER  1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>POLAR</name>
                        <description>POLARITY  1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
            </cluster>
         </registers>
      </peripheral>
      <peripheral derivedFrom="UART0">
         <name>UART1</name>
         <baseAddress>0x400F2800</baseAddress>
         <interrupt>
            <name>UART1</name>
            <value>41</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>GPIO</name>
         <version>261.0</version>
         <description>GPIO Pin Control Registers</description>
         <baseAddress>0x40081000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x7C4</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ08</name>
            <value>0</value>
         </interrupt>
         <interrupt>
            <name>GIRQ09</name>
            <value>1</value>
         </interrupt>
         <interrupt>
            <name>GIRQ10</name>
            <value>2</value>
         </interrupt>
         <interrupt>
            <name>GIRQ11</name>
            <value>3</value>
         </interrupt>
         <interrupt>
            <name>GIRQ12</name>
            <value>4</value>
         </interrupt>
         <interrupt>
            <name>GIRQ26</name>
            <value>17</value>
         </interrupt>
         <registers>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL0[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL1[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL3[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x60</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL4[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x80</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL5[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0xa0</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL6[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0xc0</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL7[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0xe0</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL10[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x100</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL11[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x120</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL12[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x140</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL13[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x160</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL14[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x180</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL15[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x1a0</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL16[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x1c0</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL17[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x1e0</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL20[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x200</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL21[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x220</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL22[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x240</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL23[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x260</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL24[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x280</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL25[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x2a0</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL26[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x2c0</addressOffset>
               <size>32</size>
               <resetValue>0x00008040</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>Determines the interrupt capability of the GPIO input.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>Buffer direction when GPIO selected by pin mux 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>GPIO outputs registe select.0=GPIO ALTERNATE_GPIO_DATA 1=GPIO Output Register.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>00 = GPIO Function, 01 = Function 1, 10 = Function 2, 11 = Function 3.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>INP_DIS</name>
                     <description>GPIO input disable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>GPIO Alternate Data Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>GPIO input from pin, independent of the Mux selection for the pin or the Direction.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>6</dim>
               <dimIncrement>4</dimIncrement>
               <name>PARIN[%s]</name>
               <description>The GPIO Input Registers.</description>
               <addressOffset>0x300</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <dim>6</dim>
               <dimIncrement>4</dimIncrement>
               <name>PAROUT[%s]</name>
               <description>The GPIO Output Registers.</description>
               <addressOffset>0x380</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P0[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x500</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P1[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x520</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P2[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x540</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P3[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x560</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P4[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x580</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P5[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x5a0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P6[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x5c0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P7[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x5e0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P10[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x600</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P11[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x620</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P12[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x640</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P13[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x660</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P14[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x680</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P15[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x6a0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P16[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x6c0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P17[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x6e0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P20[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x700</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P21[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x720</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P22[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x740</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P23[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x760</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P24[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x780</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P25[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x7a0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2P26[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x7c0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_CTRL</name>
                     <description>Selects slew rate on the pin. 1=fast 0=slow</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>Selects the drive strength on the pin. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>WDT</name>
         <version>881.0</version>
         <description>The function of the Watchdog Timer is to provide a mechanism to detect if the internal embedded controller has failed.</description>
         <baseAddress>0x40000400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x15</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ21</name>
            <value>13</value>
         </interrupt>
         <interrupt>
            <name>WDT</name>
            <value>171</value>
         </interrupt>
         <registers>
            <register>
               <name>LOAD</name>
               <description>Writing this field reloads the Watch Dog Timer counter.</description>
               <addressOffset>0x0</addressOffset>
               <size>16</size>
               <resetValue>0xFFFF</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>WDT Control Register</description>
               <addressOffset>0x4</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>WDT_EN</name>
                     <description>WDT Block enabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_STS</name>
                     <description>WDT_STATUS is set by hardware if the last reset of the device was caused by an underflow of the WDT. This bit must      be cleared by the EC firmware writing a '1' to this bit. Writing a '0' to this bit has no effect.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HIB_TMR0_STL</name>
                     <description>This bit enables the WDT Stall function if the Hibernation Timer 0 is active.      1=The WDT is stalled while the Hibernation Timer 0 is active      0=The WDT is not affected by Hibernation Timer 0.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WK_TMR_STL</name>
                     <description>This bit enables the WDT Stall function if the Week Timer is active.      1=The WDT is stalled while the Week Timer is active      0=The WDT is not affected by the Week Timer.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>JTAG_STL</name>
                     <description>This bit enables the WDT Stall function if JTAG or SWD debug functions are active      1=The WDT is stalled while either JTAG or SWD is active      0=The WDT is not affected by the JTAG debug interface.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_RST</name>
                     <description>If the WDT_RESET bit is set and the watch dog timer expires, the Watch dog module will         generate interrupt and clear the WDT_RESET to 0b.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>KICK</name>
               <description>The WDT Kick Register is a strobe. Reads of this register return 0. Writes to this register cause the WDT to reload     the WDT Load Register value and start decrementing when the WDT_ENABLE bit in the WDT Control Register is set to '1'. When the WDT_ENABLE     bit in the WDT Control Register is cleared to '0', writes to the WDT Kick Register have no effect.</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>CNT</name>
               <description>This read-only register provides the current WDT count.</description>
               <addressOffset>0xC</addressOffset>
               <size>16</size>
               <access>read-only</access>
               <resetValue>0xFFFF</resetValue>
            </register>
            <register>
               <name>STS</name>
               <description>This register provides the current WDT count.</description>
               <addressOffset>0x10</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>WDT_EV_IRQ</name>
                     <description>WDT_EVENT_IRQ : This bit indicates the status of interrupt from Watch dog module.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>Watch Dog Interrupt Enable Register.</description>
               <addressOffset>0x14</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>WDT_INTEN</name>
                     <description>WDT_Int_Enable: This is the interrupt enables bit for WDT_INT interrupt.                   1= WDT_INT Interrupt Enable                   0= WDT_INT Interrupt Disabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>TIMER16_0</name>
         <version>108a1.0</version>
         <description>This 16-bit timer block offers a simple mechanism for firmware to maintain a time base.</description>
         <groupName>TIMER16</groupName>
         <prependToName>TIMER16_</prependToName>
         <baseAddress>0x40000C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x14</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ23</name>
            <value>14</value>
         </interrupt>
         <interrupt>
            <name>TIMER16_0</name>
            <value>136</value>
         </interrupt>
         <registers>
            <register>
               <name>CNT</name>
               <description>This is the value of the Timer counter.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>PRLD</name>
               <description>This is Timer pre-load for the counter.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>STS</name>
               <description>This is the interrupt status that fires when the timer reaches its limit</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EVT_INT</name>
                     <description>This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer Control Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>This is the WDT Interrupt Enable Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL</name>
               <description>Timer Control Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>This enables the block for operation.      1=This block will function normally;     0=This block will gate its clock and go into its lowest power state</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_UP</name>
                     <description>This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event     when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment;     0=The counter will decrement</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AU_RESTRT</name>
                     <description>This will select the action taken upon completing a count.     1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register.     The interrupt will be set in edge mode     0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SFT_RST</name>
                     <description>This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need     to wait before reconfiguring the Basic Timer following soft reset.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT</name>
                     <description>This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will     clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so     this bit will never clear. Clearing this bit will halt the timer counter.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RLD</name>
                     <description>This bit reloads the counter without interrupting it operation. This will not function if the timer has already     completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an     event occurs. Usage while the timer is off may result in erroneous behaviour.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HLT</name>
                     <description>This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will     start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRESCALE</name>
                     <description>This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow     slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts.     The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1     runs at half speed.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="TIMER16_0">
         <name>TIMER16_1</name>
         <baseAddress>0x40000C20</baseAddress>
         <interrupt>
            <name>TIMER16_1</name>
            <value>137</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="TIMER16_0">
         <name>TIMER16_2</name>
         <baseAddress>0x40000C40</baseAddress>
         <interrupt>
            <name>TIMER16_2</name>
            <value>138</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="TIMER16_0">
         <name>TIMER16_3</name>
         <baseAddress>0x40000C60</baseAddress>
         <interrupt>
            <name>TIMER16_3</name>
            <value>139</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>TIMER32_0</name>
         <version>108b1.0</version>
         <description>This 32-bit timer block offers a simple mechanism for firmware to maintain a time base.</description>
         <groupName>TIMER32</groupName>
         <prependToName>TIMER32_</prependToName>
         <baseAddress>0x40000C80</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x14</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>TIMER32_0</name>
            <value>140</value>
         </interrupt>
         <registers>
            <register>
               <name>CNT</name>
               <description>This is the value of the Timer counter. This is updated by Hardware but may be set by Firmware.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>PRLD</name>
               <description>This is the value of the Timer pre-load for the counter. This is used by H/W when the counter is to be restarted    automatically; this will become the new value of the counter upon restart.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>STS</name>
               <description>This is the interrupt status that fires when the timer reaches its limit</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EVT_INT</name>
                     <description>This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when        the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer        Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL</name>
               <description>Timer Control Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>This enables the block for operation. 1=This block will function normally;     0=This block will gate its clock and go into its lowest power state</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_UP</name>
                     <description>This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event     when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment;     0=The counter will decrement</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AU_RESTRT</name>
                     <description>This will select the action taken upon completing a count.     1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register.     The interrupt will be set in edge mode     0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SFT_RST</name>
                     <description>This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need     to wait before reconfiguring the Basic Timer following soft reset.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT</name>
                     <description>This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will     clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so     this bit will never clear. Clearing this bit will halt the timer counter.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RLD</name>
                     <description>This bit reloads the counter without interrupting it operation. This will not function if the timer has already     completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an     event occurs. Usage while the timer is off may result in erroneous behaviour.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HLT</name>
                     <description>This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will     start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRESCALE</name>
                     <description>This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow     slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts.     The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1     runs at half speed.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="TIMER32_0">
         <name>TIMER32_1</name>
         <baseAddress>0x40000CA0</baseAddress>
         <interrupt>
            <name>TIMER32_1</name>
            <value>141</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>CNTR_TMR0</name>
         <version>691.0</version>
         <description>This interface is a 16-bit auto-reloading timer/counter.</description>
         <groupName>CNTR_TMR</groupName>
         <prependToName>CNTR_TMR_</prependToName>
         <baseAddress>0x40000D00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>CNTR_TMR0</name>
            <value>142</value>
         </interrupt>
         <registers>
            <register>
               <name>TIMERX_CONTROL</name>
               <description>This bit reflects the current state of the timer's Clock_Required output signal.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ENABLE</name>
                     <description>This bit is used to start and stop the timer. This bit does not reset the timer count but does reset the timer                       pulse output. This bit will be cleared when the timer stops counting in One-Shot mode. The ENABLE bit is cleared after a           RESET cycle has completed. Firmware must poll the RESET bit in order to determine when the timer is active after reset.        1=Timer is enabled; 0=Timer is disabled.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RESET</name>
                     <description>This bit stops the timer and resets the internal counter to the value in the Timer Reload Register. This bit                   also clears the ENABLE bit if it is set. This bit is self-clearing after the timer is reset. Firmware must poll the          RESET bit in order to determine when the timer is active after reset. Interrupts are blocked only when RESET takes        effect and the ENABLE bit is cleared. If interrupts are not desired, firmware must mask the interrupt in the interrupt       block. 1=Timer reset; 0=Normal timer operation.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MODE</name>
                     <description>Timer Mode. 3=Measurement Mode; 2=One Shot Mode; 1=Event Mode; 0=Timer Mode.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INPOL</name>
                     <description>This bit selects the polarity of the TINx input. 1=TINx is active low; 0=TINx is active high.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UPDN</name>
                     <description>In Event Mode, this bit selects the timer count direction. In Timer Mode enables timer control by the TINx input pin.          Event Mode: 1=The timer counts up; 0=The timer counts down.                 Timer Mode:; 1=TINx pin pauses the timer when de-asserted; 0=TINx pin has no effect on the timer.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TOUT_EN</name>
                     <description>This bit enables the TOUTx pin. 1=TOUTx pin function is enabled; 0=TOUTx pin is inactive.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RLOAD</name>
                     <description>Reload Control. This bit controls how the timer is reloaded on overflow or underflow in Event and Timer modes.                    It has no effect in One shot mode. 1=Reload timer from Timer Reload Register and continue counting;                    0=Roll timer over to FFFFh and continue counting when counting down and rolls over to 0000h and continues counting when counting up.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYPASS</name>
                     <description>This bit is used to enable or disable the noise filter on the TINx input signal. 1=Bypass Mode: input filter disabled.                     The TINx input directly affects the timer; 0=Filter Mode: input filter enabled. The TINx input is filtered by the input filter.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PD</name>
                     <description>Power Down. 1=The timer is powered down and all clocks are gated; 0=The timer is in a running state.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TOUT_POLARITY</name>
                     <description>This bit determines the polarity of the TOUTx output signal. In timer modes that toggle the TOUTx signal,           this polarity bit will not have a perceivable difference, except to determine the inactive state. In One-Shot mode           this determines if the pulsed output is active high or active low. 1=Active low; 0=Active high.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLEEP_ENABLE</name>
                     <description>This bit reflects the current state of the timer's Sleep_Enable input signal. 1=Normal operation; 0=Sleep Mode is requested.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TIMERX_CLK_REQ</name>
                     <description>This bit reflects the current state of the timer's Clock_Required output signal. 1=The main clock is required by this block;         0=The main clock is not required by this block.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_EVNT_CTRL</name>
               <description>This is the  Timer Clock and Event Control Register.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TCLK</name>
                     <description>Timer Clock Select. This field determines the clock source for the 16-bit counter in the timer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>EDGE</name>
                     <description>This field selects which edge of the TINx input signal affects the timer in Event Mode, One-Shot Mode and Measurement Mode.          Event Mode: 11b=No event selected; 10b=Counts rising and falling edges; 01b=Counts rising edges; 00b=Counts falling edges.         One-Shot Mode: 11b=Start counting when the Enable bit is set; 10b=Starts counting on a rising or falling edge; 01b=Starts       counting on a rising edge; 00b=Starts counting on a falling edge. Measurement Mode: 11b=No event selected; 10b=Measures         the time between rising edges and falling edges and the time between falling edges and rising edges; 01b=Measures the        time between rising edges; 00b=Measures the time between falling edges.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>EVENT</name>
                     <description>Event Select. This bit is used to select the count source when the timer is operating in Event Mode.          1=TINx is count source; 0=Timer x-1 overflow is count source.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK</name>
                     <description>Timer Clock Select. This field determines the clock source for the TINx noise filter. The available frequencies                are the same as for TCLK.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TIMERX_RELOAD</name>
               <description>This register is used in Timer and One-Shot modes to set the lower limit of the timer.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x0000FFFF</resetValue>
               <fields>
                  <field>
                     <name>TIMER_RELOAD</name>
                     <description>The Timer Reload register is used in Timer and One-Shot modes to set the lower limit of the timer.                 In Event mode the Timer Reload register sets either the upper or lower limit of the timer depending on if the            timer is counting up or down. Valid Timer Reload values are 0001h - FFFFh. If the timer is running, the                 reload value will not be updated until the timer overflows or underflows. Programming a 0000h as a preload             value is not a valid count value. Using a value of 0000h will cause unpredictable behavior.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TIMERX_COUNT</name>
               <description>This register returns the current value of the timer in all modes.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x0000FFFF</resetValue>
               <fields>
                  <field>
                     <name>TIMER_COUNT</name>
                     <description>This is the current value of the timer in all modes.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="CNTR_TMR0">
         <name>CNTR_TMR1</name>
         <baseAddress>0x40000D20</baseAddress>
         <interrupt>
            <name>CNTR_TMR1</name>
            <value>143</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="CNTR_TMR0">
         <name>CNTR_TMR2</name>
         <baseAddress>0x40000D40</baseAddress>
         <interrupt>
            <name>CNTR_TMR2</name>
            <value>144</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="CNTR_TMR0">
         <name>CNTR_TMR3</name>
         <baseAddress>0x40000D60</baseAddress>
         <interrupt>
            <name>CNTR_TMR3</name>
            <value>145</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>CCT</name>
         <version>121.0</version>
         <description>This is a 16-bit auto-reloading timer/counter.</description>
         <baseAddress>0x40001000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x34</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>CCT</name>
            <value>146</value>
         </interrupt>
         <interrupt>
            <name>CCT_CAP0</name>
            <value>147</value>
         </interrupt>
         <interrupt>
            <name>CCT_CAP1</name>
            <value>148</value>
         </interrupt>
         <interrupt>
            <name>CCT_CAP2</name>
            <value>149</value>
         </interrupt>
         <interrupt>
            <name>CCT_CAP3</name>
            <value>150</value>
         </interrupt>
         <interrupt>
            <name>CCT_CAP4</name>
            <value>151</value>
         </interrupt>
         <interrupt>
            <name>CCT_CAP5</name>
            <value>152</value>
         </interrupt>
         <interrupt>
            <name>CCT_CMP0</name>
            <value>153</value>
         </interrupt>
         <interrupt>
            <name>CCT_CMP1</name>
            <value>154</value>
         </interrupt>
         <registers>
            <register>
               <name>CTRL</name>
               <description>This register controls the capture and compare timer.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>This bit is used to start the capture and compare timer running and power it down.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FREE_EN</name>
                     <description>Free-Running Timer Enable. This bit is used to start and stop the free running timer.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FREE_RST</name>
                     <description>Free Running Timer Reset. This bit stops the timer and resets the internal counter to 0000_0000h.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TCLK</name>
                     <description>This 3-bit field sets the clock source for the Free-Running Counter.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>CMP_EN0</name>
                     <description>Compare Enable for Compare 0 Register.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP_EN1</name>
                     <description>Compare Enable for Compare 1 Register.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP_SET1</name>
                     <description>When read, returns the current value off the Compare Timer Output 1 state.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP_SET0</name>
                     <description>When read, returns the current value off the Compare Timer Output 0 state.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP_CLR1</name>
                     <description>When read, returns the current value off the Compare Timer Output 1 state.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP_CLR0</name>
                     <description>When read, returns the current value off the Compare Timer Output 0 state.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP0_CTRL</name>
               <description>This register is used to configure capture and compare timers 0-3.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_EDGE0</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP0</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 0, so that the input signal goes directly into the timer.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL0</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 0.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>CAP_EDGE1</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 1.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP1</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 1, so that the input signal goes directly into the timer.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL1</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 1.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>CAP_EDGE2</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 2.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP2</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 2, so that the input signal goes directly into the timer.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL2</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 2.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>CAP_EDGE3</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 3.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP3</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 3, so that the input signal goes directly into the timer.</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL3</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 3.</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP1_CTRL</name>
               <description>This register is used to configure capture and compare timers 4-5.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_EDGE4</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 4.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP4</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 4, so that the input signal goes directly into the timer.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL4</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 4.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>CAP_EDGE5</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 5.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP5</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 5, so that the input signal goes directly into the timer.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL5</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 5.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FREE_RUN</name>
               <description>This register contains the current value of the Free Running Timer.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TMR</name>
                     <description>This register contains the current value of the Free Running Timer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP0</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT0.</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_0</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP1</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT1.</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_1</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP2</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT0.</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_2</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT2.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP3</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT0.</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_3</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT3.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP4</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT4.</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_4</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT4.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP5</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT5.</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_5</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT5.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>COMP0</name>
               <description>A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer.</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>COMP_0</name>
                     <description>A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>COMP1</name>
               <description>A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer.</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>COMP_1</name>
                     <description>A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MUX_SEL</name>
               <description>This register selects the pin mapping to the capture register.</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <resetValue>0x00543210</resetValue>
               <fields>
                  <field>
                     <name>CAP0</name>
                     <description>Mux Select for Capture 0 register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CAP1</name>
                     <description>Mux Select for Capture 1 register.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CAP2</name>
                     <description>Mux Select for Capture 2 register.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CAP3</name>
                     <description>Mux Select for Capture 3 register.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CAP4</name>
                     <description>Mux Select for Capture 4 register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>CAP5</name>
                     <description>Mux Select for Capture 5 register.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>HTM0</name>
         <version>291.0</version>
         <description>The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode.</description>
         <groupName>HTM</groupName>
         <prependToName>HTM_</prependToName>
         <baseAddress>0x40009800</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xA</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>HTMR0</name>
            <value>112</value>
         </interrupt>
         <registers>
            <register>
               <name>PRLD</name>
               <description>[15:0] This register is used to set the Hibernation Timer Preload value.</description>
               <addressOffset>0x0</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>HTimer Control Register</description>
               <addressOffset>0x4</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>CTRL</name>
                     <description>1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours.     0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CNT</name>
               <description>The current state of the Hibernation Timer.</description>
               <addressOffset>0x8</addressOffset>
               <size>16</size>
               <access>read-only</access>
               <resetValue>0x0000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="HTM0">
         <name>HTM1</name>
         <baseAddress>0x40009820</baseAddress>
         <interrupt>
            <name>HTMR1</name>
            <value>113</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>RTOS</name>
         <version>1401.0</version>
         <description>RTOS is a 32-bit timer designed to operate on the 32kHz oscillator which is available during all chip sleep states.</description>
         <baseAddress>0x40007400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>RTMR</name>
            <value>111</value>
         </interrupt>
         <registers>
            <register>
               <name>CNT</name>
               <description>RTOS Timer Count Register.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CNTR</name>
                     <description>This register contains the current value of the RTOS Timer counter. This register should be read as a DWORD. There is no latching mechanism         of the upper bytes implemented if the register is accessed as a byte or word. Reading the register with byte or word operations may give incorrect results.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PRLD</name>
               <description>RTOS Timer Preload Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PRELOAD</name>
                     <description>The this register is loaded into the RTOS Timer counter either when the TIMER_START bit is written with a 1, or when the timer counter counts down to 0 and the AUTO_RELOAD bit is 1.      This register must be programmed with a new count value before the TIMER_START bit is set to 1. If this register is updated while the counter is operating, the new count value will only take effect if      the counter transitions form 1 to 0 while the AUTO_RELOAD bit is set.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL</name>
               <description>RTOS Timer Control Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BLK_EN</name>
                     <description>1=RTOS timer counter is enabled     0=RTOS timer disabled. All register bits are reset to their default state</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AU_RELOAD</name>
                     <description>1=The the RTOS Timer Preload Register is loaded into the timer counter and the counter is restarted when the counter transitions from 1 to 0     0=The timer counter halts when it transitions from 1 to 0 and will not restart.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR_STRT</name>
                     <description>Writing a 1 to this bit will load the timer counter with the RTOS Timer Preload Register and start counting. If the Preload Register is 0, counting will not start and this bit will be cleared to 0.     Writing a 0 to this bit will halt the counter and clear its contents to 0. The RTOS timer interrupt will not be generated. This bit is automatically cleared if the AUTO_RELOAD bit is 0 and the     timer counter transitions from 1 to 0.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EXT_HW_HALT_EN</name>
                     <description>1=The timer counter is halted when the external HALT signal is asserted. Counting is always enabled if HALT is de-asserted.     0=The HALT signal does not affect the RTOS Timer</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FW_TMR_HALT</name>
                     <description>1=The timer counter is halted. If the counter was running, clearing this bit will restart the counter from the value at which it halted     0=The timer counter, if enabled, will continue to run</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SOFTIRQ</name>
               <description>Soft Interrupt Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SWI0</name>
                     <description>Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SWI1</name>
                     <description>Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SWI2</name>
                     <description>Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SWI3</name>
                     <description>Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.     Writes of a '0' have no effect. Reads return '0'.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>RTC</name>
         <version>1261.0</version>
         <description>This is the set of registers that are automatically counted by hardware every 1 second while the block is enabled.</description>
         <baseAddress>0x400F5000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x20</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>RTC</name>
            <value>119</value>
         </interrupt>
         <interrupt>
            <name>RTC_ALARM</name>
            <value>120</value>
         </interrupt>
         <registers>
            <register>
               <name>SEC</name>
               <description>Seconds Register</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>SEC_ALARM</name>
               <description>Seconds Alarm Register</description>
               <addressOffset>0x1</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>MIN</name>
               <description>Minutes Register</description>
               <addressOffset>0x2</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>MIN_ALARM</name>
               <description>Minutes Alarm Register</description>
               <addressOffset>0x3</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HR</name>
               <description>Hours Register</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HR_ALARM</name>
               <description>Hours Alarm Register</description>
               <addressOffset>0x5</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>DAY_OF_WK</name>
               <description>Day of Week Register</description>
               <addressOffset>0x6</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>DAY_OF_MON</name>
               <description>Day of Month Register</description>
               <addressOffset>0x7</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>MONTH</name>
               <description>Month Register</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>YEAR</name>
               <description>Year Register</description>
               <addressOffset>0x9</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>REGA</name>
               <description>Register A</description>
               <addressOffset>0xA</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>REGB</name>
               <description>Register B</description>
               <addressOffset>0xB</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>REGC</name>
               <description>Register C</description>
               <addressOffset>0xC</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>REGD</name>
               <description>Register D</description>
               <addressOffset>0xD</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>RTC Control Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BLK_EN</name>
                     <description>BLOCK_ENABLE This bit must be 1 in order for the block to function internally. Registers may be initialized first, before      setting this bit to '1' to start operation.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RST</name>
                     <description>SOFT_RESET A 1 written to this bit position will trigger the RTC_RST reset, resetting the block and all registers except      this one and the Test Register. This bit is self-clearing at the end of the reset, one cycle of Host Bus Clock later, and so requires      no waiting.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VCI_EN</name>
                     <description>VCI Enable 1= RTC Alarm to VCI Circuitry, 0= No RTC alarm to VCI circuitry</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALM_EN</name>
                     <description>ALARM_ENABLE  1=Enables the Alarm features, 0=Disables the Alarm features</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WK_ALARM</name>
               <description>Week Alarm Register[7:0] - ALARM_DAY_OF_WEEK This register, if written to a value in the range 1- -7, will inhibit the Alarm     interrupt unless this field matches the contents of the Day of Week Register also.</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x000000FF</resetValue>
            </register>
            <register>
               <name>DAYLT_SAVF</name>
               <description>Daylight Savings Forward Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DST_MON</name>
                     <description>This field matches the Month Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>DST_DAY_OF_WK</name>
                     <description>This field matches the Day of Week Register bits[2:0].</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>DST_WK</name>
                     <description>5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>DST_HR</name>
                     <description>This field holds the matching value for bits[6:0] of the Hours register. The written value will be interpreted according      to the 24/12 Hour mode and DM mode settings at the time of writing.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>DST_AM_PM</name>
                     <description>This bit selects AM vs. PM, to match bit[7] of the Hours Register if 12-Hour mode is selected in Register B at the time      of writing.</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DAYLT_SAVB</name>
               <description>Daylight Savings Backward Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DST_MON</name>
                     <description>This field matches the Month Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>DST_DAY_OF_WK</name>
                     <description>This field matches the Day of Week Register bits[2:0].</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>DST_WK</name>
                     <description>5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>DST_HR</name>
                     <description>This field holds the matching value for bits[6:0] of the Hours register. The written value will be interpreted according      to the 24/12 Hour mode and DM mode settings at the time of writing.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>DST_AM_PM</name>
                     <description>This bit selects AM vs. PM, to match bit[7] of the Hours Register if 12-Hour mode is selected in Register B at the time      of writing.</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>WEEK</name>
         <version>761.0</version>
         <description>The Week Timer and the Sub-Week Timer assert the Power-Up Event Output which automatically powers-up the system from the G3 state</description>
         <baseAddress>0x4000AC80</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x28</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>WK</name>
            <value>114</value>
         </interrupt>
         <interrupt>
            <name>WKSUB</name>
            <value>115</value>
         </interrupt>
         <interrupt>
            <name>WKSEC</name>
            <value>116</value>
         </interrupt>
         <interrupt>
            <name>WKSUBSEC</name>
            <value>117</value>
         </interrupt>
         <interrupt>
            <name>SYSPWR</name>
            <value>118</value>
         </interrupt>
         <registers>
            <register>
               <name>CTRL</name>
               <description>Control Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000001</resetValue>
               <fields>
                  <field>
                     <name>WT_EN</name>
                     <description>The WT_ENABLE bit is used to start and stop the Week Alarm Counter Register and the Clock Divider Register.     The value in the Counter Register is held when the WT_ENABLE bit is not asserted (0) and the count is resumed from the last value when the bit is asserted (1).     The 15-Bit Clock Divider is reset to 00h and the Week Alarm Interface is in its lowest power consumption state when the WT_ENABLE bit is not asserted.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWRUP_EN</name>
                     <description>This bit controls the state of the Power-Up Event Output and enables Week POWER-UP Event decoding in the VBAT-Powered Control Interface.     1=Power-Up Event Output Enabled     0=Power-Up Event Output Disabled and Reset</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ALARM_CNT</name>
               <description>Week Alarm Counter Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>WK_CNTR</name>
                     <description>While the WT_ENABLE bit is 1, this register is incremented at a 1 Hz rate. Writes of this register may require one second     to take effect. Reads return the current state of the register. Reads and writes complete independently of the state of WT_ENABLE.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>28</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TMR_COMP</name>
               <description>Week Timer Compare Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x0FFFFFFF</resetValue>
               <fields>
                  <field>
                     <name>WK_COMP</name>
                     <description>A Week Alarm Interrupt and a Week Alarm Power-Up Event are asserted when the Week Alarm Counter Register is greater than     or equal to the contents of this register. Reads and writes complete independently of the state of WT_ENABLE.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>28</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLKDIV</name>
               <description>Clock Divider Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DIV</name>
                     <description>Reads of this register return the current state of the Week Timer 15- bit clock divider.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>15</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SS_INTR_SEL</name>
               <description>Sub-Second Programmable Interrupt Select Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SPISR</name>
                     <description>This field determines the rate at which Sub-Second interrupt events are generated.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SWK_CTRL</name>
               <description>Sub-Week Control Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SWKTMR_PWRUP_EVT_STS</name>
                     <description>This bit is set to 1 when the Sub-Week Alarm Counter Register decrements from 1 to 0 and the POWERUP_EN is 1.     Writes of 1 clear this bit. Writes of 0 have no effect. Note: This bit MUST be cleared to remove a Sub-Week Timer Power-Up Event.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WKTMR_PWRUP_EVT_STS</name>
                     <description>This bit is set to 1 when the Week Alarm Counter Register is greater than or equal the contents of the Week Timer Compare     Register and the POWERUP_EN is 1. Writes of 1 clear this bit. Writes of 0 have no effect.     Note: This bit does not have to be cleared to remove a Week Timer Power-Up Event.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST</name>
                     <description>Test</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST0</name>
                     <description>Test</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AU_RLD</name>
                     <description>1= No reload occurs when the Sub-Week Counter expires     0= Reloads the SUBWEEK_COUNTER_LOAD field into the Sub- Week Counter when the counter expires.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SWK_TICK</name>
                     <description>This field selects the clock source for the Sub-Week Counter.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SWK_ALARM</name>
               <description>Sub-Week Alarm Counter Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CNTR_LOAD</name>
                     <description>Writes with a non-zero value to this field reload the 9-bit Sub-Week Alarm counter. Writes of 0 disable the counter.     If the Sub-Week Alarm counter decrements to 0 and the AUTO_RELOAD bit is set, the value in this field is automatically loaded into the Sub-Week Alarm counter.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>9</bitWidth>
                  </field>
                  <field>
                     <name>CNTR_STS</name>
                     <description>Reads of this register return the current state of the 9-bit Sub-Week Alarm counter.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>9</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BGPO_DATA</name>
               <description>BGPO Data Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DAT</name>
                     <description>Battery powered General Purpose Output. Each output pin may be individually configured to be either a VBAT-power BGPO or a VTR     powered GPIO, based on the corresponding settings in the BGPO Power Register. Additionally, each output pin may be individually configured     to reset to 0 on either RESET_VTR or RESET_SYS, based on the corresponding settings in the BGPO Reset Register.     For each bit [i] in the field: 1=BGPO[i] output is high; 0=BGPO[i] output is low.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BGPO_PWR</name>
               <description>BGPO Power Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000007</resetValue>
               <fields>
                  <field>
                     <name>PWR</name>
                     <description>Battery powered General Purpose Output power source. For each bit [i] in the field:     1=BGPO[i] is powered by VBAT. The BGPO[i] pin is always determined by the corresponding bit in the BGPO Data Register. The GPIO Input register     for the GPIO that is multiplexed with the BGPO always returns a '1b'.     0=The pin for BGPO[i] functions as a GPIO. When VTR is powered, the pin associated with BGPO[i] is determined by the GPIO associated with the pin.     When VTR is unpowered, the pin is tristated.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BGPO_RST</name>
               <description>BGPO Reset Register</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RST</name>
                     <description>Battery powered General Purpose Output reset event. For each bit [i] in the field:     1=BGPO[i] is reset to 0 on RESET_VTR; 0=BGPO[i] is reset to 0 on RESET_SYS.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>TACH0</name>
         <version>661.0</version>
         <description>This block monitors TACH output signals from various types of fans, and determines their speed</description>
         <groupName>TACH</groupName>
         <prependToName>TACH_</prependToName>
         <baseAddress>0x40006000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>TACH0</name>
            <value>71</value>
         </interrupt>
         <registers>
            <register>
               <name>CTRL</name>
               <description>TACHx Control Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OUTOF_LIM_EN</name>
                     <description>TACH_OUT_OF_LIMIT_ENABLE  This bit is used to enable the TACH_OUT_OF_LIMIT_STATUS bit in the TACHx Status Register to generate an interrupt event.                  1=Enable interrupt output from Tach block                  0=Disable interrupt output from Tach block (default)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN</name>
                     <description>TACH_ENABLE  1= TACH Monitoring enabled, clocks enabled. 0= TACH Idle, clocks gated</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FILT_EN</name>
                     <description>FILTER_ENABLE  This filter is used to remove high frequency glitches from Tach Input. When this filter is enabled, Tach input pulses less than two 100kHz_- Clk periods wide get filtered.                  1= Filter enabled                  0= Filter disabled (default)                  It is recommended that the Tach input filter always be enabled.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RD_MOD_SEL</name>
                     <description>TACH_READING_MODE_SELECT                  1=Counter is incremented on the rising edge of the 100kHz_Clk input. The counter is latched into the TACHX_COUNTER field and reset when the programmed number of edges is detected.                  0=Counter is incremented when Tach Input transitions from low-tohigh state (default)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EDGES</name>
                     <description>TACH_EDGES A Tach signal is a square wave with a 50 percent duty cycle. Typically, two Tach periods represents one revolution of the fan. A Tach period consists of three Tach edges. This programmed value represents the number of Tach edges that will be used to determine the interval for which the number of 100kHz_Clk pulses will be counted                  11b=9 Tach edges (4 Tach periods)                  10b=5 Tach edges (2 Tach periods)                  01b=3 Tach edges (1 Tach period)                  00b=2 Tach edges (1/2 Tach period)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CNT_RDY_INT_EN</name>
                     <description>COUNT_READY_INT_EN 1=Enable Count Ready interrupt from Tach block, 0=Disable Count Ready interrupt from Tach block</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IN_INT_EN</name>
                     <description>TACH_INPUT_INT_EN 1=Enable Tach Input toggle interrupt from Tach block, 0=Disable Tach Input toggle interrupt from Tach block</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNTR</name>
                     <description>This 16-bit field contains the latched value of the internal Tach pulse counter, which may be configured by the Tach Reading Mode Select field to operate as a free-running counter or to be gated by the Tach input signal.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS</name>
               <description>TACHx Status Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OUTOF_LIM_STS</name>
                     <description>TACH_OUT_OF_LIMIT_STATUS  1=Tach is outside of limits, 0=Tach is within limits (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PIN_STS</name>
                     <description>TACH_PIN_STATUS  1= Tach Input is high, 0= Tach Input is low</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TOG_STS</name>
                     <description>TOGGLE_STATUS  1=Tach Input changed state (this bit is set on a low-to-high or high-tolow transition), 0=Tach stable (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_RDY_STS</name>
                     <description>COUNT_READY_STATUS  1=Reading ready, 0=Reading not ready</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LIM_HI</name>
               <description>TACH HIGH LIMIT Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x0000FFFF</resetValue>
               <fields>
                  <field>
                     <name>T_HIGH</name>
                     <description>This value is compared with the value in the TACHX_COUNTER field. If the value in the counter is greater than the value     programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS status event may be enabled     to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx Control Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LIM_LO</name>
               <description>TACHx Low Limit Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>T_LOW</name>
                     <description>This value is compared with the value in the TACHX_COUNTER field of the TACHx Control Register. If the value in the counter     is less than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS     status event may be enabled to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx     Control Register To disable the TACH_OUT_OF_LIMIT_STATUS low event, program 0000h into this register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="TACH0">
         <name>TACH1</name>
         <baseAddress>0x40006010</baseAddress>
         <interrupt>
            <name>TACH1</name>
            <value>72</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="TACH0">
         <name>TACH2</name>
         <baseAddress>0x40006020</baseAddress>
         <interrupt>
            <name>TACH2</name>
            <value>73</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="TACH0">
         <name>TACH3</name>
         <baseAddress>0x40006030</baseAddress>
         <interrupt>
            <name>TACH3</name>
            <value>159</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>PWM0</name>
         <version>541.0</version>
         <description>The PWM block generates an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.</description>
         <groupName>PWM</groupName>
         <prependToName>PWM_</prependToName>
         <baseAddress>0x40005800</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>CNT_ON</name>
               <description>This field determines both the frequency and duty cycle of the PWM signal. Setting this field to a value of n will    cause the On time of the PWM to be n+1 cycles of the PWM Clock Source.    When this field is set to zero and the PWMX_COUNTER_OFF_TIME is not set to zero, the PWM_OUTPUT is held low (Full Off).</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CNT_OFF</name>
               <description>This field determine both the frequency and duty cycle of the PWM signal. Setting this field to a value of n will    cause the Off time of the PWM to be n+1 cycles of the PWM Clock Source.    When this field is set to zero, the PWM_OUTPUT is held high (Full On).</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x0000FFFF</resetValue>
            </register>
            <register>
               <name>CFG</name>
               <description>PWMx CONFIGURATION REGISTER</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWM_EN</name>
                     <description>When the PWM_ENABLE is set to 0 the internal counters are reset and the internal state machine is set to the OFF state.     In addition, the PWM_OUTPUT signal is set to the inactive state as determined by the Invert bit. The PWMx Counter ON Time Register     and PWMx Counter OFF Time Register are not affected by the PWM_ENABLE bit and may be read and written while the PWM enable bit is 0.     1=Enabled (default); 0=Disabled (gates clocks to save power).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLK_SEL</name>
                     <description>This bit determines the clock source used by the PWM duty cycle and frequency control logic.                    1=CLOCK_LOW                    0=CLOCK_HIGH</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INV</name>
                     <description>1= PWM_OUTPUT ON State is active low; 0=PWM_OUTPUT ON State is active high.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLK_PRE_DIV</name>
                     <description>The Clock source for the 16-bit down counter (see PWMx Counter ON Time Register and PWMx Counter OFF Time Register)     is determined by bit D1 of this register. The Clock source is then divided by the value of Pre-Divider+1 and the resulting     signal determines the rate at which the down counter will be decremented. For example, a Pre-Divider value of 1 divides     the input clock by 2 and a value of 2 divides the input clock by 3. A Pre-Divider of 0 will disable the Pre-Divider option.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM1</name>
         <baseAddress>0x40005810</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM2</name>
         <baseAddress>0x40005820</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM3</name>
         <baseAddress>0x40005830</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM4</name>
         <baseAddress>0x40005840</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM5</name>
         <baseAddress>0x40005850</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM6</name>
         <baseAddress>0x40005860</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM7</name>
         <baseAddress>0x40005870</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM8</name>
         <baseAddress>0x40005880</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM9</name>
         <baseAddress>0x40005890</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM10</name>
         <baseAddress>0x400058A0</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM11</name>
         <baseAddress>0x400058B0</baseAddress>
      </peripheral>
      <peripheral>
         <name>FAN0</name>
         <version>1071.0</version>
         <description>The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors the fan's speed and automatically adjusts       the drive to maintain the desired fan speed. This RPM based Fan Control Algorithm controls a PWM output based on a tachometer input.</description>
         <groupName>FAN</groupName>
         <prependToName>FAN_</prependToName>
         <baseAddress>0x4000A000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x12</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>RPM2PWM_0_STALL</name>
            <value>74</value>
         </interrupt>
         <interrupt>
            <name>RPM2PWM_0_SPIN</name>
            <value>75</value>
         </interrupt>
         <registers>
            <register>
               <name>SETNG</name>
               <description>The Fan Driver Setting used to control the output of the Fan Driver.</description>
               <addressOffset>0x0</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>FAN_SETNG</name>
                     <description>The Fan Driver Setting used to control the output of the Fan Driver.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>10</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CNFG</name>
               <description>The Fan Configuration Register controls the general operation of the RPM based Fan Control Algorithm used by the fan driver.</description>
               <addressOffset>0x2</addressOffset>
               <size>16</size>
               <resetValue>0x342B</resetValue>
               <fields>
                  <field>
                     <name>UPDATE</name>
                     <description>Determines the base time between fan driver updates. The Update Time, along with the Fan Step Register, is used to control       the ramp rate of the drive response to provide a cleaner transition of the actual fan operation as the desired fan speed changes.           7=1600ms          6=1200ms                  5=800ms            4=500ms            3=400ms                   2=300ms                 1=200ms                 0=100ms              Note: This ramp rate control applies for all changes to the active PWM output including when the RPM based Fan Speed Control Algorithm       is disabled.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <name>UPDATESelect</name>
                        <enumeratedValue>
                           <name>BASE_TIME_1600ms</name>
                           <description>7=1600ms</description>
                           <value>0x7</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_1200ms</name>
                           <description>6=1200ms</description>
                           <value>0x6</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_800ms</name>
                           <description>5=800ms </description>
                           <value>0x5</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_500ms</name>
                           <description>4=500ms </description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_400ms</name>
                           <description>3=400ms </description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_300ms</name>
                           <description>2=300ms </description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_200ms</name>
                           <description>1=200ms </description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_100ms</name>
                           <description>0=100ms </description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>EDGES</name>
                     <description>Determines the minimum number of edges that must be detected on the TACH signal to determine a single rotation. A typical      fan measured 5 edges (for a 2-pole fan). Increasing the number of edges measured with respect to the number of poles of the fan will         cause the TACH Reading registers to indicate a fan speed that is higher or lower than the actual speed. In order for the FSC Algorithm       to operate correctly, the TACH Target must be updated by the user to accommodate this shift. The Effective Tach Multiplier is used as        a direct multiplier term that is applied to the Actual RPM to achieve the Reported RPM. It should only be applied if the number of        edges measured does not match the number of edges expected based on the number of poles of the fan (which is fixed for any given fan).</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>RANGE</name>
                     <description>Adjusts the range of reported and programmed tachometer reading values. The RANGE bits determine the weighting of all        TACH values (including the Valid TACH Count, TACH Target, and TACH reading).      3=Reported Minimum RPM: 4000. Tach Count Multiplier: 1               2=Reported Minimum RPM: 2000. Tach Count Multiplier: 2                1=Reported Minimum RPM: 1000. Tach Count Multiplier: 4                0=Reported Minimum RPM: 500. Tach Count Multiplier: 8</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>RANGESelect</name>
                        <enumeratedValue>
                           <name>TACH_COUNT_MULTIPLIER_8</name>
                           <description>3=Reported Minimum RPM: 4000. Tach Count Multiplier: 8</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TACH_COUNT_MULTIPLIER_4</name>
                           <description>2=Reported Minimum RPM: 2000. Tach Count Multiplier: 4</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TACH_COUNT_MULTIPLIER_2</name>
                           <description>1=Reported Minimum RPM: 1000. Tach Count Multiplier: 2</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TACH_COUNT_MULTIPLIER_1</name>
                           <description>0=Reported Minimum RPM:  500. Tach Count Multiplier: 1</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>EN_ALGO</name>
                     <description>Enables the RPM based Fan Control Algorithm.                  1=The control circuitry is enabled and the Fan Driver output will be automatically updated to maintain the programmed fan speed        as indicated by the TACH Target Register.        0=The control circuitry is disabled and the fan driver output is determined by the Fan Driver Setting Register.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POLARITY</name>
                     <description>Determines the polarity of the PWM driver. This does NOT affect the drive setting registers. A setting of 0% drive will      still correspond to 0% drive independent of the polarity.      1 - The Polarity of the PWM driver is inverted. A drive setting of 00h will cause the output to be set at 100% duty cycle and       a drive setting of FFh will cause the output to be set at 0% duty cycle.       0 - the Polarity of the PWM driver is normal. A drive setting of 00h will cause the output to be set at 0% duty cycle and      a drive setting of FFh will cause the output to be set at 100% duty cycle.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERR_RNG</name>
                     <description>Control some of the advanced options that affect the error window. When the measured fan speed is within the programmed         error window around the target speed, the fan drive setting is not updated. These bits only apply if the Fan Speed Control Algorithm is used.            3=200 RPM               2=100 RPM               1=50 RPM              0=0 RPM</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>ERR_RNGSelect</name>
                        <enumeratedValue>
                           <name>RPM_200</name>
                           <description>3=200 RPM</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RPM_100</name>
                           <description>2=100 RPM</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RPM_50</name>
                           <description>1=50 RPM</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RPM_0</name>
                           <description>0=0 RPM</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DER_OPT</name>
                     <description>Control some of the advanced options that affect the derivative portion of the RPM based fan control algorithm.        These bits only apply if the Fan Speed Control Algorithm is used.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>DIS_GLITCH</name>
                     <description>Disables the low pass glitch filter that removes high frequency noise injected on the TACH pin.       1 - The glitch filter is disabled.      0 - The glitch filter is enabled.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_RRC</name>
                     <description>Enables the ramp rate control circuitry during the Manual Mode of operation.        1=The ramp rate control circuitry for the Manual Mode of operation is enabled. The PWM setting will follow the ramp rate controls       as determined by the Fan Step and Update Time settings. The maximum PWM step is capped at the Fan Step setting and is updated        based on the Update Time as given by the field UPDATE.         0=The ramp rate control circuitry for the Manual Mode of operation is disabled. When the Fan Drive Setting values are changed        and the RPM based Fan Control Algorithm is disabled, the fan driver will be set to the new setting immediately.</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PWM_DIVIDE</name>
               <description>PWM Divide</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <resetValue>0x01</resetValue>
               <fields>
                  <field>
                     <name>PWM_DIVIDE</name>
                     <description>The PWM Divide value determines the final frequency of the PWM driver. The driver base frequency is divided by the      PWM Divide value to determine the final frequency.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>GAIN</name>
               <description>Gain Register stores the gain terms used by the proportional and integral portions of the RPM based Fan Control Algorithm.</description>
               <addressOffset>0x5</addressOffset>
               <size>8</size>
               <resetValue>0x2A</resetValue>
               <fields>
                  <field>
                     <name>GAINP</name>
                     <description>The proportional gain term.       Gain Factor:          3=8x             2=4x              1=2x             0=1x</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>GAINPSelect</name>
                        <enumeratedValue>
                           <name>GAINP_8X</name>
                           <description>Gain Factor: 3=8x</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINP_4X</name>
                           <description>Gain Factor: 2=4x</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINP_2X</name>
                           <description>Gain Factor: 1=2x</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINP_1X</name>
                           <description>Gain Factor: 0=1x</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>GAINI</name>
                     <description>The integral gain term.        Gain Factor:                3=8x               2=4x                 1=2x                 0=1x</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>GAINISelect</name>
                        <enumeratedValue>
                           <name>GAINI_8X</name>
                           <description>Gain Factor: 3=8x</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINI_4X</name>
                           <description>Gain Factor: 2=4x</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINI_2X</name>
                           <description>Gain Factor: 1=2x</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINI_1X</name>
                           <description>Gain Factor: 0=1x</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>GAIND</name>
                     <description>The derivative gain term.      Gain Factor:       3=8x           2=4x           1=2x              0=1x</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>GAINDSelect</name>
                        <enumeratedValue>
                           <name>GAIND_8X</name>
                           <description>Gain Factor: 3=8x</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAIND_4X</name>
                           <description>Gain Factor: 2=4x</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAIND_2X</name>
                           <description>Gain Factor: 1=2x</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAIND_1X</name>
                           <description>Gain Factor: 0=1x</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>SPN_UP_CNFG</name>
               <description>The Fan Spin Up Configuration Register controls the settings of Spin Up Routine.</description>
               <addressOffset>0x6</addressOffset>
               <size>8</size>
               <resetValue>0x19</resetValue>
               <fields>
                  <field>
                     <name>SPINUP_TIME</name>
                     <description>Determines the maximum Spin Time that the Spin Up Routine will run for. If a valid tachometer measurement is not           detected before the Spin Time has elapsed, an interrupt will be generated. When the RPM based Fan Control Algorithm is active,         the fan driver will attempt to re-start the fan immediately after the end of the last spin up attempt.               3=2 seconds               2=1 second                 1=500 ms               0=250 ms</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>SPINUP_TIMESelect</name>
                        <enumeratedValue>
                           <name>SPINUP_2_SEC</name>
                           <description>3=2 seconds</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPINUP_1_SEC</name>
                           <description>2=1 second</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPINUP_500_MSEC</name>
                           <description>1=500 ms</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPINUP_250_MSEC</name>
                           <description>0=250 ms</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SPIN_LVL</name>
                     <description>Determines the final drive level that is used by the Spin Up Routine.       7=65%             6=60%           5=55%            4=50%               3=45%            2=40%            1=35%           0=30%</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <name>SPIN_LVLSelect</name>
                        <enumeratedValue>
                           <name>SPIN_LVL_65</name>
                           <description>7=65%</description>
                           <value>0x7</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_60</name>
                           <description>6=60%</description>
                           <value>0x6</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_55</name>
                           <description>5=55%</description>
                           <value>0x5</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_50</name>
                           <description>4=50%</description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_45</name>
                           <description>3=45%</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_40</name>
                           <description>2=40%</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_35</name>
                           <description>1=35%</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_30</name>
                           <description>0=30%</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>NOKICK</name>
                     <description>Determines if the Spin Up Routine will drive the fan to 100% duty cycle for 1/4 of the programmed spin up time before            driving it at the programmed level.              1=The Spin Up Routine will not drive the PWM to 100%. It will set the drive at the programmed spin level for the entire duration of         the programmed spin up time         0=The Spin Up Routine will drive the PWM to 100% for 1/4 of the programmed spin up time before reverting to the programmed spin level.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRV_FAIL_CNT</name>
                     <description>Determines how many update cycles are used for the Drive Fail detection function. This circuitry determines whether the      fan can be driven to the desired Tach target. These settings only apply if the Fan Speed Control Algorithm is enabled.        3=Drive Fail detection circuitry will count for 64 update periods       2=Drive Fail detection circuitry will count for 32 update periods         1=Drive Fail detection circuitry will count for 16 update periods          0=Drive Fail detection circuitry is disabled.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>DRV_FAIL_CNTSelect</name>
                        <enumeratedValue>
                           <name>DRIVE_FAIL_CNT_64_PERIOD</name>
                           <description>3=Drive Fail detection circuitry will count for 64 update periods</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DRIVE_FAIL_CNT_32_PERIOD</name>
                           <description>2=Drive Fail detection circuitry will count for 32 update periods</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DRIVE_FAIL_CNT_16_PERIOD</name>
                           <description>1=Drive Fail detection circuitry will count for 16 update periods</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DRIVE_FAIL_CNT_DIS</name>
                           <description>0=Drive Fail detection circuitry is disabled.</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>STEP</name>
               <description>FAN_STEP The Fan Step value represents the maximum step size the fan driver will take between update times</description>
               <addressOffset>0x7</addressOffset>
               <size>8</size>
               <resetValue>0x10</resetValue>
               <fields>
                  <field>
                     <name>FAN_STEP</name>
                     <description>The Fan Step value represents the maximum step size the fan driver will take between update times.      When the PWM_BASE frequency range field in the PWM Driver Base Frequency Register is set to the value 1, 2 or 3, this 8-bit field        is added to the 10-bit PWM duty cycle, for a maximum step size of 25%. When the PWM_BASE field is set to 0, the PWM operates in        an 8-bit mode. In 8-bit mode, this 8-bit field is added to the 8-bit duty cycle, for a maximum step size of 100%.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MIN_DRV</name>
               <description>the minimum drive setting for the RPM based Fan Control Algorithm.</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <resetValue>0x66</resetValue>
               <fields>
                  <field>
                     <name>MIN_DRIVE</name>
                     <description>The minimum drive setting.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>VALID_TCH_CNT</name>
               <description>The maximum TACH Reading Register value to indicate that the fan is spinning properly.</description>
               <addressOffset>0x9</addressOffset>
               <size>8</size>
               <resetValue>0xF5</resetValue>
               <fields>
                  <field>
                     <name>VALID_TACH_CNT</name>
                     <description>The maximum TACH Reading Register value to indicate that the fan is spinning properly.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DRV_FAL_BND</name>
               <description>The number of Tach counts used by the Fan Drive Fail detection circuitry</description>
               <addressOffset>0xA</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>FAN_DRIVE_FAIL_BAND</name>
                     <description>The number of Tach counts used by the Fan Drive Fail detection circuitry.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TACH_TRGT</name>
               <description>The target tachometer value.</description>
               <addressOffset>0xC</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>TACH_TARGET</name>
                     <description>The target tachometer value.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TACH_RDNG</name>
               <description>[15:3] The current tachometer reading value.</description>
               <addressOffset>0xE</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>TACH_READING</name>
                     <description>The current tachometer reading value.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DRV_BS_FREQ</name>
               <description>[1:0] Determines the frequency range of the PWM fan driver</description>
               <addressOffset>0x10</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>PWM_BASE</name>
                     <description>Determines the frequency range of the PWM fan driver (when enabled). PWM resolution is 10-bit, except when this field        is set to '0b', when it is 8-bit.                 3=2.34KHz                 2=4.67KHz                 1=23.4KHz                0=26.8KHz</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>PWM_BASESelect</name>
                        <enumeratedValue>
                           <name>PWM_FAN_FREQ_2KHZ</name>
                           <description>3=2.34KHz</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PWM_FAN_FREQ_4KHZ</name>
                           <description>2=4.67KHz</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PWM_FAN_FREQ_23KHZ</name>
                           <description>1=23.4KHz</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PWM_FAN_FREQ_26KHZ</name>
                           <description>0=26.8KHz</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS</name>
               <description>The bits in this register are routed to interrupts.</description>
               <addressOffset>0x11</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>FAN_STALL</name>
                     <description>The bit Indicates that the tachometer measurement on the Fan detects a stalled fan.  (R/WC)       0 - Stalled fan not detected.               1 - Stalled fan detected.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAN_SPIN</name>
                     <description>The bit Indicates that the Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum           time window. (R/WC)            1 - The Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum time window.          0 - The Spin up Routine for the Fan detected a valid tachometer reading within its maximum time window.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIVE_FAIL</name>
                     <description>The bit Indicates that the RPM-based Fan Speed Control Algorithm cannot drive the Fan to the desired target setting at       maximum drive. (R/WC)        1- The RPM-based Fan Speed Control Algorithm cannot drive Fan to the desired target setting at maximum drive.                0- The RPM-based Fan Speed Control Algorithm can drive Fan to the desired target setting.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="FAN0">
         <name>FAN1</name>
         <baseAddress>0x4000A080</baseAddress>
         <interrupt>
            <name>RPM2PWM_1_STALL</name>
            <value>76</value>
         </interrupt>
         <interrupt>
            <name>RPM2PWM_1_SPIN</name>
            <value>77</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>PECI</name>
         <version>481.0</version>
         <description>The PECI Interface allows the EC to retrieve temperature readings from PECI-compliant devices.</description>
         <baseAddress>0x40006400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x48</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ17</name>
            <value>9</value>
         </interrupt>
         <interrupt>
            <name>PECI</name>
            <value>70</value>
         </interrupt>
         <registers>
            <register>
               <name>WDATA</name>
               <description>The Write Data Register provides access to a 32-byte Transmit FIFO.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>RDATA</name>
               <description>The Read Data Register provides access to a 32-byte Receive FIFO.</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>Control Register</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <resetValue>0x01</resetValue>
               <fields>
                  <field>
                     <name>PD</name>
                     <description>PD (Power Down) along with RST controls the Power Management Interface</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST</name>
                     <description>RST indicates that the PECI Core should be reset.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FRST</name>
                     <description>FRST is the FIFO Reset bit.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXEN</name>
                     <description>TXEN is the Transmit Enable bit.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MIEN</name>
                     <description>MIEN is the Master Interrupt Enable</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS1</name>
               <description>Status Register 1</description>
               <addressOffset>0xC</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>BOF</name>
                     <description>BOF (Beginning of Frame) is asserted when the PECI Core begins Address Timing Negotiation. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EOF</name>
                     <description>EOF (End of Frame) is asserted following Message Stop (tSTOP). (R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERR</name>
                     <description>ERR Indicates that an error for the current transaction has been detected.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RDY</name>
                     <description>RDY represents the state of the READY signal function</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RDYLO</name>
                     <description>RDYLO is asserted '1' on the falling edge of the READY signal function (R/WC)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RDYHI</name>
                     <description>RDYHI is asserted '1' on the rising edge of the READY signal function (R/WC)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MINT</name>
                     <description>MINT is the Master Interrupt Status bit and is asserted when any interrupt status bit in the Interrupt Interface is asserted.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS2</name>
               <description>Status Register 2</description>
               <addressOffset>0x10</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x8A</resetValue>
               <fields>
                  <field>
                     <name>WFF</name>
                     <description>WFF indicates that the Write Data Register FIFO is full. WFF does not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WFE</name>
                     <description>WFE indicates that the Write Data Register FIFO is empty.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RFF</name>
                     <description>RFF indicates that the Read Data Register FIFO is full.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RFE</name>
                     <description>RFE indicates that the Read Data Register FIFO is empty. RFE does not generate an interrupt.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IDLE</name>
                     <description>The IDLE status bit indicates when the SST/PECI bus is idle and a new transaction may begin.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ERROR</name>
               <description>Error Register</description>
               <addressOffset>0x14</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>FERR</name>
                     <description>FERR (Frame Check Sequence Error). (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BERR</name>
                     <description>BERR (Bus Error). Bus contention has been detected. BERR is asserted when the PECI Module reads a value that is different from what it has driven (R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REQERR</name>
                     <description>REQERR is asserted if PEC_AVAILABLE (READY) input is not asserted when the counts down to zero as shown in. When asserted, REQERR can generate interrupt. (R/WC)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WROV</name>
                     <description>WROV (Write Overrun). (R/WC)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WRUN</name>
                     <description>WRUN (Write Underrun). (R/WC)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RDOV</name>
                     <description>RDOV (Read Overrun). RDOV indicates that the internal read buffer has overflowed (R/WC)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLKERR</name>
                     <description>CLKERR indicates that the READY signal function in the Hardware Interface was de-asserted in the middle of a transaction (R/WC)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN1</name>
               <description>Interrupt Enable 1 Register</description>
               <addressOffset>0x18</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>BIEN</name>
                     <description>When the BIEN bit is asserted '1' the BOF interrupt is enabled.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EIEN</name>
                     <description>When the EIEN bit is asserted '1' the EOF interrupt is enabled.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EREN</name>
                     <description>When the EREN bit is asserted '1' the ERR interrupt is enabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RLEN</name>
                     <description>When the RLEN bit is asserted '1' the RDYLO interrupt is enabled.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RHEN</name>
                     <description>When the RHEN bit is asserted '1' the RDYHI interrupt is enabled.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN2</name>
               <description>Interrupt Enable 2 Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ENWFE</name>
                     <description>When the ENWFE bit is asserted '1' the WFE interrupt is enabled.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENRFF</name>
                     <description>When the ENRFF bit is asserted '1' the RFF interrupt is enabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OPTBTLO</name>
               <description>Optimal Bit Time Register (Low Byte)</description>
               <addressOffset>0x20</addressOffset>
               <size>8</size>
               <resetValue>0x16</resetValue>
            </register>
            <register>
               <name>OPTBTHI</name>
               <description>Optimal Bit Time Register (High Byte)</description>
               <addressOffset>0x24</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>BDCTRL</name>
               <description>Baud Control Register.     The baud div value divides down the sytem clock frequency to create the peci CORE_CLK frequency.</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <resetValue>0x00000006</resetValue>
            </register>
            <register>
               <name>BLKID</name>
               <description>Block ID Register</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x000000C0</resetValue>
            </register>
            <register>
               <name>BLKREV</name>
               <description>Revision Register</description>
               <addressOffset>0x44</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>ADC</name>
         <version>1771.0</version>
         <description>This block is designed to convert external analog voltage readings into digital values.</description>
         <baseAddress>0x40007C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x90</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>ADC_SNGL</name>
            <value>78</value>
         </interrupt>
         <interrupt>
            <name>ADC_RPT</name>
            <value>79</value>
         </interrupt>
         <registers>
            <register>
               <name>CTRL</name>
               <description>The ADC Control Register is used to control the behavior of the Analog to Digital Converter.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00010106</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>0: The ADC is disabled and placed in its lowest power state. 1: ADC block is enabled for operation.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT_SIN</name>
                     <description>(START_SINGLE) 0: The ADC Single Mode is disabled. 1: The ADC Single Mode is enabled. Note: This bit is self-clearing</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT_RPT</name>
                     <description>0: The ADC Repeat Mode is disabled. 1: The ADC Repeat Mode is enabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWR_SAV_DIS</name>
                     <description>0: Power saving feature is enabled. 1: Power saving feature is disabled.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SFT_RST</name>
                     <description>(SOFT_RESET) 1: writing one causes a reset of the ADC block hardware (not the registers) 0: writing zero takes the ADC block out of reset</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPT_DONE_STS</name>
                     <description>0: ADC repeat-sample conversion is not complete. 1: ADC repeat-sample conversion is completed. (R/WC)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SIN_DONE_STS</name>
                     <description>0: ADC single-sample conversion is not complete. 1: ADC single-sample conversion is completed. (R/WC)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DELAY</name>
               <description>The ADC Delay register determines the delay from setting Start_Repeat in the ADC Control Register and the start of a conversion cycle. This register also controls the interval between conversion cycles in repeat mode.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>STRT_DLY</name>
                     <description>This field determines the starting delay before a conversion cycle is begun when Start_Repeat is written with a 1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
                  <field>
                     <name>RPT_DLY</name>
                     <description>This field determines the interval between conversion cycles when Start_Repeat is 1.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CHAN_STS</name>
               <description>The ADC Status Register indicates whether the ADC has completed a conversion cycle. All bits are cleared by being written with a 1.             0: conversion of the corresponding ADC channel is not complete            1: conversion of the corresponding ADC channel is complete</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>STS</name>
                     <description>All bits are cleared by being written with a '1'. 1=conversion of the corresponding ADC channel is complete;      0=conversion of the corresponding ADC channel is not complete. For enabled single cycles, the SINGLE_DONE_STATUS bit in the      ADC Control Register is also set after all enabled channel conversion are done; for enabled repeat cycles, the REPEAT_DONE_STATUS      in the ADC Control Register is also set after all enabled channel conversion are done.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SNG_EN</name>
               <description>The ADC Single Register is used to control which ADC channel is captured during a Single-Sample conversion cycle initiated by the Start_Single bit in the ADC Control Register.             APPLICATION NOTE: Do not change the bits in this register in the middle of a conversion cycle to insure proper operation.            0: single cycle conversions for this channel are disabled            1: single cycle conversions for this channel are enabled</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>S_EN</name>
                     <description>Each bit in this field enables the corresponding ADC channel when a single cycle of conversions is started when the      START_SINGLE bit in the ADC Control Register is written with a 1. 1=single cycle conversions for this channel are enabled      0=single cycle conversions for this channel are disabled. Note: If this register is changed while a conversion.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>REPT_EN</name>
               <description>The ADC Repeat Register is used to control which ADC channels are captured during a repeat conversion cycle initiated by the Start_Repeat bit in the ADC Control Register.</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>R_EN</name>
                     <description>Each bit in this field enables the corresponding ADC channel for each pass of the Repeated ADC Conversion that is      controlled by bit START_REPEAT in the ADC Control Register. 1=repeat conversions for this channel are enabled;      0=repeat conversions for this channel are disabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>16</dim>
               <dimIncrement>4</dimIncrement>
               <name>CHAN_RD[%s]</name>
               <description>All 16 ADC channels return their results into a 32-bit reading register. In each case the low 10 bits of the reading register     return the result of the Analog to Digital conversion and the upper 22 bits return 0.</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CFG</name>
               <description>The ADC Configuration Register is used to configure the ADC clock timing.</description>
               <addressOffset>0x7C</addressOffset>
               <size>32</size>
               <resetValue>0x00000101</resetValue>
               <fields>
                  <field>
                     <name>CLKLW_TIM</name>
                     <description>These bits define the low time count of the ADC clock.         0= not used.         1= 1 System Clock.         2= 2 System Clock.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CLKHIGH_TIM</name>
                     <description>These bits define the high time count of the ADC clock.         0= not used.         1= 1 System Clock.         2= 2 System Clock.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CLKDUMY_TIM</name>
                     <description>These bits define the dummy cycles of the ADC clock.         Valid Values are from 0x0 to 0xF.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>PWRUP_DLY</name>
                     <description>These bits define the power up delay in number of micro-seconds.         Valid Values are from 0x0 to 0xF.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>DUMYCYC_GAP</name>
                     <description>These bits define the number of micro-seconds between consective Starts.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>VREF_CHAN</name>
               <description>The ADC Channel Register is used to configure the reference voltage to the clock timing.</description>
               <addressOffset>0x80</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SEL0</name>
                     <description>These bits define the reference voltage for Channel 0.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL1</name>
                     <description>These bits define the reference voltage for Channel 1.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL2</name>
                     <description>These bits define the reference voltage for Channel 2.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL3</name>
                     <description>These bits define the reference voltage for Channel 3.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL4</name>
                     <description>These bits define the reference voltage for Channel 4.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL5</name>
                     <description>These bits define the reference voltage for Channel 5.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL6</name>
                     <description>These bits define the reference voltage for Channel 6.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL7</name>
                     <description>These bits define the reference voltage for Channel 7.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL8</name>
                     <description>These bits define the reference voltage for Channel 8.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL9</name>
                     <description>These bits define the reference voltage for Channel 9.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL10</name>
                     <description>These bits define the reference voltage for Channel 10.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL11</name>
                     <description>These bits define the reference voltage for Channel 11.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL12</name>
                     <description>These bits define the reference voltage for Channel 12.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL13</name>
                     <description>These bits define the reference voltage for Channel 13.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL14</name>
                     <description>These bits define the reference voltage for Channel 14.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SEL15</name>
                     <description>These bits define the reference voltage for Channel 15.         0h= VREF0         1h= VREF1         2h= Reserved         3h= Reserved</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>VREF_CTRL</name>
               <description>This is the VREF Control Register</description>
               <addressOffset>0x84</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CHRG_DLY</name>
                     <description>This field represnts the delay time to charge up the external VREF capacitor.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
                  <field>
                     <name>SWITCH_DLY</name>
                     <description>This field represnts the delay time interval between switching VREF Selects.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
                  <field>
                     <name>PADCTRL</name>
                     <description>This fields give the choice to the application whether to float the unused PAD's or to Drive them to 0.         1= Drive unused PAD's Low 0b         0= Leave unused PAD's Floating.</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SELSTAT</name>
                     <description>This fields gives information about the current VREF selected.         0x0= VREF0         0x1= VREF1         0x2= Reserved         0x3= Reserved</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SAR_CTRL</name>
               <description>This is the SAR ADC Control Register.</description>
               <addressOffset>0x88</addressOffset>
               <size>32</size>
               <resetValue>0x00000006</resetValue>
               <fields>
                  <field>
                     <name>SEL_DIFF</name>
                     <description>This field select between Single ended / Differential input.    0= ADC core is enabled for single ended input operation.    1= ADC core is enabled for differential input operation.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SEL_RES</name>
                     <description>This field select the ADC Resolution (10/12 bits).    0x0= Reserved.    0x1= Reserved.    0x2= 10 bit ADC resolution.    0x3= 12 bit ADC resolution.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SHIFT_DAT</name>
                     <description>This field defined if the ADC output is Right or Left Justified.         1= adc_dout is not shifted and lower bits are set to 0.         0= adc_dout is shifted right following resolution selected.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_ASYN_SMPL</name>
                     <description>This field enables asynchronous sampling.         0= Async Sampling Disabled.         1= Async Sampling Enabled.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_SERIAL</name>
                     <description>This field enables serial output (dout) from ADC.         0= Parallel dout.         1= Serial dout.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WARM_UP_DLY</name>
                     <description>This field represents the warmup delay number in microseconds.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>9</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SAR_CFG</name>
               <description>This is the SAR ADC Configuration Register.</description>
               <addressOffset>0x8C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN_CMBF</name>
                     <description>Enable Common Mode Buffer Amplifier.    0= Common Mode Buffer Amplifier is high all the time.    1= Controls Common Mode Buffer Amplifier during power cycling.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIS_DOUT</name>
                     <description>Disable Parallel Output.    0= Enable Parallel Output.    1= Disable Parallel Output.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_DITHER</name>
                     <description>Enable Dithering.    0= Disable Dither.    1= Enable Dither.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAZ_AU_ZERO</name>
                     <description>Enable F_AZ AUTOZEROING.    1= Disable f_az autozeroing.    0= Enable f_az autozeroing.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAZ_AU_ZERO</name>
                     <description>Enable S_AZ AUTOZEROING.    1= Disable S_AZ autozeroing.    0= Enable S_AZ autozeroing.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LAZ_AU_ZERO</name>
                     <description>Enable L_AZ AUTOZEROING.    1= Disable L_AZ autozeroing.    0= Enable L_AZ autozeroing.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_RADC</name>
                     <description>Enable RADC.    1 = RDAC remains high during power cycling.    0 = Controls RDAC during power cycling.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REGEN_DLY</name>
                     <description>This register defines the delay between regen and latch.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CLK_DIV</name>
                     <description>This register defines the programmable ADC Clock divider value.         Divider ratios of 256,128,64,32,16 are supported.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
                  <field>
                     <name>IADC_RANGE2</name>
                     <description>This register controls the current consumption for the whole ADC.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>IADC_RANGE1</name>
                     <description>This register controls the current consumption for the whole ADC.</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>ICMBF_STG1</name>
                     <description>This register controls the bias current for the 1st stage of the comparator.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>ICMBF_STG2</name>
                     <description>This register controls the bias current for the 2nd stage of the comparator.</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>ICMBF</name>
                     <description>This register controls the bias current for common mode buffer amplifier.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>EN_EXT_BIAS</name>
                     <description>EN external bias.    1 = Disables internal switched cap bias circuit.    0 = Enables internal switched cap bias circuit.</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>PHOT</name>
         <version>511.0</version>
         <description>This block monitors the PROCHOT# signal and designed to detect single assertions and monitor cumulative PROCHOT active time.</description>
         <baseAddress>0x40003400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x18</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>PHOT</name>
            <value>87</value>
         </interrupt>
         <registers>
            <register>
               <name>CUCNT</name>
               <description>PROCHOT Cumulative Count Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ACTIVE</name>
                     <description>This register contains the current filtered PROCHOT Active Counter value.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>24</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DC_CNT</name>
               <description>PROCHOT Duty Cycle Count Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CNT</name>
                     <description>The contents of the PROCHOT Cumulative Count Register is copied into this register when the PROCHOT Duty Cycle Period Register transitions from 1 to 0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>24</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DC_PER</name>
               <description>PROCHOT Duty Cycle Period Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PER</name>
                     <description>This register defines the number of 100KHz periods required for a duty cycle measurement.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>24</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL_STS</name>
               <description>PROCHOT Status/Control Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000002</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>This bit enables the PROCHOT Monitor logic.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PIN</name>
                     <description>When PHOT_ENABLE is 1b, this bit reflects the state of the PROCHOT# Pin input.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ASSERT_EN</name>
                     <description>This bit determines whether or not an interrupt will be generated when the PHOT_ASSERT bit is set.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PER_EN</name>
                     <description>This bit determines whether or not an interrupt will be generated when the PHOT_PERIOD bit is set.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST</name>
                     <description>Writing this self-clearing bit to one resets all the registers and logic in the PROCHOT Monitor block to its defined initial state.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FILT_EN</name>
                     <description>This bit determines whether a digital filter eliminates pulses on the PROCHOT# signal before PROCHOT# is sampled by the Assertion counter or the Active counter.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ASSERT</name>
                     <description>This bit is set when the PROCHOT Assertion Counter Register value is greater than or equal to the PROCHOT Assertion Counter Limit Register value. (R/WC)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PER</name>
                     <description>This sticky status bit is set to '1b' when the PROCHOT Period Counter transitions from '1b' to '0b.' (R/WC)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ASCNT</name>
               <description>PROCHOT Assertion Counter Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CNT</name>
                     <description>The PROCHOT Assertion Counter is a 16-bit up-counter that is clocked by the 100KHz and is gated and reset by the PROCHOT# input signal. This counter is used to measure a single PROCHOT assertion.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ASCLIM</name>
               <description>PROCHOT Assertion Counter Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CLIM</name>
                     <description>The PROCHOT Assertion Counter Limit register is compared to the 16-bit PROCHOT Assertion Counter.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>LED0</name>
         <version>1111.0</version>
         <description>The LED is implemented using a PWM that can be driven either by the 48 MHz clock or by a 32.768 KHz clock input.</description>
         <groupName>LED</groupName>
         <prependToName>LED_</prependToName>
         <baseAddress>0x4000B800</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x18</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>LED0</name>
            <value>83</value>
         </interrupt>
         <registers>
            <register>
               <name>CFG</name>
               <description>LED Configuration</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00001400</resetValue>
               <fields>
                  <field>
                     <name>CTRL</name>
                     <description>CONTROL 3=PWM is always on                  2=LED blinking (standard PWM)                  1=LED breathing configuration                  0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CLK_SRC</name>
                     <description>1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SYNCH</name>
                     <description>SYNCHRONIZE  When this bit is '1', all counters for all LEDs are reset to their initial values. When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM_SIZE</name>
                     <description>PWM_SIZE This bit controls the behavior of PWM:                  3=Reserved                  2=PWM is configured as a 6-bit PWM                  1=PWM is configured as a 7-bit PWM                  0=PWM is configured as an 8-bit PWM</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>EN_UPDATE</name>
                     <description>ENABLE_UPDATE  This bit is set to 1 when written with a '1'. Writes of '0' have no effect. Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST</name>
                     <description>RESET  Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing. Writes of '0' to this bit have no effect.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_RELOAD</name>
                     <description>WDT_RELOAD  The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>SYMMETRY</name>
                     <description>SYMMETRY  1=The rising and falling ramp times are in Asymmetric mode.                  0=The rising and falling ramp times are in Symmetric mode.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LIMIT</name>
               <description>LED Limits This register may be written at any time. Values written into the register are held in an holding register, which is transferred into the actual register at the end of a PWM period. The two byte fields may be written independently. Reads of this register return the current contents and not the value of the holding register.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MIN</name>
                     <description>In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode, this field defines the duty cycle of the blink function.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MAX</name>
                     <description>In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DLY</name>
               <description>LED Delay</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LOW_PULSE</name>
                     <description>The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MIN in register LED_LIMIT.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>HIGH_PULSE</name>
                     <description>In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MAX in register LED_LIMIT.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STEP</name>
               <description>This register has eight segment fields which provide the amount the current duty cycle is adjusted at the end of every PWM period. Segment field selection is decoded based on the segment index. The segment index equation utilized depends on the SYMMETRY bit in the LED Configuration Register Register)              . In Symmetric Mode the Segment_Index[2:0] = Duty Cycle Bits[7:5]              . In Asymmetric Mode the Segment_Index[2:0] is the bit concatenation of following: Segment_Index[2] = (FALLING RAMP TIME in Figure 30-3, Clipping Example) and Segment_Index[1:0] = Duty Cycle Bits[7:6].</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>S0</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S1</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S2</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S3</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S4</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S5</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S6</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S7</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INTRVL</name>
               <description>LED Update Interval</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>I0</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I1</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I2</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I3</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I4</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I5</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I6</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I7</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OUTDLY</name>
               <description>LED Output Delay</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DELAY</name>
                     <description>The delay, in counts of the clock defined in Clock Source (CLKSRC), in which output transitions are delayed.     When this field is 0, there is no added transition delay. When the LED is programmed to be Always On or Always Off, the     Output Delay field has no effect.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="LED0">
         <name>LED1</name>
         <baseAddress>0x4000B900</baseAddress>
         <interrupt>
            <name>LED1</name>
            <value>84</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="LED0">
         <name>LED2</name>
         <baseAddress>0x4000BA00</baseAddress>
         <interrupt>
            <name>LED2</name>
            <value>85</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="LED0">
         <name>LED3</name>
         <baseAddress>0x4000BB00</baseAddress>
         <interrupt>
            <name>LED3</name>
            <value>86</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>RC_ID0</name>
         <version>551.0</version>
         <description>This interface provides a single pin interface which can discriminate a number of quantized RC constants.</description>
         <groupName>RC_ID</groupName>
         <prependToName>RC_ID_</prependToName>
         <baseAddress>0x40001400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x8</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>RC_ID0</name>
            <value>80</value>
         </interrupt>
         <registers>
            <register>
               <name>CONTROL</name>
               <description>RC_ID Control Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DONE</name>
                     <description>This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes an RC_ID measurement.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TC</name>
                     <description>This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes the Discharged phase of an RC_ID measurement.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CY_ER</name>
                     <description>This bit is 1 if an RC_ID measurement encountered an error and the reading in the RC_ID Data Register is invalid. This bit is cleared to 0 when the RC_ID interface is in the Reset phase.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>START</name>
                     <description>Setting this bit to 1 initiates the Discharged phase of an RC_ID measurement.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENABLE</name>
                     <description>Clearing the bit to 0 causes the RC_ID interface to enter the Reset state, gating its clocks, clearing the status bits in this register and entering        into its lowest power state. Setting this bit to 1 causes the RC_ID interface to enter the Armed phase of an RC_ID measurement.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLOCK_SET</name>
                     <description>This field selects the frequency of the Counter circuit clock. This field must retain the same value as long as the ENABLE bit in this register is 1.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DATA</name>
               <description>Reads of this register provide the result of an RC_ID measurement.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RCID_DATA</name>
                     <description>Reads of this register provide the result of an RC_ID measurement.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="RC_ID0">
         <name>RC_ID1</name>
         <baseAddress>0x40001480</baseAddress>
         <interrupt>
            <name>RC_ID1</name>
            <value>81</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="RC_ID0">
         <name>RC_ID2</name>
         <baseAddress>0x40001500</baseAddress>
         <interrupt>
            <name>RC_ID2</name>
            <value>82</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>KMS</name>
         <version>331.0</version>
         <description>The Keyboard Scan Interface block provides a register interface to directly scan an external keyboard matrix of size up to 18x8.</description>
         <baseAddress>0x40009C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x18</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>KEYSCAN</name>
            <value>135</value>
         </interrupt>
         <registers>
            <register>
               <name>KSO_SEL</name>
               <description>KSO Select and control</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000040</resetValue>
               <fields>
                  <field>
                     <name>SEL</name>
                     <description>This field selects a KSO line (00000b = KSO[0] etc.) for output according to the value off KSO_INVERT in this register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
                  <field>
                     <name>ALL</name>
                     <description>0=When key scan is enabled, KSO output controlled by the KSO_SELECT field.                1=KSO[x] driven high when selected.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KSEN</name>
                     <description>0= Keyboard scan enabled, 1= Keyboard scan disabled. All KSO output buffers disabled.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INV</name>
                     <description>0= KSO[x] driven low when selected, 1= KSO[x] driven high when selected.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>KSI</name>
               <description>[7:0] This field returns the current state of the KSI pins.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>KSI_STS</name>
               <description>[7:0] Each bit in this field is set on the falling edge of the corresponding KSI input pin.            A KSI interrupt is generated when its corresponding status bit and interrupt enable bit are both set. KSI interrupts are logically ORed together to produce KSC_INT and KSC_INT_WAKE.            Writing a '1' to a bit will clear it. Writing a '0' to a bit has no effect.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>KSI_IEN</name>
               <description>[7:0] Each bit in KSI_INT_EN enables interrupt generation due to highto-low transition on a KSI input. An interrupt is generated when the corresponding bits in KSI_STATUS and KSI_INT_EN are both set.</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EXT_CTRL</name>
               <description>[0:0] PREDRIVE_ENABLE enables the PREDRIVE mode to actively drive the KSO pins high for approximately 100ns before switching to open-drain operation.            0=Disable predrive on KSO pins            1=Enable predrive on KSO pins.</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>SMB0</name>
         <version>311.0</version>
         <description>The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface.</description>
         <groupName>SMB</groupName>
         <prependToName>SMB_</prependToName>
         <baseAddress>0x40004000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x7D</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ13</name>
            <value>5</value>
         </interrupt>
         <interrupt>
            <name>I2CSMB0</name>
            <value>20</value>
         </interrupt>
         <registers>
            <register>
               <name>WCTRL</name>
               <description>Control Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ACK</name>
                     <description>The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STO</name>
                     <description>See STA description</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STA</name>
                     <description>The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENI</name>
                     <description>Enable Interrupt bit (ENI) controls the Interrupt Interface</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESO</name>
                     <description>The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PIN</name>
                     <description>The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RSTS</name>
               <description>Status Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000081</resetValue>
               <fields>
                  <field>
                     <name>NBB</name>
                     <description>The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LAB</name>
                     <description>The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AAS</name>
                     <description>The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LRB_AD0</name>
                     <description>The Last Received Bit  or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0').                When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus.                When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BER</name>
                     <description>When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS</name>
                     <description>When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAD</name>
                     <description>SMBus Address Decoded (SAD)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PIN</name>
                     <description>Pending Interrupt bit</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OWN_ADDR</name>
               <description>Own Address Register           Note that the Data Register and Own Address fields are offset by one bit, so that programming Own Address 1 with a value of 55h will result in the value AAh being recognized as the SMB Controller Core slave address.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADDR1</name>
                     <description>The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>ADDR2</name>
                     <description>The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>I2CDATA</name>
               <description>This register holds the data that are either shifted out to or shifted in from the I2C port.</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <dim>3</dim>
               <dimIncrement>1</dimIncrement>
               <name>RSVD1[%s]</name>
               <description>Reserved</description>
               <addressOffset>0x9</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>MCMD</name>
               <description>SMBus Master Command Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MRUN</name>
                     <description>While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MPROCEED</name>
                     <description>When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>START0</name>
                     <description>If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STARTN</name>
                     <description>If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STOP</name>
                     <description>If this bit is 1, send a Stop bit after the transaction completes.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PEC_TERM</name>
                     <description>If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>READM</name>
                     <description>If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount[7:0] is 1. After ReadCount[7:0] is updated, this bit is cleared to 0.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RD_PEC</name>
                     <description>If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_CNT</name>
                     <description>This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>RD_CNT</name>
                     <description>This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCMD</name>
               <description>SMBus Slave Command Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRUN</name>
                     <description>Setting this bit to 1 enables the Slave State Machine to operate.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPROCEED</name>
                     <description>When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PEC</name>
                     <description>If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_CNT</name>
                     <description>This field is set to the number of bytes software expects to send to the Master.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>RD_CNT</name>
                     <description>This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PEC</name>
               <description>Packet Error Check (PEC) Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PEC</name>
                     <description>The SMBus Packet Error Check (PEC) byte.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RSHTM</name>
               <description>Repeated Start Hold Time Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x0000004D</resetValue>
               <fields>
                  <field>
                     <name>RSHTM</name>
                     <description>This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold      the clock until the Hold Time for the repeated Start Bit has been satisfied.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EXTND_LEN</name>
               <description>Extended Length Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EXTND_LEN</name>
                     <description>Extended Length Register adds 8 MSB bits to the SMBUS Master/Slave Tx/Rx Length fields.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>COMPL</name>
               <description>Completion Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DTEN</name>
                     <description>When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MCEN</name>
                     <description>When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCEN</name>
                     <description>When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BIDEN</name>
                     <description>When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TIMERR</name>
                     <description>The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DTO</name>
                     <description>DTO is the Device Time-out bit. (R/WC)</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MCTO</name>
                     <description>MCTO is the Master Cumulative Time-out bit. (R/WC)</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCTO</name>
                     <description>SCTO is the Slave Cumulative Time-out bit(R/WC)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHDL</name>
                     <description>CHDL is the clock high time-out detect bit(R/WC)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHDH</name>
                     <description>CHDH is the bus idle time-out detect bit(R/WC)</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BER</name>
                     <description>If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LAB</name>
                     <description>If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SNAKR</name>
                     <description>If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STR</name>
                     <description>0: Slave has just finished the receive phase of a transaction.                 1: Slave has just finished the transmit phase of a transaction.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPROT</name>
                     <description>If this bit is 1, the WriteCount[7:0] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REP_RD</name>
                     <description>If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REP_WR</name>
                     <description>If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MNAKX</name>
                     <description>If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MTR</name>
                     <description>0: Master has just finished the receive phase of a transaction.                 1: Master has just finished the transmit phase of a transaction.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IDLE</name>
                     <description>This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MDONE</name>
                     <description>If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SDONE</name>
                     <description>If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IDLSC</name>
               <description>Idle Scaling Register</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x01FC01ED</resetValue>
               <fields>
                  <field>
                     <name>FAIR_BUS_IDL_MIN</name>
                     <description>This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>FAIR_IDL_DLY</name>
                     <description>This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CFG</name>
               <description>Configuration Register</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PORT_SEL</name>
                     <description>The PORT SEL [3:0] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>TCEN</name>
                     <description>When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLOW_CLK</name>
                     <description>When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST</name>
                     <description>Must be always written with 0.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PECEN</name>
                     <description>When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FEN</name>
                     <description>Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available.      1=Input filtering is enabled; 0=Input filtering is disabled.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST</name>
                     <description>When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN</name>
                     <description>When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State).                The ENAB bit must be asserted ('1') for normal operation.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DSA</name>
                     <description>0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAIR</name>
                     <description>If this bit is 1, the MCTP Fairness protocol is in effect.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST0</name>
                     <description>Must be always written with 0.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GC_DIS</name>
                     <description>This is the General Call Disable bit.                0: the response to the General Call address as a slave is enabled                1: the response to the General Call address as a slave is disabled.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CFG_PROMIS</name>
                     <description>This bit define the Mode of SM Bus Controler Mode of operation.         0= Normal Operation.         1=  Promiscuous Mode Enable.</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_SXBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_SRBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_MXBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_MRBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_AAS</name>
                     <description>0: Disable the AAS, 1: Enable the AAS Interrupt</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENIDI</name>
                     <description>If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled.</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENMI</name>
                     <description>If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled.</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENSI</name>
                     <description>If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BUSCLK</name>
               <description>Bus Clock Register</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00004F4F</resetValue>
               <fields>
                  <field>
                     <name>LOW_PER</name>
                     <description>This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>HIGH_PER</name>
                     <description>This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BLKID</name>
               <description>Block ID Register</description>
               <addressOffset>0x30</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x11</resetValue>
               <fields>
                  <field>
                     <name>ID</name>
                     <description>Block ID.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BLKREV</name>
               <description>Revision Register</description>
               <addressOffset>0x34</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>REV</name>
                     <description>Block Revision Number</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BBCTRL</name>
               <description>Bit-Bang Control Register</description>
               <addressOffset>0x38</addressOffset>
               <size>32</size>
               <resetValue>0x00000060</resetValue>
               <fields>
                  <field>
                     <name>BBEN</name>
                     <description>Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLDIR</name>
                     <description>Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DADIR</name>
                     <description>Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BBCLK</name>
                     <description>Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BBDAT</name>
                     <description>Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BBCLKI</name>
                     <description>Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BBDATI</name>
                     <description>Bit-Bang Data In. The BBDATI bit always returns the state of SDAT</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TEST</name>
               <description>Test</description>
               <addressOffset>0x3C</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x05</resetValue>
               <fields>
                  <field>
                     <name>TEST</name>
                     <description>This register must not be written, or undesirable results may occur.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DATATM</name>
               <description>Data Timing Register</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x0C4D5006</resetValue>
               <fields>
                  <field>
                     <name>DATA_HOLD</name>
                     <description>The Data Hold [7:0] timer determines the SDAT hold time following SCLK driven low.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>RESTART_SETUP</name>
                     <description>The Restart Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOP_SETUP</name>
                     <description>The Stop Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>FIRST_START_HOLD</name>
                     <description>This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter      THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TMOUTSC</name>
               <description>Time-Out Scaling Register</description>
               <addressOffset>0x44</addressOffset>
               <size>32</size>
               <resetValue>0x4B9CC2C7</resetValue>
               <fields>
                  <field>
                     <name>CLK_HIGH_TIM_OUT</name>
                     <description>Clock High time out period = Clock High Time-Out [7:0] x Baud_Clock_Period x 2</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>SLV_CUM_TIM_OUT</name>
                     <description>Slave Cumulative Time-Out duration = Slave Cum Time-Out [7:0] x Baud_Clock_Period x 1024</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MAST_CUM_TIM_OUT</name>
                     <description>Master Cumulative Time-Out duration = Master Cum Time-Out [7:0] x Baud_Clock_Period x 512</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>BUS_IDLE_MIN</name>
                     <description>Bus Idle Minimum time = Bus Idle Min [7:0] x Baud_Clock_Period</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLV_TXB</name>
               <description>SMBus Slave Transmit Buffer Register</description>
               <addressOffset>0x48</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>STXB</name>
                     <description>SLAVE_TRANSMIT_BUFFER</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLV_RXB</name>
               <description>SMBus Slave Receive Buffer Register</description>
               <addressOffset>0x4C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRXB</name>
                     <description>SLAVE_RECEIVE_BUFFER</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MTR_TXB</name>
               <description>SMBus Master Transmit Buffer Register</description>
               <addressOffset>0x50</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MTXB</name>
                     <description>MASTER_TRANSMIT_BUFFER</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MTR_RXB</name>
               <description>SMBus Master Receive Buffer Register</description>
               <addressOffset>0x54</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MRXB</name>
                     <description>MASTER_RECEIVE_BUFFER</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WAKE_STS</name>
               <description>WAKE STATUS Register</description>
               <addressOffset>0x60</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>START_BIT_DET</name>
                     <description>This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when      written with a '1'. Writes of '0' have no effect. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WAKE_EN</name>
               <description>WAKE ENABLE Register</description>
               <addressOffset>0x64</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>START_DET_INT_EN</name>
                     <description>Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable.      1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLV_ADDR</name>
               <description>This is the Slave Address Register</description>
               <addressOffset>0x6C</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>SADDR</name>
                     <description>This register stores value of address + LSB direction after the 8th clock of the Address Byte.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PRM_STS</name>
               <description>This is the Promiscuous Interrupt Register</description>
               <addressOffset>0x70</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ADDR_INTR</name>
                     <description>This is the Promiscuous Address Status interrupt and is set on the 8th clock of the I2C Address.         This bit will hold the Clock line low till this register bit is cleared. This is Write 1 to clear.         R/W1C.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PRM_IEN</name>
               <description>This is the Promiscuous Interrupt Enable Register</description>
               <addressOffset>0x74</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ADDR</name>
                     <description>This is the Promiscuous interrupt enable register.         1= Interrupt Enable.          0= Interrupt Disabled. </description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PRM_CTRL</name>
               <description>This is the Promiscuous Control Register</description>
               <addressOffset>0x78</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ACK_NAK</name>
                     <description>This is the Promiscuous ACK / NAK response register.         1= ACK.          0= NAK. </description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SHDW_DATA</name>
               <description>This is the I2C Shadow Data Register</description>
               <addressOffset>0x7C</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>SHDW_DATA</name>
                     <description>This is the I2C Shadow Data Register</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="SMB0">
         <name>SMB1</name>
         <baseAddress>0x40004400</baseAddress>
         <interrupt>
            <name>I2CSMB1</name>
            <value>21</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="SMB0">
         <name>SMB2</name>
         <baseAddress>0x40004800</baseAddress>
         <interrupt>
            <name>I2CSMB2</name>
            <value>22</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="SMB0">
         <name>SMB3</name>
         <baseAddress>0x40004C00</baseAddress>
         <interrupt>
            <name>I2CSMB3</name>
            <value>23</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="SMB0">
         <name>SMB4</name>
         <baseAddress>0x40005000</baseAddress>
         <interrupt>
            <name>I2CSMB4</name>
            <value>158</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>QMSPI</name>
         <version>1471.0</version>
         <description>The QMSPI may be used to communicate with various peripheral devices that use a Serial Peripheral Interface.</description>
         <baseAddress>0x40070000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x170</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ18</name>
            <value>10</value>
         </interrupt>
         <interrupt>
            <name>QMSPI</name>
            <value>91</value>
         </interrupt>
         <registers>
            <register>
               <name>MODE</name>
               <description>QMSPI Mode Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>This bit is used to activate the QMSPI block.     1=Enabled. The block is fully operational                 0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RESET</name>
                     <description>Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DMA_UNLGND_MOD</name>
                     <description>When enabled the DMA is allowed to operate w/ unaligned transfer lengths.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LDMA_RXEN</name>
                     <description>This enables the Local DMA RX usage (instead of the Central DMA) when the Control register enables the DMA.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LDMA_TXEN</name>
                     <description>This enables the Local DMA TX usage (instead of the Central DMA) when the Control register enables the DMA.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CPOL</name>
                     <description>Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHPA_MOSI</name>
                     <description>Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register.     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.                 If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock                 If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHPA_MISO</name>
                     <description>Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register.     e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.                 If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock                 If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS</name>
                     <description>This defines which Chip Select will be used by the H/W when doing a transfer.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CLK_DIV</name>
                     <description>The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255. A value of 0 divides the master clock by 256.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL</name>
               <description>QMSPI SPI Control</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_MODE</name>
                     <description>This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either      TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.                  3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>TX_TRANS_EN</name>
                     <description>This field bit selects the transmit function of the SPI interface.                 3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used.                 2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.                 1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.                 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>TX_DMA_EN</name>
                     <description>This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either     the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte                 2=DMA is enabled and set to 2 Bytes                 3=DMA is enabled and set to 4 Bytes.     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>RX_TRANS_EN</name>
                     <description>This bit enables the receive function of the SPI interface.                 1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer                 0=Receive is disabled</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_DMA_EN</name>
                     <description>This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface                 reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.                 1=DMA is enabled.and set to 1 Byte                 2=DMA is enabled and set to 2 Bytes                 3=DMA is enabled and set to 4 Bytes                 0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CLOSE_TRANS_EN</name>
                     <description>This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI      interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer.     1=The transaction is terminated     0=The transaction is not terminated</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_UNITS</name>
                     <description>3=TRANSFER_LENGTH defined in units of 16-byte segments     2=TRANSFER_LENGTH defined in units of 4-byte segments     1=TRANSFER_LENGTH defined in units of bytes     0=TRANSFER_LENGTH defined in units of bits.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>DESCR_BUFF_PTR</name>
                     <description>This field selects the first buffer used if Description Buffers are enabled.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>DESCR_BUFF_EN</name>
                     <description>This enables the Description Buffers to be used.     1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER     0=Description Buffers disabled.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_LEN</name>
                     <description>The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS.     A value of 0 means an infinite length transfer.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>15</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EXE</name>
               <description>QMSPI Execute Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>START</name>
                     <description>Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing.     This bit must not be set to 1 if the field STOP in this register is set to 1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STOP</name>
                     <description>Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect.     This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLR_DAT_BUFF</name>
                     <description>Writing a 1 to this bit will clear out the Transmit and Receive FIFOs. Any data stored in the FIFOs is discarded and all count fields are reset.     Writing a 0 to this bit has no effect. This bit is self clearing.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IFCTRL</name>
               <description>QMSPI Interface Control Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>WR_PRCT_OUT_VAL</name>
                     <description>This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven.                 1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_PRCT_OUT_EN</name>
                     <description>1=WRITE PROTECT SPI Output Port is driven                 0=WRITE PROTECT SPI Output Port is not driven</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HLD_OUT_VAL</name>
                     <description>This bit sets the value on the HOLD SPI Output Port if it is driven.                 1=HOLD is driven to 1; 0=HOLD is driven to 0.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HLD_OUT_EN</name>
                     <description>1=HOLD SPI Output Port is driven                 0=HOLD SPI Output Port is not driven.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PD_ON_NOT_SEL</name>
                     <description>1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted     0=No pull-down resistors enabled on Receive pins</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PU_ON_NOTSEL</name>
                     <description>1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted     0=No pull-up resistors enabled on Receive pins.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PD_ON_NOTDRIVEN</name>
                     <description>1=Enable pull-down resistors on Transmit pins while the pins are not driven     0=No pull-down resistors enabled ion Transmit pins.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PU_ON_NOTDRIVEN</name>
                     <description>1=Enable pull-up resistors on Transmit pins while the pins are not driven     0=No pull-up resistors enabled ion Transmit pins.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS</name>
               <description>QMSPI Status Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00002200</resetValue>
               <fields>
                  <field>
                     <name>TRANS_COMPL</name>
                     <description>In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH.                 If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer.     In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied.                 1=Transfer completed; 0=Transfer not complete.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DMA_COMPL</name>
                     <description>This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller.     This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are      active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously.     This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode.                 1=DMA completed; 0=DMA not completed.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUFF_ERR</name>
                     <description>1=Overflow error occurred (attempt to write to a full Transmit Buffer)                 0=No overflow occurred.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_ERR</name>
                     <description>1=Underflow error occurred (attempt to read from an empty Receive Buffer)                 0=No underflow occurred.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRGM_ERR</name>
                     <description>This bit if a programming error is detected.     1=Programming Error detected; 0=No programming error detected.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LDMA_RXERR</name>
                     <description>This bit is set if Local DMA Receive error is detected.     1=Local DMA RX Error detected; 0=No Local DMA RX detected.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LDMA_TXERR</name>
                     <description>This bit is set if Local DMA Transmit error is detected.     1=Local DMA TX Error detected; 0=No Local DMA TX detected.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUFF_FULL</name>
                     <description>1=The Transmit Buffer is full     0=The Transmit Buffer is not full.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUFF_EMP</name>
                     <description>1=The Transmit Buffer is empty     0=The Transmit Buffer is not empty.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUFF_REQ</name>
                     <description>This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field.     1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUFF_STALL</name>
                     <description>1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer)     0=No stalls occurred.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_FULL</name>
                     <description>1=The Receive Buffer is full     0=The Receive Buffer is not full.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_EMP</name>
                     <description>1=The Receive Buffer is empty     0=The Receive Buffer is not empty.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_REQ</name>
                     <description>This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field.                 1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER                 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_STALL</name>
                     <description>1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer)     0=No stalls occurred.</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_ACTIV</name>
                     <description>1=A transfer is currently executing     0=No transfer currently in progress.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CUR_DESCR_BUF</name>
                     <description>This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BUF_CNT_STS</name>
               <description>QMSPI Buffer Count Status Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_BUFF_CNT</name>
                     <description>This is a count of the number of bytes currently valid in the Transmit Buffer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_CNT</name>
                     <description>This is a count of the number of bytes currently valid in the Receive Buffer.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>QMSPI Interrupt Enable Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00002000</resetValue>
               <fields>
                  <field>
                     <name>TRANS_COMPL_EN</name>
                     <description>1=Enable an interrupt if TRANSFER_COMPLETE is asserted     0=Disable the interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DMA_COMPL_EN</name>
                     <description>1=Enable an interrupt if DMA_COMPLETE is asserted     0=Disable the interrupt.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUF_ERR_EN</name>
                     <description>1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted     0=Disable the interrupt.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUF_ERR_EN</name>
                     <description>1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted     0=Disable the interrupt.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRGM_ERR_EN</name>
                     <description>1=Enable an interrupt if PROGRAMMING_ERROR is asserted     0=Disable the interrupt.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LDMA_RXERRIE</name>
                     <description>1=Enable an interrupt if Local DMA RX Error is asserted     0=Disable the interrupt.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LDMA_TXERRIE</name>
                     <description>1=Enable an interrupt if Local DMA TX Error is asserted     0=Disable the interrupt.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUF_FULL_EN</name>
                     <description>1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted     0=Disable the interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUF_EMPTY_EN</name>
                     <description>1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted     0=Disable the interrupt.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUF_REQ_EN</name>
                     <description>1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted     0=Disable the interrupt.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUF_FUL_EN</name>
                     <description>1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted     0=Disable the interrupt.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUF_EMPTY_EN</name>
                     <description>1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted     0=Disable the interrupt.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUF_REQ_EN</name>
                     <description>1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted     0=Disable the interrupt.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BUF_CNT_TRIG</name>
               <description>QMSPI Buffer Count Trigger Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_BUF_TRIG</name>
                     <description>An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUF_TRIG</name>
                     <description>An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TX_FIFO</name>
               <description>QMSPI Transmit Buffer Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_BUF</name>
                     <description>Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.     Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.     The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).     An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs. Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RX_FIFO</name>
               <description>QMSPI Receive Buffer Register</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RX_BUF</name>
                     <description>Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.     Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].     It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).     Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CSTM</name>
               <description>QMSPI Chip Select Timing Register</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x06060406</resetValue>
               <fields>
                  <field>
                     <name>DLY_CS_ON_CLK_STRT</name>
                     <description>This selects the number of system clock cycles between CS assertion to the start of the SPI Clock.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>DLY_CLK_STOP_CS_OFF</name>
                     <description>This selects the number of system clock cycles between the last clock edge and the deassertion of CS.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>DLY_LAST_DAT_HLD</name>
                     <description>This selects the number of system clock cycles between CS deassertion to the data ports for WP and HOLD     switching from input to output.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>DLY_OFF_TO_ON</name>
                     <description>This selects the number of system clock cycles between CS deassertion to CS assertion. This is the minimum            pulse width of CS deassertion.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>16</dim>
               <dimIncrement>4</dimIncrement>
               <name>DESCR[%s]</name>
               <description>QMSPI Description Buffer 0 Register</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>INFACE_MOD</name>
                     <description>This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.     3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>TX_TRANS_EN</name>
                     <description>This field bit selects the transmit function of the SPI interface.     3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used     2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.     1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.     0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>TX_DMA_EN</name>
                     <description>This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface     reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte      2=DMA is enabled and set to 2 Bytes      3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>RX_TRANS_EN</name>
                     <description>This bit enables the receive function of the SPI interface.     1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_DMA_EN</name>
                     <description>This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.     1=DMA is enabled.and set to 1 Byte     2=DMA is enabled and set to 2 Bytes     3=DMA is enabled and set to 4 Bytes     0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CLOSE_TRANS_EN</name>
                     <description>This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.     1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.     0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_LEN_BITS</name>
                     <description>3=TRANSFER_LENGTH defined in units of 16-byte segments,     2=TRANSFER_LENGTH defined in units of 4-byte segments,     1=TRANSFER_LENGTH defined in units of bytes     0=TRANSFER_LENGTH defined in units of bits</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>DESCR_BUF_NXT_PTR</name>
                     <description>This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. This can point to the current buffer, creating an infinite loop.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>DESCR_BUF_LAST</name>
                     <description>Last Descriptor. 1=Last Description Buffer in the chain. 0=This is not the last buffer.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_LEN</name>
                     <description>The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANSFER_LENGTH_BITS. A value of 0 means an infinite length transfer.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>15</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ALIAS_CTRL</name>
               <description>QMSPI Alias Control Register</description>
               <addressOffset>0xB0</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ALS_EXEC_STRT</name>
                     <description>Alias for the QMSPI Execution:Start field.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLS_ALTMODE_EN</name>
                     <description>Enable the CS1 Clock Divide to be active if CS1 is the interface in use.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALS_WR_TXBUF</name>
                     <description>Alias that triggers a write to the Tx Buffer of 1 Byte using data from Alias Tx Buffer Data in this register.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALS_WRDBUF_XFRLEN</name>
                     <description>Alias that triggers a write to the Description Buffer pointed to by Alias Description Buffer Select in this register to modify the Transfer Length field with the value of Alias Description Buffer Transfer Length in this register.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALS_MOD_CS</name>
                     <description>Alias for the QMSPI Mode:Chip Select field.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>ALS_LDMA_INCR_ADD</name>
                     <description>Alias that overrides the value in all QMSPI Local DMA * [Tx/Rx] Control:Increment Address Enable fields w/ this value.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALS_CTRL_DBUF_PTR</name>
                     <description>Alias for the QMSPI Control:Description Buffer Pointer field.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>ALS_DBUF_SEL</name>
                     <description>Which Description Buffer will be modified by a write if Alias Write Description Buffer Transfer Length is set.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>ALS_DBUF_XFR_LEN</name>
                     <description>The value of the data written to the Description Buffers Transfer Length field, if the write is enabled.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>ALS_TXDBUF_DATA</name>
                     <description>The Byte of data written into the Tx Buffer if the write is enabled.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MODE_ALT1</name>
               <description>QMSPI Mode Alternate 1 Register</description>
               <addressOffset>0xC0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CS1_ALTMOD_EN</name>
                     <description>Enable the CS1 Clock Divide to be active if CS1 is the interface in use.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS1_ALTCLK_DIV</name>
                     <description>The SPI clock divide in number of system clocks when CS1 is in use and CS1 Alt Mode Enable is set.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TAPS</name>
               <description>QMSPI TAPs Register</description>
               <addressOffset>0xD0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCK_TAP</name>
                     <description>This will select the tap point for the feed-back SCK.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CTRL_TAP</name>
                     <description>This will select the tap point for signals that go from the System Domain.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TAP_ADJ</name>
               <description>QMSPI TAP Control Register</description>
               <addressOffset>0xD4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCK_ADJ</name>
                     <description>This is a signed value that will be added to the Select SCK Tap to come up with the final value for the delay.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CTRL_ADJ</name>
                     <description>This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TAP_CTRL</name>
               <description>QMSPI TAP Adjustment Register</description>
               <addressOffset>0xD8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>AUTO_MOD</name>
                     <description>This enables the automatic H/W trim of the Tap.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CTRL</name>
                     <description>This is a signed value that will be added to the Select Control Tap to come up with the final value for the delay.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FW_GO</name>
                     <description>This will force the auto-trim H/W to run and find a new trim value.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AUTO_MULT</name>
                     <description>This will multiply the target delay value the Auto-trim H/W will search for.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DESC_LDMA_TXEN</name>
               <description>QMSPI Descriptor Local DMA Tx Enable Register</description>
               <addressOffset>0x104</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DESC_LDMA_TXEN</name>
                     <description>This enables the Local TX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DESC_LDMA_RXEN</name>
               <description>QMSPI Descriptor Local DMA Rx Enable Register</description>
               <addressOffset>0x100</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DESC_LDMA_RXEN</name>
                     <description>This enables the Local RX DMA usage (instead of the Central DMA) when the Descriptor Buffer register enables the DMA.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <cluster>
               <dim>3</dim>
               <dimIncrement>0x10</dimIncrement>
               <name>LDMA_RX[%s]</name>
               <description/>
               <addressOffset>0x110</addressOffset>
               <register>
                  <name>LDMA_RXCTRL</name>
                  <description>QMSPI RX Control Register</description>
                  <addressOffset>0x0</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000000</resetValue>
                  <fields>
                     <field>
                        <name>CH_EN</name>
                        <description>This enables the Local RX DMA Channel.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RSTRT_EN</name>
                        <description>This bit automatically re-enables the Local DMA Channel after completion of previous transfer.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>BUF_ADDR_EN</name>
                        <description>Address re-enable will automatically re-enables the same address upon completion previous transfer.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OVRD_LEN</name>
                        <description>Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>ACS_SZ</name>
                        <description>Access Size selects the AHB Access Size.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                     <field>
                        <name>INC_ADDR_EN</name>
                        <description>When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LDMA_RXSTRT_ADDR</name>
                  <description>QMSPI Local DMA Rx Start Address Register</description>
                  <addressOffset>0x4</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000000</resetValue>
                  <fields>
                     <field>
                        <name>STRT_ADDR</name>
                        <description>This is the Starting Address for the DMA access into the memory space (write to this address on Rx). This address is updated by the transfer size based on the Local DMA Access Size after every access.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>32</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LDMA_RX_LEN</name>
                  <description>QMSPI Local DMA Rx Length Register</description>
                  <addressOffset>0x8</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000000</resetValue>
                  <fields>
                     <field>
                        <name>RX_LEN</name>
                        <description>This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>32</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>RSVD</name>
                  <description>Reserved Register</description>
                  <addressOffset>0xC</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x00000000</resetValue>
               </register>
            </cluster>
            <cluster>
               <dim>3</dim>
               <dimIncrement>0x10</dimIncrement>
               <name>LDMA_TX[%s]</name>
               <description/>
               <addressOffset>0x140</addressOffset>
               <register>
                  <name>LDMA_TXCTRL</name>
                  <description>QMSPI TX Control Register</description>
                  <addressOffset>0x0</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000000</resetValue>
                  <fields>
                     <field>
                        <name>CH_EN</name>
                        <description>This enables the Local TX DMA Channel.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RSTRT_EN</name>
                        <description>This bit automatically re-enables the Local DMA Channel after completion of previous transfer.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>BUF_ADDR_EN</name>
                        <description>Address re-enable will automatically re-enables the same address upon completion previous transfer.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OVRD_LEN</name>
                        <description>Override Lenght will override the length field to the QMSPI protocol FSM with the length programmed into the Local DMA.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>ACS_SZ</name>
                        <description>Access Size selects the AHB Access Size.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                     <field>
                        <name>INC_ADDR_EN</name>
                        <description>When set, the DMA Channels Start Address will increment on every access. If not set the address will not increment.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LDMA_TXSTRT_ADDR</name>
                  <description>QMSPI Local DMA Tx Start Address Register</description>
                  <addressOffset>0x4</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000000</resetValue>
                  <fields>
                     <field>
                        <name>STRT_ADDR</name>
                        <description>This is the Starting Address for the DMA access into the memory space (Read from this address on Tx). This address is updated by the transfer size based on the Local DMA Access Size after every access.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>32</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LDMA_TX_LEN</name>
                  <description>QMSPI Local DMA Tx Length Register</description>
                  <addressOffset>0x8</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000000</resetValue>
                  <fields>
                     <field>
                        <name>TX_LEN</name>
                        <description>This is the maximum Length of the transfer in Bytes that the DMA Channel will allow access to.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>32</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>RSVD</name>
                  <description>Reserved Register</description>
                  <addressOffset>0xC</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x00000000</resetValue>
               </register>
            </cluster>
         </registers>
      </peripheral>
      <peripheral>
         <name>GP_SPI0</name>
         <version>621.0</version>
         <description>The General Purpose Serial Peripheral Interface (GP-SPI) may be used       to communicate with various peripheral devices, e.g., EEPROMS, DACs, ADCs, that use a         standard Serial Peripheral Interface.</description>
         <groupName>GP_SPI</groupName>
         <prependToName>GP_SPI_</prependToName>
         <baseAddress>0x40009400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x1C</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>TX0</name>
            <value>92</value>
         </interrupt>
         <interrupt>
            <name>RX0</name>
            <value>93</value>
         </interrupt>
         <registers>
            <register>
               <name>ENABLE</name>
               <description>[0:0]  1=Enabled. The device is fully operational          0=Disabled. Clocks are gated to conserve power and the SPDOUT and SPI_CLK signals are set to their inactive state</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x0000000F</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>SPI Control</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000002</resetValue>
               <fields>
                  <field>
                     <name>LSBF</name>
                     <description>Least Significant Bit First             1= The data is transferred in LSB-first order.        0= The data is transferred in MSB-first order. (default)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BIOEN</name>
                     <description>Bidirectional Output Enable control.             1=The SPDOUT_Direction signal configures the SPDOUT signal as an output.         0=The SPDOUT_Direction signal configures the SPDOUT signal as an input.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPDIN_SELECT</name>
                     <description>[3:2] 1xb=SPDIN1 and SPDIN2. Select this option for Dual Mode        [3:2] 01b=SPDIN2 only. Select this option for Half Duplex                   [3:2] 00b=SPDIN1 only. Select this option for Full Duplex</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RESET</name>
                     <description>Soft Reset is a self-clearing bit. Writing zero to this bit has no effect.       Writing a one to this bit resets the entire SPI Interface, including all counters and registers back to their initial state.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AUTO_READ</name>
                     <description>Auto Read Enable.             1=A read of the SPI RX_DATA Register will clear both the RXBF status bit and the TXBE status bit          0=A read of the SPI RX_DATA Register will clear the RXBF status bit. The TXBE status bit will not be modified</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CE</name>
                     <description>SPI Chip Select Enable.                 1= SPI_CS# output signal is asserted, i.e., driven to logic '0'                     0= SPI_CS# output signal is deasserted, i.e., driven to logic '1'</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS</name>
               <description>SPI Status</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TXBE</name>
                     <description>1=TX_Data buffer is empty, 0=TX_Data buffer is not empty</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXBF</name>
                     <description>1=RX_Data buffer is full, 0=RX_Data buffer is not full</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACTIVE</name>
                     <description>ACTIVE status</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TX_DATA</name>
               <description>[7:0]  A write to this register when the        Tx_Data buffer is empty (TXBE in the SPI Status Register is '1') initiates a SPI transaction.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RX_DATA</name>
               <description>[7:0] This register is used to read the value returned by the external SPI device.</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CLK_CTRL</name>
               <description>SPI Clock Control. This register should not be changed during an active SPI transaction.</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TCLKPH</name>
                     <description>1=Valid data is clocked out on the first SPI_CLK edge on SPDOUT signal. The slave device should sample this data on the second and        following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is clocked out on the SPDOUT signal prior to the first SPI_CLK edge.        The slave device should sample this data on the first and following odd SPI_CLK edges (i.e., sample data on rising edge)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RCLKPH</name>
                     <description>1=Valid data on SPDIN signal is expected after the first SPI_CLK edge. This data is sampled on the second and        following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is expected on the SPDIN signal on the first SPI_CLK edge.        This data is sampled on the first and following odd SPI_-CLK edges (i.e., sample data on rising edge)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLKPOL</name>
                     <description>1=The SPI_CLK signal is high when the interface is idle and the first clock edge is a falling edge            0=The SPI_CLK is low when the interface is idle and the first clock edge is a rising edge</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLKSRC</name>
                     <description>1=2MHz, 0=48 MHz Ring Oscillator</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_GEN</name>
               <description>[5:0] PRELOAD SPI Clock Generator Preload value.</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000002</resetValue>
               <fields>
                  <field>
                     <name>PRELOAD</name>
                     <description>SPI Clock Generator Preload Value</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="GP_SPI0">
         <name>GP_SPI1</name>
         <baseAddress>0x40009480</baseAddress>
         <interrupt>
            <name>TX1</name>
            <value>94</value>
         </interrupt>
         <interrupt>
            <name>RX1</name>
            <value>95</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>BC_LINK0</name>
         <version>2021.0</version>
         <description>This block provides BC-Link connectivity to a slave device. The BC-Link        protocol includes a start bit to signal the beginning of a message and a turnaround (TAR)        period for bus transfer between the Master and Companion devices.</description>
         <groupName>BC_LINK</groupName>
         <prependToName>BC_LINK_</prependToName>
         <baseAddress>0x4000CD00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>BCM_ERR_0</name>
            <value>96</value>
         </interrupt>
         <interrupt>
            <name>BCM_BUSY_CLR_0</name>
            <value>97</value>
         </interrupt>
         <registers>
            <register>
               <name>STS</name>
               <description>BC-Link Status</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000001</resetValue>
               <fields>
                  <field>
                     <name>BUSY</name>
                     <description>This bit is asserted to '1' when the BC interface is transferring data and on reset.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BUSY_CLR_INT_EN</name>
                     <description>This bit is an enable for generating an interrupt when the BUSY bit in this register is cleared by hardware. When this bit is set to '1', the interrupt signal is enabled. When the this bit is cleared to '0', the interrupt is disabled. When enabled, the interrupt occurs after a BC Bus read or write.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERR_INT_EN</name>
                     <description>This bit is an enable for generating an interrupt when the BC_ERR bit is set by hardware. When this bit is '1', the interrupt signal is enabled. When this bit is '0', the interrupt is disabled.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERROR</name>
                     <description>This bit indicates that a BC Bus Error has occurred. (R/WC)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RESET</name>
                     <description>When this bit is '1'the BC_Link Master Interface will be placed in reset and be held in reset until this bit is cleared to '0'. Setting RESET to '1' causes the BUSY bit to be set to '1'. The BUSY remains set to '1' until the reset operation of the BC Interface is completed, which takes approximately 48 BC clocks.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ADDR</name>
               <description>BC-Link Address Register [7:0] Address in the Companion for the BC-Link transaction.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>DATA</name>
               <description>BC-Link Data Register [7:0] this register hold data used in a BC-Link transaction.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CLK_SEL</name>
               <description>BC-Link Clock Select Register [7:0] DIVIDER  The BC Clock is set to the Master Clock divided by this field, or 48MHz/ (Divider +1). The clock divider bits can only can be changed when the BC Bus is in soft RESET (when either the Reset bit is set by software or when the BUSY bit is set by the interface).</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000004</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>PS2_0</name>
         <version>521.0</version>
         <description>The four PS/2 Ports implementation eliminates the need to bit bang I/O ports to generate PS/2 traffic.</description>
         <groupName>PS2</groupName>
         <prependToName>PS2_</prependToName>
         <baseAddress>0x40009000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>PS2_0_ACT</name>
            <value>100</value>
         </interrupt>
         <interrupt>
            <name>PS2_0A_WAKE</name>
            <value>129</value>
         </interrupt>
         <interrupt>
            <name>PS2_0B_WAKE</name>
            <value>130</value>
         </interrupt>
         <registers>
            <register>
               <name>TX_DATA</name>
               <description>Writes to bits 7:0 of this register start a transmission of the data in this register to the peripheral</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RX_DATA</name>
               <description>Data received from a peripheral are recorded in this register in bits 7:0.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x000000FF</resetValue>
            </register>
            <register>
               <name>CONTROL</name>
               <description>PS2 Control Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TR</name>
                     <description>PS/2 Transmit/Receive                   0=The P2/2 channel is enabled to receive data.                  1=The PS2 channel is enabled to transmit data.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN</name>
                     <description>PS/2 Enable. 0=The PS/2 state machine is disabled. 1=The PS/2 state machine is enabled.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PARITY</name>
                     <description>00b=Receiver expects Odd Parity (default).                   01b=Receiver expects Even Parity.                  10b=Receiver ignores level of the parity bit (10th bit is not interpreted as a parity bit).                  11b=Reserved</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOP</name>
                     <description>00b=Receiver expects an active high stop bit.                   01b=Receiver expects an active low stop bit.                  10b=Receiver ignores the level of the Stop bit (11th bit is not interpreted as a stop bit).                   11b=Reserved.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STATUS</name>
               <description>PS2 Status Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000010</resetValue>
               <fields>
                  <field>
                     <name>RDATA_RDY</name>
                     <description>Receive Data Ready. Reading the Receive Register clears this bit. A low to high transition on this bit generates a PS2 Activity interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REC_TIMEOUT</name>
                     <description>Receive Timeout. The REC_TIMEOUT bit is cleared when the Status Register is read. A low to high transition on this bit generates a PS2 Activity interrupt. (R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PE</name>
                     <description>Parity Error</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FE</name>
                     <description>Framing Error</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>XMIT_IDLE</name>
                     <description>Transmitter Idle. 0=The channel is actively transmitting PS/2 data. 1=The channel is not transmitting. A low to high transition on this bit generates a PS2 Activity interrupt.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>XMIT_TIME_OUT</name>
                     <description>Transmitter Time-out. When the XMIT_TIMEOUT bit is set, the PS2_T/R bit is held clear, the PS/2 channel's CLK line is pulled low for a minimum of 300us until the PS/2 Status register is read.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUSY</name>
                     <description>Receive Channel Busy.                  0=The channel is idle                  1=The channel is actively receiving PS/2 data</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>XMIT_START_TIMEOUT</name>
                     <description>Transmit Start Timeout.                  0=No transmit start timeout detected                  1=A start bit was not received within 25 ms following the transmit start event. The transmit start bit time-out condition is also indicated by the XMIT_TIMEOUT bit.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>TFDP</name>
         <version>681.0</version>
         <description>The TFDP serially transmits EC-originated diagnostic vectors to an external debug trace system.</description>
         <baseAddress>0x40008C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x5</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>MSDATA</name>
               <description>Debug data to be shifted out on the TFDP Debug port. While data is being shifted out, the Host Interface will 'hold-off' additional writes to the data register until the transfer is complete.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>Debug Control Register</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>Enable. 1=Clock enabled, 0=Clock is disabled (Default)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_SEL</name>
                     <description>1= Data is shifted out on the falling edge of the debug clock, 0= Data is shifted out on the rising edge of the debug clock (Default)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIVSEL</name>
                     <description>Clock Divider Select.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>IP_DLY</name>
                     <description>Inter-packet Delay. The delay is in terms of TFDP Debug output clocks.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>PORT_80_DEBUG</name>
         <version>1161.0</version>
         <description>Diagnostic data is written by the Host Interface to the Port 80 BIOS Debug Port.</description>
         <baseAddress>0x400F8000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x7F1</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>P80CAP0</name>
            <value>62</value>
         </interrupt>
         <registers>
            <register>
               <name>HOST_DATA32</name>
               <description>Host Data Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>H_DAT</name>
                     <description>This is the host data.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_DATA</name>
               <description>EC Data Register.</description>
               <addressOffset>0x100</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_DATA</name>
                     <description>This is the Oldest FIFO byte from the Host.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_ATTR</name>
               <description>EC Attribute Register.</description>
               <addressOffset>0x101</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_LANE</name>
                     <description>The byte address to which this byte was written    00 = Byte Lane 0     01 = Byte Lane 1     10 = Byte Lane 2     11 = Byte Lane 3</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>EC_LEN</name>
                     <description>Length     00 = One byte, or a continuation of a multi-byte value.      01 = The first byte (LSB) of a two-byte value.      10 = The first byte (LSB) of a 4-byte value.      11 = Invalid</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FIFO_NEMPTY</name>
                     <description>FIFO Not Empty Status</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_OVR</name>
                     <description>FIFO Overflow     1 = One or more bytes have been lost from the FIFO before this byte.     0 = No loss of information has occurred immediately before this byte.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>THRES_STAT</name>
                     <description>Threshold Status</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CFG</name>
               <description>Configuration Register.</description>
               <addressOffset>0x104</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>FLUSH</name>
                     <description>Flush FIFO (also clears the OVERRUN bit) Self Clearing bit. This bit does not affect the Snapshot Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SNPSHT_CLR</name>
                     <description>Writing this bit clears the Snapshot Register as well as the Capture Register (Buffer).</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FIFO_THRESHOLD</name>
                     <description>This field determines the threshold for the Port 80 32-Bit BIOS Debug Port Interrupts.  7=30 entry threshold     6=28 entry threshold 5=24 entry threshold 4=20 entry threshold 3=16 entry threshold 2=8 entry threshold 1=4 entry threshold     0=1 entry threshold</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RST</name>
                     <description>Soft Reset, When a 1 is written to this bit a one clock wide pulse resets the entire block</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS</name>
               <description>Status Register</description>
               <addressOffset>0x108</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>NOT_EMPTY</name>
                     <description>The NOT EMPTY bit is 1 when there is data in the FIFO. The NOT EMPTY bit is 0 when the FIFO is empty.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OVERRUN</name>
                     <description>The OVERRUN bit is 1 when the host writes the Host Data Register when the FIFO is full.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>THRES_STAT</name>
                     <description>Threshold Status is set when the number of threshold entries are above the selected threshold</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INT_EN</name>
               <description>Interrupt Enable Register</description>
               <addressOffset>0x109</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>THRES_IEN</name>
                     <description>Enable Threshold interrupt. When set threshold interrupt is enabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SNAPSHOT</name>
               <description>Snapshot Register</description>
               <addressOffset>0x10C</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SNAPSHOT</name>
                     <description>Current image of the 4-byte Port 80 value, captured immediately from the Host CPU.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAPTURE</name>
               <description>Capture Register</description>
               <addressOffset>0x110</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAPTURE</name>
                     <description>Current image of the 4-byte Port 80 value capture register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TEST_MODES</name>
               <description>Test Mode Register</description>
               <addressOffset>0x114</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN_OMASTR</name>
                     <description>Enable other masters (JTAG, EC etc) to be able to write to Port80 FIFO with size selection.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SZ4M_OMASTR</name>
                     <description>Size from other master     00 = Byte    01 = Word     10 = Double Word     11 = Invalid</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACTIVATE32</name>
               <description>Activate Register</description>
               <addressOffset>0x330</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>When this bit is asserted 1, the block is enabled. When this bit is 0, writes by the Host interface to the Host Data Register      are not claimed, the FIFO is flushed.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HOST_DATA8</name>
               <description>Host Data Register</description>
               <addressOffset>0x400</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>HOST_DATA</name>
                     <description>This is the host data.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACTIVATE8</name>
               <description>Activate Register</description>
               <addressOffset>0x730</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ACTIVATE</name>
                     <description>When this bit is asserted 1, the block is enabled. When this bit is 0, writes by the Host interface to the Host Data Register      are not claimed, the FIFO is flushed.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HST_ALIS_DATA</name>
               <description>Host Alias Data Register</description>
               <addressOffset>0x7F0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ALIS_BLANE</name>
                     <description>Byte from Alias LDN Port80 mapped location in Snapshot Register     b00 = Byte 0    b01 = Byte 1    b10 = Byte 2    b11 = Byte 3</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>VCI</name>
         <version>751.0</version>
         <description>The VBAT-Powered Control Interfaces with the RTC With Date and DST Adjustment as well as the Week Alarm.</description>
         <baseAddress>0x4000AE00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x24</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>VCI_OVRD_IN</name>
            <value>121</value>
         </interrupt>
         <interrupt>
            <name>VCI_IN0</name>
            <value>122</value>
         </interrupt>
         <interrupt>
            <name>VCI_IN1</name>
            <value>123</value>
         </interrupt>
         <interrupt>
            <name>VCI_IN2</name>
            <value>124</value>
         </interrupt>
         <interrupt>
            <name>VCI_IN3</name>
            <value>125</value>
         </interrupt>
         <registers>
            <register>
               <name>CTRL_STS</name>
               <description>VCI Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000080</resetValue>
               <fields>
                  <field>
                     <name>VCI_IN</name>
                     <description>These bits provide the latched state of the associated VCI_IN# pin, if latching is enabled or the current state of the pin     if latching is not enabled. In both cases, the value is determined after the action of the VCI Polarity Register.     Note: The VCI_IN[6:0]# bits default to the state of their respective input pins.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>VCI_OUT_GPIO_SEL</name>
                     <description>This bit selects the power source for GPIO outputs.    1= GPIO will be powered by VBAT power well (VCI_OUT functionality).    0= GPIO will be powered by VTR power well.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VCI_OVRD_IN</name>
                     <description>This bit provides the current status of the VCI_OVRD_IN pin.     Note: The VCI_OVRD_IN bit defaults to the state of the respective input pin.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VCI_OUT</name>
                     <description>This bit provides the current status of the VCI_OUT pin.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VCI_FW_CTRL</name>
                     <description>This bit can allow EC firmware to control the state of the VCI_OUT pin. For example, when VTR_PWRGD is asserted and the     FW_EXT bit is 1, clearing the VCI_FW_CNTRL bit de-asserts the active high VCI_OUT pin. BIOS must set this bit to 1 prior to setting     the FW_EXT bit to 1 on power up, in order to avoid glitches on the VCI_OUT pin.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FW_EXT</name>
                     <description>This bit controls selecting between the external VBAT-Powered Control Interface inputs, or the VCI_FW_CNTRL bit output to control the VCI_OUT pin.     1=VCI_OUT is determined by the VCI_FW_CNTRL field, when VTR is active     0=VCI_OUT is determined by the external inputs.     Note: This bit used to be called GPO/nEXT. The name was changed to distinguish it from the BGPOs, which are elsewhere, and to remove a / in a bit name.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLTRS_BYPASS</name>
                     <description>The Filters Bypass bit is used to enable and disable the input filters on the VCI_IN# pins.     1=Filters disabled; 0=Filters enabled (default).</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WK_ALRM</name>
                     <description>If enabled by WEEK_ALRM_LE, this bit is set to 1 if the Week Alarm signal is asserted. It is reset by writes to WEEK_ALRM_LS.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_ALRM</name>
                     <description>If enabled by RTC_ALRM_LE, this bit is set to 1 if the RTC Alarm signal is asserted. It is reset by writes to RTC_ALRM_LS.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SYSPWR_PRES</name>
                     <description>This is the System power present select bit.    1= VCI_IN3 is used as System power present.    0= VCI_IN3 is used as VCI_IN3.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LATCH_EN</name>
               <description>Latch Enable Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LE</name>
                     <description>Latching Enables. Latching occurs after the Polarity configuration, so a VCI_INi# pin is asserted when it is '0' if VCI_IN_POL is '0', and asserted when it is '1' if VCI_IN_POL is '1'.     For each bit in the field:     1=Enabled. Assertions of the VCI_INi# pin are held until the latch is reset by writing the corresponding LS bit     0=Not Enabled. The VCI_INi# signal is not latched but passed directly to the VCI_OUT logic</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>WK_ALRM_LE</name>
                     <description>Latch enable for the Week Alarm Power-Up signal.     1=Enabled. Assertions of the Week Alarm are held until the latch is reset by writing the corresponding LS bit     0=Not Enabled. The Week Alarm signal is not latched but passed directly to the VCI_OUT logic</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_ALRM_LE</name>
                     <description>Latch enable for the RTC Power-Up signal.     1=Enabled. Assertions of the RTC Alarm are held until the latch is reset by writing the corresponding LS bit     0=Not Enabled. The RTC Alarm signal is not latched but passed directly to the VCI_OUT logic</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LATCH_RST</name>
               <description>Latch Resets Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LS</name>
                     <description>Latch Resets. When a Latch Resets bit is written with a '1', the corresponding VCI_INi# latch is de-asserted ('1'). The VCI_INi#     input to the latch has priority over the Latch Reset input, so firmware cannot reset the latch while the VCI_INi# pin is asserted. Firmware     should sample the state of the pin in the VCI Register before attempting to reset the latch. As noted in the Latch Enable Register,     the assertion level is determined by the VCI_IN_POL bit. Reads of this register are undefined.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>WK_ALRM_LS</name>
                     <description>Week Alarm Latch Reset. When this bit is written with a '1', the Week Alarm Event latch is reset.     The Week Alarm input to the latch has priority over the Reset input Reads of this register are undefined.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_ALRM_LS</name>
                     <description>RTC Alarm Latch Reset. When this bit is written with a '1', the RTC Alarm Event latch is reset.     The RTC Alarm input to the latch has priority over the Reset input Reads of this register are undefined.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INPUT_EN</name>
               <description>VCI Input Enable Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000007</resetValue>
               <fields>
                  <field>
                     <name>IE</name>
                     <description>Input Enables for VCI_IN# signals. After changing the input enable for a VCI input, firmware should reset the input latch and clear     any potential interrupt that may have been triggered by the input, as changing the enable may cause the internal status to change.     For each bit in the field:     1=Enabled. The corresponding VCI_IN# input is not gated and toggling the pin will affect the VCI_OUT pin     0=Not Enabled. the corresponding VCI_IN# input does not affect the VCI_OUT pin, even if the input is '0'. Unless the corresponding bit     in the VCI Buffer Enable Register is 1, latches are not asserted, even if the VCI_IN# pin is low, during a VBAT power transition</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HLDOFF_CNT</name>
               <description>Holdoff Count Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TIME</name>
                     <description>These bits determine the period of time the VCI_OUT logic is inhibited from re-asserting VCI_OUT after a SYS_SHDN# event.     FFh-01h=The Power On Inhibit Holdoff Time is set to a period between 125ms and 31.875 seconds.     0=The Power On Inhibit function is disabled.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>POLARITY</name>
               <description>VCI Polarity Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VCI_IN</name>
                     <description>These bits determine the polarity of the VCI_IN input signals: For each bit in the field:     1=Active High. The value on the pins is inverted before use     0=Active Low (default).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PEDGE_DET</name>
               <description>VCI Posedge Detect Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VCI_IN</name>
                     <description>These bits record a low to high transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field:     1=Positive Edge Detected; 0=No edge detected.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>NEDGE_DET</name>
               <description>VCI Negedge Detect Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VCI_IN</name>
                     <description>These bits record a high to low transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field:     1=Negative Edge Detected; 0=No edge detected.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BUFFER_EN</name>
               <description>VCI Buffer Enable Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>V_BUF</name>
                     <description>Input Buffer enable. After changing the buffer enable for a VCI input, firmware should reset the input latch and clear any     potential interrupt that may have been triggered by the input, as changing the buffer may cause the internal status to change. This register     has no effect when VTR is powered. When VTR is on, the input buffers are enabled only by the IE bit. For each bit in the field:     1=VCI_IN# input buffer enabled independent of the IE bit. The edge detection latches for this input are always enabled     0=VCI_IN# input buffer enabled by the IE bit. The edge detection latches are only enabled when the IE bit is 1 (default).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>VBAT_RAM</name>
         <version>931.0</version>
         <description>The VBAT RAM is operational while the main power rail is operational, and will retain its values powered by battery power while the main rail is unpowered.</description>
         <baseAddress>0x4000A800</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xC8</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <dim>32</dim>
               <dimIncrement>4</dimIncrement>
               <name>MEM[%s]</name>
               <description>32-bits of VBAT powered RAM.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>VBAT</name>
         <version>941.0</version>
         <description>The VBAT Register Bank block is a block implemented for miscellaneous battery-backed registers.</description>
         <baseAddress>0x4000A400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x38</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>PFRS</name>
               <description>The Power-Fail and Reset Status Register collects and retains the VBAT RST and WDT event status when VCC1 is unpowered.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x80</resetValue>
               <fields>
                  <field>
                     <name>SOFT</name>
                     <description>This bit is set to '1b' if a was triggered by an assertion of the SOFT_SYS_RESET bit in the System Reset Register.      This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST</name>
                     <description>Test</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RSTI</name>
                     <description>This bit is set to '1b' if a RESET_SYS was triggered by a low signal on the RESETI# input pin. This bit is      cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_EVT</name>
                     <description>This bit is set to '1b' if a RESET_SYS was triggered by a Watchdog Timer event. This bit is cleared to '0b' when      written with a '1b'; writes of a '0b' have no effect. (R/WC)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SYS_RSTREQ</name>
                     <description>This bit is set to '1b' if a RESET_SYS was triggered by an ARM SYSRESETREQ event. This bit is cleared to '0b' when      written with a '1b'; writes of a '0b' have no effect. (R/WC)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VBAT_RST</name>
                     <description>The VBAT RST bit is set to '1' by hardware when a RESET_VBAT is detected. This is the register default value.      To clear VBAT RST EC firmware must write a '1' to this bit; writing a '0' to VBAT RST has no affect.(R/WC)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_EN</name>
               <description>32KHz Clock Enable Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TEST</name>
                     <description>This is a test bit and must not be modified.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>XTAL_EN</name>
                     <description>XTAL Enable Enables/Starts the XTAL clock operation.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>XOSEL</name>
                     <description>This bit selects between a single-ended clock source for the crystal oscillator or an external parallel crystal.                1= the Crystal Oscillator is driven by a single-ended 32KHz clock source connected to the XTAL2 pin.                 0= the Crystal Oscillator requires a 32KHz parallel resonant crystal connected between the XTAL1 and XTAL2 pins (default).</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>XSTRTP_DIS</name>
                     <description>XTAL Startup Disable When enabled the XTAL, in Dual-Ended Mode, will enter a low power mode.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>XTAL_CTRL</name>
                     <description>XTAL Gain Control 0 = Original Gain. 1 or 2=Gain reduced. 3= Gain is smallest.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PRPHL_32KHZ_CLK</name>
                     <description>MUX Select for the source of the 32kHz Peripheral Clock.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>ICLK_SPRS</name>
                     <description>When enabled the Internal 32kHz VBAT clock source is suppressed (disabled) when VTR goes down.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MCNT_LO</name>
               <description>MONOTONIC COUNTER</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CNTR</name>
                     <description>Read-only register that increments by 1 every time it is read. It is reset to 0 on a VBAT Power On Reset.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MCNT_HI</name>
               <description>COUNTER HIWORD</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CNTR</name>
                     <description>Thirty-two bit read/write register. If software sets this register to an incrementing value, based on an external      non-volatile store, this register may be combined with the Monotonic Counter Register to form a 64-bit monotonic counter.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMDRST_DBNC_EN</name>
               <description>Embedded Reset Debouce Enable.</description>
               <addressOffset>0x34</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DBNC_EN</name>
                     <description>Embedded Reset Debouce Enable.  0 = Disable 1 = Enable </description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>EC_REG_BANK</name>
         <version>951.0</version>
         <description>This block is designed to be accessed internally by the EC via the register interface.</description>
         <baseAddress>0x4000FC00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x190</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>SRAM_CNFG</name>
               <description>SRAM Configuration Register</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>SRAM_SIZE</name>
                     <description>SRAM Configuration Register:     0: 384KB         (352k Code, 32k Data)    1: 320kB         (288k Code, 32k Data)    2: 256kB         (224k Code, 32k Data)    3: Illegal 256kB (224k Code, 32k Data)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>AHB_ERR_ADDR</name>
               <description>AHB Error Address [0:0]</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>AHB_ERR_CTRL</name>
               <description>AHB Error Control [0:0] AHB_ERROR_DISABLE, 0: EC memory exceptions are enabled. 1: EC memory exceptions are disabled.</description>
               <addressOffset>0x14</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>INTR_CTRL</name>
               <description>Interrupt Control [0:0] NVIC_EN (NVIC_EN) This bit enables Alternate NVIC IRQ's Vectors. The Alternate NVIC Vectors provides each interrupt event with a dedicated (direct) NVIC vector.            0 = Alternate NVIC vectors disabled, 1= Alternate NVIC vectors enabled</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000001</resetValue>
            </register>
            <register>
               <name>ETM_CTRL</name>
               <description>ETM TRACE Enable [0:0] TRACE_EN (TRACE_EN) This bit enables the ARM TRACE debug port (ETM/ITM). The Trace Debug Interface pins are forced to the TRACE functions.            0 = ARM TRACE port disabled, 1= ARM TRACE port enabled</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>DEBUG_CTRL</name>
               <description>Debug Enable Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>DEBUG_EN (JTAG_EN) This bit enables the JTAG/SWD debug port.               0= JTAG/SWD port disabled. JTAG/SWD cannot be enabled (i.e., the TRST# pin is ignored and the JTAG signals remain in their non-JTAG state)               1= JTAG/SWD port enabled. A high on TRST# enables JTAG or SWD, as determined by SWD_EN.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PIN_CFG</name>
                     <description>This field determines which pins are affected by the TRST# debug enable pin.      3=Reserved      2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins      associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial      Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required      1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin      associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug      (SWD) and Serial Wire Viewer (SWV) are both required for debugging      0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high.      This setting should be used when the JTAG TAP controller is required for debugging.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>PIN_CFGSelect</name>
                        <enumeratedValue>
                           <name>JTAG_TCK_TMS</name>
                           <description>2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins           associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial          Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required </description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTAG_TCK_TMS_TDO</name>
                           <description>1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin           associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug             (SWD) and Serial Wire Viewer (SWV) are both required for debugging</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTAG_TCK_TMS_TDO_TDI</name>
                           <description>0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high.         This setting should be used when the JTAG TAP controller is required for debugging.</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PU_EN</name>
                     <description>If this bit is set to '1b' internal pull-up resistors are automatically enabled on the appropriate debugging port      wires whenever the debug port is enabled (the DEBUG_EN bit in this register is '1b' and the JTAG_RST# pin is high). The setting      of DEBUG_PIN_CFG determines which pins have pull-ups enabled when the debug port is enabled.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BSP_EN</name>
                     <description>This bit sets the boundary scan tap controller accessibility from JTAG port.         1= Boundary scan tap controller accessibile through JTAG Port.         0= Boundary scan tap controller not accessibile through JTAG Port.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OTP_LOCK</name>
               <description>Lock Register</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TEST</name>
                     <description>Test</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VBAT_RAM_LOCK</name>
                     <description>VBAT RAM LOCK bit.         0 = Not Locked.         1 = Locked.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VBAT_REG_LOCK</name>
                     <description>VBAT REG LOCK.         0 = Not Locked.         1 = Locked.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WDT_CNT</name>
               <description>WDT Event Count [3:0] WDT_COUNT (WDT_COUNT) These EC R/W bits are cleared to 0 on VCC1 POR, but not on a WDT.            Note: This field is written by Boot ROM firmware to indicate the number of times a WDT fired before loading a good EC code image.</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>AESH_BSWAP_CTRL</name>
               <description>AES HASH Byte Swap Control Register.</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IP_BYTE_SWAP_EN</name>
                     <description>Used to enable byte swap on a DWORD during AHB read from AES / HASH block: 1=Enable; 0=Disable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OP_BYTE_SWAP_EN</name>
                     <description>Used to enable byte swap on a DWORD during AHB write from AES / HASH block: 1=Enable; 0=Disable.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IP_BLK_SWAP_EN</name>
                     <description>Used to enable word swap on a DWORD during AHB read from AES / HASH block 0=Disable.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <name>IP_BLK_SWAP_ENSelect</name>
                        <enumeratedValue>
                           <name>SWAP_128_BYTE_BLOCK</name>
                           <description>4=Swap 32-bit doublewords in 128-byte blocks </description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_64_BYTE_BLOCK</name>
                           <description>3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,          0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,...</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_16_BYTE_BLOCK</name>
                           <description>2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,...</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_8_BYTE_BLOCK</name>
                           <description>1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4,       0x0, 0xC, 0x8, ...</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIS</name>
                           <description>0=Disable.</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>OP_BLK_SWAP_EN</name>
                     <description>Used to enable word swap on a DWORD during AHB write from AES / HASH block 0=Disable.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <name>OP_BLK_SWAP_ENSelect</name>
                        <enumeratedValue>
                           <name>SWAP_128_BYTE_BLOCK</name>
                           <description>4=Swap 32-bit doublewords in 128-byte blocks </description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_64_BYTE_BLOCK</name>
                           <description>3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,          0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,...</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_16_BYTE_BLOCK</name>
                           <description>2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,...</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_8_BYTE_BLOCK</name>
                           <description>1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4,       0x0, 0xC, 0x8, ...</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIS</name>
                           <description>0=Disable.</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>PECI_DIS</name>
               <description>PECI Disable</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>P_DIS</name>
                     <description>When this bit is asserted ('1'), it disables the PECI pads to reduce leakage.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>GPIO_BANK_PWR</name>
               <description>GPIO Bank Power Register</description>
               <addressOffset>0x64</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TEST</name>
                     <description>This bit must be programmed to 0h for proper operation of the device.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VTR_LVL2</name>
                     <description>Voltage value on VTR2. This bit is set by Firmware after a VTR Power On Reset.         It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted.         Write access is determined by bit 7.      1=VTR2 is powered by 1.8V      0=VTR2 is powered by 3.3V.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_BANK_PWR_LOCK</name>
                     <description>GPIO Bank Power Lock. 0: VTR_LEVEL bits[2:0] and GPIO Bank Power Lock bit are R/W      1 = VTR_LEVEL bits[2:0] and GPIO Bank Power Lock bit are Read Only.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MCFG</name>
               <description>JTAG Master Configuration Register</description>
               <addressOffset>0x70</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTM_CLK</name>
                     <description>This field determines the JTAG Master clock rate, derived from the 48MHz master clock.      7=375KHz; 6=750KHz; 5=1.5Mhz; 4=3Mhz; 3=6Mhz; 2=12Mhz; 1=24MHz; 0=Reserved.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <name>JTM_CLKSelect</name>
                        <enumeratedValue>
                           <name>JTM_CLK_375KHz</name>
                           <description>7=375KHz</description>
                           <value>0x7</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_750KHz</name>
                           <description>6=750KHz</description>
                           <value>0x6</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_1MHz</name>
                           <description>5=1.5Mhz</description>
                           <value>0x5</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_3Mhz</name>
                           <description>4=3Mhz</description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_6Mhz</name>
                           <description>3=6Mhz</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_12Mhz</name>
                           <description>2=12Mhz</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_24MHz</name>
                           <description>1=24MHz</description>
                           <value>0x1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MAS_SLV</name>
                     <description>This bit controls the direction of the JTAG port. 1=The JTAG Port is configured as a Master      0=The JTAG Port is configures as a Slave.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MSTS</name>
               <description>JTAG Master Status Register</description>
               <addressOffset>0x74</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTM_DONE</name>
                     <description>This bit is set to '1b' when the JTAG Master Command Register is written. It becomes '0b' when shifting has completed.      Software can poll this bit to determine when a command has completed and it is therefore safe to remove the data in the JTAG Master TDO      Register and load new data into the JTAG Master TMS Register and the JTAG Master TDI Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MTDO</name>
               <description>JTAG Master TDO Register</description>
               <addressOffset>0x78</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTM_TDO</name>
                     <description>When the JTAG Master Command Register is written, from 1 to 32 bits are shifted into this register, starting with bit 0,      from the JTAG_TDO pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MTDI</name>
               <description>JTAG Master TDI Register</description>
               <addressOffset>0x7C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTM_TDI</name>
                     <description>When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0,      onto the JTAG_TDI pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MTMS</name>
               <description>JTAG Master TMS Register</description>
               <addressOffset>0x80</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTM_TMS</name>
                     <description>When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0,      onto the JTAG_TMS pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MCMD</name>
               <description>JTAG Master Command Register</description>
               <addressOffset>0x84</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTM_COUNT</name>
                     <description>If the JTAG Port is configured as a Master, writing this register starts clocking and shifting on the JTAG port. The JTAG      Master port will shift JTM_COUNT+1 times, so writing a '0h' will shift 1 bit, and writing '31h' will shift 32 bits. The signal JTAG_CLK      will cycle JTM_COUNT+1 times. The contents of the JTAG Master TMS Register and the JTAG Master TDI Register will be shifted out on      the falling edge of JTAG_CLK and the.JTAG Master TDO Register will get shifted in on the rising edge of JTAG_CLK.      If the JTAG Port is configured as a Slave, writing this register has no effect.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>VW_SRC_CNGF</name>
               <description>Virtual Wire Source Configuration Register</description>
               <addressOffset>0x90</addressOffset>
               <size>32</size>
               <resetValue>0x00000007</resetValue>
               <fields>
                  <field>
                     <name>VW_SRC</name>
                     <description>VWIRE_SOURCE [2], VWIRE_SOURCE [1], VWIRE_SOURCE [0]</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACOMP_CTRL</name>
               <description>Comparator Enable</description>
               <addressOffset>0x94</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CMP0EN</name>
                     <description>Comparator 0 Enable         0: Disable Comparator for operation         1: Enable Comparator operation.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CONF0LCK</name>
                     <description>Comparator 0 Configuration Locked         0: Configuration Not Locked. Bits[2,0] are Read-Write         1: Configuration Locked. Bits[2,0] are Read-Only         Note: If the CMP_STRAP0 Pin = 1 the Boot ROM writes this bit. Once it is written         this bit becomes a read-only bit.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP1EN</name>
                     <description>Comparator 1 Enable         0: Disable Comparator for operation         1: Enable Comparator operation.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACOMP_SLP_CTRL</name>
               <description>Analog Comparator Sleep Control Register</description>
               <addressOffset>0x98</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CMP0SLP_EN</name>
                     <description>Comparator 0 Deep Sleep Enable.         0 = Comparator Deep Sleep Disable.         1 = Comparator Deep Sleep Enable.         Note: If the CMP_STRAP0 Pin = 1 the Boot ROM writes this bit. Once it is written          this bit becomes a read-only bit.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP1SLP_EN</name>
                     <description>Comparator 1 Deep Sleep Enable.         0 = Comparator Deep Sleep Disable.         1 = Comparator Deep Sleep Enable.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMDRST_EN</name>
               <description>Embedded Reset Enable Register</description>
               <addressOffset>0xB0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>Embedded Reset Enable Register.  0 = Disable, 1 = Enable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMDRST_TOUT</name>
               <description>Embedded Reset Timeout Register</description>
               <addressOffset>0xB4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TOUT</name>
                     <description>Embedded Reset Timeout Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMDRST_STS</name>
               <description>Embedded Reset Status Register</description>
               <addressOffset>0xB8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>STS</name>
                     <description>Embedded Reset Status Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EMDRST_CNT</name>
               <description>Embedded Reset Count Register</description>
               <addressOffset>0xBC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CNT</name>
                     <description>Embedded Reset CNT Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>19</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FW_SCR0</name>
               <description>BOOT ROM Scratch 0 Register</description>
               <addressOffset>0x180</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCR0</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FW_SCR1</name>
               <description>BOOT ROM Scratch 1 Register</description>
               <addressOffset>0x184</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>UDS_CRC_STS</name>
                     <description>UDS CRC status. 0 = UDS CRC checking disabled. Hardware POR state    1 = UDS CRC check passed,    2 = UDS CRC check failed,           3 = invalid.  Can only get this result if UDS CRC feature not enabled and bits are set by application code.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SCR1</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>30</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FW_SCR2</name>
               <description>BOOT ROM Scratch 2 Register</description>
               <addressOffset>0x188</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCR2</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FW_SCR3</name>
               <description>BOOT ROM Scratch 3 Register</description>
               <addressOffset>0x18C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCR3</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>ASIF</name>
         <version>61.0</version>
         <description>The ASIF allows the Host and EC to use index addressing to access registers residing in an external IC.</description>
         <baseAddress>0x400FC000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x140</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>ASIF</name>
            <value>64</value>
         </interrupt>
         <registers>
            <register>
               <name>HOST_BAL</name>
               <description>LPC BAL Register</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0xE0</resetValue>
               <fields>
                  <field>
                     <name>LPC_BAL</name>
                     <description>Nominally, the low-byte of the block's LPC base address. This register has no function. It is provided for legacy reasons.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HOST_BAH</name>
               <description>LPC BAH Register.</description>
               <addressOffset>0x1</addressOffset>
               <size>8</size>
               <resetValue>0x15</resetValue>
               <fields>
                  <field>
                     <name>LPC_BAH</name>
                     <description>Nominally, the high-byte of the block's LPC base address. This register has no function. It is provided for legacy reasons.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>10</dim>
               <dimIncrement>1</dimIncrement>
               <name>SCRATCH[%s]</name>
               <description>Scratch 0 Register</description>
               <addressOffset>0x2</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>SCR</name>
                     <description>This field has no functionality other than storage. This register is aliased to EC-Only Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HOST_AIXL</name>
               <description>LPC AIXL Register</description>
               <addressOffset>0xC</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>LPC_IND_LOW</name>
                     <description>Low-byte of the 10-bit index from the LPC interface.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HOST_AIXH</name>
               <description>LPC AIXH Register</description>
               <addressOffset>0xD</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>LPC_IND_HI</name>
                     <description>Most significant two bits of the 10-bit index from the LPC interface.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>LPC_ACCESS_MODE</name>
                     <description>1=Synchronous mode: the host would poll the LPC Status Register after issuing a command. When the LPC_IF_BUSY bit is      cleared, write data has been latched by the external IC or read data has been fetched into the LPC Data In Register.      0=Atomic access mode. LPC cycles to Data register will be blocked until current LPC request is serviced.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HOST_DATA_IN</name>
               <description>LPC Data In Register</description>
               <addressOffset>0xE</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>LPC_DATA_IN</name>
                     <description>This register contains data read from the external ASIC. This register shares an offset with LPC Data Out Register.      After a read command is issued, software reads from this register when LPC_IF_BUSY='0' and LPC_OBF= 1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HOST_DATA_OUT</name>
               <description>LPC Data Out Register</description>
               <addressOffset>0xE</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>LPC_DATA_OUT</name>
                     <description>This register contains write data targeting the external ASIC. This register shares an offset with LPC Data In Register.      Writes to this register are ignored while LPC_IF_BUSY is 1, i.e., until write data has been transferred to the external IC over SPI.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HOST_STS</name>
               <description>LPC Status Register</description>
               <addressOffset>0xF</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_IF_BUSY</name>
                     <description>EC Interface Busy. Set to 1 when the EC issues a read or write to the EC_DAT Register. Set to 0 when the SPI transfer      to the external ASIC that is triggered by the EC register access is completed. This is the same bit as EC_IF_BUSY in the EC Status Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LPC_IF_BUSY</name>
                     <description>LPC Interface Busy, also known as Host Command in Progress. The bit is set to 1 when the Host issues a command to the LPC      interface, by either reading from the LPC Data In Register or writing to the LPC Data Out Register. The bit is cleared to 0 when the      corresponding SPI transfer to the external IC is completed. This is the same bit as LPC_IF_BUSY in the EC Status Register.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LPC_OBF</name>
                     <description>LPC Output Buffer Full. This bit is set to 1 after read data from the external IC has been latched into the LPC Data In Register.      Cleared after the ASIF returns read data to the host. This register is aliased to EC-Only Register.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LPC_IBF</name>
                     <description>LPC Input Buffer Full. This bit is set to 1 after the host issues a write command. The bit is reset to 0 when the SPI write      transfer to the external IC has completed.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_AIXL</name>
               <description>EC AIXL Register</description>
               <addressOffset>0x100</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>IND_LOW</name>
                     <description>Low-byte of the 10-bit index from the EC interface.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_AIXH</name>
               <description>EC AIXH Register</description>
               <addressOffset>0x101</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_IND_HI</name>
                     <description>Most significant two bits of the 10-bit index from the EC interface.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>EC_ACCESS_MODE</name>
                     <description>0: Atomic access mode. EC cycles to Data register will be blocked until current LPC request is serviced      1: Synchronous mode: EC polls the EC Status Register after issuing a command. When EC-IF Busy bit is cleared, write data has      been latched by the external IC or read data has been fetched into the EC Data In Register.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_DATA_IN</name>
               <description>EC Data In Register</description>
               <addressOffset>0x102</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>DATA</name>
                     <description>This register contains data read from the external ASIC. This register shares an offset with EC Data Out Register.      After a read command is issued, software reads from this register when EC_IF_BUSY='0' and EC_OBF= 1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_DATA_OUT</name>
               <description>EC Data Out Register</description>
               <addressOffset>0x102</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_DATA_OUT</name>
                     <description>This register contains write data targeting the external ASIC. This register shares an offset with EC Data In Register.      Writes to this register are ignored while EC_IF_BUSY is 1, i.e., until write data has been transferred to the external IC over SPI.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_STS</name>
               <description>EC Status Register</description>
               <addressOffset>0x103</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>LPC_IF_BUSY</name>
                     <description>This bit is set to 1 when the Host issues a command to the Auxiliary SPI Interface. This bit is cleared to 0 when      the corresponding SPI transfer to the external IC is completed. This bit is the same as the LPC_IF_BUSY bit in the LPC Status Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_IF_BUSY</name>
                     <description>This bit is set to 1 when the EC issues a command to the Auxiliary SPI Interface. This bit is cleared to 0 when the      corresponding SPI transfer to the external IC is completed. This bit is the same as EC_IF_BUSY in the LPC Status Register.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_OBF</name>
                     <description>EC Output Buffer Full. This bit is set to 1 after read data from the external IC has been latched into the EC Data In Register.      This bit is cleared to 0 after the register has been read.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_IBF</name>
                     <description>EC Input Buffer Full. This bit is set to 1 when the EC issues a write command to the Auxiliary SPI Interface.      This bit is cleared to 0 after transfer to the external IC has completed.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_TX_DONE</name>
                     <description>EC Transmission Done. This bit is set to 1 when a write transfer to the external IC is completed. It is cleared when it is written with a 0.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_BAL</name>
               <description>EC BAL Register</description>
               <addressOffset>0x104</addressOffset>
               <size>8</size>
               <resetValue>0xE0</resetValue>
               <fields>
                  <field>
                     <name>LPC_BAL</name>
                     <description>Nominally, the low-byte of the block's LPC base address. This register is a writable alias of the LPC BAL Register.      This register has no function. It is provided for legacy reasons.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_BAH</name>
               <description>EC BAH Register.</description>
               <addressOffset>0x105</addressOffset>
               <size>8</size>
               <resetValue>0x15</resetValue>
               <fields>
                  <field>
                     <name>LPC_BAH</name>
                     <description>Nominally, the high-byte of the block's LPC base address. This register is a writable alias of the LPC BAH Register.      This register has no function. It is provided for legacy reasons.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_IEN</name>
               <description>EC Interrupt Enable Register</description>
               <addressOffset>0x110</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EC_CMDDONE_IE</name>
                     <description>EC Command Done Interrupt Enable.      1=Enable interrupt when the transaction to the external IC is complete (when the status bit EC_CMD_DONE is 1)      0=Command Done interrupts disabled.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RD_DONE_IE</name>
                     <description>Read Done Interrupt Enable.      1=Enable interrupt when read data from the external IC is available for the EC (when the status bit EC_RD_DONE is 1)      0=Read Done interrupts disabled</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_DONE_IE</name>
                     <description>Write Done Interrupt Enable.      1=Enable interrupt when transfer of write data to the external IC is complete (when the status bit EC_WR_DONE is 1)      0=Write Done interrupts disabled.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TIMEOUT_IE</name>
                     <description>Timeout Interrupt Enable.      1=Enable interrupt when Timeout Counter expires      0=Timeout interrupts disabled.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_ISTS</name>
               <description>EC Interrupt Status Register</description>
               <addressOffset>0x114</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CMD_DONE</name>
                     <description>EC Command Done Status. This bit is set to 1 when the SPI transfer to service an EC command to the external IC, either read or write,      has completed. This bit is cleared when written with a 1. Writes of a 0 have no effect.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RD_DONE</name>
                     <description>Read Done Status.This bit is set to 1 when the external IC returns data to the EC as a result of an EC read command.      This bit is cleared when written with a 1. Writes of a 0 have no effect.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_DONE</name>
                     <description>Write Done Status.This bit is set to 1 when EC write data has been transfered to the external IC (when EC_IF_BUSY is cleared).      This bit is cleared when written with a 1. Writes of a 0 have no effect.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCKED_TO</name>
                     <description>Locked Timeout. This bit is set to 1 when the Timeout Counter Register counts down to 0, indicating the Auxiliary Serial Interface is reset due to a time-out event.      Although this bit is cleared to 0 on a Soft Reset that is generated by a write to the SOFT_RESET bit, it is not cleared if the Soft Reset is generated by a time-out event.      This bit is cleared when written with a 1. Writes of a 0 have no effect.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_TMOUT_CNTR</name>
               <description>Timeout Counter Register.</description>
               <addressOffset>0x118</addressOffset>
               <size>32</size>
               <resetValue>0x000000FF</resetValue>
               <fields>
                  <field>
                     <name>TIMEOUT_CNT</name>
                     <description>Timeout period in number of 100KHz cycles -1. Reads return the current count value.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_BLK_CFG</name>
               <description>Block Configuration Register</description>
               <addressOffset>0x120</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>1=Block is operational      0=Block is disabled. Clocks are gated to conserve power and output signals are set to their inactive state. The block must finish all      outstanding transactions on both SPI and LPC/EC logical interfaces before it can gate off internal clocks.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RST</name>
                     <description>Set to 1 to issue a soft reset to the block. Soft reset has similar effect as a hardware power-on reset except that register      settings other than status bits remain unchanged. This bit is self-clearing. The interface bus signals after a soft reset are as follows:      SPI_CS# is de-asserted high; SPI clock is low; SPI_MOSI is high after POR and retains its bus value when Soft Reset is asserted; SPI_MISO is input.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_SPI_CLK_GEN</name>
               <description>SPI Clock Generator Register.</description>
               <addressOffset>0x130</addressOffset>
               <size>32</size>
               <resetValue>0x07</resetValue>
               <fields>
                  <field>
                     <name>PRELD</name>
                     <description>SPI Clock Generator Preload value.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_SPI_CTRL</name>
               <description>SPI Control Register</description>
               <addressOffset>0x134</addressOffset>
               <size>32</size>
               <resetValue>0x00000002</resetValue>
               <fields>
                  <field>
                     <name>LSBF</name>
                     <description>Least Significant Bit First. 1= The data is transferred in LSB-first order.      0= The data is transferred in MSB-first order. (default).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BIOEN</name>
                     <description>Bidirectional Output Enable control. When the SPI is configured for Half Duplex mode or Dual Mode the SPDOUT pin operates as a      bidirectional signal. The BIOEN bit is used by the internal DIRECTION bit to control the direction of the SPDOUT buffers. The direction of the      buffer is never changed while a byte is being transmitted.      1=The SPDOUT_Direction signal configures the SPDOUT signal as an output.      0=The SPDOUT_Direction signal configures the SPDOUT signal as an input.      If the SPIMODE bit is configured for Full Duplex mode the BIOEN bit must be set to 1 to configure the SPI_MOSI signal as an output. Although      the design supports back-to-back transmissions even when the direction of the buffer is changed, it is the software's responsibility to avoid      collisions on the SPI_MOSI signal. The design has been implemented to support a 0 second (max) turnaround (TAR) time. If TAR greater than zero is      required, the software must wait for the transmission in one direction to complete before writing the TX_DATA register to start sending/receiving in the opposite direction.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPDIN_SEL</name>
                     <description>The SPDIN Select which SPI input signals are enabled when the BIOEN bit is configured as an input.      1xb=SPDIN1 and SPDIN2. Select this option for Dual Mode      01b=SPDIN2 only. Select this option for Half Duplex      00b=SPDIN1 only. Select this option for Full Duplex.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_SPI_CLK_CTRL</name>
               <description>SPI Clock Control Register</description>
               <addressOffset>0x138</addressOffset>
               <size>32</size>
               <resetValue>0x00000020</resetValue>
               <fields>
                  <field>
                     <name>TCLKPH</name>
                     <description>Transmit Clock Phase, the SPCLK edge on which the master will clock data out. The transmit clock phase is not affected by the SPI Clock Polarity.      1=Valid data is clocked out on the first SPI_CLK edge on SPDOUT signal. The slave device should sample this data on the second and following even       SPI_CLK edges (i.e., sample data on falling edge)      0=Valid data is clocked out on the SPDOUT signal prior to the first SPI_CLK edge. The slave device should sample this data on the first and following odd      SPI_CLK edges (i.e., sample data on rising edge).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RCLKPH</name>
                     <description>Receive Clock Phase, the SPI_CLK edge on which the master will sample data. The receive clock phase is not affected by the SPI Clock Polarity.      1=Valid data on SPDIN signal is expected after the first SPI_CLK edge. This data is sampled on the second and following even      SPI_CLK edges (i.e., sample data on falling edge)      0=Valid data is expected on the SPDIN signal on the first SPI_CLK edge. This data is sampled on the first and following odd      SPI_CLK edges (i.e., sample data on rising edge)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLKPOL</name>
                     <description>SPI Clock Polarity.      1=The SPI_CLK signal is high when the interface is idle and the first clock edge is a falling edge      0=The SPI_CLK is low when the interface is idle and the first clock edge is a rising edge.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLKSRC</name>
                     <description>Clock Source for the SPI Clock Generator. This bit should not be changed during a SPI transaction. When the field PRELOAD in the SPI      Clock Generator Register is 0, this bit is ignored and the Clock Source is always the main system clock (the equivalent of setting this bit to 0).      1=2MHz; 0=48MHz.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST</name>
                     <description>This bit must remain at 1, its reset default, for correct operation.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_SPI_EN</name>
               <description>SPI Enable Register</description>
               <addressOffset>0x13C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RXEN</name>
                     <description>SPI Receive transfer enable. 1=SPI read transfer is enabled      0=SPI read transfer is disabled. Read commands received at the LPC and EC interfaces will not result in SPI transfers to IC, i.e.,      address is not shifted out and read data not shifted in.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXEN</name>
                     <description>SPI Transmit transfer enable. 1=SPI write transfer is enabled      0=SPI write transfer is disabled. Write commands received at the LPC and EC interfaces will not result in SPI transfers to IC, i.e.,      address and write data are not shifted out.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXBUSY</name>
                     <description>Receive Busy. 1=Set when a SPI read transfer to external IC is started. Cleared when the transfer is completed      0=Receive channel idle.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXBUSY</name>
                     <description>Transmit Busy. 1=Set when a SPI write transfer to external IC is started. Cleared when the transfer is completed      0=Transmit channel idle.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>ESPI_SCRATCH</name>
         <version>401.0</version>
         <description>32 Byte ESPI Test Register</description>
         <baseAddress>0x400FBC00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x20</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>SCRATCH0</name>
               <description>Scratch 0 Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCR0</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCRATCH1</name>
               <description>Scratch 1 Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCR1</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCRATCH2</name>
               <description>Scratch 2 Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCR2</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCRATCH3</name>
               <description>Scratch 3 Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCR3</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCRATCH4</name>
               <description>Scratch 4 Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCR4</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCRATCH5</name>
               <description>Scratch 5 Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCR5</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCRATCH6</name>
               <description>Scratch 6 Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCR6</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCRATCH7</name>
               <description>Scratch 7 Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SCR7</name>
                     <description>This field has no functionality other than storage. This register is aliased to  ESPI Config Scratch Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>SAFBC_EC</name>
         <version>143a1.0</version>
         <description>SAF BRIDGE COMPONENT</description>
         <baseAddress>0x40008000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x214</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>SAF_DONE</name>
            <value>166</value>
         </interrupt>
         <interrupt>
            <name>SAF_ERR</name>
            <value>167</value>
         </interrupt>
         <registers>
            <register>
               <name>ECP_CMD</name>
               <description>This register defines the command type and length of transfers requested by EC firmware</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EC_PUT_CMD</name>
                     <description>This field must contain the value 0Ah; that is, the eSPI command                       PUT_FLASH_NP.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>EC_CTYPE_CMD</name>
                     <description>This field encodes the operation requested:                       00h = Read                       01h = Write (Page Program)                       02h = Erase         03h = RPMC OP1 directed to Flash CS0#          04h = RPMC OP2 directed to Flash CS0#         83h = RPMC OP1 directed to Flash CS1#         84h = RPMC OP2 directed to Flash CS1#                       Other encodings are undefined</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>EC_LEN</name>
                     <description>This field contains the Length field for all requests.                       Read or Write or  RPMC OP1 or OP2: The length in bytes of the data transfer, to or from                       the SRAM buffer. Must be in the range 1 -- 64 (01h -- 40h).                       Erase: Must encode an eSPI-defined Erase Block Size:                       00h = 4K                       01h = 32K                       02h = 64K                       Other encodings are undefined.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ECP_FLASH_ADDR</name>
               <description>This register hold the Flash Space address to be accessed by the current command from EC firmware.</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADDR</name>
                     <description>FLASH_ADDR: This field holds the Flash address to be accessed.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ECP_START</name>
               <description>This register contains the Start control for a Flash access requested in the rest of the EC    Portal registers. It triggers the requested transfer.</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>START</name>
                     <description>This bit is written with '1' to start a new request, but always appears                   '0' when being read. Writing '1' to this bit immediately sets the                   EC_BUSY bit to '1' as an acknowledgement that the request is being serviced.                   Writing '1' to the START bit again, while the EC_BUSY bit is                   already '1' will do nothing except to set the START_OVERFLOW                   error status bit to '1' and the request already in service will complete                   normally except for the START_OVERFLOW=1 status indication.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ECP_BUF_ADDR</name>
               <description>This register holds a location in the EC's own address space that is to be used as     the SRAM buffer for an EC Flash access.</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADR</name>
                     <description>This field holds bits [31:2] of the SRAM buffer address.                   Bits[1:0] of the address are fixed at 00.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>30</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ECP_STS</name>
               <description>This register holds the DONE status bit.</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DONE</name>
                     <description>This bit is set to '1' by hardware to indicate the end of a requested access by the EC.        It can be enabled to trigger an interrupt when '1'. Writing a '1' clears this bit and the interrupt source.        This is R/WC.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE_TST</name>
                     <description>This bit is set to '1' by hardware during a requested access by the EC. It has no usage        except for possible diagnostic purposes, but should be cleared (with the rest of this register)         by writing '1' before starting any new access.        This is R/WC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TIMEOUT</name>
                     <description>This bit indicates that an Erase or Write or RPMC OP1 request from the EC has failed because the Flash        has timed out. This bit is cleared by writing '1' to its position.        This is R/WC.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_OF_RANGE</name>
                     <description>This bit indicates that a request from the EC has been rejected because it is beyond the        physical limits of the attached Flash devices, as declared in the Size Limit and Threshold        Registers. This bit is cleared by writing '1' to its position.        This is R/WC.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACCESS_VIOLAT</name>
                     <description>This bit indicates that a request from the EC has been rejected because it violates the        Protection Register settings. This bit is cleared by writing '1' to its position.        This is R/WC.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BOUND_4K</name>
                     <description>This bit indicates that a Read request from the EC has been rejected because it has attempted         to cross a 4K Flash address boundary. This bit is cleared by writing '1' to its position.        This is R/WC.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERASE_SIZE</name>
                     <description>This bit indicates that an invalid Erase Block Size has been specified in an Erase request        from the EC. This error is detected by seeing 00h in the specific Erase Size opcode field. This         bit is cleared by writing '1' to its position.        This is R/WC.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT_OVRFLW</name>
                     <description>This bit indicates that an access was already in progress when a new access was        requested by writing '1' to the START bit. Such a request is ignored except to set this bit.        This bit is cleared by writing '1' to its position.        This is R/WC.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BAD_REQ</name>
                     <description>This bit indicates that an invalid Request code has been specified in the Portal        Command Register at the time the START bit was set to trigger it.        This bit is cleared by writing '1' to its position.         This is R/WC.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPMC_OP2LEN</name>
                     <description>This bit indicates that a lenght greater that 49 is set for RPMC OP2 command. This is R/WC.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ECP_IEN</name>
               <description>This register contains the one bit DONE_EN in bit position[0]. This bit enables the DONE bit in     the status register to trigger an interrupt.</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DONE_EN</name>
                     <description>This bit enables interrupts from the DONE bit in the Status register.         1 = Enabled         0 = Disabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TIMEOUT_EN</name>
                     <description>This controls whether an interrupt is fired when Timeout is asserted.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUTOFRNG_EN</name>
                     <description>This controls whether an interrupt is fired when Out Of Range is asserted.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACCESS_VIOLAT_EN</name>
                     <description>This controls whether an interrupt is fired when Access Violation is asserted.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BOUND_4K_EN</name>
                     <description>This controls whether an interrupt is fired when 4K Boundary is asserted.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERASE_SIZ_EN</name>
                     <description>This controls whether an interrupt is fired when Erase Size Error is asserted.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT_OVRFL_EN</name>
                     <description>This controls whether an interrupt is fired when Start Overflow is asserted.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BAD_REQ_EN</name>
                     <description>This controls whether an interrupt is fired when Bad Request is asserted.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPMC_OP2LEN_EN</name>
                     <description>This controls whether an interrupt is fired when RPMC OP2 Lenght is asserted.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FLASH_SIZE_LIM</name>
               <description>This register declares the address of the final byte of the Flash space implemented in the    physically present Flash device or devices.</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LIMIT</name>
                     <description>This register declares the address of the final byte of the Flash space implemented in the    physically present Flash device or devices.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FLASH_THR</name>
               <description>This register declares whether there are two Flash devices, and if so, where the boundary is     between the devices.</description>
               <addressOffset>0x34</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>THRES</name>
                     <description>The address placed in this register is the address of the first byte of the second Flash         device. If there is only one Flash device, then this register must contain a value greater than         the Size Limit register above.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FLASH_MISC_CFG</name>
               <description>Bits[7:6] (PREFIX) declare the need for some Flash devices (notably Micron) to be given an     explicit command to enter Continuous Mode, as opposed to requiring only Mode bits in the first     Read access.</description>
               <addressOffset>0x38</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PREFETCH_OPT_EN</name>
                     <description>Selects optimized data prefetching from the Flash devices to the eSPI Master. This field has no        effect unless the PREFETCH_EN bit is also '1'         00= Prefetched data from Flash is delivered using canonical eSPI methods. (Default)        11= Prefetched data from Flash is delivered using expedited eSPI methods.        01,10= (Reserved)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CS0_4BYTE_ADDR_MODE</name>
                     <description>Declares whether the Flash device on CS0# uses a 32-bit address. Set this bit to '1' if the Flash         device is 32Mbytes (256MBits) or greater. This bit does not cause the Flash device itself to be placed         into 4-byte address mode; that must be done by EC firmware before enabling SAFS operation.         0=Issue 3-byte addresses to the CS0# Flash device.         1=Issue 4-byte addresses to the CS0# Flash device.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS1_4BYTE_ADDR_MODE</name>
                     <description>Declares whether the Flash device on CS1# uses a 32-bit address. Set this bit to '1' if the Flash         device is 32Mbytes (256MBits) or greater. This bit does not cause the Flash device itself to be placed         into 4-byte address mode; that must be done by EC firmware before enabling SAFS operation.         0=Issue 3-byte addresses to the CS1# Flash device.         1=Issue 4-byte addresses to the CS1# Flash device.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS0_CONT_PREFIX_EN</name>
                     <description>Declares whether the Flash device on CS0# requires a prefix command to enter Continuous Mode.         0=No prefix command is required by the Flash device on CS0#.         1=A Prefix command will be issued from the CS0 fields of the SAF Flash Configuration Special Mode Register         to the Flash device on CS0# before entry into Continuous Mode.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS1_CONT_PREFIX_EN</name>
                     <description>Declares whether the Flash device on CS1# (if any) requires a prefix command to enter Continuous Mode.         0=No prefix command is required by the Flash device on CS1#.         1=A Prefix command will be issued from the CS1 fields of the SAF Flash Configuration Special Mode Register         to the Flash device on CS1# before entry into Continuous Mode.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_MODE_EN</name>
                     <description>0=SAFS Mode operation is globally disabled.               1=SAFS Mode operation is globally enabled. The Captive QMSPI Block register set and       the SAF Communication register set also become inaccessible to EC firmware.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_MODE_LOCK</name>
                     <description>0=The SAF Bridge register sets are unlocked and available R/W to EC firmware.               1=The SAF Bridge register sets Device Configuration and Device Timing, including this                register, are locked read-only to EC firmware.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FPWRDN_LGHT_SLPEN</name>
                     <description>Enables the SAF block to sleep the flash on Light Sleep Enable</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FPWRDN_HVY_SLPEN</name>
                     <description>Enables the SAF block to sleep the flash on Heavy Sleep Enable</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FACTV_CNT_EN</name>
                     <description>Enables the saf block to sleep on the Activity Counter reaching zero.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RLD_ACTV_CNT_ESPI_EN</name>
                     <description>Enables the Activity Counter to Reload On SPI Enable</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RLD_ACTV_CNT_EC0_EN</name>
                     <description>Enables the activity counter to reload on EC0 Activity Counter Reload</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RLD_ACTV_CNT_EC1_EN</name>
                     <description>Enables the activity counter to reload on EC1 Activity</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>F_RPMC_SCSS</name>
                     <description>Force RPMC Success. 1=Forces all RPMC OP1 operations to be reported as successful.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ESPI_ERRINTR_STAT</name>
               <description>These bits may be individually enabled to trigger interrupts using the corresponding        Interrupt Enable register.</description>
               <addressOffset>0x3C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TIMEOUT</name>
                     <description>This bit indicates that an Erase or Write request from the Host Chipset has failed               because the Flash has timed out. This bit is cleared by writing '1' to its position.        This is R/WC.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_OF_RANGE</name>
                     <description>This bit indicates that a request from the Host Chipset has been rejected because        it is beyond the physical limits of the attached Flash devices. This bit is cleared by        writing '1' to its position.        This is R/WC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACCESS_VIOLAT</name>
                     <description>This bit indicates that a request from the Host Chipset has been rejected because        it violates the Protection Register settings. This bit is cleared by writing '1' to its        position.        This is R/WC.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BOUND_4K</name>
                     <description>This bit indicates that a Read request from the Host Chipset has been rejected        because it has attempted to cross a 4K Flash address boundary. This bit is cleared by        writing '1' to its position.        This is R/WC.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERASE_SIZE</name>
                     <description>This bit indicates that an invalid Erase Block Size has been specified in        an Erase request from the Host Chipset. This bit is cleared by writing '1' to its position.        This is R/WC.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ESPI_ERR_IEN</name>
               <description>This is the eSPI Error interrupt Enable Register.</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TIMEOUT_EN</name>
                     <description>This bit enables the TIMEOUT status bit as an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_OF_RANGE_EN</name>
                     <description>This bit enables the OUT_OF_RANGE status bit as an interrupt.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACCESS_VIOLAT_EN</name>
                     <description>This bit enables the ACCESS_VIOLATION status bit as an interrupt.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BOUND_4K_EN</name>
                     <description>This bit enables the 4K_BOUNDARY status bit as an interrupt.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERASE_SIZE_EN</name>
                     <description>This bit enables the ERASE_SIZE status bit as an interrupt.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPMC_OP2LEN_EN</name>
                     <description>This bit enables the RPMC OP2 Length Error status bit as an interrupt.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_BUSY</name>
               <description>This register holds the EC_BUSY status bit, which indicates when the EC Portal    is busy performing an access.</description>
               <addressOffset>0x44</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EC_BUSY</name>
                     <description>This Read-Only bit is set to '1' by hardware when the START bit is written with        '1' to start a new request. It is cleared to '0' when request completes, and its        falling edge sets the DONE bit. While this bit is '1', the EC Portal Command, Flash        Address and Buffer Address registers are locked Read-Only, and the START bit is disabled,        causing it only to set the START_OVERFLOW error status bit to '1'.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CS0_OPA</name>
               <description>There are two Opcode A registers, one associated with each of the Flashes. If the CS1     Flash does not exist, its register can be left in its default state. The four fields in each     register represent the 8-bit Flash opcodes for Write Enable, Suspend, Resume and Read Status     Register. The Status Register referred to is the register inside the Flash which contains the     (BUSY) or (IN PROGRESS) status bit in position 0.</description>
               <addressOffset>0x4C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OP_WE</name>
                     <description>This field contains the 8-bit Opcode for Write Enable in the respective Flash device.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_SUS</name>
                     <description>This field contains the 8-bit Opcode for Suspend in the respective Flash device.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_RSM</name>
                     <description>This field contains the 8-bit Opcode for Resume in the respective Flash device.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_POLL1</name>
                     <description>This field contains the 8-bit Opcode for Read Status Register in the respective Flash       device.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CS0_OPB</name>
               <description>There are two Opcode B registers, one associated with each of the Flashes. If the CS1 Flash    does not exist, its register can be left in its default state. The OP_PROGRAM field is mandatory,    and must hold the Page Program opcode for the respective Flash. The Erase size of 4K is mandatory,    and so the OP_ERASE0 field must be initialized to the appropriate opcode for the Flash device.    There is only one bit declaring each Erase size up to the Host System (instead of one per Flash device,    see eSPI Configuration Register 44h), so if there are two Flash devices, each    Erase size over 4K must be declared here only if BOTH Flash devices support it.</description>
               <addressOffset>0x50</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OP_ERASE0</name>
                     <description>This field contains the 8-bit Opcode for 4K Erase in the respective Flash device. This Erase         size is mandatory.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_ERASE1</name>
                     <description>This field contains the 8-bit Opcode for 32K Erase in the respective Flash device. If there         are two Flash devices present, and 32K Erase is not supported by both Flash devices, then this         field must be left as 00h in both the CS0 and CS1 registers.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_ERASE2</name>
                     <description>This field contains the 8-bit Opcode for 64K Erase in the respective Flash device. If there         are two Flash devices present, and 64K Erase is not supported by both Flash devices, then this         field must be left as 00h in both the CS0 and CS1 registers.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_PRG</name>
                     <description>This field contains the 8-bit Opcode for Page Program in the respective Flash device.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CS0_OPC</name>
               <description>There are two Opcode C registers, one associated with each of the Flashes. If the CS1 Flash     does not exist, its register can be left in its default state. Two fields (OP) define opcodes,     and two fields (MODE) represent the Mode code values. Mode codes are provided immediately after     the Address in Continuous Read traffic, and are used to keep the Flash device in Continuous     Read Mode. Depending on the Flash device manufacturer, this mode may be documented in their     datasheet as either a Mode byte, or as certain bits of a first Dummy byte or first Dummy     clock. The recommended Mode values given below are selected to be appropriate for any Flash device.</description>
               <addressOffset>0x54</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OP_READ</name>
                     <description>This field must contain the 8-bit Opcode for Fast Read Quad or Fast Read Dual in the         respective Flash device. This code is used in entering Continuous Read mode, and does not         appear afterward.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MODE_NONC</name>
                     <description>This field is currently a placeholder and is not used. The recommended value for this         field, for future compatibility, is FFh.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MODE_CONT</name>
                     <description>This field contains the 8-bit Mode code used to place (or keep) the Flash device in         Continuous Read mode. It is strongly recommended that this value be set to A5h, as a         universally-acceptable value among Flash devices.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_POLL2</name>
                     <description>This field contains the 8-bit Opcode used to confirm Suspended status in the Flash device.         It is issued using a designated Timing Descriptor chain Poll which is used to read a 16-bit         value. This value is evaluated using the Mask values in the Poll2 Mask register</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CS0_PFD</name>
               <description>There are two Per-Flash Descriptors registers,          one associated with each of the Flash devices.</description>
               <addressOffset>0x58</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ENTER_CONT</name>
                     <description>This field points to the first Descriptor element of the Enter Continuous Mode chain.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>READ_CONT</name>
                     <description>This field points to the first Descriptor element of the Continuous Read chain.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SIZE_CONT</name>
                     <description>This field points to the Descriptor element within the READ_CONT chain that contains         the Length field for data.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CS1_OPA</name>
               <description>This is the CS1 Opcode A register.    If the CS1 Flash does not exist, its register can be left in its default state. The four fields in each register represent the 8-bit Flash   opcodes for Write Enable, Suspend, Resume and Read Status Register. The Status Register referred to is the register inside the Flash which          contains the BUSY or IN PROGRESS status bit in position 0.</description>
               <addressOffset>0x5C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OP_WE</name>
                     <description>This field contains the 8-bit Opcode for Write Enable in the respective Flash device.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_SUS</name>
                     <description>This field contains the 8-bit Opcode for Suspend in the respective Flash device.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_RSM</name>
                     <description>This field contains the 8-bit Opcode for Resume in the respective Flash device.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_POLL1</name>
                     <description>This field contains the 8-bit Opcode for Read Status Register in the respective Flash       device.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CS1_OPB</name>
               <description>This is the CS1 Flash Opcode B register. If the CS1 Flash does not exist, its register can be     left in its default state. The OP_PROGRAM field is mandatory, and must hold the Page Program     opcode for the respective Flash. The Erase size of 4K is mandatory, and so the OP_ERASE0 field     must be initialized to the appropriate opcode for the Flash device. There is only one bit     declaring each Erase size up to the Host System (instead of one per Flash device, see eSPI     Configuration Register 44h), so if there are two Flash devices, each Erase size over 4K must     be declared here only if BOTH Flash devices support it.</description>
               <addressOffset>0x60</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OP_ERASE0</name>
                     <description>This field contains the 8-bit Opcode for 4K Erase in the respective Flash device. This Erase         size is mandatory.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_ERASE1</name>
                     <description>This field contains the 8-bit Opcode for 32K Erase in the respective Flash device. If there         are two Flash devices present, and 32K Erase is not supported by both Flash devices, then this         field must be left as 00h in both the CS0 and CS1 registers.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_ERASE2</name>
                     <description>This field contains the 8-bit Opcode for 64K Erase in the respective Flash device. If there         are two Flash devices present, and 64K Erase is not supported by both Flash devices, then this         field must be left as 00h in both the CS0 and CS1 registers.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_PROGRAM</name>
                     <description>This field contains the 8-bit Opcode for Page Program in the respective Flash device.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CS1_OPC</name>
               <description>This is the CS1 Flash device Opcode C register. If the CS1 Flash does not exist, its     register can be left in its default state. Two fields (OP) define opcodes, and two fields     (MODE) represent the Mode code values. Mode codes are provided immediately after the Address     in Continuous Read traffic, and are used to keep the Flash device in Continuous Read Mode.     Depending on the Flash device manufacturer, this mode may be documented in their datasheet     as either a Mode byte, or as certain bits of a first Dummy byte or first Dummy clock.     The recommended Mode values given below are selected to be appropriate for any Flash device.</description>
               <addressOffset>0x64</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OP_READ</name>
                     <description>This field must contain the 8-bit Opcode for Fast Read Quad or Fast Read Dual in the         respective Flash device. This code is used in entering Continuous Read mode, and does not         appear afterward.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MODE_NONC</name>
                     <description>This field is currently a placeholder and is not used. The recommended value for this         field, for future compatibility, is FFh.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MODE_CONT</name>
                     <description>This field contains the 8-bit Mode code used to place (or keep) the Flash device in         Continuous Read mode. It is strongly recommended that this value be set to A5h, as a         universally-acceptable value among Flash devices.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>OP_POLL2</name>
                     <description>This field contains the 8-bit Opcode used to confirm Suspended status in the Flash device.         It is issued using a designated Timing Descriptor chain Poll which is used to read a 16-bit         value. This value is evaluated using the Mask values in the Poll2 Mask register</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CS1_PFD</name>
               <description>This is the Per-Flash Descriptors register for CS1 Flash.</description>
               <addressOffset>0x68</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ENTER_CONT</name>
                     <description>This field points to the first Descriptor element of the Enter Continuous Mode chain.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>READ_CONT</name>
                     <description>This field points to the first Descriptor element of the Continuous Read chain.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SIZE_CONT</name>
                     <description>This field points to the Descriptor element within the READ_CONT chain that contains         the Length field for data.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>GEND</name>
               <description>This is a single register, which accompanies the two Per-Flash Descriptors registers, and     provides Descriptor pointers that are shared by both CS0 and CS1 devices uniformly.     Each 4-bit field is a pointer which identifies a Timing Descriptor location in the Captive     QMSPI block's memory. The EXIT_CONT field (Exit Continuous Mode) points to the single chain     invoked to exit the Flash from Continuous Mode, allowing an Erase or Program command to be     entered. This chain is identical for either Flash device, regardless of its manufacturer, and     simply directs a universal Exit symbol to the appropriate CS0/CS1 device. The POLL1 and POLL2     fields should both point to the same chain. This chain will issue the appropriate opcode for the     operation (Poll1 or Poll2) supplied by the SAF Bridge from the Opcode registers, and will read     back 16 bits of information for use by the SAF Bridge.</description>
               <addressOffset>0x6C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EXIT_CONT</name>
                     <description>This field points to the first Descriptor element of the Exit Continuous Mode chain.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>POLL1</name>
                     <description>This field points to the first Descriptor element of the Poll chain, used when         polling for Busy status.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>POLL2</name>
                     <description>This field points to the first Descriptor element of the Poll chain, used when         polling for Suspended status.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PRLOCK</name>
               <description>There is a bit in this register for each of the 17 Protection Region Register sets. Writing     '1' to a bit locks the associated 4-Register set to Read-Only access, and also locks this bit     itself to a Read-Only '1'.</description>
               <addressOffset>0x70</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SAF_0</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 0: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_1</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 1: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_2</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 2: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_3</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 3: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_4</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 4: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_5</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 5: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_6</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 6: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_7</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 7: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_8</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 8: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_9</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 9: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_10</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 10: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_11</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 11: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_12</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 12: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_13</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 13: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_14</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 14: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_15</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 15: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_16</name>
                     <description>In its initial 0 state, this bit allows Read and Write access to the corresponding         Region Register set RR = 16: Start, Limit, Write and Read.          When written to 1, this bit locks those four registers as read-only, and also locks this         bit itself against being cleared.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PRDIRTY</name>
               <description>There is a bit in this register for each of the 12 Flash Regions that can be allocated from     the Region Table in the Intel Descriptor structure. Register sets 12 through 16 do not represent     allocated Flash regions, and so they do not have bits in this register.</description>
               <addressOffset>0x74</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SAF_0</name>
                     <description>Indicates whether contents of Region 0 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_1</name>
                     <description>Indicates whether contents of Region 1 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_2</name>
                     <description>Indicates whether contents of Region 2 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_3</name>
                     <description>Indicates whether contents of Region 3 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_4</name>
                     <description>Indicates whether contents of Region 4 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_5</name>
                     <description>Indicates whether contents of Region 5 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_6</name>
                     <description>Indicates whether contents of Region 6 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_7</name>
                     <description>Indicates whether contents of Region 7 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_8</name>
                     <description>Indicates whether contents of Region 8 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_9</name>
                     <description>Indicates whether contents of Region 9 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_10</name>
                     <description>Indicates whether contents of Region 10 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF_11</name>
                     <description>Indicates whether contents of Region 11 have been changed.         0=There has been no Write or Erase performed in this region since this bit was last cleared.         1=A Write or Erase has been performed in this region since this bit was last cleared.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TAG_MAP0</name>
               <description>The default values in this register match hard-wired assignments made in the Chipset for eSPI     Tag values 0h through 7h. A default value of 7 indicates a non-existent map entry, for a Tag value     which should never happen.</description>
               <addressOffset>0x78</addressOffset>
               <size>32</size>
               <resetValue>0x23221100</resetValue>
               <fields>
                  <field>
                     <name>STM_0</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value 0h to its 3-bit Protection Master         number.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_1</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value 1h to its 3-bit Protection Master         number.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_2</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value 2h to its 3-bit Protection Master         number.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_3</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value 3h to its 3-bit Protection Master         number.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_4</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value 4h to its 3-bit Protection Master         number.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_5</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value 5h to its 3-bit Protection Master         number.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_6</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value 6h to its 3-bit Protection Master         number.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_7</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value 7h to its 3-bit Protection Master         number.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TAG_MAP1</name>
               <description>The default values in this register match hard-wired assignments made in the Chipset for eSPI Tag     values 8h through Fh. A default value of 7 indicates a non-existent map entry, for a Tag value which     should never happen.</description>
               <addressOffset>0x7C</addressOffset>
               <size>32</size>
               <resetValue>0x77677767</resetValue>
               <fields>
                  <field>
                     <name>STM_8</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value 8h to its 3-bit Protection Master         number.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_9</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value 9h to its 3-bit Protection Master         number.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_A</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value Ah to its 3-bit Protection Master         number.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_B</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value Bh to its 3-bit Protection Master         number.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_C</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value Ch to its 3-bit Protection Master         number.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_D</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value Dh to its 3-bit Protection Master         number.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_E</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value Eh to its 3-bit Protection Master         number.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_F</name>
                     <description>This bit contains the mapping of the 4-bit eSPI Tag value Fh to its 3-bit Protection Master         number.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TAG_MAP2</name>
               <description>The default value in bits [2:0] of this register matches the hard-wired assignment made in the     Chipset for accesses made by an EC. After ensuring that all three Tag Map Registers [2:0] contain     valid mappings, the STM_LK bit should be set to '1' to lock them, preventing firmware from     re-assigning them later.</description>
               <addressOffset>0x80</addressOffset>
               <size>32</size>
               <resetValue>0x00000005</resetValue>
               <fields>
                  <field>
                     <name>SM_EC</name>
                     <description>This bit maps the 3-bit Protection Master number assigned to EC Firmware accesses.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>STM_LK</name>
                     <description>1 Locks all bits in the Tag Map Registers, including this bit.              0 (Default) keeps all Tag Map Register fields R/W.</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <cluster>
               <dim>17</dim>
               <dimIncrement>0x10</dimIncrement>
               <name>SAF_PROT[%s]</name>
               <description/>
               <addressOffset>0x84</addressOffset>
               <register>
                  <name>START</name>
                  <description>This is Start00 register. Unless the Start register is less than or equal to the Limit register,     the associated register set [RR] is Disabled, and has no effect on permissions.     The default state of these registers, in all of the register sets, is this Disabled state. While all     register sets remain Disabled, no Protection Master except Master #0 (PCH HW) will be able to perform     any Flash access anywhere through SAFS operations, and this restriction includes the EC firmware (as     Master #5).</description>
                  <addressOffset>0x00</addressOffset>
                  <size>32</size>
                  <resetValue>0x00007FFF</resetValue>
                  <fields>
                     <field>
                        <name>SAF_PROT</name>
                        <description>This field contains the start address of this Region, in units of 4K bytes.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>20</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LIMIT</name>
                  <description>This is Limit00 register. Unless the Start register is less than or equal to the Limit register,     the associated register set [RR] is Disabled, and has no effect on permissions.     The default state of these registers, in all of the register sets, is this Disabled state. While all     register sets remain Disabled, no Protection Master except Master #0 (PCH HW) will be able to perform     any Flash access anywhere through SAFS operations, and this restriction includes the EC firmware (as     Master #5).</description>
                  <addressOffset>0x04</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000000</resetValue>
                  <fields>
                     <field>
                        <name>SAF_PROT</name>
                        <description>This field contains the limit address of this Region, in units of 4K bytes. The entire 4K         block identified is within the Region: that is, the final byte address is determined by appending         FFFh to this field.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>20</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>WRITE</name>
                  <description>This is Write00 register. It applies to the region defined by the associated [RR] Start and     Limit registers. Bits at positions [0]--[7] grant Write/Erase permission to Permission Masters     numbered 0--7 respectively.</description>
                  <addressOffset>0x08</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000001</resetValue>
                  <fields>
                     <field>
                        <name>SAF_PROT_WR0</name>
                        <description>This bit contains the permission for Write or Erase access by Protection Master 0 to this         Region. It is a read-only '1' placeholder because Protection Master 0 has full access to all         Flash locations.          1=Protection Master 0 may always Write and Erase in this region.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_WR1</name>
                        <description>This bit contains the permission for Write or Erase access by Protection Master 1 to this         Region.          0=Protection Master 1 may not Write or Erase in this region.         1=Protection Master 1 may Write and Erase in this region.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_WR2</name>
                        <description>This bit contains the permission for Write or Erase access by Protection Master 2 to this         Region.          0=Protection Master 2 may not Write or Erase in this region.         1=Protection Master 2 may Write and Erase in this region.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_WR3</name>
                        <description>This bit contains the permission for Write or Erase access by Protection Master 3 to this         Region.          0=Protection Master 3 may not Write or Erase in this region.         1=Protection Master 3 may Write and Erase in this region.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_WR4</name>
                        <description>This bit contains the permission for Write or Erase access by Protection Master 4 to this         Region.          0=Protection Master 4 may not Write or Erase in this region.         1=Protection Master 4 may Write and Erase in this region.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_WR5</name>
                        <description>This bit contains the permission for Write or Erase access by Protection Master 5 to this         Region.          0=Protection Master 5 may not Write or Erase in this region.         1=Protection Master 5 may Write and Erase in this region.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_WR6</name>
                        <description>This bit contains the permission for Write or Erase access by Protection Master 6 to this         Region.          0=Protection Master 6 may not Write or Erase in this region.         1=Protection Master 6 may Write and Erase in this region.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_WR7</name>
                        <description>This bit contains the permission for Write or Erase access by Protection Master 7 to this         Region.          0=Protection Master 7 may not Write or Erase in this region.         1=Protection Master 7 may Write and Erase in this region.</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>READ</name>
                  <description>This is Read00 register. Bits at positions [0]--[7] grant Read permission to Permission     Masters numbered 0--7 respectively.</description>
                  <addressOffset>0x0C</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000001</resetValue>
                  <fields>
                     <field>
                        <name>SAF_PROT_RD0</name>
                        <description>This bit contains the permission for Read access by Protection Master 0 to this Region.         It is a read-only placeholder because Protection Master 0 has full access to all Flash locations.         1=Protection Master 0 may always Read in this region.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_RD1</name>
                        <description>This bit contains the permission for Read access by Protection Master 1 to this Region.         0=Protection Master 1 may not Read in this region.         1=Protection Master 1 may Read in this region.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_RD2</name>
                        <description>This bit contains the permission for Read access by Protection Master 2 to this Region.         0=Protection Master 2 may not Read in this region.         1=Protection Master 2 may Read in this region.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_RD3</name>
                        <description>This bit contains the permission for Read access by Protection Master 3 to this Region.         0=Protection Master 3 may not Read in this region.         1=Protection Master 3 may Read in this region.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_RD4</name>
                        <description>This bit contains the permission for Read access by Protection Master 4 to this Region.         0=Protection Master 4 may not Read in this region.         1=Protection Master 4 may Read in this region.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_RD5</name>
                        <description>This bit contains the permission for Read access by Protection Master 5 to this Region.         0=Protection Master 5 may not Read in this region.         1=Protection Master 5 may Read in this region.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_RD6</name>
                        <description>This bit contains the permission for Read access by Protection Master 6 to this Region.         0=Protection Master 6 may not Read in this region.         1=Protection Master 6 may Read in this region.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>SAF_PROT_RD7</name>
                        <description>This bit contains the permission for Read access by Protection Master 7 to this Region.        0=Protection Master 7 may not Read in this region.        1=Protection Master 7 may Read in this region.</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
            </cluster>
            <register>
               <name>POLL_TMOUT</name>
               <description>This is an error timeout value imposed on any consecutive series of Poll-1 commands to a     Flash. The timeout counter starts whenever any new Poll-1 sequence starts, and stops when a     Poll-1 detects Not-BUSY status from the Flash.</description>
               <addressOffset>0x194</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TOUT</name>
                     <description>This field provides a polling timeout value in units of the 32KHz clock. Recommended         value is 5 seconds, expressed as 28000h (163,840 decimal) in this field.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>POLL_INTRVL</name>
               <description>This register should be kept zero except for diagnostic purposes. Where needed, it can be set     to provide spacing between consecutive Poll-1 operations to limit the amount of traffic.</description>
               <addressOffset>0x198</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>INTRVL</name>
                     <description>This field provides an interval in units of the EC internal clock MCLK.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SUSP_RES_INTRVL</name>
               <description>The value placed in this register provides necessary programmable support to a Flash that is     performing an Erase or a Program operation.  When an Erase or Program is started or Resumed, a     Suspend is held off until this time expires.  While an Erase or Program is in process but     Suspended, a Resume is forced when this time expires, even if Read requests are still pending,     causing the Erase or Program operation to continue, and again inhibiting the next Suspend until     it expires again.</description>
               <addressOffset>0x19C</addressOffset>
               <size>32</size>
               <resetValue>0x00000001</resetValue>
               <fields>
                  <field>
                     <name>INTRVL</name>
                     <description>This field provides an interval value in units of the 32KHz RTC clock. Its value should         be taken from the Flash datasheet parameter that specifies minimum time for an Erase or         Program step to make progress.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CONSEC_RD_TMOUT</name>
               <description>This register is used to detect when a series of Read transfers has finished. When this time     expires without any new Read request, any suspended Erase or Program operation is given the     Resume command to continue.</description>
               <addressOffset>0x1A0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RD_TOUT</name>
                     <description>This field provides a timeout value in units of the EC internal clock MCLK. This value is         tunable for system performance, but a value at or below 20us is suggested.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>20</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_POLL2_MASK</name>
               <description>Upon issuing a Suspend command, a Poll-1 operation is repeated until the Flash is no longer     BUSY, then a Poll-2 operation to determine whether the Flash device is in a Suspended state.</description>
               <addressOffset>0x1A4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CS0_POLL2</name>
                     <description>A '1' in this field masks out (ignores) the corresponding bit returned in Poll-2 status         for the CS0 Flash.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
                  <field>
                     <name>CS1_POLL2</name>
                     <description>A '1' in this field masks out (ignores) the corresponding bit returned in Poll-2 status         for the CS1 Flash.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_SPEC_MODE</name>
               <description>This register provides special mode control.</description>
               <addressOffset>0x1A8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DIS_SUSPEND</name>
                     <description>A '1' in this field enters DISABLE_SUSPEND mode, which prevents suspending an Erase or         Write in progress. In this mode, Read operations will be held waiting until the Erase or         Write finishes.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SUSP_CHECK_DLY</name>
               <description>This register provides a time delay for support of some Flash devices. It holds off the     first Poll-1 check after a Suspend command has been given to the Flash.</description>
               <addressOffset>0x1AC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DLY</name>
                     <description>This field provides a delay value in units of the EC internal clock MCLK. This value         should be set to 20us.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>20</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FC_SPEC_MODE2</name>
               <description>Micron requires a prefix consisting of two command frames (in separate CS# assertions) to     be sent before Mode information will be recognized to enter Continuous Read mode. This     technique is called (Micron XIP) in their datasheets.  The support for these chips requires     setting up this register and setting the corresponding Prefix Enable bit(s) to enable this     handling.  The first command frame of the Prefix sequence will be a single byte consisting of     the Write Enable opcode, taken from the OP_WE opcode field of the appropriate Opcode A register     (Section 7.3.5, on page 113).  The second command frame of the Prefix sequence comes from this     register, consisting of first the PREFIX_OP byte for the corresponding Flash device (CS0/CS1),     and then its PREFIX_DAT byte.  The PREFIX_OP byte will be 81h always, which is documented as     the Micron opcode (WRITE VOLATILE CONFIGURATION REGISTER) The PREFIX_DAT byte contains the data     written to the Micron Flash device's Volatile Configuration Register. It has potential     side-effects beyond just enabling Micron XIP Mode, so it must be constructed very carefully.</description>
               <addressOffset>0x1B0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CS0_PRE_OP</name>
                     <description>This field is the Prefix Opcode for Micron XIP mode on CS0. It should be set to 81h,         for Micron parts.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CS0_PRE_DAT</name>
                     <description>This field is the data sent with the CS0_PREFIX_OP command.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CS1_PRE_OP</name>
                     <description>This field is the Prefix Opcode for Micron XIP mode on CS1. It should be set to 81h,         for Micron parts.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CS1_PRE_DAT</name>
                     <description>This field is the data sent with the CS1_PREFIX_OP command.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DNX_PRO_BYPAS</name>
               <description>DnX DnX Protection Bypass Register.</description>
               <addressOffset>0x1B4</addressOffset>
               <size>32</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>DNX_LK</name>
                     <description>Lock bit for this register:     0= All Read/Write bits in this register are unlocked and writable.    1= All Read/Write bits in this register are locked to Read-Only (including this bit).</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACTV_CNT</name>
               <description>Timeout Activity Counter.</description>
               <addressOffset>0x1B8</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>FT_ACTV_CNT</name>
                     <description>This is the Flash Avtivity Timeout Counter.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FLP_CTRL</name>
               <description>SAF Low Power Control Register.</description>
               <addressOffset>0x1BC</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CS0LP_EN</name>
                     <description>CS0 Low Power Enable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS1LP_EN</name>
                     <description>CS1 Low Power Enable.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS0WAKON_PROCESSOR_ACTI_EN</name>
                     <description>Enable wake SPI Flash CS0 when processor wakes.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS1WAKON_PROCESSOR_ACTI_EN</name>
                     <description>Enable wake SPI Flash CS1 when processor wakes.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FLP_STAT</name>
               <description>SAF Low Power Status Register.</description>
               <addressOffset>0x1C0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CS0LP_STAT</name>
                     <description>CS0 Low Power Status.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CS1LP_STAT</name>
                     <description>CS1 Low Power Enable.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FLP_CS0_OPCD</name>
               <description>SAF Low Power CS0 OPCODE Register.</description>
               <addressOffset>0x1C4</addressOffset>
               <size>32</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>CS0OPCD_NTRY</name>
                     <description>CS0 Low Power Opcode for low power entry.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CS0OPCD_XIT</name>
                     <description>CS0 Low Power Opcode for low power exit.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CS0_RPMC_OP2</name>
                     <description>CS0 Opcode for rpmc op2.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FLP_CS1_OPCD</name>
               <description>SAF Low Power CS0 OPCODE Register.</description>
               <addressOffset>0x1C8</addressOffset>
               <size>32</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>CS1OPCD_NTRY</name>
                     <description>CS1 Low Power Opcode for low power entry.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CS1OPCD_XIT</name>
                     <description>CS1 Low Power Opcode for low power exit.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>CS1_RPMC_OP2</name>
                     <description>CS1 Opcode for rpmc op2.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FPD_TOUT_PDUP</name>
               <description>Flash Timeout Power Down Up.</description>
               <addressOffset>0x1CC</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>FPD_TOUT_CNT</name>
                     <description>This is the Flash Timeout Power Down Up.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CS0CLKDIV</name>
               <description>Clock Divider for CS0.</description>
               <addressOffset>0x200</addressOffset>
               <size>32</size>
               <resetValue>0x00020001</resetValue>
               <fields>
                  <field>
                     <name>CS0RDCLKDIV</name>
                     <description>Read clock divider for CS0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
                  <field>
                     <name>CS0RESTCLKDIV</name>
                     <description>Read clock divider for CS0.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CS1CLKDIV</name>
               <description>Clock Divider for CS1.</description>
               <addressOffset>0x204</addressOffset>
               <size>32</size>
               <resetValue>0x00020001</resetValue>
               <fields>
                  <field>
                     <name>CS1RDCLKDIV</name>
                     <description>Read clock divider for CS1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
                  <field>
                     <name>CS1RESTCLKDIV</name>
                     <description>Read clock divider for CS1.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ESPIRPMCOP2_RESADD</name>
               <description>eSPI RPMC OP2 Result Address.</description>
               <addressOffset>0x208</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EC0RPMCOP2_RESADD</name>
                     <description>eSPI RPMC OP2 Result Address for EC0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC0RPMCOP2_RESADD</name>
               <description>EC0 RPMC OP2 Result Address.</description>
               <addressOffset>0x20C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EC0RPMCOP2_RESADD</name>
                     <description>eSPI RPMC OP2 Result Address for EC0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC1RPMCOP2_RESADD</name>
               <description>EC1 RPMC OP2 Result Address.</description>
               <addressOffset>0x210</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EC1RPMCOP2_RESADD</name>
                     <description>eSPI RPMC OP2 Result Address for EC1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>SAFBC_CACHE</name>
         <version>143b1.0</version>
         <description>SAF BRIDGE CACHE INTERFACE</description>
         <baseAddress>0x4000F000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x30</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>EC_LEN_TAG_CMD</name>
               <description>This register defines the command type and length of transfers requested by EC firmware</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EC_PUT_CMD</name>
                     <description>This field must contain the value 0Ah; that is, the eSPI command                       PUT_FLASH_NP.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>EC_CTYPE_CMD</name>
                     <description>This field encodes the operation requested:                       00h = Read                       01h = Write (Page Program)                       02h = Erase                       Other encodings are undefined</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>EC_LENGTH</name>
                     <description>This field contains the Length field for all requests.                       Read or Write: The length in bytes of the data transfer, to or from                       the SRAM buffer. Must be in the range 1 -- 64 (01h -- 40h).                       Erase: Must encode an eSPI-defined Erase Block Size:                       00h = 4K                       01h = 32K                       02h = 64K                       Other encodings are undefined.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_FLASH_ADD</name>
               <description>This register hold the Flash Space address to be accessed by the current command from EC firmware.</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>FLASH_ADDR</name>
                     <description>FLASH_ADDR: This field holds the Flash address to be accessed.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_START</name>
               <description>This register contains the Start control for a Flash access requested in the rest of the EC    Portal registers. It triggers the requested transfer.</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>START</name>
                     <description>This bit is written with '1' to start a new request, but always appears 0 when being read.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_AHB_ADD</name>
               <description>This register holds a location in the EC's own address space that is to be used as     the SRAM buffer for an EC Flash access.</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADDR_INC</name>
                     <description>This bit controls whether the saf bridge increases the address in saf2_ahb_address.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BUF_ADDR</name>
                     <description>This field holds bits [31:2] of the SRAM buffer address. Bits[1:0] of the address are fixed at 00.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>30</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_DONE_STATUS</name>
               <description>This register holds the DONE status bit.</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SAF2_RDY_NXT</name>
                     <description>When this bit is set the f/w initiated transaction is complete. This field is auto cleared by hardware. This is R/WC.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAF2_AK_NKN</name>
                     <description>This bit will always return 1 for f/w. This field is auto cleared by hardware. This is R/WC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TIMEOUT</name>
                     <description>This bit indicates that an Erase or Write request from the EC has failed because the Flash has timed out. This is R/WC.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUTOFRNG</name>
                     <description>This bit indicates that a request has been rejected because it is beyond the physical limits of the attached Flash devices.      This bit is cleared by writing '1' to its position. This is R/WC.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACCESS_VIOLATION</name>
                     <description>This bit indicates that a request from the EC has been rejected because it violates the        Protection Register settings. This bit is cleared by writing '1' to its position. This is R/WC.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BOUNDARY_4K</name>
                     <description>This bit indicates that a Read request from the EC has been rejected because it has attempted to cross a 4K Flash address boundary.        This bit is cleared by writing '1' to its position. This is R/WC.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERASE_SIZ_ERR</name>
                     <description>This bit indicates that an invalid Erase Block Size has been specified in an Erase request. This is R/WC.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>START_OVERFLOW</name>
                     <description>This bit indicates that an access was already in progress when a new access was requested by writing '1' to the START bit. This is R/WC.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BAD_REQUEST</name>
                     <description>This bit indicates that an invalid Request code has been specified in the Portal Command Register at the time the START bit was set to trigger it.        This is R/WC.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPMC_OP2LEN</name>
                     <description>This bit indicates that a lenght greater that 49 is set for RPMC OP2 command. This is R/WC.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_EN</name>
               <description>This register contains the one bit DONE_EN in bit position[0]. This bit enables the DONE bit in     the status register to trigger an interrupt.</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RDY_NXT_EN</name>
                     <description>This bit controls whether an interrupt is fired when Ready_Next is asserted.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TIMEOUT_EN</name>
                     <description>This controls whether an interrupt is fired when Timeout is asserted.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUTOFRNG_EN</name>
                     <description>This controls whether an interrupt is fired when Out Of Range is asserted.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACCESS_VIOLATION_EN</name>
                     <description>This controls whether an interrupt is fired when Access Violation is asserted.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BOUNDARY_4K_EN</name>
                     <description>This controls whether an interrupt is fired when 4K Boundary is asserted.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERASE_SIZ_ERR_EN</name>
                     <description>This controls whether an interrupt is fired when Erase Size Error is asserted.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>START_OVERFLOW_EN</name>
                     <description>This controls whether an interrupt is fired when Start Overflow is asserted.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BAD_REQUEST_EN</name>
                     <description>This controls whether an interrupt is fired when Bad Request is asserted.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPMC_OP2LEN_EN</name>
                     <description>This controls whether an interrupt is fired when RPMC OP2 Lenght is asserted.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>SAFCOMM</name>
         <version>1431.0</version>
         <description>This register contains one bit PREFETCH_EN that should be set to '1' during initialization, to        enable Prefetch Mode operation in SAFS Mode. Prefetch Mode allows overlapped anticipatory reading of        information from Flash during the eSPI delivery of previously-read data to the Host Chipset. If        enabled, Prefetching is invoked during consecutive Reads that are 64 bytes in length and from        consecutive 64-byte aligned Flash addresses. With roughly equal clock rates on eSPI and SPI, these        features together can approximately double the effective bandwidth of consecutive Flash reads        performed over eSPI.  In SAFS operation (SAF_MODE_ENABLE bit = 1) attempted accesses by EC firmware        to this register are blocked.</description>
         <baseAddress>0x40071000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x2BC</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>SAF_MODE</name>
               <description>This register contains one bit PREFETCH_EN that should be set to '1' during initialization, to enable Prefetch Mode operation in SAFS Mode.</description>
               <addressOffset>0x2B8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PREFETCH_EN</name>
                     <description>1= Allow Prefetching from Flash devices, and use the bits CS0_PREFETCH_OPT_EN and         CS1_PREFETCH_OPT_EN to select any additional optimization.         0= Do not perform Prefetches from Flash devices</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>OTP</name>
         <version>961.0</version>
         <description>OTP Programming registers.</description>
         <baseAddress>0x40082000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x54</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ20</name>
            <value>12</value>
         </interrupt>
         <registers>
            <register>
               <name>WR_LOCK0</name>
               <description>This is the Write Lock Register.</description>
               <addressOffset>0x44</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>WL0</name>
                     <description>When any of the bits are set, the corresponding 32byte range in the OTP is not writable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WR_LOCK1</name>
               <description>This is the Write Lock Register.</description>
               <addressOffset>0x45</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>WL1</name>
                     <description>When any of the bits are set, the corresponding 32byte range in the OTP is not writable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WR_LOCK2</name>
               <description>This is the Write Lock Register.</description>
               <addressOffset>0x46</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>WL2</name>
                     <description>When any of the bits are set, the corresponding 32byte range in the OTP is not writable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WR_LOCK3</name>
               <description>This is the Write Lock Register.</description>
               <addressOffset>0x47</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>WL3</name>
                     <description>When any of the bits are set, the corresponding 32byte range in the OTP is not writable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RD_LOCK0</name>
               <description>This is the Read Lock Register.</description>
               <addressOffset>0x48</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>RL0</name>
                     <description>When any of the bits are set, the corresponding 32byte range in the OTP is not readable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RD_LOCK1</name>
               <description>This is the Read Lock Register.</description>
               <addressOffset>0x49</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>RL1</name>
                     <description>When any of the bits are set, the corresponding 32byte range in the OTP is not readable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RD_LOCK2</name>
               <description>This is the Read Lock Register.</description>
               <addressOffset>0x4A</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>RL2</name>
                     <description>When any of the bits are set, the corresponding 32byte range in the OTP is not readable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RD_LOCK3</name>
               <description>This is the Read Lock Register.</description>
               <addressOffset>0x4B</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>RL3</name>
                     <description>When any of the bits are set, the corresponding 32byte range in the OTP is not readable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WR_FINE_LCK</name>
               <description>This is the Write Fine Lock Register.</description>
               <addressOffset>0x4C</addressOffset>
               <size>32</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>WR_FINE_LCK</name>
                     <description>Each bit locks write to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RD_FINE_LCK</name>
               <description>This is the Read Fine Lock Register.</description>
               <addressOffset>0x50</addressOffset>
               <size>32</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>RD_FINE_LCK</name>
                     <description>Each bit locks read to a byte in the OTP range starting byte 320 to 351 0=Not Locked 1=Locked.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>SPI_SLAVE</name>
         <version>1701.0</version>
         <description>SPI Slave Register.</description>
         <baseAddress>0x40007000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x4C</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>SPISLV</name>
            <value>90</value>
         </interrupt>
         <registers>
            <register>
               <name>SPI_CFG</name>
               <description>SPI Slave Communication Configuration Register.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00040000</resetValue>
               <fields>
                  <field>
                     <name>SNG_QUD_SEL</name>
                     <description>This field defines the Single / Quad Wire mode of operation for SPI Slave block.         0 = Single Wire Slave SPI block operation.         1 = Quad Wire Slave SPI block operation.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TAR_TIM_SEL</name>
                     <description>Turn Around Time select for Quad wire mode.         0h = 1 cycle.         1h = 2 cycles.         2h = 4 cycles.         3h = 8 cycles.         Other values are reserved.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>WAIT_TIME</name>
                     <description>These bits set the amount of wait time in cycles before transmitting data back to master.         During this wait time status bits will be transmitted</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SPI_STS</name>
               <description>SPI Slave Status Register.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000500</resetValue>
               <fields>
                  <field>
                     <name>MEM_WR_DONE</name>
                     <description>When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to         Memory for Posted Writes . Clear with new Write request.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_RD_DONE</name>
                     <description>When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data         read from Memory for Posted Reads. - cleared with new Read request.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_WR_BUSY</name>
                     <description>When an Memory Write transaction is currently being processed.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_RD_BUSY</name>
                     <description>When an Memory Read transaction is currently being processed.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SREG_TRANS</name>
                     <description>When an SREG transaction is currently being processed.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POLL_HIGH</name>
                     <description>If this bit is set, then something in the high 16-bit of status register is set and needs to be checked.         SPI Master should take action to clear this.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_EMP</name>
                     <description>Signifies all Memory write transactions for the SPI Masters requested size have been performed.         New transactions are allowed.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_FUL</name>
                     <description>The RX FIFO is full of data to be written to Memory.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_EMP</name>
                     <description>Signifies SPI Master has read the data requested from Memory. Can be used to show there is data         the SPI Master has requested and not been read yet. New read transactions will be aligned.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_FUL</name>
                     <description>The TX FIFO is full of data that was read from Memory.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMCLK_CNT_ERR</name>
                     <description>This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF_FLG</name>
                     <description>Set when the Host writes to the Input Buffer signaling there is data for the EC to read.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OBF_FLG</name>
                     <description>Set when the EC writes to the Output Buffer signaling there is data for the Host to read.</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPIM_RST_REQ</name>
                     <description>Set when the SPI Master Requested a Configuration Reset.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_RST_DN</name>
                     <description>Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_RST_DN</name>
                     <description>Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OOL0_ERR</name>
                     <description>This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OOL1_ERR</name>
                     <description>This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ARMBUS_ERR</name>
                     <description>ARM Bus Error returned for the curren data transfer.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNDEF_CMD_ERR</name>
                     <description>Undefined Command Error: The command received from the master isn't defined.</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DV_BUSY</name>
                     <description>If the Master requested a transaction whose destination is busy the request is ignored.         Should use the poll or wait for interrupts.</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_SIZE_ERR</name>
                     <description>If size requested is more than what Master provided and the Master terminates early error flag         shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and         continue transaction, may be taking in garbage.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_UNFLW</name>
                     <description>If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned         will just be the last valid pointer value.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_OVRFLW</name>
                     <description>If Master doesn't read all of the data it requested from the posted read block cycle, than data         will still be left in the FIFO. This will cause misalignment with the following transactions and a new         read cycle can cause overflow.</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_UNFLW</name>
                     <description>If the SPI Slave reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition         will never happen under normal situation.</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_OVRFLW</name>
                     <description>If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data         will not be stored.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SPI_EC_STS</name>
               <description>SPI Slave EC Status Register.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000500</resetValue>
               <fields>
                  <field>
                     <name>MEM_WR_DONE</name>
                     <description>When the ARM BUS side has fully finished the last transaction from the FIFO to write the data to         Memory for Posted Writes .- clear with new Write request.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_RD_DONE</name>
                     <description>When the ARM BUS side has fully finished writing the last written DWord to the FIFO for a set of data         read from Memory for Posted Reads. - cleared with new Read request.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_WR_BUSY</name>
                     <description>When an Memory Write transaction is currently being processed.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_RD_BUSY</name>
                     <description>When an Memory Read transaction is currently being processed.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SREG_TRANS</name>
                     <description>When an SREG transaction is currently being processed.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POLL_HI</name>
                     <description>If this bit is set, then something in the high 16-bit of status register is set and needs to be checked.         SPI Master should take action to clear this.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_EMP</name>
                     <description>Signifies all Memory write transactions for the SPI Masters requested size have been performed.         New transactions are allowed.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_FUL</name>
                     <description>The RX FIFO is full of data to be written to Memory.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_EMP</name>
                     <description>Signifies SPI Master has read the data requested from Memory. Can be used to show there is data         the SPI Master has requested and not been read yet. New read transactions will be aligned.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_FUL</name>
                     <description>The TX FIFO is full of data that was read from Memory.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMCLK_CNT_ERR</name>
                     <description>This bit is set when the SPI Clock Count Test Mode is set and there is an uneven amount of clocks.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF_FLG</name>
                     <description>Set when the Host writes to the Input Buffer signaling there is data for the EC to read.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OBF_FLG</name>
                     <description>Set when the EC writes to the Output Buffer signaling there is data for the Host to read.</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPIM_RST_REQ</name>
                     <description>Set when the SPI Master Requested a Configuration Reset.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_RST_DN</name>
                     <description>Set after the SPI Master initiates a RX FIFO reset and the reset has been processed. FIFO is cleared.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_RST_DN</name>
                     <description>Set after the SPI Master initiates a TX FIFO reset and the reset has been processed. FIFO is cleared.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OOL0_ERR</name>
                     <description>This flag is set with the transfer address requested by the master is out of Limit 0 range or when the BAR is disabled.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OOL1_ERR</name>
                     <description>This flag is set with the transfer address requested by the master is out of Limit 1 range or when the BAR is disabled.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ARMBUS_ERR</name>
                     <description>ARM Bus Error returned for the curren data transfer.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNDEF_CMD_ERR</name>
                     <description>Undefined Command Error: The command received from the master isn't defined.</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DV_BUSY</name>
                     <description>If the Master requested a transaction whose destination is busy the request is ignored.         Should use the poll or wait for interrupts.</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_SIZE_ERR</name>
                     <description>If size requested is more than what Master provided and the Master terminates early error flag         shut down request signal to ARM Bus. Size requested is less than what Master provided -- ignored and         continue transaction, may be taking in garbage.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_UNFLW</name>
                     <description>If Master reads more than what is in FIFO, FIFO will flag an underflow error and the data returned         will just be the last valid pointer value.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_OVRFLW</name>
                     <description>If Master doesn't read all of the data it requested from the posted read block cycle, than data         will still be left in the FIFO. This will cause misalignment with the following transactions and a new         read cycle can cause overflow.</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_UNFLW</name>
                     <description>If the SPI Slave reads RX FIFO when it is empty, RX FIFO Underflow flag will be set. This condition         will never happen under normal situation.</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_OVRFLW</name>
                     <description>If SPI Master writes more than the space in the FIFO, the FIFO will flag an overflow error and data         will not be stored.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SPI_IEN</name>
               <description>SPI Slave Interrupt Enable Register.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MEM_WR_DONE</name>
                     <description>Enable Memory Write Done Interrupt to SPI Master.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_RD_DONE</name>
                     <description>Enable Memory Read Done Interrupt to SPI Master.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_WR_BUSY</name>
                     <description>Enable Memory Write Busy Interrupt to SPI Master.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_RD_BUSY</name>
                     <description>Enable Memory Read Busy Interrupt to SPI Master.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SREG_TRANS</name>
                     <description>Enable SREG Trans Busy Interrupt to SPI Master.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POLL_HI</name>
                     <description>Enable Poll High Request Interrupt to SPI Master.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_EMP</name>
                     <description>Enable SREG RX FIFO Empty Interrupt to SPI Master.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_FUL</name>
                     <description>Enable RX FIFO Full Interrupt to SPI Master.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_EMP</name>
                     <description>Enable TX FIFO Empty Interrupt to SPI Master.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_FUL</name>
                     <description>Enable TX FIFI FULL Interrupt to SPI Master.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMCLK_CNT_ERR</name>
                     <description>Enable Test Mode SPI Clock Count Error Interrupt to SPI Master.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF_FLG</name>
                     <description>Enable Input Buffer Signaling Interrupt to SPI Master.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OBF_FLG</name>
                     <description>Enable Output Buffer signaling Interrupt to SPI Master.</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPIM_RST_REQ</name>
                     <description>Enable SPI Master Request Reset Interrupt to SPI Master.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_RST_DN</name>
                     <description>Enable RX FIFO Reset Done Interrupt to SPI Master.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_RST_DN</name>
                     <description>Enable TX FIFO Reset Done Interrupt to SPI Master.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OOL0_ERR</name>
                     <description>Enable Out Of Limit 0 Error Interrupt to SPI Master.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OOL1_ERR</name>
                     <description>Enable Out Of Limit 1 Error Interrupt to SPI Master.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ARMBUS_ERR</name>
                     <description>Enable AHB BUS Error Interrupt to SPI Master.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNDEF_CMD_ERR</name>
                     <description>Enable Undefined Command Error Interrupt to SPI Master.</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DV_BUSY</name>
                     <description>Enable Device Busy Interrupt to SPI Master.</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_SIZE_ERR</name>
                     <description>Enable RX FIFO SIZE Error Interrupt to SPI Master.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_UNFLW</name>
                     <description>Enable TX FIFO Underflow Interrupt to SPI Master.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_OVRFLOW</name>
                     <description>Enable TX FIFO Overflow Interrupt to SPI Master.</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_UNFLW</name>
                     <description>Enable RX FIFO Underflow Interrupt to SPI Master.</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_OVRFLW</name>
                     <description>Enable RX FIFO Overflow Interrupt to SPI Master.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_IEN</name>
               <description>SPI Slave EC Interrupt Enable Register.</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MEM_WR_DONE</name>
                     <description>Enable Memory Write Done Interrupt to EC.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_RD_DONE</name>
                     <description>Enable Memory Read Done Interrupt to EC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_WR_BUSY</name>
                     <description>Enable Memory Write Busy Interrupt to EC.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEM_RD_BUSY</name>
                     <description>Enable Memory Read Busy Interrupt to EC.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SREG_TRANS</name>
                     <description>Enable SREG Trans Busy Interrupt to EC.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POLL_HI</name>
                     <description>Enable Poll High Request Interrupt to EC.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_EMP</name>
                     <description>Enable SREG RX FIFO Empty Interrupt to EC.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_FUL</name>
                     <description>Enable RX FIFO Full Interrupt to EC.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_EMP</name>
                     <description>Enable TX FIFO Empty Interrupt to EC.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_FUL</name>
                     <description>Enable TX FIFI FULL Interrupt to EC.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMCLK_CNT_ERR</name>
                     <description>Enable Test Mode SPI Clock Count Error Interrupt to EC.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF_FLG</name>
                     <description>Enable Input Buffer Signaling Interrupt to EC.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OBF_FLG</name>
                     <description>Enable Output Buffer signaling Interrupt to EC.</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPIM_RST_REQ</name>
                     <description>Enable SPI Master Request Reset Interrupt to EC.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_RST_DN</name>
                     <description>Enable RX FIFO Reset Done Interrupt to EC.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_RST_DN</name>
                     <description>Enable TX FIFO Reset Done Interrupt to EC.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OOL0_ERR</name>
                     <description>Enable Out Of Limit 0 Error Interrupt to EC.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OOL1_ERR</name>
                     <description>Enable Out Of Limit 1 Error Interrupt to EC.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ARMBUS_ERR</name>
                     <description>Enable AHB BUS Error Interrupt to EC.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNDEF_CMD_ERR</name>
                     <description>Enable Undefined Command Error Interrupt to EC.</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DV_BUSY</name>
                     <description>Enable Device Busy Interrupt to EC.</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_SIZE_ERR</name>
                     <description>Enable RX FIFO SIZE Error Interrupt to EC.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_UNFLW</name>
                     <description>Enable TX FIFO Underflow Interrupt to EC.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXF_OVRFLW</name>
                     <description>Enable TX FIFO Overflow Interrupt to EC.</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_UNFLW</name>
                     <description>Enable RX FIFO Underflow Interrupt to EC.</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXF_OVRFLW</name>
                     <description>Enable RX FIFO Overflow Interrupt to EC.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MEM_CFG</name>
               <description>SPI Slave Memory Configuration Register.</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BAR_EN0_SEL</name>
                     <description>Enables Region 0 operation.         0 = Disable Region 0.         1 = Enable Region 0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BAR_EN1_SEL</name>
                     <description>Enables Region 1 operation.         0 = Disable Region 1.         1 = Enable Region 1.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MEM_BAR0</name>
               <description>SPI Slave Memory Base Address0 Register.</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BAS_ADD0</name>
                     <description>Base Address for Region 0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MEM_WR_LIM0</name>
               <description>SPI Slave Memory Write LIMIT 0 Register.</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LMT0</name>
                     <description>Write Limit for Region 0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>15</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MEM_RD_LIM0</name>
               <description>SPI Slave Memory Read LIMIT 0 Register.</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LMT0</name>
                     <description>Read Limit for Region 0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>15</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MEM_BAR1</name>
               <description>SPI Slave Memory Base Address1 Register.</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADD1</name>
                     <description>Base Address for Region 1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MEM_WR_LIM1</name>
               <description>SPI Slave Memory Write LIMIT 1 Register.</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LMT1</name>
                     <description>Write Limit for Region 1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>15</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MEM_RD_LIM1</name>
               <description>SPI Slave Memory Read LIMIT 1 Register.</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LMT1</name>
                     <description>Read Limit for Region 1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>15</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RXF_HOST_BAR</name>
               <description>SPI Slave RX FIFO Host Bar Register.</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BAR</name>
                     <description>RX FIFO Host Bar Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RXF_BYTE_CNT</name>
               <description>SPI Slave RX FIFO Byte Counter Register.</description>
               <addressOffset>0x34</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BCNT</name>
                     <description>RX FIFO Byte Count Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>15</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TXF_HOST_BAR</name>
               <description>SPI Slave TX FIFO Host Bar Register.</description>
               <addressOffset>0x38</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BAR</name>
                     <description>TX FIFO Host Bar Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TXF_BYTE_CNT</name>
               <description>SPI Slave TX FIFO Byte Counter Register.</description>
               <addressOffset>0x3C</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BCNT</name>
                     <description>TX FIFO Byte Count Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>15</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SYS_CFG</name>
               <description>SPI Slave System Configuration Register.</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x000004C0</resetValue>
               <fields>
                  <field>
                     <name>SOFT_RST</name>
                     <description>Soft reset for entire SPI Slave Block. This bit is self clearing.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK_QUAD_SNGL_WRMOD</name>
                     <description>Lock Quad / Single Write Mode bit, write access from SPI Master.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK_TAR_TIME</name>
                     <description>Lock Tar Time bit, write access from SPI Master.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK_WAIT_CYCL</name>
                     <description>Lock Wait Cycle bits, write access from SPI Master.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK_MEM_CFG</name>
                     <description>Lock Memory Configuration register, write access from SPI Master.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK_SPIINT_EN</name>
                     <description>Lock SPI Interrupt Enable register, write access from SPI Master.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK_MEM_BAR0</name>
                     <description>Lock Memory Bar 0 register, write access from SPI Master.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK_MEM_BAR1</name>
                     <description>Lock Memory Bar 1 register, write access from SPI Master.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK_TEST_MODE</name>
                     <description>Lock TEST Mode register, write access from SPI Master.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPI_SLV_EN</name>
                     <description>Enable / Disable SPI Slave Block.         0 = Disable SPI Slave module.         1 = Enable SPI Slave module.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MAS_ECREG</name>
                     <description>Mask EC register 'fld_mask_ec_register' from SPI Master. All the register are         neither readable now writable from SPI Master.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SIM_EN</name>
                     <description>Enable SPI Slave Simple Mode operation.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ECDATL</name>
                     <description>Notification to TX FIFO Engine that data is available for AHB Transfer. This register         but is cleared by Hardware at the end of the transaction, with SPI_CS_N de-assertion.         (R/WC).</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SPIM2EC_MBX</name>
               <description>SPI Slave Master to EC Mailbox Register.</description>
               <addressOffset>0x44</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>M2EC</name>
                     <description>Write only register for the Host. When data is written to this register the IBF Flag         is set. EC can read the data and writes of 0xFFFF will clear this register. Any form of         read will clear the flag for this register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC2SPIM_MBX</name>
               <description>SPI Slave Master to EC Mailbox Register.</description>
               <addressOffset>0x48</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EC2M</name>
                     <description>Read only register for the Host. When data is written to this register the OBF Flag         is set. Host can read the data and writes of 0xFFFF_FFFF will clear this register, also         clearing the flag. Any form of read will clear the flag for this register</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>FPU</name>
         <description>Floating Point Unit</description>
         <baseAddress>0xE000EF30</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x18</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>FPCCR</name>
               <description>Floating-Point Context Control Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0xC0000000</resetValue>
               <fields>
                  <field>
                     <name>LSPACT</name>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>USER</name>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>THREAD</name>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HFRDY</name>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MMRDY</name>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BFRDY</name>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MONRDY</name>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LSPEN</name>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ASPEN</name>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FPCAR</name>
               <description>Floating-Point Context Address Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>ADDRESS</name>
                     <description>Address for FP registers in exception stack frame</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>29</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FPDSCR</name>
               <description>Floating-Point Default Status Control Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RMODE</name>
                     <description>Default value for FPSCR.RMODE</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>RMODESelect</name>
                        <enumeratedValue>
                           <name>RN</name>
                           <description>Round to Nearest</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RP</name>
                           <description>Round towards Positive Infinity</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RM</name>
                           <description>Round towards Negative Infinity</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RZ</name>
                           <description>Round towards Zero</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>FZ</name>
                     <description>Default value for FPSCR.FZ</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DN</name>
                     <description>Default value for FPSCR.DN</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AHP</name>
                     <description>Default value for FPSCR.AHP</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MVFR0</name>
               <description>Media and FP Feature Register 0</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <fields>
                  <field>
                     <name>A_SIMD_registers</name>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>Single_precision</name>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>Double_precision</name>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>FP_excep_trapping</name>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>Divide</name>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>Square_root</name>
                     <bitOffset>20</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>Short_vectors</name>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>FP_rounding_modes</name>
                     <bitOffset>28</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MVFR1</name>
               <description>Media and FP Feature Register 1</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <fields>
                  <field>
                     <name>FtZ_mode</name>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>D_NaN_mode</name>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>FP_HPFP</name>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>FP_fused_MAC</name>
                     <bitOffset>28</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>POWERGUARD_0</name>
         <version>1711.0</version>
         <description>This block monitors PowerGuard output signals (or locked rotor signals) from        various types of fans, and determines their speed.</description>
         <groupName>POWERGUARD</groupName>
         <prependToName>POWERGUARD_</prependToName>
         <baseAddress>0x40003000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x24</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>POWERGUARD_0</name>
            <value>88</value>
         </interrupt>
         <registers>
            <register>
               <name>LPF1_FREQ_CUTOFF_RATE</name>
               <description>LPF1 Frequency Cut-off Rate Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LPF1_CUTOFF_FREQ</name>
                     <description>The cutoff frequency for the Linear Predictive Filter 1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>20</bitWidth>
                  </field>
                  <field>
                     <name>WEIGHT</name>
                     <description>This bit controls the weight parameter W in the First Order Average Equation and the weight parameter W2 in the Second Order Average Equation for Linear Predictive Filter 1.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LPF1_SAMPLE_EQ_ADC</name>
                     <description>FILTER_ENABLE  This bit controls the LPF1 sampling rate.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LPF2_FREQ_CUTOFF_RATE</name>
               <description>LPF2 Frequency Cut-off Rate Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LPF2_CUTOFF_FREQ</name>
                     <description>The cutoff frequency for the Linear Predictive Filter 2.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>20</bitWidth>
                  </field>
                  <field>
                     <name>WEIGHT</name>
                     <description>This bit controls the weight parameter W in the First Order Average Equation and the weight parameter W2 in the Second Order Average Equation for Linear Predictive Filter 1.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LPF1_SAMPLE_EQ_ADC</name>
                     <description>FILTER_ENABLE  This bit controls the LPF1 sampling rate.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DATA_REG</name>
               <description>Data Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SELECTED_BYTE0</name>
                     <description>The contents of this read-only field is controlled by the value written into the DATA_MUX_SELECT field in the Control And Status Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LPF1_OUTPUT_DAT</name>
                     <description>Data output of 1st Order LPF.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>LPF2_OUTPUT_DATA</name>
                     <description>Data output of 2nd Order LPF.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>TEST_WRITE_DATA</name>
                     <description>When the TEST_DATA_MUX_SELECT bit in the Control And Status Register is a 1, writes to this register are used as the ADC sample data.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>THRESHOLD_LIMIT</name>
               <description>Threshold Limit Register.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BIAS</name>
                     <description>The contents of this field are added to both THRESHOLD_HIGH and THRESHOLD_LOW when generating the comparison thresholds for the high-side and low-side comparators, respectively.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>HYSTERESIS</name>
                     <description>The contents of this field is added or subtracted both comparator thresholds, based on the hysteresis settings for the comparators.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
                  <field>
                     <name>THRESHOLD_LOW</name>
                     <description>This field contains the base value for setting the comparison threshold for the low-side comparator.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>THRESHOLD_HIGH</name>
                     <description>This field contains the base value for setting the comparison threshold for the high-side comparator.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LOW_TIMER</name>
               <description>Low Timer Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LOW_TIMER_COUNTER</name>
                     <description>Reads of this field provides the current count of the low-side timer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>LOW_TIMER_LOAD</name>
                     <description>The value written into this field is the Load Count value for the LOW_TIMER_COUNTER.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>TEST_BIT</name>
                     <description>All writes to this register should clear this test bit to 0.</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOW_TIMER_RECOVERY_OPTIONS</name>
                     <description>Recovery mode for the low-side timer.</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HIGH_TIMER</name>
               <description>High Timer Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>HIGH_TIMER_COUNTER</name>
                     <description>Reads of this field provides the current count of the high-side timer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>HIGH_TIMER_LOAD</name>
                     <description>The value written into this field is the Load Count value for the HIGH_TIMER_COUNTER.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>TEST_BIT</name>
                     <description>All writes to this register should clear this test bit to 0.</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HIGH_TIMER_RECOVERY_OPTIONS</name>
                     <description>Recovery mode for the high-side timer.</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL_STS</name>
               <description>Control and Status Register.</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CTMER_OUT_HI_ENABLE</name>
                     <description>The high-side timer output enable bit.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CTMER_OUT_LO_ENABLE</name>
                     <description>The low-side timer output enable bit.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FORCE_PROCHOT_ENABLE</name>
                     <description>FORCE_PROCHOT Enable bit</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MANUAL_RECOVERY</name>
                     <description>This bit is set to '1b' if either high-side timer or the low-side timer is configured for Manual Recovery Mode and the timer times out and asserts.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DATA_MUX_SELECT</name>
                     <description>The field controls the read data accessible of the SELECTED_- BYTE0 field of the Data Register.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>PROCHOT_GATE</name>
                     <description>This bit controls the effect of the VCI_OVRD_IN pin on the PROCHOT_IO# Output.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST_DATA_MUX_SELECT</name>
                     <description>This bit controls the source of the ADC sample data to the Second Order LPF.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PROCHOT_DATA_MUX_SELECT</name>
                     <description>This field controls the source of the Prochot Data Mux.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>LOW_COMPARATOR_HYSTERESIS_MODE</name>
                     <description>This bit selects Hysteresis Mode for the low-side comparator.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HIGH_COMPARATOR_HYSTERESIS_MODE</name>
                     <description>This bit selects Hysteresis Mode for the high-side comparator.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST1</name>
                     <description>All writes to this register should clear this test bit to 0.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST2</name>
                     <description>All writes to this register should clear this test bit to 0.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST3</name>
                     <description>All writes to this register should clear this test bit to 0.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>TEST4</name>
                     <description>All writes to this register should clear this test bit to 0.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>BLOCK_DISABLE</name>
                     <description>When this bit is set to '1b' the PowerGuard block is disabled and placed in a low power state.</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BLOCK_RESET</name>
                     <description>When this bit is set to '1b' the entire block is reset.</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CTMR_OUT_LO</name>
                     <description>Status bit of the low-side timer.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CTMR_OUT_HI</name>
                     <description>Status bit of the high-side timer.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MAN_RECOVERY_OUT</name>
                     <description>If both the high-side timer and the low-side timer are configured for Manual Recovery Mode, this bit reports the status of the timer contribution to the ORing Logic.</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FORCE_PROCHOT</name>
                     <description>Inverted copy of the current state of the input signal FORCE_PROCHOT# from the PROCHOT PWM.</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>COUT_LO</name>
                     <description>Current output of the low-side comparator.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>COUT_HI</name>
                     <description>Current output of the high-side comparator.</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PROCHOT_OUT</name>
                     <description>Current output of the ORing Logic.</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INT_STATUS</name>
               <description>PowerGuard Interrupt Status Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CT_HI_H2L</name>
                     <description>This bit is set to 1b when the CTMR_OUT_HI in the Control And Status Register transitions from '1b' to '0b'. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CT_LO_H2L</name>
                     <description>This bit is set to 1b when the CTMR_OUT_LO in the Control And Status Register transitions from '1b' to '0b'. (R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CT_HI_L2H</name>
                     <description>This bit is set to 1b when the CTMR_OUT_HI in the Control And Status Register transitions from '0b' to '1b'. (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CT_LO_L2H</name>
                     <description>This bit is set to 1b when the CTMR_OUT_LO in the Control And Status Register transitions from '0b' to '1b'. (R/WC)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FORCE_PROCHOT</name>
                     <description>This bit is set to '1b' if the FORCE_PROCHOT# input from the PROCHOT PWM is low (asserted). (R/WC)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>PowerGuard Interrupt Enable Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CT_HI_H2L_ENABLE</name>
                     <description>This bit is used to enable/disable the CTMR_OUT_HI interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CT_LO_H2L_ENABLE</name>
                     <description>This bit is used to enable/disable the CTMR_OUT_LO interrupt.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CT_HI_L2H_ENABLE</name>
                     <description>This bit is used to enable/disable the CTMR_OUT_HI interrupt.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CT_LO_L2H_ENABLE</name>
                     <description>This bit is used to enable/disable the CTMR_OUT_LO interrupt.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FORCE_PROCHOT_ENABLE</name>
                     <description>This bit is used to enable/disable the FORCE_PROCHOT# interrupt.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="POWERGUARD_0">
         <name>POWERGUARD_1</name>
         <baseAddress>0x40003080</baseAddress>
         <interrupt>
            <name>POWERGUARD_1</name>
            <value>89</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>IMSPI</name>
         <version>1731.0</version>
         <description>Internal Master SPI.</description>
         <baseAddress>0x40220000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>MODE</name>
               <description>IMSPI Mode Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ACTIVATE</name>
                     <description>This bit enables the controller. 1=The controller is enabled; 0=The controller is disabled and placed in its lowest power state.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RESET</name>
                     <description>A write of '1b' to this bit resets the controller. This bit is self-clearing.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DLY2_SUSB</name>
                     <description>This bit is routed to the DLY2_SUSB# pin function.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CPOL</name>
                     <description>This bit corresponds to the Polarity control for the underlying SPI controller. It describes the default state of      the SPI Clock signal. 1=The clock starts in a high state; 0=The clock starts in a low state.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CPHA_MOSI</name>
                     <description>This field is the CPHA field of the underlying SPI controller which affects only the MOSI Data. This field changes      determines the clock edge on which data are sent, in combination with the CPOL field. 1=If CPOL=0, data sent on Rising Edge;      if CPOL=1, data sent on Falling Edge ; 0=If CPOL=0, data sent on Falling Edge; if CPOL=1, data sent on Rising Edge.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CPHA_MISO</name>
                     <description>This field is the CPHA field of the underlying SPI controller which affects only the MISO Data. This field changes      determines the clock edge on which data are captured, in combination with the CPOL field. For standard SPI Modes, this must be      programmed with the same value as CPHA_MOSI. 1=If CPOL=0, data captured on Falling Edge; if CPOL=1, data captured on Rising Edge      0=If CPOL=0, data captured on Rising Edge; if CPOL=1, data captured on Falling Edge.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLOCK_DIVIDE</name>
                     <description>This SPI clock divide in terms of the number of system clocks. 255:1=The SPI clock period is equal to this number of      system clocks. 0=The SPI clock period is equal to 256 system clocks.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>IF_MODE</name>
                     <description>This field sets the interface mode for the SPI controller. 3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single Mode.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STATUS</name>
               <description>IMSPI Status Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TIMEOUT</name>
                     <description>This flags when a transfer has terminated due to timeout on the response phase. 1=A transfer error occurred due to an      invalid response; 0=No error occurred. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INVALID_RESPONSE</name>
                     <description>The IMSPI has detected an invalid response field and therefore is aborting the transfer in failure. 1=A transfer error      occurred due to an invalid response; 0=No error occurred. (R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INT_ENABLE</name>
               <description>IMSPI Interrupt Enable Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TIMEOUT_LE</name>
                     <description>Assert an IMSPI interrupt when the TIMEOUT status is asserted. 1=Enable Interrupt; 0=Disable Interrupt</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INVALID_RESPONSE_LE</name>
                     <description>Assert an EEPROM interrupt when the INVALID_RESPONSE status is asserted. 1=Enable Interrupt; 0=Disable Interrupt</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TIMEOUT_CONTROL</name>
               <description>IMSPI Timeout Control Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RESPONSE_TIMEOUT</name>
                     <description>This field is the maximum number of response cycles the IMSPI will wait until flagging a timeout. A setting of 0 will      disable the timeout feature.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>NVIC</name>
         <description>Nested Vectored Interrupt Controller</description>
         <baseAddress>0xE000E100</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xE04</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>ISER[%s]</name>
               <description>Interrupt Set Enable Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>SETENA</name>
                     <description>Interrupt set enable bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>ICER[%s]</name>
               <description>Interrupt Clear Enable Register</description>
               <addressOffset>0x80</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>CLRENA</name>
                     <description>Interrupt clear-enable bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>ISPR[%s]</name>
               <description>Interrupt Set Pending Register</description>
               <addressOffset>0x100</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>SETPEND</name>
                     <description>Interrupt set-pending bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>ICPR[%s]</name>
               <description>Interrupt Clear Pending Register</description>
               <addressOffset>0x180</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>CLRPEND</name>
                     <description>Interrupt clear-pending bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>IABR[%s]</name>
               <description>Interrupt Active Bit Register</description>
               <addressOffset>0x200</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>ACTIVE</name>
                     <description>Interrupt active bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>1</dimIncrement>
               <name>IP[%s]</name>
               <description>Interrupt Priority Register n</description>
               <addressOffset>0x300</addressOffset>
               <size>8</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>PRI0</name>
                     <description>Priority of interrupt n</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STIR</name>
               <description>Software Trigger Interrupt Register</description>
               <addressOffset>0xE00</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <fields>
                  <field>
                     <name>INTID</name>
                     <description>Interrupt ID to trigger</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>9</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>SysTick</name>
         <description>System timer</description>
         <baseAddress>0xE000E010</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>CSR</name>
               <description>SysTick Control and Status Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x0</resetValue>
               <fields>
                  <field>
                     <name>ENABLE</name>
                     <description>SysTick Counter Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>ENABLESelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Counter disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Counter enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TICKINT</name>
                     <description>SysTick Exception Request Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>TICKINTSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Counting down to 0 does not assert the SysTick exception request</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Counting down to 0 asserts the SysTick exception request</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CLKSOURCE</name>
                     <description>Clock Source 0=external, 1=processor</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>CLKSOURCESelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>External clock</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Processor clock</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>COUNTFLAG</name>
                     <description>Timer counted to 0 since last read of register</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RVR</name>
               <description>SysTick Reload Value Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>RELOAD</name>
                     <description>Value to load into the SysTick Current Value Register when the counter reaches 0</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>24</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CVR</name>
               <description>SysTick Current Value Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>CURRENT</name>
                     <description>Current value at the time the register is accessed</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>24</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CALIB</name>
               <description>SysTick Calibration Value Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>TENMS</name>
                     <description>Reload value to use for 10ms timing</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>24</bitWidth>
                  </field>
                  <field>
                     <name>SKEW</name>
                     <description>TENMS is rounded from non-integer ratio</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>SKEWSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>10ms calibration value is exact</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>10ms calibration value is inexact, because of the clock frequency</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>NOREF</name>
                     <description>No Separate Reference Clock</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>NOREFSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>The reference clock is provided</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>The reference clock is not provided</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>SystemControl</name>
         <description>System Control Registers</description>
         <baseAddress>0xE000E000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xD8C</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>ICTR</name>
               <description>Interrupt Controller Type Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <fields>
                  <field>
                     <name>INTLINESNUM</name>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACTLR</name>
               <description>Auxiliary Control Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>DISMCYCINT</name>
                     <description>Disable interruption of LDM/STM instructions</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DISDEFWBUF</name>
                     <description>Disable wruite buffer use during default memory map accesses</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DISFOLD</name>
                     <description>Disable IT folding</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DISFPCA</name>
                     <description>Disable automatic update of CONTROL.FPCA</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DISOOFP</name>
                     <description>Disable out-of-order FP instructions</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CPUID</name>
               <description>CPUID Base Register</description>
               <addressOffset>0xD00</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x410FC241</resetValue>
               <fields>
                  <field>
                     <name>REVISION</name>
                     <description>Processor revision number</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>PARTNO</name>
                     <description>Process Part Number, 0xC24=Cortex-M4</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>CONSTANT</name>
                     <description>Constant</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>VARIANT</name>
                     <description>Variant number</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>IMPLEMENTER</name>
                     <description>Implementer code, 0x41=ARM</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ICSR</name>
               <description>Interrupt Control and State Register</description>
               <addressOffset>0xD04</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>VECTACTIVE</name>
                     <description>Active exception number</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>9</bitWidth>
                  </field>
                  <field>
                     <name>RETTOBASE</name>
                     <description>No preempted active exceptions to execute</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VECTPENDING</name>
                     <description>Exception number of the highest priority pending enabled exception</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>ISRPENDING</name>
                     <description>Interrupt pending flag</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ISRPREEMPT</name>
                     <description>Debug only</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PENDSTCLR</name>
                     <description>SysTick clear-pending bit</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>PENDSTCLRSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>No effect</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Removes the pending state from the SysTick exception</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PENDSTSET</name>
                     <description>SysTick set-pending bit</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>PENDSTSETSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Write: no effect; read: SysTick exception is not pending</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Write: changes SysTick exception state to pending; read: SysTick exception is pending</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PENDSVCLR</name>
                     <description>PendSV clear-pending bit</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>PENDSVCLRSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>No effect</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Removes the pending state from the PendSV exception</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PENDSVSET</name>
                     <description>PendSV set-pending bit</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>PENDSVSETSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Write: no effect; read: PendSV exception is not pending</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Write: changes PendSV exception state to pending; read: PendSV exception is pending</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>NMIPENDSET</name>
                     <description>NMI set-pending bit</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>NMIPENDSETSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Write: no effect; read: NMI exception is not pending</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Write: changes NMI exception state to pending; read: NMI exception is pending</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>AIRCR</name>
               <description>Application Interrupt and Reset Control Register</description>
               <addressOffset>0xD0C</addressOffset>
               <size>32</size>
               <resetValue>0xFA050000</resetValue>
               <fields>
                  <field>
                     <name>VECTRESET</name>
                     <description>Must write 0</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VECTCLRACTIVE</name>
                     <description>Must write 0</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SYSRESETREQ</name>
                     <description>System Reset Request</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>SYSRESETREQSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>No system reset request</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Asserts a signal to the outer system that requests a reset</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PRIGROUP</name>
                     <description>Interrupt priority grouping</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>ENDIANNESS</name>
                     <description>Data endianness, 0=little, 1=big</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>ENDIANNESSSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Little-endian</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Big-endian</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>VECTKEY</name>
                     <description>Register key</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCR</name>
               <description>System Control Register</description>
               <addressOffset>0xD10</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>SLEEPONEXIT</name>
                     <description>Sleep-on-exit on handler return</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>SLEEPONEXITSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Do not sleep when returning to Thread mode</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Enter sleep, or deep sleep, on return from an ISR</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLEEPDEEP</name>
                     <description>Deep Sleep used as low power mode</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>SLEEPDEEPSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Sleep</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Deep sleep</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SEVONPEND</name>
                     <description>Send Event on Pending bit</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>SEVONPENDSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Enabled events and all interrupts, including disabled interrupts, can wakeup the processor</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>CCR</name>
               <description>Configuration and Control Register</description>
               <addressOffset>0xD14</addressOffset>
               <size>32</size>
               <resetValue>0x00000200</resetValue>
               <fields>
                  <field>
                     <name>NONBASETHRDENA</name>
                     <description>Indicates how processor enters Thread mode</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>USERSETMPEND</name>
                     <description>Enables unprivileged software access to STIR register</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNALIGN_TRP</name>
                     <description>Enables unaligned access traps</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>UNALIGN_TRPSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Do not trap unaligned halfword and word accesses</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Trap unaligned halfword and word accesses</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DIV_0_TRP</name>
                     <description>Enables divide by 0 trap</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BFHFNMIGN</name>
                     <description>Ignore LDM/STM BusFault for -1/-2 priority handlers</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STKALIGN</name>
                     <description>Indicates stack alignment on exception entry</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>STKALIGNSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>4-byte aligned</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>8-byte aligned</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>SHPR1</name>
               <description>System Handler Priority Register 1</description>
               <addressOffset>0xD18</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>PRI_4</name>
                     <description>Priority of system handler 4, MemManage</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>PRI_5</name>
                     <description>Priority of system handler 5, BusFault</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>PRI_6</name>
                     <description>Priority of system handler 6, UsageFault</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SHPR2</name>
               <description>System Handler Priority Register 2</description>
               <addressOffset>0xD1C</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>PRI_11</name>
                     <description>Priority of system handler 11, SVCall</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SHPR3</name>
               <description>System Handler Priority Register 3</description>
               <addressOffset>0xD20</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>PRI_14</name>
                     <description>Priority of system handler 14, PendSV</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>PRI_15</name>
                     <description>Priority of system handler 15, SysTick exception</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SHCSR</name>
               <description>System Handler Control and State Register</description>
               <addressOffset>0xD24</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>MEMFAULTACT</name>
                     <description>MemManage exception active bit</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BUSFAULTACT</name>
                     <description>BusFault exception active bit</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>USGFAULTACT</name>
                     <description>UsageFault exception active bit</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SVCALLACT</name>
                     <description>SVCall active bit</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MONITORACT</name>
                     <description>DebugMonitor exception active bit</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PENDSVACT</name>
                     <description>PendSV exception active bit</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SYSTICKACT</name>
                     <description>SysTick exception active bit</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>USGFAULTPENDED</name>
                     <description>UsageFault exception pending bit</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEMFAULTPENDED</name>
                     <description>MemManage exception pending bit</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BUSFAULTPENDED</name>
                     <description>BusFault exception pending bit</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SVCALLPENDED</name>
                     <description>SVCall pending bit</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEMFAULTENA</name>
                     <description>MemManage enable bit</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BUSFAULTENA</name>
                     <description>BusFault enable bit</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>USGFAULTENA</name>
                     <description>UsageFault enable bit</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CFSR</name>
               <description>Configurable Fault Status Register</description>
               <addressOffset>0xD28</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>IACCVIOL</name>
                     <description>Instruction access violation</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DACCVIOL</name>
                     <description>Data access violation</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUNSTKERR</name>
                     <description>MemManage Fault on unstacking for exception return</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MSTKERR</name>
                     <description>MemManage Fault on stacking for exception entry</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MLSPERR</name>
                     <description>MemManager Fault occured during FP lazy state preservation</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MMARVALID</name>
                     <description>MemManage Fault Address Register valid</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBUSERR</name>
                     <description>Instruction bus error</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRECISERR</name>
                     <description>Precise data bus error</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IMPRECISERR</name>
                     <description>Imprecise data bus error</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNSTKERR</name>
                     <description>BusFault on unstacking for exception return</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STKERR</name>
                     <description>BusFault on stacking for exception entry</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LSPERR</name>
                     <description>BusFault occured during FP lazy state preservation</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BFARVALID</name>
                     <description>BusFault Address Register valid</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNDEFINSTR</name>
                     <description>Undefined instruction UsageFault</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INVSTATE</name>
                     <description>Invalid state UsageFault</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INVPC</name>
                     <description>Invalid PC load UsageFault</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>NOCP</name>
                     <description>No coprocessor UsageFault</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNALIGNED</name>
                     <description>Unaligned access UsageFault</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIVBYZERO</name>
                     <description>Divide by zero UsageFault</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HFSR</name>
               <description>HardFault Status Register</description>
               <addressOffset>0xD2C</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>VECTTBL</name>
                     <description>BusFault on a Vector Table read during exception processing</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FORCED</name>
                     <description>Forced Hard Fault</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DEBUGEVT</name>
                     <description>Debug: always write 0</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DFSR</name>
               <description>Debug Fault Status Register</description>
               <addressOffset>0xD30</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>HALTED</name>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BKPT</name>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DWTTRAP</name>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VCATCH</name>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EXTERNAL</name>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MMFAR</name>
               <description>MemManage Fault Address Register</description>
               <addressOffset>0xD34</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>ADDRESS</name>
                     <description>Address that generated the MemManage fault</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BFAR</name>
               <description>BusFault Address Register</description>
               <addressOffset>0xD38</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>ADDRESS</name>
                     <description>Address that generated the BusFault</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>AFSR</name>
               <description>Auxiliary Fault Status Register</description>
               <addressOffset>0xD3C</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>IMPDEF</name>
                     <description>AUXFAULT input signals</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>2</dim>
               <dimIncrement>4</dimIncrement>
               <name>PFR[%s]</name>
               <description>Processor Feature Register</description>
               <addressOffset>0xD40</addressOffset>
               <size>32</size>
            </register>
            <register>
               <name>DFR</name>
               <description>Debug Feature Register</description>
               <addressOffset>0xD48</addressOffset>
               <size>32</size>
               <access>read-only</access>
            </register>
            <register>
               <name>ADR</name>
               <description>Auxiliary Feature Register</description>
               <addressOffset>0xD4C</addressOffset>
               <size>32</size>
               <access>read-only</access>
            </register>
            <register>
               <dim>4</dim>
               <dimIncrement>4</dimIncrement>
               <name>MMFR[%s]</name>
               <description>Memory Model Feature Register</description>
               <addressOffset>0xD50</addressOffset>
               <size>32</size>
               <access>read-only</access>
            </register>
            <register>
               <dim>5</dim>
               <dimIncrement>4</dimIncrement>
               <name>ISAR[%s]</name>
               <description>Instruction Set Attributes Register</description>
               <addressOffset>0xD60</addressOffset>
               <size>32</size>
               <access>read-only</access>
            </register>
            <register>
               <name>CPACR</name>
               <description>Coprocessor Access Control Register</description>
               <addressOffset>0xD88</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>CP10</name>
                     <description>Access privileges for coprocessor 10</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>CP10Select</name>
                        <enumeratedValue>
                           <name>DENIED</name>
                           <description>Access denied</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PRIV</name>
                           <description>Privileged access only</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>FULL</name>
                           <description>Full access</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CP11</name>
                     <description>Access privileges for coprocessor 11</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>CP11Select</name>
                        <enumeratedValue>
                           <name>DENIED</name>
                           <description>Access denied</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PRIV</name>
                           <description>Privileged access only</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>FULL</name>
                           <description>Full access</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
   </peripherals>
</device>
